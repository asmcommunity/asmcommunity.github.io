<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Q: multiply to divide from Mark Larsons optimiziation guide - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21308" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=21308">Q: multiply to divide from Mark Larsons optimiziation guide</a></p>
   <div class="post" id="post-161203">
    <div class="subject"><a href="#post-161203">Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">hi <br /><br />Mark Larson wrote in his &#39;Assembly Optimization Tips&#39;:<br /><br />Multiply to divide.<br /><br />If you have a full 32-bit number and you need to divide, you can simply do a multiply and take the top 32-bit half as the result. This is faster because multiplication is faster than division. ( thanks to pdixon for the tip). <br /><br /><br />i don?t understand how it should work. counld someone show me some peace of code ? in C or ASM. but C would be better for me.<br />i?m just beginning to play with asm und with english. you will notice ;o)<br /><br />with greetings from germany<br /><br />Nachtschatten</div>
    <div class="meta">Posted on 2005-06-17 09:29:06 by Nachtschatten</div>
   </div>
   <div class="post" id="post-161205">
    <div class="subject"><a href="#post-161205">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">Try playing with this tool by The Svin. </div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=693" target="_blank">Magic.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-06-17 10:25:09 by roticv</div>
   </div>
   <div class="post" id="post-161206">
    <div class="subject"><a href="#post-161206">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">hi roticv<br /><br /><div class="quote"><br />Try playing with this tool by The Svin. <br /></div><br /><br />i know that tool.is very good. but i?m asm beginner and therfore it?s very hard for me to read and anderstand the code.<br /><br />back to marks divide tip<br /><br />i understand his sentence as follow:<br /><br />i have a variable named &#39;x&#39;. its a full 32 bit number ie. 3123456789<br />now, if i want to divide x by 10, i have to &quot; multiply and take the top 32-bit half as the result&quot;<br /><br />ok, some pseudocode:<br /><br />int32 x = 3123456789;<br />int32 div = 10;<br />int64 res = 0;<br /><br />res = (int64)x * 10; <br />res shr 32;<br /><br />now res should contain the result of &quot;x / div&quot;. <br />i think, i missunderstand the meaning of his sentence.<br /><br />do you know now my problem ?<br />thinks for helping<br /><br />Nachtschatten</div>
    <div class="meta">Posted on 2005-06-17 11:12:22 by Nachtschatten</div>
   </div>
   <div class="post" id="post-161207">
    <div class="subject"><a href="#post-161207">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">He did not say that. He said<br /><br />&quot;If you have a full 32-bit number and you need to divide, you can simply do a multiply and take the top 32-bit half as the result. This is faster because multiplication is faster than division. ( thanks to pdixon for the tip).&quot;<br /><br />For instance if you want to divide a number by 10, it would be faster to multiply by 0.1 than divide by 10, assuming that you are using fpu.<br /><br />Using the tool by The Svin, you can easily determine the constant that you should multiply by to get the number you want to find.</div>
    <div class="meta">Posted on 2005-06-17 12:50:56 by roticv</div>
   </div>
   <div class="post" id="post-161212">
    <div class="subject"><a href="#post-161212">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">wow, this tool rocks! now i don&#39;t have to calculate it &#39;manually&#39; :D thanx roticv, thanx The Svin :D</div>
    <div class="meta">Posted on 2005-06-17 19:14:28 by ti_mo_n</div>
   </div>
   <div class="post" id="post-161216">
    <div class="subject"><a href="#post-161216">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">You are welcome. This tool used to be found on this board, until the hacking incidents happened.</div>
    <div class="meta">Posted on 2005-06-17 21:54:04 by roticv</div>
   </div>
   <div class="post" id="post-161221">
    <div class="subject"><a href="#post-161221">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">there are a lot of instructions excluding mul to be done, is it all really faster than one div ??</div>
    <div class="meta">Posted on 2005-06-18 03:12:45 by AceEmbler</div>
   </div>
   <div class="post" id="post-161227">
    <div class="subject"><a href="#post-161227">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">If you ask me, yes. a mul + a shift should be faster than a divison. You can try it out&nbsp; ;)</div>
    <div class="meta">Posted on 2005-06-18 08:35:10 by roticv</div>
   </div>
   <div class="post" id="post-161230">
    <div class="subject"><a href="#post-161230">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body"><div class="quote"><br />If you ask me, yes. a mul + a shift should be faster than a divison. You can try it out&nbsp; ;)<br /></div><br /><br />Is there any algo for this, because I&#39;m not good at reading someone else asm code.Is there any point of implementing something similar&nbsp; in c++ app ??</div>
    <div class="meta">Posted on 2005-06-18 09:43:43 by AceEmbler</div>
   </div>
   <div class="post" id="post-161261">
    <div class="subject"><a href="#post-161261">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">I really didn&#39;t see how Mark&#39;s tip from pdixon would work as stated. It was also confusing to me. I had found a very nice tutorial about??<a target="_blank" href="http://www.cs.uiowa.edu/~jones/bcd/divide.html">reciprocal multiplication</a> written by Douglas Jones that clarified a lot for me. It also discusses problems with rounding that need to be considered at times. Just wanted to pass the link along.<br />-Phil<br /></div>
    <div class="meta">Posted on 2005-06-18 15:57:02 by IndyGump</div>
   </div>
   <div class="post" id="post-161728">
    <div class="subject"><a href="#post-161728">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">&nbsp;  I think you&#39;ve taken the suggestion out of context. It doesn&#39;t apply to all cases, just to the specific case being discussed.<br /><br />	If I remember correctly, this came from an attempt to optimise a random number routine to give a random integer between 0 and SomeLimit.<br /><br />&nbsp; &nbsp; e.g. rnd(10) should return an integer from 0 to 9<br /><br />	There were various algoritms discussed for producing random numbers of various precision typically 32 bits.<br /><br />	The next step in converting the the 32 bit random number into an integer from 0 to 9 was invariably to divide the 32 bit value by 10 and keep the remainder. This is what the DIV instruction does, it divides the 2 numbers giving the quotient in EAX (which is ignored) and the remainder in EDX which is the required result, an integer from 0 to 9.<br /><br />	The suggestion was to replace the DIV by 10 with a MUL by 10 which is much faster. You&#39;ll find that the high word of the result which appears in EDX is also a random integer from 0 to 9.<br />	This only works if the initial random bits fill the register (or at least are uniformaly distributed within the high bits of that register).<br /><br />pdixon</div>
    <div class="meta">Posted on 2005-07-05 16:59:35 by pdixon</div>
   </div>
   <div class="post" id="post-161731">
    <div class="subject"><a href="#post-161731">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">For power of 2 constants you can just AND Variable, Constant -1? ; 1111 &amp; 7 = R111<br /><br />The FPU has an opcode for remainder but it&#39;s slower than hell.<br /><br />The magic number thing is great. But it seems to get shaky as the numbers get very large 4bil-ish.<br />Because of the FPU&#39;s precision I wonder if it&#39;ll be able to use the same calculation to get a magic number for a 64bit integer divide.<br /><br />Processors need a fast MODULUS opcode!</div>
    <div class="meta">Posted on 2005-07-05 21:04:37 by r22</div>
   </div>
   <div class="post" id="post-161738">
    <div class="subject"><a href="#post-161738">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body"><div class="quote">Is there any point of implementing something similar&nbsp; in c++ app ??</div><br /><br />Some C/C++ compilers do this automatically when optimization is turned on (e.g. Visual C++ and GCC).</div>
    <div class="meta">Posted on 2005-07-06 02:31:16 by Jibz</div>
   </div>
   <div class="post" id="post-161744">
    <div class="subject"><a href="#post-161744">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">If you want to divide by the odd number, and you know the number you want to divide is divisible without remainder, you can do this by multiplying by &quot;magic&quot; number and take the LOW half of the result, without need to do any shifts etc.<br /><br />This approach is based on the theory of 2-adic numbers, if you need some elementary information on 2-adic number, you can find it in the <a target="_blank" href="http://flatassembler.net/docs/tutorial.zip">Programming Tutorial</a> I&#39;ve once started.<br /><br />For example, the 2-adic reciprocal of 3 is 110101010101... (infinite chain), if we multiply any integer N divisible by 3 by such infinite chain, we will get N/3. On computer we are able to operate only on finite chains, but note, that even when multiplyng the infinite ones, the n first bits always depends only on the first n bits of both numbers we multiply. So if we take the first 32 bits of 2-adic 1/3 and multiply the 32-bit integer by it, the low 32 bits of the result will be the correct first 32 bits of the result, N/3 in this case.<br /><br />The first 32 bits of infinite 1/3 expansion are 0AAAAAAABh (and the whole expansion goes as if we were adding infinite amount of A digits to the left), therefore this code:<br /><pre><code>mov eax,N<br />mov ebx,0AAAAAAABh<br />mul ebx</code></pre><br />will calculate the N/3 for us in EAX.<br /><br />When you want to divide by even number, you can factorize it to some power of two end off number and make one multiplication live above and then shift by the amount of bits equal to the power of two from the factorization. Always operating on the lower half of the result! This means you can use this method also with the IMUL instruction variants, which give you only the lower half of the result, like:<br /><pre><code>imul eax,0AAAAAAABh ; divide by 3</code></pre><br /><br />However this method has the substantial flow, that the number we want to divide has to de divisible by the value, whose reciprocal we use - otherwise we get the low bits of some infinite expansion of rational number.<br /><br />The method discussed above doesn&#39;t have such disadvantage. But let&#39;s see how the two method are related to each other. If you use Svin&#39;s tool to get the magic number for dividing by 3, you will see that it&#39;s actually the same as the low 32 bits of p-adic 1/3 we used above. But this time you are told to get the HIGH 32 bits of result and shift them right by one bit.<br /><br />Indeed, if you check it, when you multiply by 0AAAAAAABh the 32-bit N divisible by 3, you will get N/3 in low 32 bits, and 2N/3 in the high 32 bits. To see how the 2-adic arithmetics can explain this, let&#39;s analyze in terms of p-adic rational numbers, what you exactly get, when you do such multiplication. The 0AAAAAAAB is incomplete 1/3, what we cut off is the infinite amount of A digits starting from ninth one (33rd bit), therefore:<br /><br />N*0AAAAAAABh = N*(1/3 - ...AAA00000000h)<br /><br />note now that ...AAA00000000h = ...AAAAh * 100000000h = ...AAAAh * (2^32)<br />but ...AAAAh = ...AAABh - 1 = 1/3 - 1 = -2/3, so:<br /><br />N*0AAAAAAABh = N * (1/3 - (-2/3)*(2^32)) = N*3 + (2N/3)*(2^32)<br /><br />so we get exactly what we expected - after multiplyng by 0AAAAAAABh we get N/3 in low 32 bits and 2N/3 in the high bits.<br /><br />But how does it come, that even when N is not divisible by 3, we get the correct rounded value of N/3 starting from the 34th bit?<br />If N=M+r, where r&lt;3, then we can split the N*0AAAAAAABh to the sum of two products - for M we know we get 2M/3 in upper bits, so it suffices to show that r*0AAAAAAABh has zeros starting from the 34th bit - what is actually evident, since r is smaller than 2^2 and the 0AAAAAAABh is smaller than 2^32, so their product is smaller than 2^34. Well, there might be some overflow when M is very large, near to 2^32, but that&#39;s another story - I&#39;m providing only very simplified analysis on single example, but I believe the analogous reasoning works for the general case.<br /><br />Also, for the small values of M, the &quot;middle&quot; bits, just below the result in high bits, would even allow to recover the remainder from division - though I doubt it could be done efficiently. But if I design any nice algorithm for this, I&#39;ll let you know.<br /><br />I hope I have not bored everyone with those theoretical divagations...</div>
    <div class="meta">Posted on 2005-07-06 04:54:16 by Tomasz Grysztar</div>
   </div>
   <div class="post" id="post-162006">
    <div class="subject"><a href="#post-162006">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body"><div class="quote"><br />i know that tool.is very good. but i?m asm beginner and therfore it?s very hard for me to read and anderstand the code.<br /></div><br /><br />forget &quot;Magic Divider&quot; it sucks, you&#39;d better use this binary technic (here, we use the size of the register as a &quot;pivot&quot; (sorry i don&#39;t know the word in english...) :<br /><br />	real magic number = ( MAX register value / YOUR VALUE ) + 1<br /><br />here, a small example with a 32 bits register :<br /><br />	2 000 000 / 127 773 = 15,652759190126239502868368121591 (respectively in eax and edx)<br />	<br />	( 4 294 967 295 / 127 773 ) + 1 = 3 3615 (our magic value)<br />	2 000 000 * 3 3615 = 67 230 000 000 (but this number exceed the eax registrer, so the corresponding value is send in edx)<br />	and here is the magic =&gt; 67 230 000 000 / 4 294 967 296 = 15,6532041728496551513671875<br />	(there is a lacks of precision here, but we don&#39;t care because we are only interested by the integer part in edx =&gt; 15)<br /><br />advantages of this technic :<br />	- easy to remember<br />	- there&#39;s no need to pratice a shr on the result, etc... the result is directly in edx.<br />	- it works with all registers size byte/word/dword/qword, etc..<br />	- no limit for the size of the numbers (but of course, they can&#39;t exceed the size of the used registers) <br /><br />to finish, if you want to obtain the fractionnal part, you just have to multiply your result by the original divider<br />	15 * 127 773 = 1 916 595<br />and substract this value to the original value	<br />	2 000 000 - 1 916 595 = 83 405 (83 405 / 127 773 = 0,65275919012623950286836812159063)<br />	(hey, we have a very good precision here...)<br /><br /><div class="quote"><br />there are a lot of instructions excluding mul to be done, is it all really faster than one div ??<br /></div><br /><br />on a pentium 3, a div/idiv instruction takes 39 clock cycles and a mul/imul instruction just take 4 cycles...<br /><br /><br />PLEASE FORGIVE ME, FOR MY POOR POOR POOR ENGLISH</div>
    <div class="meta">Posted on 2005-07-12 19:17:27 by NightWare</div>
   </div>
   <div class="post" id="post-162013">
    <div class="subject"><a href="#post-162013">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">Noobies MUST remember one thing. This technique of multiplying instead of dividing is fine to improve execution speed <strong>IF AND ONLY IF</strong> the <em>divider</em> is a constant which is used more than once and its reciprocal can be stored in memory to be used whenever required.<br /><br />If the <em>divider</em> is a variable which can change throughout an application, using the &quot;multiplication technique&quot; would slow down execution speed because a division needs to be performed anyway to obtain the &quot;magic&quot; number in addition to a multiplication to obtain the quotient!!!<br /><br />Raymond<br /></div>
    <div class="meta">Posted on 2005-07-12 21:50:29 by Raymond</div>
   </div>
   <div class="post" id="post-162023">
    <div class="subject"><a href="#post-162023">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">NightWare: yeah, that&#39;s a simple and neat trick, however it still may give wrong results sometimes. Example: 411287/17137 = 23,99994..., so the rounded down result of division should be 23 in this case, but the trick gives 411287*(4294967295/17137+1)/4294967296 = 24,0000...<br /><br />Raymond: I have designed an algorithm to calculate 2-dic reciprocals without any division, though it might need a large amount of multiplications sometimes, so it won&#39;t be much more efficient. But just as a kind of curiosity - it is possible to do it without division.</div>
    <div class="meta">Posted on 2005-07-13 03:52:46 by Tomasz Grysztar</div>
   </div>
   <div class="post" id="post-162102">
    <div class="subject"><a href="#post-162102">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body"><div class="quote"><br />however it still may give wrong results sometimes.</div><br />hmm... i didn&#39;t know that... it&#39;s a small error, but it&#39;s an error... now i have to verify/change some of my codes... but thanks for the info.<br /><br />it should be easy to solve the problem... here, an attempt to solve the problem (not tested) :<br /><br />; MagicNumber = ( MAX register value / OriginalValue ) + 1<br /><br />; the integer part :<br />	mov edi,X		;backup of the value to divide<br />	mov eax,edi<br />	mov edx,MagicNumber	;) use &quot;mul MagicNumber&quot; if you don&#39;t use an immediate value<br />	mul edx		;)<br /><br />; fraction part :<br />	mov esi,edx	;backup of our integer result<br />	mov eax,edx<br />	mov edx,OriginalValue	;) use &quot;mul OriginalValue&quot; if you don&#39;t use an immediate value<br />	mul edx		;)<br />	sub edi,eax<br /><br />; error solving :<br />	jns NoError<br />	dec esi		;our integer - 1<br />	add edi,OriginalValue	;a small negative value + OriginalValue<br />NoError:<br />; here we have the integer in esi, and the fraction in edi<br /><br />it should work, it still faster than a division (18/24 cycles insteed of 39 on a P3), but it&#39;s not as fast as the previous trick, hmm... magic divider give the good result... lol, maybe it&#39;s not so useless, after all...<br /><br /><div class="quote"><br />If the <em>divider</em> is a variable which can change throughout an application, using the &quot;multiplication technique&quot; would slow down execution speed because a division needs to be performed anyway to obtain the &quot;magic&quot; number in addition to a multiplication to obtain the quotient!!!</div><br /><br />well, in fact it&#39;s not totally true... you&#39;re right on the principle, but since this otptimization only concern integer values, it&#39;s possible to use this trick with a variable by using a table, in this case the optimization still faster than a classic division (of course, here we&#39;re limited to small numbers, or a small range of numbers, otherwise it cost a lot of memory)<br />in some case, it could even be usefull if your cpu don&#39;t support sse instructions (i know it must be rare now...)<br /></div>
    <div class="meta">Posted on 2005-07-14 19:57:17 by NightWare</div>
   </div>
   <div class="post" id="post-163818">
    <div class="subject"><a href="#post-163818">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">I&#39;m using that program, trying to do a simple conversion from fahrenheit to celsius.<br /><br /><div class="quote">; 9<br />MagicNumber = 3817748708<br />mov eax,X<br />mov edx, MagicNumber<br />mul edx<br />SHR edx, 3</div><br /><br /><pre><code>&nbsp; &nbsp; invoke GetDlgItemInt, hWnd, IDC_FIREN, NULL, FALSE<br />&nbsp; &nbsp; ; formula: (5*(x - 32))/9<br />&nbsp; &nbsp; sub eax, 32<br />&nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; mov edx, 3817748708<br />&nbsp; &nbsp; mul edx<br />&nbsp; &nbsp; shr edx, 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; invoke SetDlgItemInt, hWnd, IDC_CELSIUS, edx, TRUE</code></pre><br /><br />But my results are totally wrong...</div>
    <div class="meta">Posted on 2005-08-27 11:39:42 by Lenin</div>
   </div>
   <div class="post" id="post-163825">
    <div class="subject"><a href="#post-163825">Re: Q: multiply to divide from Mark Larsons optimiziation guide</a></div>
    <div class="body">It doesn&#39;t work if EAX has a negative number in it.<br />You can check the math with your Windows Calculator<br /><br />EAX = 212<br />-32 = 180<br />*5&nbsp; = 900<br />900 * 3817748708 = 3435973837200<br />In Hex = 00000320 00000190h<br />EAX = 190h<br />EDX = 320h<br />320h / 8 (shr 3) = 64h<br />64h = 100 decimal 212F = 100C<br /><br /><br />So the problem you&#39;re having is either in the API calls or your value in eax after 32 is subtracted from it is LESS than 0.<br />If the value in EAX is negative the MUL by magic number will fail</div>
    <div class="meta">Posted on 2005-08-27 17:56:49 by r22</div>
   </div>
  </div>
 </body>
</html>