<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Profling Bresenham's Line Drawing Algorithm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8386" />
    <link rel="next" href="../?id=8386&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=8386">Profling Bresenham's Line Drawing Algorithm</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=8386&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=8386&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="8386" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=8386&amp;page=2">&gt;</a><a href="../?id=8386&amp;page=2">&raquo;</a></form>   <div class="post" id="post-61276">
    <div class="subject"><a href="#post-61276">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Hey guys,<br /><br />I hope this is the right forum for this topic. It isn't really a normal question so bear with me. :)<br /><br />Something really odd is happening and I was hoping one of you might have a thought as to what it could be.<br /><br />I wrote two implementations of Bresenham's line drawing algorithm. One in C and one in assembly. By all accounts the assembly version looks faster when compared to the C routine's disassembly. However, the routine is only sometimes faster.  The assembly version is in a separate library with the C calling convention.<br /><br />If I call both routines in windowed mode (I am using sdl for simplicity's sake), using hard coded coordinates from (0,0) to (399, 599) then the assembly version beats the C version by quite a bit ~114,000 lines per second as opposed to ~55,000 lines per second for the C version.<br /><br />However, if the same number of lines are drawn using randomly generated coordinates then the two routines are about the same with the C version having a narrow edge (about 1-2k lines extra per second). This seems really strange to me since with either test it is using the same seed on a psuedo-random number generator so all the lines being drawn are exactly the same for each routine. The only difference is the random nature in which things are being called. But, since both routines are being called in the same order for each test one would think that both routines would slow down similarly, but this isn't the case.<br /><br />Finally, if I run the first test (the one with hard coded coordinates) in full screen mode then the same thing happens as with random coordinates ... the C version slightly edges the asm version. <br /><br />This is boggling my mind. The thing I first thought of was maybe the rate in full screen mode was because of the display memory surface instead of system memory. So, I manually allocated an 800x600x32 buffer and drew to that. Results were the same as drawing to the normal full screen back buffer. But, even if this were the case how would it explain it doing the same thing in windowed mode when the coordinates are randomized?<br /><br />Does anybody have a clue as to what the problem might be? I can post the code if anybody needs/want that to look at. But, I don't have a problem with the code ... I have a problem with the varying results that don't seem to correlate with any aspect of hardware/software that I am familiar with.<br /><br />Thanks for any insight!<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 00:11:16 by bit</div>
   </div>
   <div class="post" id="post-61281">
    <div class="subject"><a href="#post-61281">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Chris,<br /><br />Just as a rough guess, I would suggest that the random algo is slowing things up enough for the times to be much closer between versions. Just try this, make sure you align the code in the asm version to at least 4 and see if it makes any difference.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-10-11 02:39:41 by hutch--</div>
   </div>
   <div class="post" id="post-61283">
    <div class="subject"><a href="#post-61283">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Hi <strong>Chris</strong>,<br />Post the asm source, the C source and the asm output of the C compiler.</div>
    <div class="meta">Posted on 2002-10-11 03:15:44 by Maverick</div>
   </div>
   <div class="post" id="post-61344">
    <div class="subject"><a href="#post-61344">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Hey Hutch,<br /><br />I thought about that, but why wouldn't both versions slow down accordingly? The C version runs a smidge faster without random numbers (which is to be expected), but why would the asm version more than double in speed? Shouldn't they experience the same speed-up and slow-down?<br /><br />Maverick,<br /><br />I included the source to both functions, the C version's disassembly, and an already built library file. Let me know if there is anything you would like to see.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 10:11:08 by bit</div>
   </div>
   <div class="post" id="post-61387">
    <div class="subject"><a href="#post-61387">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">The other key thing is that when I place it in full screen mode with hard-coded numbers the asm version runs a little slower than he C. But, in windowed mode is where I get that performance boost.<br /><br />It has me completely baffled.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 15:50:18 by bit</div>
   </div>
   <div class="post" id="post-61397">
    <div class="subject"><a href="#post-61397">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">I think there is too much branching. :)<br />How about an inner (and outer ;)) loop like this:<pre><code>; X increases with each loop<br /><br />GRADIENT_Y	EQU &lt;eax&gt;<br />COLOR		EQU &lt;ebx&gt;<br />INDEX		EQU &lt;ecx&gt;<br />TEMP		EQU &lt;edx&gt;<br />BUFFER		EQU &lt;edi&gt;<br />PITCH		EQU &lt;esi&gt;<br />DELTA_YoX	EQU &lt;ebp&gt;<br /><br />; INDEX = x2 - x1 ; x2 &lt; x1<br />; BUFFER = &#123;memory&#125; + y2 - INDEX<br />; DELTA_YoX = 2^32 * &#91; ABS&#40;y1-y2&#41; / &#40;x1-x2&#41; &#93;<br />; GRADIENT_Y = 0<br />; PITCH = -pitch if y2 &lt; y1 else pitch<br />_3&#58;<br />	add GRADIENT_Y, DELTA_YoX<br />	sbb TEMP, TEMP<br /><br />	mov &#91;BUFFER + INDEX*4&#93;, COLOR<br /><br />	and TEMP, PITCH<br />	inc INDEX<br /><br />	lea BUFFER, &#91;BUFFER + TEMP&#93;<br />	jne _3<br /><br /><br /><br /><br />; Y increase / decreases with each loop<br /><br />GRADIENT_X	EQU &lt;eax&gt;<br />COLOR		EQU &lt;ebx&gt;<br />INDEX		EQU &lt;ecx&gt;<br />BUFFER		EQU &lt;edi&gt;<br />PITCH		EQU &lt;esi&gt;<br />DELTA_XoY	EQU &lt;ebp&gt;<br /><br />; INDEX = x2 - x1 ; x2 &lt; x1<br />; BUFFER = &#123;memory&#125; + y2 - INDEX<br />; DELTA_XoY = 2^32 * &#91; ABS&#40;x1-x2&#41; / &#40;y1-y2&#41; &#93;<br />; GRADIENT_X = 0<br />; PITCH = -pitch if y2 &lt; y1 else pitch<br />_3&#58;<br />	mov &#91;BUFFER + INDEX*4&#93;, COLOR<br />	add BUFFER, PITCH<br /><br />	add GRADIENT_X, DELTA_XoY<br />	adc INDEX, 0<br />	jne _3<br /></code></pre>You'll also need a version for dx &lt; dy<br /><strong> Added code for dx &lt; dy</strong><br /><br />Your going to be bound by memory speed.<br />I think that is what you were testing. :)<br />Try testing a cache size virtual screen on random data.</div>
    <div class="meta">Posted on 2002-10-11 19:23:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-61398">
    <div class="subject"><a href="#post-61398">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Great Idea bitRake. I was trying to figure out how to eliminate that one branch in the inner loop, and I think that may be a great way to do it.<br /><br />But, do you have any idea why the assembly version slows down so much when using random lines, or when placed in full screen mode? That is my main concern in all of this. Something really strange is going on, and I am not sure what. I can understand my routine not being faster than the C version (although that doesn't seem very likely loking at the code). What I don't understand is why the thing runs at almost double the speed when tested in windowed mode with random lines, but a smidge slower using random lines or when placed in full screen mode.<br /><br />The varying results are driving me nuts! :confused: <br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 19:33:55 by bit</div>
   </div>
   <div class="post" id="post-61399">
    <div class="subject"><a href="#post-61399">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Ooops ... I posted before you edited your post. :)<br /><br />I thought the memory might have been an issue.<br /><br />But, why does it slow down when the hardcoded line version is tested in full screen? The memory is the same. I have tried using both system memory and video memory. When in windowed mode I get about double the lines per second rate, but when I switch that same code to use full screen the assembly version all of the sudden becomes slower than the C (but not by much).<br /><br />However, this explanation makes sense for the slowdown when switching to randomized lines. In that case, cahce hits/misses could bring the performance of the assembly version down to that of the C version ... but why doesn't the C version slow down more too?<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 19:41:55 by bit</div>
   </div>
   <div class="post" id="post-61401">
    <div class="subject"><a href="#post-61401">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Think about having 90+ cycles between memory accesses - both should run about the same on random data.  I'm not sure why windowed mode is faster, but I doubt it has anything to do with your code.  Rather than random data, try running a test of every line from the corners to every pixel in say a 256x256 space - don't use the same corner twice in a row and use relitive offsets for the pixels.  And if you cycle the colors it will look pretty. :)</div>
    <div class="meta">Posted on 2002-10-11 19:59:59 by bitRAKE</div>
   </div>
   <div class="post" id="post-61404">
    <div class="subject"><a href="#post-61404">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">No, I don't think my code has much to do with windowed mode being faster. I just wonder why the asm version is faster with hard-coded data, but not with random data when it is the same data for each test!<br /><br />Maybe' I'll try that test later tonight/tomorrow and see what happens.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 20:03:02 by bit</div>
   </div>
   <div class="post" id="post-61405">
    <div class="subject"><a href="#post-61405">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body"><div class="quote"><br />No, I don't think my code has much to do with windowed mode being faster. I just wonder why the asm version is faster with hard-coded data, but not with random data when it is the same data for each test!</div>Oh, thought I answered that - caching.<br />That is why I suggested to try a virtual screen the size of the cache.<br /><br />Also, note how a slight change in the algo for cheap anti-aliased effect lines...<pre><code>;#############################<br />; Anti-Aliased Versions&#58;<br /><br />; Blend two pixels, writing the result in the destination<br />Pixel_Blend MACRO Dest, Source<br />ENDM<br /><br />; X increases with each loop<br /><br />GRADIENT_Y	EQU &lt;eax&gt;<br />COLOR		EQU &lt;ebx&gt;<br />INDEX		EQU &lt;ecx&gt;<br />TEMP		EQU &lt;edx&gt;<br />BUFFER		EQU &lt;edi&gt;<br />PITCH		EQU &lt;esi&gt;<br />DELTA_YoX	EQU &lt;ebp&gt;<br /><br />; INDEX = x2 - x1 ; x2 &lt; x1<br />; BUFFER = &#123;memory&#125; + y2 - INDEX<br />; DELTA_Y = 2^32 * &#91; ABS&#40;y1-y2&#41; / &#40;x1-x2&#41; &#93;<br />; GRADIENT_Y = 0<br />; PITCH = -pitch if y2 &lt; y1 else pitch<br />_3&#58;<br />	add GRADIENT_Y, DELTA_YoX<br />	sbb TEMP, TEMP<br /><br />mov COLOR_A, GRADIENT_Y<br />and COLOR_A, 0FF000000h<br />or COLOR_A, COLOR<br />push COLOR_A<br />xor COLOR_A, 0FF000000h<br /><br />Pixel_Blend &#91;BUFFER + INDEX*4&#93;, COLOR_A<br /><br />pop COLOR_A<br />lea TEMP_2, &#91;BUFFER + PITCH&#93;<br />Pixel_Blend &#91;TEMP_2 + INDEX*4&#93;, COLOR_A<br /><br />	and TEMP, PITCH<br />	inc INDEX<br /><br />	lea BUFFER, &#91;BUFFER + TEMP&#93;<br />	jne _3</code></pre></div>
    <div class="meta">Posted on 2002-10-11 20:05:01 by bitRAKE</div>
   </div>
   <div class="post" id="post-61412">
    <div class="subject"><a href="#post-61412">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Sorry, I guess I wasn't clear with that last statement. What I really meant was:  <br /><br />I just wonder why the asm version is faster than the C version with hard-coded data, but not faster than the C version with random data when it is the same data for the C version and the Asm version! The caching problem would explain a slowdown from hard-coded lines to random lines since different areas of a 800x600x32bit buffer would be pulled in. But, it doesn't explain why the C version doesn't have the same amount of a slowdown since it has to pull in the same buffer areas during its execution.<br /><br />Thanks for the AA version. I have a Wu anti-aliased version in C but hadn't yet converted it to assembly. I am still deciding whether or not it is worth doing the conversion. If the assembly version isn't that much faster than the C, then I may not even bother. <br /><br /><br /><br />My latest benchmarks are as follows ...<br /><br />Windowed Mode:<br /> - ASM Version Hard-Coded (0, 0)-(799, 599) = 90,909 lines per second<br /> - C Version Hard-Coded (0, 0)-(799, 599) = 40,540 lines per second<br /><br />Full Screen Mode:<br /> - ASM Version Hard-Coded (0, 0)-(799, 599) = 17,400 lines per second<br /> - C Version Hard-Coded (0, 0)-(799, 599) = 17,045 lines per second<br /><br />So, I would expect the full screen version to run at 38,222 lines per second. In other words, at the same ratio as in windowed mode. Slow-downs in code are reasonable because of caching and other things going on in the system ... I just expect a similar slowdown for another routine that performs the same task. It just doesn't make sense to me how the assembly version can slow down by 80% and the C version only slows down by 57% when they are both being profiled on the same data set.<br /><br />Am I making any sense at all? I have been trying to sort this problem out for a few days now and it just isn't meshing well in my mind.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 22:47:13 by bit</div>
   </div>
   <div class="post" id="post-61414">
    <div class="subject"><a href="#post-61414">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">Here are the results of trying the two routines on a 100x100x32bit system allocated buffer.<br /><br />Windowed Mode:<br />- ASM Version Hard-Coded (0, 0)-(99, 99) = 1,851,851 lines per second<br />- C Version Hard-Coded (0, 0)-(99, 99) = 516,351 lines per second<br /><br />Full Screen Mode:<br />- ASM Version Hard-Coded (0, 0)-(99, 99) = 1,886,792 lines per second<br />- C Version Hard-Coded (0, 0)-(99, 99) = 559,179 lines per second<br /><br />=====<br /><br />Windowed Mode:<br />- ASM Version Random Lines = 525,394 lines per second<br />- C Version Random Lines = 414,078 lines per second<br /><br />Full Screen Mode:<br />- ASM Version Random Lines  = 525,394 lines per second<br />- C Version Random  = 419,580 lines per second<br /><br /><br />Now that makes sense!!! <br /><br />Obviously the first test hits the special cased diagonal line code and that is why it is so fast. But, these numbers are in line with my initial test results that I performed on hard coded lines (only in windowed mode). Those results were Vertical Lines: 15% faster - Horizontal Lines: 37% faster - Diagonal Lines: 55.7% faster - Random Lines: 53.8% faster.<br /><br />So, it obviously has something to do with memory ... but why/what/how is only one of the routines (the asm version) slowing down tremendously? Why doesn't the C routine do the same? This test proves that my gut feeling on the asm routine being a lot faster was indeed correct. But, why isn't it showing so?<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 23:08:50 by bit</div>
   </div>
   <div class="post" id="post-61415">
    <div class="subject"><a href="#post-61415">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">The answer is probably just simplier than you imagined - let me explain each test result in very general terms:<br /><br /><strong>Windowed Mode:</strong><br />All test are only run for a single line, so we can assume the line is in the<br />CPU cache - windows is controling the copy of memory to video.<br /><strong>- ASM Version Hard-Coded (0, 0)-(799, 599) = 90,909 lines per second</strong><br />This version runs as fast as memory will allow (assumed because all memory is in the cache).<br /><strong>- C Version Hard-Coded (0, 0)-(799, 599) = 40,540 lines per second</strong><br />This version is slower by over half.<br /><br /><strong>Full Screen Mode:</strong><br />All test are only run for a single line, so we can assume the line is in the<br />CPU cache, but it doesn't matter because we are writing directly to video memory.<br /><strong>- ASM Version Hard-Coded (0, 0)-(799, 599) = 17,400 lines per second</strong><br />This version hits memory wall.<br /><strong>- C Version Hard-Coded (0, 0)-(799, 599) = 17,045 lines per second</strong><br />This version hits memory wall.<br /><br />Basically, the full screen versions can't go faster than memory allows - there is no logic in calculating a ratio between slow downs of the routines as the slow down is not based on the performance of the code, but directly on the speed of video memory transfer.  The assembler routine has much more to loose by waiting around and doing nothing!<br /><br /><u>Moral of the story</u>:<br />If you are going to code in asm for speed: Do not wait on memory - keep the CPU busy.  And on todays faster processors you have many cycles to be very creative with.<br /><br /> Your second test show that ASM code is always waiting on memory. :)</div>
    <div class="meta">Posted on 2002-10-11 23:15:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-61416">
    <div class="subject"><a href="#post-61416">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">bitRake,<br /><br />Yeah ... it makes sense when put in those terms. :) I remember reading Michael Abrash's Black Book. In the chapter &quot;Lightning Lines and Dead Cats&quot; he talks about how the performance of the VGA display adapter was causing his ASM routine to be only twice as fast as the C version, but in reality it was actually 4 times as fast. So, that was the first thing I looked at. But, for whatever reason the explanation you just gave didn't &quot;click&quot; for me ... mainly because of what I am going to ask next. I think I was mainly being thrown off by the windowed mode results, but since that was simply a matter of it being in the cache it makes more sense now that the full screen version wasn't achieving those numbers since it was using video memory.<br /><br />So, the other question I have (and why it didn't click for me) is this:<br /><br />I created a buffer with malloc() that was the same size as the screen (800x600x32). Then I ran the same tests using that system memory buffer. With the same result as the video memory. I take it this means the ~55,000 lines per second I was getting for both routines is basically just the maximum amount of time needed for memory to be pulled in to cache and written to?<br /><br />And, a few extra just out of curiousity ...<br /><br />1 - Since I might actually be wasting a ton of cycles it seems reasonable to try and create an optimized version of the Wu anti-aliasing routine. The extra calculations per pixel could be done while waiting for memory to be pulled in since an 800x600x32 screen is never going to fit in a 64k, or even 128k, cache. What do you think of this plan? <br /><br />2 - Is it even worth it to rewrite this thing in assembly? And, is it worth it to recode so that branch is out of the inner loop? I am still up in the air. I wonder how many machines are going to have the bottleneck on memory. I suppose the asm version would allow for faster times on the lower end machines. <br /><br />Any thoughts are appreciated, as was all your guys' help. bitRake ... an extra thanks to you for the clarification I needed to see what was already in front of me. :) <br /><br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-11 23:47:50 by bit</div>
   </div>
   <div class="post" id="post-61417">
    <div class="subject"><a href="#post-61417">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">1. That is a good idea. :)<br /><br />2. Yes, but it is not easy.  I suggest studying the memory access characteristics of the CPUs (and Windows) and developing algorithms designed around those limitations.  The above line algo has been used for ages, but it can be further optimized for modern processors - be creative.<br /><br /> And you should ask yourself why you need so many lines per second. :)<br />My GeForce will beat any lines the CPU could draw.</div>
    <div class="meta">Posted on 2002-10-12 00:08:44 by bitRAKE</div>
   </div>
   <div class="post" id="post-61445">
    <div class="subject"><a href="#post-61445">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">There really isn't a need for so many lines. :) This was just a little exercise for fun. However, when I start writing my 3d software engine, simple line tracing is needed for determing the correct scan lines when rendering triangles. But the act of just drawing lines probably won't be needed. Hardware is a nice thing, but there are still a ton of machines that lack a good video card. For instance, my laptop that I do almost all of my work on doesn't have a good one at all. <br /><br />As for the algo ... I have tried the simple, straight-forward Bresenham's as well as the run-slice version, and symmetric algorithms. All variations I have tried have fallen a little short of the simple one. My guess is that all the variables that need to be maintained can't all be placed in registers and thus a lot of time is spent moving things around. But, I haven't really investigated it completely.<br /><br />One other thing is that with the little optimization you showed earlier the inner loop should be quite clean, and insanely fast. Especially for the Pentiums and their mis-predicted branching tendencies. :)<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-10-12 08:25:02 by bit</div>
   </div>
   <div class="post" id="post-61454">
    <div class="subject"><a href="#post-61454">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body"><div class="quote"><em>Originally posted by bitRAKE </em><br /><strong> And you should ask yourself why you need so many lines per second. :)<br />My GeForce will beat any lines the CPU could draw. </div><br /><br />One little question, how to instruct a GeForce (or any other gfx-card) to draw lines, plot pixles, etc?</div>
    <div class="meta">Posted on 2002-10-12 12:25:48 by scientica</div>
   </div>
   <div class="post" id="post-61456">
    <div class="subject"><a href="#post-61456">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body"><u>Use one of these</u>:<br />IDirect3DDevice8::DrawIndexedPrimitive<br />IDirect3DDevice8::DrawIndexedPrimitiveUP<br />IDirect3DDevice8::DrawPrimitive<br />IDirect3DDevice8::DrawPrimitiveUP<br /><br /><u>With one of these</u>:<br /><strong>D3DPT_POINTLIST</strong> - Renders the vertices as a collection of isolated points. <br /><strong>D3DPT_LINELIST</strong> - Renders the vertices as a list of isolated straight line segments.<br /><strong>D3DPT_LINESTRIP</strong> - Renders the vertices as a single polyline.</div>
    <div class="meta">Posted on 2002-10-12 13:27:38 by bitRAKE</div>
   </div>
   <div class="post" id="post-61489">
    <div class="subject"><a href="#post-61489">Profling Bresenham's Line Drawing Algorithm</a></div>
    <div class="body">I implemented something similar also, but I didnt profile it and it's very buggy. Anyway here it is, please don't criticize too harshly, I converted it from C directly from GameDev ;)<br /><br /><pre><code><br />mov ax,x2<br />mov bx,x1<br />sub ax,bx<br />mov deltax,ax               ;Store DELTAX in LOCAL stack RAM<br />mov ax,y2<br />mov bx,y1<br />sub ax,bx<br />mov deltay,ax               ;Store DELTAY in LOCAL stack RAM<br />mov ax,x1<br />mov bx,x2<br />;AX==X1, BX==X2<br />.IF BX &gt;= AX<br />mov xinc1,1<br />mov xinc2,1<br />.ELSE<br />mov xinc1,-1<br />mov xinc2,-1		<br />.endif<br />mov ax,y1<br />mov bx,y2<br />.IF BX &gt;= AX<br />mov yinc1,1<br />mov yinc2,1<br />.ELSE<br />mov yinc1,-1<br />mov yinc2,-1	<br />.ENDIF<br />;Initialized structures<br />mov ax,deltax<br />mov bx,deltay<br />.IF AX &gt;=BX<br />xor ax,ax<br />mov xinc1,ax<br />mov yinc2,ax<br />mov ax,deltax<br />mov den,ax<br />shr ax,1<br />mov num,ax<br />mov ax,deltay<br />mov numadd,ax<br />mov ax,deltax<br />mov numpixels,ax<br />.ELSE<br />xor ax,ax<br />mov xinc2,ax<br />mov yinc1,ax<br />mov ax,deltay<br />mov den,ax<br />shr ax,1<br />mov num,ax<br />mov ax,deltax<br />mov numadd,ax<br />mov ax,deltay<br />mov numpixels,ax		<br />.endif<br />;Precomputation is done, now time to draw line<br />;EAX==X<br />;EBX==Y<br />;ECX==Color<br />;EDX==NumPixel counter<br />movzx eax,x1<br />movzx ebx,y1<br />movzx ecx,color<br />lineloop&#58;<br />invoke DrwDot, eax, ebx, ecx<br />mov si,num<br />add si,numadd<br />mov num,si<br />.IF SI &gt;=den<br />sub si,den<br />mov num,si<br />add ax,xinc1<br />add bx,yinc1	<br />inc dx<br />cmp dx,numpixels<br />je exitlinelp<br />jmp lineloop<br />.endif<br />add ax,xinc2<br />add bx,yinc2<br />inc dx<br />cmp dx,numpixels<br />je exitlinelp<br />jmp lineloop<br />exitlinelp&#58;<br />ret<br /></code></pre></div>
    <div class="meta">Posted on 2002-10-12 18:12:25 by x86asm</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=8386&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=8386&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="8386" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=8386&amp;page=2">&gt;</a><a href="../?id=8386&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>