<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OOP framework progress - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8303" />
    <link rel="next" href="../?id=8303&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=8303">OOP framework progress</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=8303&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=8303&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="8303" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=8303&amp;page=2">&gt;</a><a href="../?id=8303&amp;page=4">&raquo;</a></form>   <div class="post" id="post-60694">
    <div class="subject"><a href="#post-60694">OOP framework progress</a></div>
    <div class="body">Hi guys<br /><br />I'm glad to see some interest in my other thread, so I thought I'd create this thread to keep everyone up to date.<br /><br />I'm currently testing some changes I've made to the framework, but it feels quite solid, so it shouldn't be too much<br />longer before it's released.<br /><br />The framework uses macros like the one by NaN and Thomas and I've actually surprised myself with<br />what I've been able to achieve using macros, especially since I didn't know that much about them when<br />I started :grin:<br /><br /><strong>DEFINING OUR OBJECT</strong><br /><br />This is the basic structure of our class<br /><br /><pre><code><br />.CLASS name, base<br /><br />	m_data dd ?<br /><br />	.OBJECT name, type, &#91;PTR&#93;<br /><br />	.STATIC name, argCount<br /><br />	.VIRTUAL name, argCount, &#91;PURE&#93;<br /><br />	.INLINE name, argList<br />		; inline code here<br />		ENDM<br /><br />.ENDC<br /></code></pre><br /><br />OK, lets get into it.<br /><br /><strong>.CLASS</strong> name, base<br /><br />This macro allows you to specify your class name and it's ( optional ) base class. <br />Only single inheritance is supported.<br /><br />Any interest or use for multiple inheritance?<br /><br /><strong>.OBJECT</strong> name, type, PTR<br /><br />This macro allows you to add an object, or an object reference to the class. If you specify the 3rd<br />argument ( PTR ) an object reference ( pointer ) will be added, otherwise the object will be<br />embedded.<br /><br /><pre><code><br />	.OBJECT m_file, CFILE ; embedded object<br />	.OBJECT m_file, CFILE, PTR ; object reference<br /></code></pre><br /><br /><strong>.STATIC</strong> name, argCount<br /><br />This macro defines a static or direct call method. The argCount are the number of arguments the method<br />expects. You don't need to include the 'THIS' argument in the count, the macro will automatically<br />add it for you.<br /><br />You can have multiple methods with the same name as long as they have different argument counts.<br />This works with virtual and inline method also.<br /><br /><pre><code><br />	.STATIC Blah, 1<br />	.STATIC Blah, 3<br />	.STATIC Blah, 256 ; ok a little excessive &#58;grin&#58; but you get the idea<br /></code></pre><br /><br /><strong>.VIRTUAL</strong> name, argCount, PURE<br /><br />This macro defines a virtual or indirect call method. The virtual macro also allows you to define abstract<br />or pure methods by specifying the 3rd argument ( PURE ). Pure virtuals are mainly for base or interface<br />classes and must be overloaded by a derived class.<br /><br /><pre><code><br />	.VIRTUAL Draw, 0 ; normal virtual<br />	.VIRTUAL Draw, 0, PURE ; pure virtual<br /></code></pre><br /><br /><strong>.INLINE</strong> name, argList<br /><br />This macro defines an inline or macro method. Since inline methods are simply macros, define arguments<br />as you would in a macro. Inline methods gain access to the 'THIS' pointer that was passed to the method<br />by using the 'this' argument.<br /><br /><pre><code><br />	.INLINE ImAMacroInDisguise, src, dest&#58;=&lt;eax&gt;<br />		mov dest, 5<br />		mov &#91;this&#93;.m_classData, src<br />		ENDM<br /></code></pre><br /><br /><strong>.ENDC</strong><br /><br />This macro ends your class definition.<br /><br /><strong>Qweerdy</strong><br /><br />Good idea about converting old OOP files :alright:<br /><br />NEXT : Defining our methods<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-05 23:50:13 by Maelstrom</div>
   </div>
   <div class="post" id="post-60697">
    <div class="subject"><a href="#post-60697">OOP framework progress</a></div>
    <div class="body"><strong>DEFINING OUR METHODS</strong><br /><br />OK, there are 3 things we need to do in the source ...<br /><br />1. Define the class template<br />2. Define the methods<br />3. Pray it works :grin:<br /><br /><strong>.TEMPLATE</strong> name<br /><br />This macro generates a template for the class. This template is used to initialize the class<br />when it's created, so it must exist. There is one exception to the rule, any class that contains<br />PURE virtuals doesn't need a template since you won't be able to create an object of that type.<br />If the macro comes across an abstract method it'll let you know.<br /><br /><pre><code><br />	.TEMPLATE CFILE<br /></code></pre><br /><br /><strong>.METHOD</strong> class, name, argList<br /><strong>.ENDM</strong><br /><br />The method macro requires the name of the class that the method belongs to, the method name,<br />and the method arguments. The macro automatically saves/restores the following registers<br />( EBX ECX EDX EDI ESI ). This behaviour can be modified the changing an equate.<br /><br /><strong>.ENTER</strong> reg<br /><br />The enter macro initializes the method ready for use. The macro can also take a single<br />argument which determines the register used to hold the 'THIS' pointer. The default is ESI.<br />You can access the 'THIS' pointer by using the 'this' equate<br /><br /><strong>.RET</strong> retVal<br /><br />The ret macro returns an optional value to the caller.<br /><br /><pre><code><br />.METHOD CFILE, Open, _pfileName<br /><br />	; locals go here<br /><br />	.ENTER<br /><br />	; code goes here<br /><br />	.RET<br /><br />.ENDM<br /></code></pre><br /><br />NEXT - Accessing our methods<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-06 03:18:51 by Maelstrom</div>
   </div>
   <div class="post" id="post-60698">
    <div class="subject"><a href="#post-60698">OOP framework progress</a></div>
    <div class="body"><strong>ACCESSING OUR METHODS</strong><br /><br /><strong>.ASSUME</strong> reg, class, ref<br /><br />The assume macro works much like MASMs keyword.<br /><br /><pre><code><br />	.ASSUME ebx, CFILE, edx<br />	.ASSUME ebx, CFILE, g_pFile<br />	.ASSUME ebx, CFILE, struct.m_pFile ; struct<br /><br />	.ASSUME ebx, CFILE, &#91;this&#93;.m_pFile ; object ref<br /></code></pre><br /><br />The 1st, 2nd, and 3rd examples read : move the value ( last arg ) into EBX and treat<br />EBX as a CFILE ptr. The values must be pointers.<br /><br />The 4th example needs more explaining. The .m_pFile is a reference to<br />either, an embedded object, or an object reference inside a CFILE class. Depending on<br />what type of object m_pFile is, the value ( reference ) or address ( embedded ) of m_pFile<br />is moved into EBX and EBX is treated like whatever type m_pFile was defined as.<br /><br /><strong>.CINVOKE</strong> class, this, method, argList<br /><br />This macro is used to call ALL methods, no matter what type they are. So if you change<br />a static method to a virtual, simply recompile and the macro will automatically adjust.<br />There is also a shorthand version, simply prefix the class name with a period.<br /><br /><pre><code><br />	.CINVOKE CFILE, this, Open, _pFileName<br /><br />	; same as<br /><br />	.CFILE this, Open, _pFileName<br /></code></pre><br /><br />I imposed one restriction on what can be passed to the macro as the 'THIS' ptr.<br />My primary reasons were to clarify what was going on and to simplify the invoke macro.<br />The 'THIS' pointer can be any of the following as long as they are pointers.<br /><br /><pre><code><br />	.CFILE ebx, Open, _pFileName<br />	.CFILE this, Open, _pFileName<br /><br />	.CFILE g_file, Open, _pFileName<br />	.CFILE g_file.m_obj, Open, _pFileName ; struct<br /><br />	.CFILE &#91;ebx&#93;, Open, pFileName ; need to test this one<br /></code></pre><br /><br />If you need to call a method from an embedded or referenced object, then use the<br />assume macro above to load a register.<br /><br /><pre><code><br />	; lets assume &#91;this&#93;.m_image was a CIMAGE class<br /><br />	.ASSUME ebx, CFILE, &#91;this&#93;.m_image<br /><br />	.CIMAGE ebx, DoSomethingUseful, blah<br /></code></pre><br /><br /><strong>.SUPERCLASS</strong> class, this, method, argList<br /><br />This macro will allow you to call the base class version of the specified method.<br />The 'THIS ptr must be a register at present, but that shouldn't be much of a<br />problem since you will probably only try to superclass a method from inside its<br />overloaded equivalent.<br /><br /><pre><code><br />	.SUPERCLASS CFILE, this, Constructor<br /></code></pre><br /><br />NEXT - Creating our object<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-06 03:39:22 by Maelstrom</div>
   </div>
   <div class="post" id="post-60699">
    <div class="subject"><a href="#post-60699">OOP framework progress</a></div>
    <div class="body"><strong>CREATING OUR OBJECT</strong><br /><br />We have 2 options when creating objects.<br /><br />1. Dynamic creation<br />2. Static creation<br /><br />Would local creation be a useful addition?<br /><br /><strong>.NEW</strong> reg, class, args<br /><strong>.DELETE</strong> this<br /><br />These macros will create and destroy dynamic objects.<br /><br /><strong>.CREATE</strong> reg, class, args<br /><strong>.DESTROY</strong> this<br /><br />These macros will create and destroy static objects.<br /><br />:eek: I hope I haven't scared everyone away ... anyone there ... it's not as complicated as it looks :grin:<br /><br />I had some more ideas while typing this and I want to I'll try them out. I will post the framework and an example ASAP.<br /><br />Comments, questions, and suggestions welcome.<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-06 04:09:37 by Maelstrom</div>
   </div>
   <div class="post" id="post-60999">
    <div class="subject"><a href="#post-60999">OOP framework progress</a></div>
    <div class="body">Come on guys, where did everyone go, Nan, Maverick, anyone ...<br /><br />Oh well, suppose I'll talk to myself some more :grin:<br /><br /><strong>CHANGES</strong><br /><br />I've tweeked the .TEMPLATE macro a little bit, simply include it in the source and let the macro determine if it's actually needed.<br /><br />I've also added local stack objects ( <strong>.LOCAL</strong> name, class, argList )<br />Simply specify them with the rest of your methods locals and they'll be automatically constructed and destroyed.<br /><br />The example below shows how to define a local object. The m_bob vararible will end up containing a pointer to the object.<br /><br /><pre><code><br />	.METHOD CCLASS, SomeMethod, args<br /><br />		.LOCAL m_bob, CBOB, bobsArgs<br /><br />		.ENTER<br /><br />		.RET<br /><br />	.ENDM<br /></code></pre><br /><br />I've also changed the way objects are destroyed. The .DELETE and .DESTROY macros have been<br />tossed and all objects now inherit a Release method. The Release method will destroy the object no matter<br />how it was created ( dynamically or statically ) which saves you from having to remember what you did.<br /><br />Also attached is a simple example.<br />You can't compile the code but it shows the framework layout, the EXE is included.<br /><br />The example is based on the simple OOP example by Nan - hope you don't mind Nan :grin:<br />Would you mind if I converted your other object examples ??<br /><br />Now come on guys, feedback<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-08 21:01:58 by Maelstrom</div>
   </div>
   <div class="post" id="post-61007">
    <div class="subject"><a href="#post-61007">OOP framework progress</a></div>
    <div class="body">I like the syntax, but the example doesn't tell much about the code generation.  I think it is important to retain the flexiblity that ASM is, while still providing OOP syntax to speed development.  Without rewriting the parser in MASM macro syntax or bloating the code, I think this is getting close to the limits of what is possible in MASM.<br /><br />For another level of granularity you will want to ensure object files are encapsulated by making all the PROCs private and only exposing public PROCs with an interface definition (ie include file).<br /><br />Can't wait to try this out on a couple of projects.  Can all the code produced be inline and without memory access?  For example, the x86 supports bit array's directly with the BT/BTC/BTR/BTS instructions and I'd like to make a bit array class that merely inlines the instructions.  Trick is: I'd like to use a register if the bit arrays are &lt;= 32 bits -- rather than using a memory pointer. :)  What is the smallest amount of code that will be produced by the class macros?</div>
    <div class="meta">Posted on 2002-10-08 22:15:11 by bitRAKE</div>
   </div>
   <div class="post" id="post-61009">
    <div class="subject"><a href="#post-61009">OOP framework progress</a></div>
    <div class="body">How about allowing:<pre><code>.CREATE m_circle, CCIRCLE<br /><br />; .CREATE macro establishes m_circle as being of type CCIRCLE<br />; so invoking methods of this object only require the instance name<br />; followed by method name and parameters.<br /><br />m_circle SetColor, 7<br />m_circle SetRadius, 2</code></pre>See other examples:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=1945">http://www.asmcommunity.net/board/index.php?topic=1945</a><br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=2932.msg18991">http://www.asmcommunity.net/board/index.php?topic=2932.msg18991</a></div>
    <div class="meta">Posted on 2002-10-08 22:36:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-61027">
    <div class="subject"><a href="#post-61027">OOP framework progress</a></div>
    <div class="body">Thanks for the suggestions <strong>bitRAKE</strong><br /><br /><div class="quote">For another level of granularity you will want to ensure object files are encapsulated by making all the PROCs private and only exposing public PROCs with an interface definition (ie include file).</div><br /><br />I think <strong>NaN</strong> posted a suggestion somewhere about using PRIVATE code segments to this end, but I haven't looked into this yet - nice idea tho<br />Can't you specify PRIVATE when you define your PROC? Would that work, would save having lots of different segments?<br /><br /><div class="quote">Can all the code produced be inline and without memory access?</div><br /><br />If you mean can all methods be inline, that should work, you still need to create an object tho - is this what you mean?<br />If not a small code example of what your after would give me a better idea of what you want.<br />The only method I can't inline is the destructor since it's virtual.<br /><br /><pre><code><br />.CLASS CBITARRAY<br /><br />	.INLINE Constructor<br />		xor eax, eax<br />		ENDM<br /><br />	.INLINE Method1<br />		add eax, ebx<br />		ENDM<br /><br />	.INLINE Method2<br />		add eax, ecx<br />		ENDM<br /><br />.ENDC<br /></code></pre><br /><br /><div class="quote">What is the smallest amount of code that will be produced by the class macros?</div> <br /><br />The smallest amount of code should be from inlines when passing the 'THIS' ptr in a register.<br />Using the above example ...<br /><br /><pre><code><br />	.CREATE ebx, CBITARRAY ; create static bit array object<br /><br />	.CBITARRAY ebx, Method1<br />	.CBITARRAY ebx, Method2<br /></code></pre><br /><br />The above code should produce the following ...<br /><br /><pre><code><br />	mov ebx, OFFSET ??0001 ; or whatever the local symbol for the object is<br />	xor eax, eax ; Constructor<br />	add eax, ebx ; Method1<br />	add eax, ecx ; Method2<br /></code></pre><br /><br /><div class="quote">How about the following .CREATE m_circle, CCIRCLE</div><br /><br />Nice idea, definitely worth some investigation, shouldn't be to hard to implement - touch wood ( taps on head ) :grin:<br /><br /><strong>EDIT1</strong><br /><br /><strong>bitRAKE</strong><br /><br />I've added your suggestion, whats next! hehe :grin:<br /><br />You can create and invoke methods as shown below and access the object ptr using m_circle<br /><br /><pre><code><br />	.CREATE m_circle, CCIRCLE, &#91;args&#93;<br /><br />	.m_circle SetColor, 7<br />	.m_circle SetRadius, 2<br /><br />	; same as<br /><br />	.CCIRCLE m_circle, SetColor, 7<br />	.CCIRCLE m_circle, SetRadius, 2<br /><br />	; or<br /><br />	.CREATE ebx, CCIRCLE, &#91;args&#93;<br /><br />	.CCIRCLE ebx, SetColor, 7<br />	.CCIRCLE ebx, SetRadius, 2<br /></code></pre><br /><br />The .LOCAL and .NEW macros to will perform the same. You will have to use the second method if you want to use <br />a register as the 'THIS' ptr however.<br /><br />When passing the 'THIS' ptr as a memory argument slightly more code is generated when calling inline or virtual<br />methods since these move the 'THIS' ptr into a register, statics are fine however since since the memory argument<br />is passed directly to the method.<br /><br /><strong>EDIT2</strong><br /><br /><strong>bitRAKE</strong><br /><br />I'm investigating replacing the .ENTER macro will a custom PROLOGUE, looks good so far but I was<br />wondering why the assembler generates an add esp, -# when allocating locals, is add more efficient than sub?<br />What about the EPILOGUE, should I use leave or mov esp, ebp, pop ebp?<br /><br />Also looking at the .LOCAL macro, it would be more efficient to create a static object since its initialized at compile time.<br />If I create an object on the stack I have to initialize it at run time. Either way the constructor ( if one exists ) and<br />destructor need to be called everytime the method is called. What do you think?<br /><br /><strong>EDIT3</strong><br /><br /><strong>bitRAKE</strong><br /><br />The prologue was going so well too, I've just found it doesn't like my segment fix ( n1 EQU $ ), it says its too complex :confused:<br />How does it work with the default prologue then?<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-09 02:21:03 by Maelstrom</div>
   </div>
   <div class="post" id="post-61113">
    <div class="subject"><a href="#post-61113">OOP framework progress</a></div>
    <div class="body"><strong>PRIVATE METHODS</strong><br /><br /><strong>bitRAKE</strong><br /><br />I think I've worked out how to support private methods. Now I'm makng the assumption that private methods should only<br />be called from inside public methods of the same class. For example, if we have a class with public methods ( x and y ) and private<br />methods ( z ), then z can only be called from inside x and y. Does this sound correct?<br /><br />This would be useful for private inline methods that set class data that you don't want to be accessed publicly. Of cource all class<br />data is still publicly accessible so you could easily break the rules.<br /><br />I can see uses for private static and inline methods, but what about private virtuals?<br /><br />Revised class format will probably look like this<br /><br /><pre><code><br />.CLASS<br /><br />	.PUBLIC<br /><br />	; data<br /><br />	; public methods<br /><br />	.PRIVATE<br /><br />	; private methods<br /><br />.ENDC<br /></code></pre><br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-09 22:20:49 by Maelstrom</div>
   </div>
   <div class="post" id="post-61124">
    <div class="subject"><a href="#post-61124">OOP framework progress</a></div>
    <div class="body"><div class="quote"><br /><strong>EDIT3</strong><br /><br /><strong>bitRAKE</strong><br /><br />The prologue was going so well too, I've just found it doesn't like my segment fix ( n1 EQU $ ), it says its too complex :confused:<br />How does it work with the default prologue then?</div>If you are speaking of using it within the prologue macro itself, then try not using it - I'm crossing my fingers that it won't be required. ;)<br /><br />Wow, the rest looks good - many layers of abstraction - mucho fun. :alright:</div>
    <div class="meta">Posted on 2002-10-09 23:06:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-61144">
    <div class="subject"><a href="#post-61144">OOP framework progress</a></div>
    <div class="body">This is what I tried<br /><br /><pre><code><br />.METHOD CTEST, TestMethod<br /><br />	.CREATE m_test, CTEST<br /><br />	.RET<br /><br />.ENDM<br /></code></pre><br /><br />The compiler says the statement is too complex ( n1 EQU $ ) which is the first thing the .CREATE macro does :rolleyes:<br /><br />No biggie if I have to keep the .ENTER macro I suppose.<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-10 02:07:22 by Maelstrom</div>
   </div>
   <div class="post" id="post-61263">
    <div class="subject"><a href="#post-61263">OOP framework progress</a></div>
    <div class="body">Oh well, no luck getting my prologue macro working with the segment fix so I've decided to forget it, for the moment anyway.<br /><br />Since the .ENTER macro stays, I decided to make it force prologue generation as the first thing it does. This way any segment<br />changes after the .ENTER should work properly without having to modify any existing macros. I also created the .PROC macro which<br />has a similar syntax to the .METHOD macro but creates non-method routines.<br /><br /><pre><code><br />.METHOD class, method, args<br /><br />	; locals here<br /><br />	.ENTER<br /><br />	; your code here<br /><br />	.RET &#91;val&#93;<br /><br />.ENDM<br /><br />.PROC name, args<br /><br />	; locals here<br /><br />	.ENTER<br /><br />	; your code here<br /><br />	.RET &#91;val&#93;<br /><br />.ENDP<br /></code></pre><br /><br />Private methods seem to be working but I need to do some more testing.<br /><br />I was thinking of changing how the .LOCAL macro creates its objects, instead of creating them on the stack<br />I thought I would create them statically. This would use a little more memory but since static objects are<br />initialized at compile time it would be faster.<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-10 21:16:07 by Maelstrom</div>
   </div>
   <div class="post" id="post-61323">
    <div class="subject"><a href="#post-61323">OOP framework progress</a></div>
    <div class="body">I was thinking about how to make accessing embedded and referenced objects a little more readable.<br /><br /><pre><code><br />.CLASS CENGINE<br /><br />	.OBJECT m_render, CRENDER, PTR<br /><br />.ENDC<br /></code></pre><br /><br />To get the address of an embedded object or the ptr to a referenced object you have to use the .ASSUME macro.<br /><br /><pre><code><br />.ASSUME ebx, CENGINE, &#91;this&#93;.m_render<br /></code></pre><br /><br />This will place the object ptr in EBX and make EBX a CENGINE type.<br />Using the suggestion above by <strong>bitRAKE</strong>, I could create a named equate so you could access EBX as .m_render<br />This would allow the following<br /><br /><pre><code><br />; default access<br /><br />.CRENDER ebx, DrawScene<br /><br />; or using the named equate<br /><br />.m_render DrawScene<br /></code></pre><br /><br />One problem that could occur would be if you trashed EBX, it would probably crash and the problem wouldn't be obvious<br />in the code since the register usage is hidden by the equate.<br /><br />A solution could be to have the .ASSUME macro create a data variable to hold the object ptr. Extra data and code<br />would be generated but the above problem wouldn't occur. I personally don't like the idea of adding any unnecessary<br />data or code, but on the other hand I don't like hard to find bugs either :grin:<br /><br />Another problem I just thought of would be if multiple objects each contained an object with the same name. A<br />simple solution to this could be to add an optional argument to the .ASSUME macro to specify a custom name for the<br />named equate.<br /><br /><pre><code><br />.ASSUME ebx, CENGINE, &#91;this&#93;.m_render, m_d3d<br />.ASSUME edx, CBLAH, &#91;this&#93;.m_render, m_opengl<br /></code></pre><br /><br />What do you guys think?<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-11 07:50:43 by Maelstrom</div>
   </div>
   <div class="post" id="post-61795">
    <div class="subject"><a href="#post-61795">OOP framework progress</a></div>
    <div class="body">Anyone still reading this - hehe :grin:<br /><br />Private methods are in and working and can only be called from public methods from the same class.<br />You can make static, virtual, and inline methods private.<br /><br />WARNING :eek:<br /><br />Inline methods have proven to be quite the minefield. I initially created inline methods for the simple<br />purpose of directly accessing object data in a controlled manner. With the improvements to the<br />framework they can now do almost anything, including calling private methods. I guarentee you<br />that they will cause a lot of headaches if your not careful using them. Since all inlines recieve there 'THIS'<br />ptr as a register and it is hidden behind the 'this' keyword, it would be very easy to trash the this register. It gets even<br />worse if you nest other inline calls inside an inline method since no register saving is done, so your code<br />could very easily turn to custard. I would recommend using inlines sparingly and VERY carefully, you've been<br />warned - hehe :grin:<br /><br /><strong>bitRAKE</strong><br /><br />You wanted to know about code generation so I've included a text file that shows the code generated when<br />defining your methods, calling methods, and creating static objects. I use the /EP compiler switch and a crappy<br />filter proggy I wrote to generate the file. I use this text file to check the framework output during testing.<br />There's room for optimization but I think I'll leave that until I look at a writing a preprocessor.<br /><br />I've also created a named equate for the 'THIS' ptr using your suggestion above.<br /><br />Tell me what you guys think :alright:<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-14 22:36:03 by Maelstrom</div>
   </div>
   <div class="post" id="post-61920">
    <div class="subject"><a href="#post-61920">OOP framework progress</a></div>
    <div class="body">Hi guys, I want your opinion<br /><br />What format would you prefer when calling methods?<br /><br /><pre><code><br />.CTEST ebx, TestMethod<br /><br />.m_test TestMethod<br /><br />or <br /><br />.CTEST&#40; ebx, TestMethod &#41;<br /><br />.m_test&#40; TestMethod &#41;<br /></code></pre><br /><br />I'm currently testing the second format to see how it feels, but I <strong>really</strong> want other opinions.<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-15 19:58:28 by Maelstrom</div>
   </div>
   <div class="post" id="post-61924">
    <div class="subject"><a href="#post-61924">OOP framework progress</a></div>
    <div class="body">Lose the parenthesis.  Really - I mean it. :grin:<br /><br />It is bad enough we will have to use them on the parameters where macros are involved - no more.</div>
    <div class="meta">Posted on 2002-10-15 20:50:13 by bitRAKE</div>
   </div>
   <div class="post" id="post-62110">
    <div class="subject"><a href="#post-62110">OOP framework progress</a></div>
    <div class="body">Okay, <strong>bitRAKE</strong> has spoken so the parentheses have been taken out back and shot! :grin: I didn't like the extra typing anyway.<br /><br />Anyway I'm currently testing the framework on my old object code ( upgrading to the new format ) and all seems to be<br />going well. The interface suggestion by <strong>bitRAKE</strong> makes for some nice clean code. So all going well I'll probably<br />release the framework some time this weekend, don't tell Murphy :rolleyes:<br /><br />I've added yet another macro, this time to export object ptrs ( I've got more macros than you can throw your cat at :grin: )<br /><br /><pre><code><br />.EXTERNDEF g_console, CCONSOLE<br /></code></pre><br /><br />This simply defines g_console as a DWORD and creates the named equate .g_console in the include file so that you can<br />access it globally.<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-17 02:03:22 by Maelstrom</div>
   </div>
   <div class="post" id="post-62158">
    <div class="subject"><a href="#post-62158">OOP framework progress</a></div>
    <div class="body">Okay, there are still a couple of things that I'm not happy with ...<br /><br />Firstly inline volatility ( big word eh :grin: )<br /><br />The problem with inlines as they stand, is that they recieve the 'THIS' ptr in a register,  <strong>any</strong> register. Passing the 'THIS' pointer in EAX would give some consistancy and would place the responsibility of register preservation in the hands of the coder. There would be a minor overhead increase as EAX would need to be set for both register and memory references ( memory only at the moment ). EAX is also a scratch register, so if other methods need to be invoked the 'THIS' register must be preserved.<br /><br />Sound okay?<br /><br />Secondly named equates for .CREATE and .NEW<br /><br />I'm mainly looking for opinions on this one. When you create an object you can specify a data name or a register to store the object pointer. If you specify a data name the macro generates a named equate so you can access the object using its name, but if you specify a register no equate is generated.<br /><br />Do I need to generate named equates for registers or not?<br /><br />If so how, I mean I can't add anything after the argList since it's VARARG. I could create another macro ( don't really like this idea, got enough already :o ) or I could create an equate like .ebx<br /><br />To put this into code ...<br /><br /><pre><code><br />; this is fine<br /><br />.CREATE m_test, CTEST, &#91;argList&#93;<br /><br />.m_test Method, args<br /><br />; but if you specify a register, no equate is generated and<br />; methods must be called using the original syntax<br /><br />.CREATE ebx, CTEST, &#91;argList&#93;<br /><br />.CTEST ebx, Method, &#91;argList&#93;<br /><br />; would this be okay &#40; easy solution &#41;<br /><br />.ebx Method, &#91;argList&#93;<br /></code></pre><br /><br />Feedback please!<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-17 06:37:38 by Maelstrom</div>
   </div>
   <div class="post" id="post-62175">
    <div class="subject"><a href="#post-62175">OOP framework progress</a></div>
    <div class="body">About the inline macro problem, perhaps the register that the THIS pointer is passed in could be defined separately for each inline method? I mean, sometimes it's a good thing to have it in eax, other times it's better when it's in a less-used register like edi.<br /><br />I have no idea if it's possible, but perhaps something like this:<br /><br /><pre><code><br />.INLINE Method1<br />.THIS ebx<br /><br />; etc...<br /><br />ENDM<br /></code></pre><br /><br />I'd really like that...</div>
    <div class="meta">Posted on 2002-10-17 08:26:40 by Qweerdy</div>
   </div>
   <div class="post" id="post-62256">
    <div class="subject"><a href="#post-62256">OOP framework progress</a></div>
    <div class="body"><pre><code>.ebx Method, &#91;argList&#93;</code></pre>The problem I see here is what <strong>.ebx</strong> is this?  Object1, Object2, ...  Just for programmer sanity we need to say what <strong>.ebx</strong> is, imho.  It is like the whole ASSUME MASM keyword idea - I don't like it - we like to ASSUME, but imho it is much better to know. :)  Maybe something like:<pre><code>.ebx CTEST, Method, &#91;argList&#93;</code></pre>This puts the object first and has the type in there - only need one macro for each register. :)</div>
    <div class="meta">Posted on 2002-10-17 19:37:56 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=8303&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=8303&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="8303" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=8303&amp;page=2">&gt;</a><a href="../?id=8303&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>