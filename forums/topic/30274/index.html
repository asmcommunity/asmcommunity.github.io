<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Tail-Call Optimization with different functions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30274" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30274">Tail-Call Optimization with different functions</a></p>
   <div class="post" id="post-213334">
    <div class="subject"><a href="#post-213334">Tail-Call Optimization with different functions</a></div>
    <div class="body">I&#039;m new to assembly programming, so hopefully the answer here is simple or at least not too difficult!<br /><br />I am writing an object that is supposed to free itself, including both data AND code, before returning. (The object in question is a COM object on Windows but the fact that it&#039;s COM doesn&#039;t matter too much.) The code needs to work on both x86 and x64.<br /><br />The general approach is that the last things the free function should do are:<br />1) clean up the stack;<br />2) do not mess with the return address;<br />3) set up the stack for VirtualFree; and finally<br />3) jump to the Win32 API call VirtualFree.<br /><br />VirtualFree will free the data and code for the object, so it is self-deleting. Then it returns directly to the caller. If it returns to my free function, the code will crash because VirtualFree just freed the memory.<br /><br />Here is a sample of some C code with sample assembly for each line:<br /><br /><pre><code><br />static ULONG WINAPI SampleObj_Release(IUnknown *This)<br />{<br />77B14C10&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; ebp&nbsp; <br />77B14C11&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  ebp,esp <br />77B14C13&nbsp; sub&nbsp; &nbsp; &nbsp; &nbsp;  esp,48h <br />77B14C16&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; ebx&nbsp; <br />77B14C17&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; esi&nbsp; <br />77B14C18&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; edi&nbsp; <br />	SampleObj *p = (SampleObj*)This;<br />77B14C19&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,dword ptr  <br />77B14C1C&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  dword ptr ,eax <br />	ULONG refs = _InterlockedDecrement(&amp;p-&gt;dwRefs);<br />77B14C1F&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,dword ptr  <br />77B14C22&nbsp; add&nbsp; &nbsp; &nbsp; &nbsp;  eax,8 <br />77B14C25&nbsp; or&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ecx,0FFFFFFFFh <br />77B14C28&nbsp; lock xadd&nbsp;  dword ptr ,ecx <br />77B14C2C&nbsp; dec&nbsp; &nbsp; &nbsp; &nbsp;  ecx&nbsp; <br />77B14C2D&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  dword ptr ,ecx <br />	if (refs != 0) return refs;<br />77B14C30&nbsp; je&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SampleObj_Release+27h (77B14C37h) <br />77B14C32&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,dword ptr  <br />77B14C35&nbsp; jmp&nbsp; &nbsp; &nbsp; &nbsp;  SampleObj_Release+66h (77B14C76h) <br /><br />...<br /><br />	// TODO: force a trampoline jump in assembly!<br />	return p-&gt;pFixedEntries-&gt;pVirtualFree(p-&gt;pVtbl, 0, MEM_RELEASE);<br />77B14C5E&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; 8000h <br />77B14C63&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; <br />77B14C65&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,dword ptr  <br />77B14C68&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  ecx,dword ptr  <br />77B14C6A&nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; ecx&nbsp; <br />77B14C6B&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  edx,dword ptr  <br />77B14C6E&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,dword ptr  <br />77B14C71&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  ecx,dword ptr  <br />77B14C74&nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; ecx&nbsp; <br />}<br />77B14C76&nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;  edi&nbsp; <br />77B14C77&nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;  esi&nbsp; <br />77B14C78&nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;  ebx&nbsp; <br />77B14C79&nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  esp,ebp <br />77B14C7B&nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;  ebp&nbsp; <br />77B14C7C&nbsp; ret&nbsp; &nbsp; &nbsp; &nbsp;  4&nbsp; &nbsp; <br /></code></pre><br /><br />What is the right assembly to do this? I know that in x86, I can get away with using inline assembly in MSVC towards the end. But in x64, I think that I have to use MASM or equivalent to write out the entire function call.<br /><br />Note that WINAPI is __stdcall, so the arguments in x86 get pushed onto the stack and are freed by the callee, not the caller. On x64, the first four arguments are passed via registers and shadow stack space is allocated. Since the initial function just takes one argument (the this pointer), and VirtualFree takes three arguments, it should work. The return value is not of any consequence.<br /><br />Thanks!</div>
    <div class="meta">Posted on 2010-10-12 20:55:27 by SeanTek</div>
   </div>
   <div class="post" id="post-213335">
    <div class="subject"><a href="#post-213335">Re: Tail-Call Optimization with different functions</a></div>
    <div class="body"><br />Who gave you the impression that code and data of a COM object are deallocated together?<br />Just imagine what would happen if you wanted to create a New Instance!!<br /><br />Truth is, the code never gets deallocated - it remains in memory at all times, there are no exceptions that I can think of.<br />The code, together with the Class Template, are embedded in the binary file you compiled, and remain available pending subsequent utilization.<br />Only thing that we are releasing is some (typically Heap) memory which represented an Instance of our Class Template (ie, a clone in heap memory).<br /><br />Therefore, after calling VirtualFree, the CODE is ok to continue executing, as long as it does NOT reference any data fields (since the data did get released).<br /><br />Now, just to convince you that this is the case, imagine that you were in fact correct about the code being associated with an object instance - this would imply that there&#039;s a whole copy of the code for EVERY INSTANCE of the class (which would be silly), and it also implies that the code must be PC-RELATIVE in order to execute at arbitrary address in memory, rather than optimized for some fixed virtual address.. which do you consider is more likely?<br /></div>
    <div class="meta">Posted on 2010-10-12 21:35:41 by Homer</div>
   </div>
   <div class="post" id="post-213336">
    <div class="subject"><a href="#post-213336">Re: Tail-Call Optimization with different functions</a></div>
    <div class="body">Ah, but that is the point. In this case, I am explicitly creating an object that does not require its DLL (with the code sections) to be loaded in memory at all times. The code executes after the DLL is loaded, but the DLL can be unloaded while the object (or at least a barebones fraction of the object) remains in memory.<br /><br />This is a pretty unusual task, but I thought the whole point of going to low-level Assembly is to unusual things.&nbsp; :thumbsup:<br /><br />In this case, yes, there&#039;s a whole copy of the code for every instance of the class. But the size is minimal, and far less than the size of a page (4096 bytes) to hold it. It does not have to be that way--one could have a reference count on the code and when the last instance is destroyed, the code is also VirtualFree&#039;d.<br /><br />The code is all PC-relative. In this case, the code is merely stub code: 99% of the main functionality is written in C/C++, not Assembly. Also, I suppose that this is a more general technique for just-in-time freeing of code--it doesn&#039;t have to be COM at all.</div>
    <div class="meta">Posted on 2010-10-12 21:53:01 by SeanTek</div>
   </div>
   <div class="post" id="post-213338">
    <div class="subject"><a href="#post-213338">Re: Tail-Call Optimization with different functions</a></div>
    <div class="body">I&#039;m writing the implementation to it.</div>
    <div class="meta">Posted on 2010-10-12 22:21:03 by SeanTek</div>
   </div>
   <div class="post" id="post-213342">
    <div class="subject"><a href="#post-213342">Re: Tail-Call Optimization with different functions</a></div>
    <div class="body">Then you answered your own question - rather than &quot;call&quot; the VirtualFree function and return to caller, we JMP to it, and return to OUR CALLER&#039;S CALLER.<br /><br />At the end of the VirtualFree function, there is a RET.<br />If we did not CALL the function but instead JMP to it, whose return address is on top of the call stack? We are returning, but not to our DLL code - instead, we are returning to the code that called our DLL stub function which lead to the VirtualFree function via a JMP - makes sense?<br /><br />In fact we can abstract this further, we could deliberately POP THE RETURN ADDRESS from the stack and shove ANY RETURN ADDRESS we wanted to, and when we return we will then return &quot;to somewhere else&quot; !!!<br /><br />But I leave this to your avid imagination ;)<br />Yes, things we can do in ASM don&#039;t always follow &quot;the rules&quot; since we are the game masters.<br /></div>
    <div class="meta">Posted on 2010-10-13 05:37:18 by Homer</div>
   </div>
   <div class="post" id="post-213371">
    <div class="subject"><a href="#post-213371">Re: Tail-Call Optimization with different functions</a></div>
    <div class="body">In order to jump directly to a STDCALL function, you need to effectively remove all stack data associated with the current function, before stacking the arguments for the function you&#039;re jumping to. You also need to ensure that the &quot;invariant&quot; registers EBX, ESI, EDI, and EBP have the correct values before jumping to the function.<br /><br />A simple-minded way to accomplish this is to first stack the arguments, stack a copy of the return address, restore registers, and then use the scratch registers EAX, ECX, and EDX to move the arguments and return address upward to replace the data that must be unstacked. Set ESP, and then jump.<br /><br />The default installation of VC uses CDECL as the default for &quot;normal&quot; C++ functions, which means you leave the arguments and replace the return address and local variables with the new arguments and a copy of the old return address. If you set the compiler option to use STDCALL or explicitly use __stdcall or WINAPI, you replace/remove the current argument list in addition to the return address and locals.</div>
    <div class="meta">Posted on 2010-10-17 02:50:41 by tenkey</div>
   </div>
   <div class="post" id="post-213378">
    <div class="subject"><a href="#post-213378">Re: Tail-Call Optimization with different functions</a></div>
    <div class="body">Thanks all! Looks like I got it working.<br /><br />Assume the pointer to VirtualFree is in EAX, and the pointer to the memory to free is in EDX<br /><pre><code><br />&nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp;  esi<br />&nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp;  ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; now ecx contains the return address<br />&nbsp; &nbsp; add&nbsp; &nbsp; &nbsp;  esp,4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; from ret 4 equivalence (pop arg0 aka this pointer--<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; we clean the stack)<br />&nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; 8000h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; MEM_RELEASE<br />&nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; 0 (size)<br />&nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; memory to free<br /><br />&nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; return pointer<br />&nbsp; &nbsp; jmp&nbsp; &nbsp; &nbsp;  eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; tail-call jump to VirtualFree(...)<br /></code></pre></div>
    <div class="meta">Posted on 2010-10-19 18:38:06 by SeanTek</div>
   </div>
  </div>
 </body>
</html>