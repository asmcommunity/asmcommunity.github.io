<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Alexei A. F. tuts in pmode... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21167" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=34">OS Development</a> &raquo; <a href="../?id=21167">Alexei A. F. tuts in pmode...</a></p>
   <div class="post" id="post-160267">
    <div class="subject"><a href="#post-160267">Alexei A. F. tuts in pmode...</a></div>
    <div class="body">Ok, I write because Im stuck, have passed much time from this subject attract me, but in fact havent done nothing about practice.<br /><br />By the way, the &quot;enviroment&quot; is still in real mode, I have &quot;copied&quot; some code for load sectors in the floppy. and jump where is it loaded...<br /><br />Im now &quot;traslating&quot; the tutorial 2 of this guy, the problem come when is called the function update_cs, tought I cant see where the problem reside...<br /><br />I will paste my code and break where I think is the problem... (scroll down to the second &quot;code&quot; section)<br /><br />This first lines are the output of the loops taht check the descriptors...<br /><pre><code><br />; (1:2)&nbsp; (3:4)&nbsp; (5) (6)&nbsp;  (7)&nbsp;  (8)&nbsp;  | NAME_OF_SELECTOR<br />; 0000 | 0000 | 00&nbsp; | 00&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (zero)<br />; ffff | 0000 | 01&nbsp; | 9a&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (code)<br />; ffff | 0000 | 01&nbsp; | 92&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (data)<br />; ffff | 0000 | 01&nbsp; | 92&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (stack)<br />; ffff | 8000 | 0b&nbsp; | 92&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (video)<br />jmp start2<br /><br />; %define REGPRINT<br />%include &quot;basic.inc&quot;<br />%include &quot;pmdefs.inc&quot;<br />Print_DL<br />Print_Hex16:<br />push bx<br />mov cx, 2<br /><br />PrintDigit:<br />		rol&nbsp;  dl, 4&nbsp; &nbsp; &nbsp; 	; rotate so that lowest 4 bits are used<br />		mov&nbsp;  ax, 0E0Fh		; ah = request, al = mask for nybble<br />		and&nbsp;  al, dl<br /><br />		add&nbsp;  al, 90h		; convert al to ascii hex (four instructions)<br />		daa<br />		adc&nbsp;  al, 40h<br />		daa<br /><br />		int&nbsp;  10h		; call BIOS to print char<br />		loop&nbsp; PrintDigit<br />		pop bx<br />		ret<br /><br />Print_CRLF:<br />		mov	ax,0E0Dh	; al=CR=0x0D, ah=0x0E=print char fn<br />		int	10h<br />		mov	ax,0E0Ah	; al=LF=0x0A<br />		int	10h<br />		ret<br />; ##########################################<br />; pm.h<br />; ##########################################<br /><br />; unsigned int read_msw();<br />read_msw:<br />	smsw ax<br />	ret<br /><br />; unsigned long read_cr0();<br />read_cr0:<br />	mov eax, cr0<br />	;mov edx, eax<br />	;shr edx, 16 ; return dx:ax<br />	ret<br /><br />; void write_cr0 (unsigned long value);<br />write_cr0:<br />	push bp<br />	mov bp, sp<br />	mov eax,  ; 2 ret addr + 2 of old bp and read from here 32-bit argument<br />	mov cr0, eax<br />	pop bp<br />	ret 4<br /><br />; void&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lgdt (GDTR *gdtr);<br />; is load_gdt because lgdt is the asm instruction...<br />load_gdt:<br />	push bp<br />	mov bp, sp<br />	push bx<br />	mov bx,  ; ds:bx = pointer to the GDTR<br />	lgdt &nbsp;  ; load GDTR<br />	pop bx<br />	pop bp<br />	ret 2<br /><br />; void&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_cs (unsigned int bew_cs);<br />update_cs:<br />	push bp<br />	mov bp, sp<br />	mov ax,  ; ax = new CS<br />	push ax&nbsp; &nbsp; &nbsp; &nbsp; ; push segment<br />	push word .1&nbsp;  ; push offset<br />	retf&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; we have a new CS now<br />	.1:<br />	pop bp<br />	ret 2<br /><br /><br /><br />; ##########################################<br /><br /><br /><br />; ####################################################################<br />; source of tutorial<br />; ####################################################################<br /><br /><br />gdt_label: times (5*DESCR_SEG_size) db 0<br />gdtr_label: times DESCR_GDTR_size db 0<br /><br />old_CS dw 0<br />old_DS dw 0<br />old_SS dw 0<br /><br />msg db &quot;H e l l o&nbsp;  f r o m&nbsp;  P M o d e&nbsp;  w i t h&nbsp;  G D T ! &quot;, 0xa, 0xd, 0x0<br /><br />;void setup_GDT_entry (DESCR_SEG *item,<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dword base, dword limit, byte access, byte attribs)<br />setup_GDT_entry:<br />%define item ebp+4&nbsp; &nbsp; ; word<br />%define base ebp+6&nbsp; &nbsp; ; dword<br />%define limit ebp+10&nbsp; ; dword<br />%define access ebp+14 ; byte<br />%define attribs ebp+16; byte<br />push bp<br />mov bp, sp<br />	mov bx, <br />; /* Setup the descriptor base address */<br />	; item-&gt;base_l = base &amp; 0xFFFF;<br />	mov ax, <br />	mov , ax<br />	; item-&gt;base_m = (base &gt;&gt; 16) &amp; 0xFF;<br />	mov al, <br />	mov , al<br />	; item-&gt;base_h = base &gt;&gt; 24;<br />	mov al, <br />	mov , al<br /><br />;/* Setup the descriptor limits */<br />	; item-&gt;limit = limit &amp; 0xFFFF;<br />	mov ax, <br />	mov , ax<br /><br />	; item-&gt;attribs = attribs | ((limit &gt;&gt; 16) &amp; 0x0F);<br />	mov al, <br />	and al, 0x0f<br />	and byte, 0xf0<br />	or al, <br />	mov , al<br />; Finally setup access<br />	; item-&gt;access = access;<br />	mov al, <br />	mov , al<br />pop bp<br />	ret 14<br /><br /><br /><br />; void my_exit();<br />msg_exit: db 13, 10, &quot;We are back...&quot;, 13, 10<br />		db &quot;PMode Tutorial by Alexei A. Frounze (c) 2000&quot;, 13, 10<br /><br />my_exit:<br />	mov ah,0x19<br />	mov si, msg_exit<br />	call PrintStr2CharVideo<br />	BEEP<br />	WAITKEY<br />	jmp $ ; don&#39;t halt the system.<br /><br />; ####################################################################<br />msg1 db &quot;Welcome to the 2nd PMode tutorial!&quot;, 13, 10, 0<br />msg2 db &quot;The CPU is already in PMode.&quot;, 13, 10, &quot;Aborting...&quot;, 13, 10, 0<br />msg3 db &quot;We&#39;re going to PMode using CR0 for 5 seconds...&quot;,13, 10, 0<br />start2:<br />; #################################################################<br />; ############# SOLAR OS startup #################################<br />	cli			; please no interupts<br />	mov	ax,cs<br />	mov	ds,ax<br />;	mov	es,ax		; es same as ds<br /><br />;	mov	,dl	; save drive #<br />;------------------------------------------------------<br />; here we make our own stack<br />; just under the A000h video memory<br />;------------------------------------------------------<br />	mov	ax,09000h	; segment for stack<br />	mov	ss,ax<br />	mov	sp,0F800h	; offset for stack<br /><br />	sti			; enable ints again<br />; #################################################################<br />; #################################################################<br />	push bp<br />	mov bp, sp<br />%define p bp-2<br />%define c bp-4 ; the align instead of take like byte...<br />%define scr bp-12<br />	sub esp, 12<br /><br />	call InitCharVideo<br />	mov ah, 0x07<br />	call ClrScr<br />	mov si, msg1<br />	call PrintStr2CharVideo<br />	mov word, my_exit ; atexit (my_exit);<br />	push ax<br />	call read_msw<br />	and ax, 1<br />	pop ax<br />	jz .noPMode<br />		mov si, msg2<br />		call PrintStr2CharVideo<br />		mov sp, bp<br />		pop bp<br />		ret<br />	.noPMode:<br /><br />	jmp .n2<br />	.m2 db &quot;0x0:NULL DESC&quot;, 13, 10, 0<br />	.m3 db &quot;0x8:CODE DESC&quot;, 13, 10, 0<br />	.m4 db &quot;0x10:DATA DESC&quot;, 13, 10, 0<br />	.m5 db &quot;0x18:STACK DESC&quot;, 13, 10, 0<br />	.m6 db &quot;0x20:Video DESC&quot;, 13, 10, 0<br />	.m7 db &quot;Entering PM&quot;, 13, 10, 0<br />	.m8 db &quot;Out of PM&quot;, 13, 10, 0<br />	.n2<br /><br />; /* 0x00 -- null descriptor */<br />; setup_GDT_entry (&amp;gdt[0], 0, 0, 0, 0);<br />mov si, .m2<br />call PrintStr2CharVideo<br />push ax<br />	push byte 0<br />	push byte 0<br />	push word 0 ; high word of the doble word<br />	push word 0 ; low word of the doble word<br />	push word 0 ; high word of doble word<br />	push word 0 ; low word of doble word<br />	push word gdt_label + 0* DESCR_SEG_size<br />	call setup_GDT_entry<br />pop ax<br />xor bx, bx<br />.descriptor1<br />	mov dl, <br />	call Print_Hex16<br />	inc bx<br />	cmp bx, 8<br />	jne .descriptor1<br />call Print_CRLF<br />; /* 0x08 -- code segment descriptor */<br />; setup_GDT_entry (&amp;gdt[1], ((dword)_CS)&lt;&lt;4, 0xFFFF, ACS_CODE, 0);<br />mov si, .m3<br />call PrintStr2CharVideo<br />push ax<br />	push byte 0<br />	push 0x9a ; ACS_CODE<br />	push word 0<br />	push word 0xffff<br />	mov ax, cs<br />	mov cx, cs<br />	shl ax, 4&nbsp; ; low<br />	shr cx, 12 ; high<br />	push cx<br />	push ax<br />	push word gdt_label + 1*DESCR_SEG_size<br />	call setup_GDT_entry<br />pop ax<br />xor bx, bx<br />.descriptor2<br />	mov dl, <br />	call Print_Hex16<br />	inc bx<br />	cmp bx, 8<br />	jne .descriptor2<br />call Print_CRLF<br />; /* 0x10 -- data segment descriptor */<br />; setup_GDT_entry (&amp;gdt[2], ((dword)_DS)&lt;&lt;4, 0xFFFF, ACS_DATA, 0);<br />mov si, .m4<br />call PrintStr2CharVideo<br />push ax<br />	push byte 0<br />	push 0x92 ; ACS_DATA<br />	push word 0&nbsp; &nbsp; &nbsp; ; high word of double word<br />	push word 0xffff ; low word of double word<br />	mov ax, cs<br />	mov cx, cs<br />	shl ax, 4<br />	shr cx, 12<br />	push cx<br />	push ax<br />	push word gdt_label + 2*DESCR_SEG_size<br />	call setup_GDT_entry<br />pop ax<br />xor bx, bx<br />.descriptor3<br />	mov dl, <br />	call Print_Hex16<br />	inc bx<br />	cmp bx, 8<br />	jne .descriptor3<br />call Print_CRLF<br />; /* 0x18 -- stack segment descriptor */<br />; setup_GDT_entry (&amp;gdt[3], ((dword)_SS)&lt;&lt;4, 0xFFFF, ACS_STACK, 0);<br />mov si, .m5<br />call PrintStr2CharVideo<br />push ax<br />	push byte 0<br />	push 0x92 ; ACS_STACK<br />	push word 0<br />	push word 0xffff<br />	mov ax, cs<br />	mov cx, cs<br />	shl ax, 4<br />	shr cx, 12<br />	push cx<br />	push ax<br />	push word gdt_label + 3*DESCR_SEG_size<br />	call setup_GDT_entry<br />pop ax<br />xor bx, bx<br />.descriptor4<br />	mov dl, <br />	call Print_Hex16<br />	inc bx<br />	cmp bx, 8<br />	jne .descriptor4<br />call Print_CRLF<br />; /* 0x20 -- text video mode segment descriptor */<br />; setup_GDT_entry (&amp;gdt[4], 0xB8000L, 0xFFFF, ACS_DATA, 0);<br />mov si, .m6<br />call PrintStr2CharVideo<br />push ax<br />	push byte 0<br />	push 0x92 ; ACS_DATA<br />	push word 0<br />	push word 0xffff<br />	push word 0xb<br />	push word 0x8000<br />	push word gdt_label + 4*DESCR_SEG_size<br />	call setup_GDT_entry<br />pop ax<br />xor bx, bx<br />.descriptor5<br />	mov dl, <br />	call Print_Hex16<br />	inc bx<br />	cmp bx, 8<br />	jne .descriptor5<br />call Print_CRLF<br /><br /><br />	; /* disable interrupts so that IRQs don&#39;t cause exceptions */<br />	cli<br />	; /* disable NMIs as well */<br />	in al, 0x70<br />	or al, 0x80<br />	out 0x70, al<br /></code></pre><br /><br />Here is where the problem reside...<br /><pre><code><br />; ########~~~~~~~~~~~~~~$$$$$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%///////////////<br />	;&nbsp;  /* setting up the GDTR register */<br />; gdtr.base = ((dword)_DS)&lt;&lt;4;<br />; gdtr.base += (word)&amp;gdt;<br />; gdtr.limit = sizeof(gdt)-1;<br />; lgdt (&amp;gdtr);<br />	mov ax, ds<br />	mov cx, ds<br />	shl ax, 4 ;low<br />	shr cx, 12 ; high<br />	; cs is now in cx + ax<br />	add ax, gdtr_label<br />	adc cx, 0<br />	mov , ax<br />	mov , cx<br />	mov ax, 5*DESCR_SEG_size-1<br />	mov , ax<br /><br />	push word gdtr_label<br />	call load_gdt<br /><br />	; /* saving real mode segment addresses */<br /><br />	mov ax, cx<br />	mov , ax<br />	mov ax, ds<br />	mov , ax<br />	mov ax, ss<br />	mov , ax<br /><br />mov si, .m7<br />call PrintStr2CharVideo<br />WAITKEY<br />	; /* WOW!!! This switches us to PMode just setting up CR0.PM bit to 1 */<br />	call read_cr0 ; ; return dx:ax<br />	or ax, 1<br />	push eax<br />	call write_cr0<br />; BEEP ; this beep sound OK !!!!<br /><br />	; /* loading segment registers with PMode selectors */<br />	mov ax, 0x8<br />	push ax<br />	call update_cs<br />BEEP ; this BEEP never sound!!!<br />; ########~~~~~~~~~~~~~~$$$$$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%///////////////<br /><br /></code></pre><br />when I call update_cs the comptuer restart... tought I think the selectors are ok... like I see my routines are ok.. load_gdt and update_cs. I supose Im blocked for see the problem...<br /><br /><pre><code><br />	mov ax, 0x8<br />	add ax, ax<br />	mov ds, ax<br />	mov es, ax<br />	add ax, ax<br />	mov ss, ax<br />	; /* writing a message to the screen */<br /><br />; this will not be done until I correct the thing :D<br /><br />	; /* get out of PMode clearing CR0.PM bit to 0 */<br />	call read_cr0<br />	and eax, 0xFFFFFFFE<br />	push eax<br />	call write_cr0<br /><br />	; /* restoring real mode segment values */<br />	push word <br />	call update_cs<br />	mov ax, <br />	mov es, ax<br />	mov ds, ax<br />	mov ax, <br />	mov ss, ax<br /><br /><br />mov ah, 0x57<br />mov si, .m8<br />call PrintStr2CharVideo<br /><br />	; /* enable NMIs */<br />	in al, 0x70<br />	and al, 0x7f<br />	out 0x70, al<br /><br />	; /* enabling interrupts */<br />	sti<br /><br />	xor ax, ax<br />	mov sp, bp<br />	pop bp<br />	ret<br /></code></pre><br /><br />Sorry for all the &quot;extra&quot; stuff that come there...<br /><br /><br />By the way, hope when I terminate with them, put all here ;).</div>
    <div class="meta">Posted on 2005-05-19 19:52:28 by rea</div>
   </div>
   <div class="post" id="post-160290">
    <div class="subject"><a href="#post-160290">Re: Alexei A. F. tuts in pmode...</a></div>
    <div class="body">I was thinking that will be more easy if I give the other two modules and the output...<br /><br />You can assemble them with <br />1) nasmw t1.asm<br />2) nasmw disk.asm or nasmw disk.asm -D emu, if you whant to pad the extra bytes have the size of a floppy disk.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=636" target="_blank">t2.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-05-20 09:13:02 by rea</div>
   </div>
   <div class="post" id="post-160310">
    <div class="subject"><a href="#post-160310">Re: Alexei A. F. tuts in pmode...</a></div>
    <div class="body">You can start by simple isolation. Put <em>jmp $</em> after certain parts to determine what &quot;exactly&quot; is causing the triple-fault. Keep moving the <em>jmp $</em> until you&#39;ve reached a point where it doesn&#39;t triple-fault anymore. Look at the code between the 2 points, then you can work your way back to the source of the problem</div>
    <div class="meta">Posted on 2005-05-20 16:37:55 by SpooK</div>
   </div>
   <div class="post" id="post-160312">
    <div class="subject"><a href="#post-160312">Re: Alexei A. F. tuts in pmode...</a></div>
    <div class="body">The code that cause the fault is the update of the CS, in any way like the following<br /><br /><pre><code><br />push 0x8<br />push .cont<br />	retf<br />	.cont<br /><br />or<br /><br />call update_cs<br /></code></pre><br /><br />also I have tested with<br /><pre><code><br />jmp 0x8:.continueHere<br />.continueHere<br /></code></pre><br /><br />And also cause the same error.<br /><br /><br /><br /><br />grrrrrr.... lol :lol: :shock: :mad: :D wait a moment, I have watched something that I have missed....<br /><br /><pre><code><br />add ax, gdtr_label<br /><br />isntead of<br /><br />add ax, gdt_label<br /></code></pre> <br /><br /><br />Lol, I must think in a good way of name my variables...<br /><br /><br />I will see what things are changed....</div>
    <div class="meta">Posted on 2005-05-20 17:35:07 by rea</div>
   </div>
   <div class="post" id="post-160316">
    <div class="subject"><a href="#post-160316">Re: Alexei A. F. tuts in pmode...</a></div>
    <div class="body">What a mess I do for detect my change of names... isnt it?<br /><br />:).<br /><br />I only have one thing left in this tut...<br /><pre><code><br />; (1:2)&nbsp; (3:4)&nbsp; (5) (6)&nbsp;  (7)&nbsp;  (8)&nbsp;  | NAME_OF_SELECTOR<br />; 0000 | 0000 | 00&nbsp; | 00&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (zero)<br />; ffff | 0000 | 01&nbsp; | 9a&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (code)<br />; ffff | 0000 | 01&nbsp; | 92&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (data)<br />; ffff | 0000 | 01&nbsp; | 92&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (stack)<br />; ffff | 8000 | 0b&nbsp; | 92&nbsp; | 00&nbsp; | 00&nbsp; |&nbsp; (video)<br />jmp start2<br /><br />; %define REGPRINT<br />%include &quot;basic.inc&quot;<br />%include &quot;pmdefs.inc&quot;<br /><br />; ##########################################<br />; pm.h<br />; ##########################################<br /><br />; unsigned int read_msw();<br />read_msw:<br />	smsw ax<br />	ret<br /><br />; unsigned long read_cr0();<br />read_cr0:<br />	mov eax, cr0<br />	;mov edx, eax<br />	;shr edx, 16 ; return dx:ax<br />	ret<br /><br />; void write_cr0 (unsigned long value);<br />write_cr0:<br />	push bp<br />	mov bp, sp<br />	mov eax,  ; 2 ret addr + 2 of old bp and read from here 32-bit argument<br />	mov cr0, eax<br />	pop bp<br />	ret 4<br /><br />; void&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lgdt (GDTR *gdtr);<br />; is load_gdt because lgdt is the asm instruction...<br />load_gdt:<br />	push bp<br />	mov bp, sp<br />	push bx<br />	mov bx,  ; ds:bx = pointer to the GDTR<br />	lgdt &nbsp;  ; load GDTR<br />	pop bx<br />	pop bp<br />	ret 2<br /><br />; void&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_cs (unsigned int bew_cs);<br />update_cs:<br />	push bp<br />	mov bp, sp<br />	mov ax,  ; ax = new CS<br />	push ax&nbsp; &nbsp; &nbsp; &nbsp; ; push segment<br />	push word .1&nbsp;  ; push offset<br />	retf&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; we have a new CS now<br />	.1:<br />	pop bp<br />	ret 2<br /><br /><br /><br />; ##########################################<br /><br /><br /><br />; ####################################################################<br />; source of tutorial<br />; ####################################################################<br /><br /><br />gdt_label: times (5*DESCR_SEG_size) db 0<br />gdtr_label: times DESCR_GDTR_size db 0<br /><br />old_CS dw 0<br />old_DS dw 0<br />old_SS dw 0<br />old_SP dw 0<br /><br />msg db &quot;H e l l o&nbsp;  f r o m&nbsp;  P M o d e&nbsp;  w i t h&nbsp;  G D T ! &quot;, 0x0<br /><br />;void setup_GDT_entry (DESCR_SEG *item,<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dword base, dword limit, byte access, byte attribs)<br />setup_GDT_entry:<br />%define item ebp+4&nbsp; &nbsp; ; word<br />%define base ebp+6&nbsp; &nbsp; ; dword<br />%define limit ebp+10&nbsp; ; dword<br />%define access ebp+14 ; byte<br />%define attribs ebp+16; byte<br />push bp<br />mov bp, sp<br />	mov bx, <br />; /* Setup the descriptor base address */<br />	; item-&gt;base_l = base &amp; 0xFFFF;<br />	mov ax, <br />	mov , ax<br />	; item-&gt;base_m = (base &gt;&gt; 16) &amp; 0xFF;<br />	mov al, <br />	mov , al<br />	; item-&gt;base_h = base &gt;&gt; 24;<br />	mov al, <br />	mov , al<br /><br />;/* Setup the descriptor limits */<br />	; item-&gt;limit = limit &amp; 0xFFFF;<br />	mov ax, <br />	mov , ax<br /><br />	; item-&gt;attribs = attribs | ((limit &gt;&gt; 16) &amp; 0x0F);<br />	mov al, <br />	and al, 0x0f<br />	and byte, 0xf0<br />	or al, <br />	mov , al<br />; Finally setup access<br />	; item-&gt;access = access;<br />	mov al, <br />	mov , al<br />pop bp<br />	ret 14<br /><br /><br /><br />; void my_exit();<br />msg_exit: db 13, 10, &quot;We are back...&quot;, 13, 10<br />		db &quot;PMode Tutorial by Alexei A. Frounze (c) 2000&quot;, 13, 10, 0<br /><br />my_exit:<br />	WAITKEY<br />	BEEP<br />	mov ah,0x19<br />	mov si, msg_exit<br />	call PrintStr2CharVideo<br />	jmp $ ; don&#39;t halt the system.<br /><br />; ####################################################################<br />msg1 db &quot;Hi. Welcome to the 2nd PMode tutorial!&quot;, 13, 10, 0<br />msg2 db &quot;The CPU is already in PMode.&quot;, 13, 10, &quot;Aborting...&quot;, 13, 10, 0<br />msg3 db &quot;We&#39;re going to PMode using CR0 for 5 seconds...&quot;,13, 10, 0<br />start2:<br />; #################################################################<br />; ############# SOLAR OS startup #################################<br />	cli			; please no interupts<br />	mov	ax,cs<br />	mov	ds,ax<br />	mov	es,ax		; es same as ds<br /><br />;	mov	,dl	; save drive #<br />;------------------------------------------------------<br />; here we make our own stack<br />; just under the A000h video memory<br />;------------------------------------------------------<br />	mov	ax,09000h	; segment for stack<br />	mov	ss,ax<br />	mov	sp,0F800h	; offset for stack<br /><br />	sti			; enable ints again<br />; #################################################################<br />; #################################################################<br />	push bp<br />	mov bp, sp<br />%define p bp-2<br />%define c bp-4 ; the align instead of take like byte...<br />%define scr bp-12<br />	sub esp, 12<br /><br />	call InitCharVideo<br />	mov ah, 0x07<br />	call ClrScr<br />	mov si, msg1<br />	call PrintStr2CharVideo<br />	mov word, my_exit ; atexit (my_exit);<br />	push ax<br />	call read_msw<br />	and ax, 1<br />	pop ax<br />	jz .noPMode<br />		mov si, msg2<br />		call PrintStr2CharVideo<br />		mov sp, bp<br />		pop bp<br />		ret<br />	.noPMode:<br /><br />; /* 0x00 -- null descriptor */<br />; setup_GDT_entry (&amp;gdt[0], 0, 0, 0, 0);<br />	push byte 0<br />	push byte 0<br />	push word 0 ; high word of the doble word<br />	push word 0 ; low word of the doble word<br />	push word 0 ; high word of doble word<br />	push word 0 ; low word of doble word<br />	push word gdt_label + 0* DESCR_SEG_size<br />	call setup_GDT_entry<br />; /* 0x08 -- code segment descriptor */<br />; setup_GDT_entry (&amp;gdt[1], ((dword)_CS)&lt;&lt;4, 0xFFFF, ACS_CODE, 0);<br />	push byte 0<br />	push 0x9a ; ACS_CODE<br />	push word 0<br />	push word 0xffff<br />	mov ax, cs<br />	mov cx, cs<br />	shl ax, 4&nbsp; ; low<br />	shr cx, 12 ; high<br />	push cx<br />	push ax<br />	push word gdt_label + 1*DESCR_SEG_size<br />	call setup_GDT_entry<br />; /* 0x10 -- data segment descriptor */<br />; setup_GDT_entry (&amp;gdt[2], ((dword)_DS)&lt;&lt;4, 0xFFFF, ACS_DATA, 0);<br />	push byte 0<br />	push 0x92 ; ACS_DATA<br />	push word 0&nbsp; &nbsp; &nbsp; ; high word of double word<br />	push word 0xffff ; low word of double word<br />	mov ax, cs<br />	mov cx, cs<br />	shl ax, 4<br />	shr cx, 12<br />	push cx<br />	push ax<br />	push word gdt_label + 2*DESCR_SEG_size<br />	call setup_GDT_entry<br />; /* 0x18 -- stack segment descriptor */<br />; setup_GDT_entry (&amp;gdt[3], ((dword)_SS)&lt;&lt;4, 0xFFFF, ACS_STACK, 0);<br />	push byte 0<br />	push 0x92 ; ACS_STACK<br />	push word 0<br />	push word 0xffff<br />	mov ax, cs<br />	mov cx, cs<br />	shl ax, 4<br />	shr cx, 12<br />	push cx<br />	push ax<br />	push word gdt_label + 3*DESCR_SEG_size<br />	call setup_GDT_entry<br />; /* 0x20 -- text video mode segment descriptor */<br />; setup_GDT_entry (&amp;gdt[4], 0xB8000L, 0xFFFF, ACS_DATA, 0);<br />	push byte 0<br />	push 0x92 ; ACS_DATA<br />	push word 0<br />	push word 0xffff<br />	push word 0xb<br />	push word 0x8000<br />	push word gdt_label + 4*DESCR_SEG_size<br />	call setup_GDT_entry<br />	; /* disable interrupts so that IRQs don&#39;t cause exceptions */<br />	cli<br />	; /* disable NMIs as well */<br />	in al, 0x70<br />	or al, 0x80<br />	out 0x70, al<br /><br />	;&nbsp;  /* setting up the GDTR register */<br />	mov ax, ds<br />	mov cx, ds<br />	shl ax, 4 ;low<br />	shr cx, 12 ; high<br />	; cs is now in cx + ax<br />	add ax, gdt_label<br />	adc cx, 0<br />	mov , ax<br />	mov , cx<br />	mov ax, 5*DESCR_SEG_size-1<br />	mov , ax<br /><br />	push word gdtr_label<br />	call load_gdt<br /><br />	; /* saving real mode segment addresses */<br /><br />	mov ax, cx<br />	mov , ax<br />	mov ax, ds<br />	mov , ax<br />	mov ax, ss<br />	mov , ax<br />	mov ax, sp<br />	mov , ax<br /><br />; Here this work OK...<br />; mov sp, bp<br />; pop bp<br />; ret<br />	; /* WOW!!! This switches us to PMode just setting up CR0.PM bit to 1 */<br />	call read_cr0 ; ; return dx:ax<br />	or ax, 1<br />	push eax<br />	call write_cr0<br /><br />	; /* loading segment registers with PMode selectors */<br />	push 0x8<br />	call update_cs<br />	mov ax, 0x10<br />	mov ds, ax<br />	mov es, ax<br />	mov ax, 0x18<br />	mov ss, ax<br /><br />	; /* writing a message to the screen */<br />		mov ax, 0x20<br />		mov gs, ax<br />		mov si, msg<br />		mov di, 40*40<br />		.aga<br />			lodsb<br />			or al, al<br />			jz .fin<br />			mov , al<br />			inc di<br />		jmp .aga<br />	.fin<br /><br />	; /* get out of PMode clearing CR0.PM bit to 0 */<br />	call read_cr0<br />	and eax, 0xFFFFFFFE<br />	push eax<br />	call write_cr0<br /></code></pre><br /><br />Code continue after this.<br /><br />From the Intel manual I read<br /><div class="quote"><br />9.9.2. Switching Back to Real-Address Mode<br />...<br />7. Execute a far JMP instruction to jump to a real-address mode program. This operation<br />flushes the instruction queue and loads the appropriate base and access rights values in the<br />CS register.<br />...<br /></div><br /><br />Aparently is only valid to return with a jump, but in the source code of the tutorial, is used the same function &quot;update_cs&quot; pushing the value of old_CS, in the precompiled exe under DosBox it work ok..., then why aparently call update_cs for return to real mode work in the exe and not in my code?.. but in the intel manual say with a &quot;jump&quot; instead of a &quot;retf&quot; it explicetely state a &quot;jump&quot;, not like to enter to PM<br /><br /><div class="quote">9.9.1. Switching to Protected Mode<br />....<br />4. Immediately following the MOV CR0 instruction, execute a far JMP or far CALL<br />instruction. (This operation is typically a far jump or call to the next instruction in the<br />instruction stream.)<br />....<br /></div><br /><br />That you can select a far jump or call...<br /><br /><br />A posible way to calculate at runtime (without hardcode that 0x1000:.continueHere) can be with a far jump with a memory operand????<br /><br /><pre><code><br />	; /* restoring real mode segment values */<br />	;push word &nbsp; ; This two lines dosent work<br />	;call update_cs<br /><br />	;push 0x1000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; This three lines also dont work<br />	;push .continueHe<br />	;retf<br /><br />	jmp 0x1000:.continueHe ; This is OK.<br />	.continueHe<br />	mov ax, <br />	mov es, ax<br />	mov ds, ax<br />	mov ax, <br />	mov ss, ax<br />	mov ax, <br />	mov sp, ax<br />	; /* enable NMIs */<br />	in al, 0x70<br />	and al, 0x7f<br />	out 0x70, al<br /><br />	; /* enabling interrupts */<br />	sti<br /><br />	call InitCharVideo<br />	mov sp, bp<br />	pop bp<br />	ret<br /></code></pre></div>
    <div class="meta">Posted on 2005-05-20 21:29:12 by rea</div>
   </div>
  </div>
 </body>
</html>