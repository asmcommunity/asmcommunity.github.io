<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>getting serial number of HDD (copy protection) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22674" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=22674">getting serial number of HDD (copy protection)</a></p>
   <div class="post" id="post-169974">
    <div class="subject"><a href="#post-169974">getting serial number of HDD (copy protection)</a></div>
    <div class="body">First i&#39;ve tried this:<br /><br /><pre><code>&nbsp; 		<br />invoke GetVolumeInformation,StrAddr ( &quot;c:\&quot; ),addr buffer,254,addr ID,0,0,0,0</code></pre><br /><br />But this can change easily, and not true hw id.<br />Then found that code, very simple:<br /><br /><pre><code>	mov di,addr buffer<br />	mov dx,1f7h	; io address of first ide controller&#39;s status register<br />@@	in al,dx	; get status<br />	test al,80h	 ; BUSY?<br />	jnz @b<br />	dec dx		&nbsp; ; 1f6h drive/head selection register<br />	mov al,0a0h	; select master drive<br />	out dx,al<br />	inc dx		&nbsp;  ; 1f7h status register<br />@@	in al,dx	; get status<br />	test al,80h<br />	jnz @b<br />	mov al,0ech	; get dive info command<br />	out dx,al<br />@@	in al,dx	; get status<br />	test al,80h<br />	jnz @b<br />	sub dx,7	 ; 1f0h controller&quot;s data port<br />	mov ecx,14h&nbsp;  ; number of words to get (last 10 word is the serial)	<br />	cld<br />	rep insw	; get words into buffer</code></pre><br /><br />This works in dos and win9x. But fails on WinXP/Win2k.<br />Ok i see: i need some dll (Inpout32.dll or WinIO,AsmIO...etc)<br />But these are ~50k , first 2 solution is only a bunch of bytes.<br />Anyway, if no other solution, i will add that 50k dll to my project.<br />I have another question:&nbsp;  this small routine gets serialnumber from ide controller.<br />Ok, this is the most common hw part in pc, but if destination pc uses sata disk (or scsi), how can i read hdd info?<br />Is there i/o port map of sata (scsi) controller available on the net? (i googled but no success)...thanks</div>
    <div class="meta">Posted on 2006-02-16 07:43:56 by s5vi</div>
   </div>
   <div class="post" id="post-169979">
    <div class="subject"><a href="#post-169979">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">probably doable via deviceiocontrol thru mountmanager or whatnot, the getvolumeinformation api should be sufficient though, and you are right in the fact that the code you pasted will not work in any os greater than win9x simply because the in/out command is priveledged, you could code your own device driver to do it however, that is probably the best approach.. but to load the drive you require admin priveledges etc...</div>
    <div class="meta">Posted on 2006-02-16 11:04:23 by evlncrn8</div>
   </div>
   <div class="post" id="post-169986">
    <div class="subject"><a href="#post-169986">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">I received a new idea:<br />For dos and w9x that direct i/o commands and for w2k/xp MS WMI api, which is icluded in OS.<br />Pro for wmi: handle all type of HDD (ata,sata,scsi)<br />Con for wmi: need ole, do you know some masm32 wmi example/tutor ?<br /></div>
    <div class="meta">Posted on 2006-02-16 13:45:05 by s5vi</div>
   </div>
   <div class="post" id="post-170017">
    <div class="subject"><a href="#post-170017">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">Hey, You won&#39;t believe! ( not a cheat! )<br />I&#39;ve played with many serialnumber retriever app, and see my hd serial is almost is my nick ! (s5viHarddisk)<br />This is my 160Gig Seagate. What is the chance of this ?<br />&quot;The chances of them coming is A million to one he said.... ... But still... they come.&quot; (from The War of the Worlds)<br /><br /><pre><code># hdparm -I /dev/hda<br />/dev/hda:<br /><br />ATA device, with non-removable media<br />	Model Number:&nbsp; &nbsp; &nbsp;  ST3160023A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	Serial Number:&nbsp; &nbsp; &nbsp; 5JS5V1HD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	Firmware Revision:&nbsp; 8.01&nbsp; &nbsp; <br />Standards:<br />	Used: ATA/ATAPI-6 T13 1410D revision 2 <br />	Supported: 6 5 4 3 <br />Configuration:<br />	Logical		max	current<br />	cylinders	16383	65535<br />	heads		16	1<br />	sectors/track	63	63</code></pre><br /><br />Anyway i found a simple commandline wmi solution for windows millenium and above:<br /><pre><code>wmic /namespace:\\root\cimv2 path Win32_PhysicalMedia</code></pre><br /></div>
    <div class="meta">Posted on 2006-02-17 15:08:10 by s5vi</div>
   </div>
   <div class="post" id="post-170074">
    <div class="subject"><a href="#post-170074">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">I worked out the complete solution (tested on w98 and xp too)<br /><pre><code><br />		;<br />		; Check wmi is present<br />		;<br />		invoke RegOpenKeyEx,HKEY_LOCAL_MACHINE,StrAddr ( &quot;SYSTEM\CurrentControlSet\Control\WMI&quot; ),0,KEY_QUERY_VALUE,addr hKey<br />		.if eax!=0 ; no wmi, it must be win95 or win98 !!<br />			;<br />			; Read HDD serialnumber via direct I/O (only for primary master IDE drive!)<br />			;<br />			invoke GetHDDSerialIO,addr numbuf<br />		.else ; wmi is present, it must be millennium or above (xp,nt,2k)<br />			; <br />			; Read HDD serialnumber via wmi<br />			;<br />			invoke GetWmiInfo<br />		.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now serialnumber string is in numbuf<br /></code></pre><br />On win9x we must use ntkern.vxd (built in w9x) to make direct i/o<br /><pre><code><br />;<br />; Win9x, ntkern.vxd&nbsp; int 2eh functions for direct hw i/O <br />;<br />NtKernInAL MACRO	;in al,dx		<br />			push edx<br />			mov edx,esp<br />			mov eax,0f1h<br />			int 2eh<br />			add esp,4<br />ENDM<br />NtKernInAX MACRO	;in ax,dx<br />			push edx<br />			mov edx,esp<br />			mov eax,0f3h<br />			int 2eh<br />			add esp,4<br />ENDM<br />NtKernOutAL MACRO	;out dx,al<br />			push eax<br />			push edx<br />			mov edx,esp<br />			mov eax,0f7h<br />			int 2eh<br />			add esp,8<br />endm<br />GetHDDSerialIO proc lpBuffer:DWORD<br />			mov edi,lpBuffer<br />			mov edx,1f7h	; io address of first ide controller&#39;s status register<br />@@:			NtKernInAL<br />			test al,80h		; BUSY?<br />			jnz @b<br />			dec dx			; 1f6h drive/head selection register<br />			mov al,0a0h		; select master drive<br />			NtKernOutAL<br />			inc dx			; 1f7h status register<br />@@:			NtKernInAL<br />			test al,80h<br />			jnz @b<br />			mov al,0ech		; get dive info command<br />			NtKernOutAL<br />@@:			NtKernInAL<br />			test al,80h<br />			jnz @b<br />			sub dx,7		; 1f0h controller&#39;s data port<br />			mov ecx,10		; number of words, skip first 10 words	<br />			cld<br />			.while ecx!=0	; get words into buffer<br />				NtKernInAX<br />				dec ecx<br />			.endw<br />			mov ecx,10		; number of words to get, 10 words is the serialnumber	<br />			cld<br />			.while ecx!=0	; get words into buffer<br />				NtKernInAX<br />				xchg al,ah<br />				mov word ptr ,ax<br />				inc edi<br />				inc edi<br />				dec ecx<br />			.endw<br />			mov ecx,246		; number of words, read remaining 246 words to complete operation	<br />			cld<br />			.while ecx!=0	; get words into buffer<br />				NtKernInAX<br />				dec ecx<br />			.endw<br />			ret<br />GetHDDSerialIO endp<br /></code></pre><br />On NT/w2k/XP we can use wmi subsystem to query hardware<br /><pre><code><br />include &lt;c:\masm32\macros\macros.asm&gt;<br />include &lt;c:\masm32\macros\ucmacros.asm&gt;<br /><br />; located in ObjIdl.h<br /><br />EOAC_NONE	EQU	0<br /><br />; located in RpcDce.h<br /><br />RPC_C_AUTHN_LEVEL_DEFAULT	EQU	0<br />RPC_C_IMP_LEVEL_DEFAULT		EQU	0<br /><br />RPC_C_IMP_LEVEL_IMPERSONATE	EQU	3<br /><br />GUID2 STRUC<br />&nbsp; &nbsp;  dd1 dd ?<br />&nbsp; &nbsp;  dw1 dw ?<br />&nbsp; &nbsp;  dw2 dw ?<br />&nbsp; &nbsp;  db1 db ?<br />&nbsp; &nbsp;  db2 db ?<br />&nbsp; &nbsp;  db3 db ?<br />&nbsp; &nbsp;  db4 db ?<br />&nbsp; &nbsp;  db5 db ?<br />&nbsp; &nbsp;  db6 db ?<br />&nbsp; &nbsp;  db7 db ?<br />&nbsp; &nbsp;  db8 db ?<br />GUID2 ENDS<br /><br />IWbemLocator STRUCT<br />	lpVtbl	DWORD	?<br />IWbemLocator ENDS<br /><br />IWbemLocatorVtbl STRUCT<br />	QueryInterface	DWORD	?<br />	AddRef		DWORD	?<br />	Release		DWORD	?<br /><br />	ConnectServer	DWORD	?<br />IWbemLocatorVtbl ENDS<br /><br />IWbemServices STRUCT<br />	lpVtbl	DWORD	?<br />IWbemServices ENDS<br /><br />IWbemServicesVtbl STRUCT<br />	QueryInterface	DWORD	?<br />	AddRef		DWORD	?<br />	Release		DWORD	?<br />	<br />	OpenNamespace			DWORD	?<br />	CancelAsyncCall			DWORD	?<br />	QueryObjectSink			DWORD	?<br />	GetObject				DWORD	?<br />	GetObjectAsync			DWORD	?<br />	PutClass				DWORD	?<br />	PutClassAsync			DWORD	?<br />	DeleteClass				DWORD	?<br />	DeleteClassAsync			DWORD	?<br />	CreateClassEnum			DWORD	?<br />	CreateClassEnumAsync		DWORD	?<br />	PutInstance				DWORD	?<br />	PutInstanceAsync			DWORD	?<br />	DeleteInstance			DWORD	?<br />	DeleteInstanceAsync		DWORD	?<br />	CreateInstanceEnum		DWORD	?<br />	CreateInstanceEnumAsync		DWORD	?<br />	ExecQuery				DWORD	?<br />	ExecQueryAsync			DWORD	?<br />	ExecNotificationQuery		DWORD	?<br />	ExecNotificationQueryAsync	DWORD	?<br />	ExecMethod				DWORD	?<br />	ExecMethodAsync			DWORD	?<br />IWbemServicesVtbl ENDS<br /><br />IEnumWbemClassObject STRUCT<br />	lpVtbl	DWORD	?<br />IEnumWbemClassObject ENDS<br /><br />IEnumWbemClassObjectVtbl STRUCT<br />	QueryInterface	DWORD	?<br />	AddRef		DWORD	?<br />	Release		DWORD	?<br /><br />	Reset			DWORD	?<br />	Next			DWORD	?<br />	NextAsync		DWORD	?<br />	Clone			DWORD	?<br />	Skip			DWORD	?<br />IEnumWbemClassObjectVtbl ENDS<br /><br />IWbemClassObject STRUCT<br />	lpVtbl	DWORD	?<br />IWbemClassObject ENDS<br /><br />IWbemClassObjectVtbl STRUCT<br />	QueryInterface	DWORD	?<br />	AddRef		DWORD	?<br />	Release		DWORD	?<br />	<br />	GetQualifierSet		DWORD	?<br />	Get				DWORD	?<br />	Put				DWORD	?<br />	Delete			DWORD	?<br />	GetNames			DWORD	?<br />	BeginEnumeration		DWORD	?<br />	Next				DWORD	?<br />	EndEnumeration		DWORD	?<br />	GetPropertyQualifierSet	DWORD	?<br />	GetObjectText		DWORD	?<br />	SpawnDerivedClass		DWORD	?<br />	SpawnInstance		DWORD	?<br />	CompareTo			DWORD	?<br />	GetPropertyOrigin		DWORD	?<br />	InheritsFrom		DWORD	?<br />	GetMethod			DWORD	?<br />	PutMethod			DWORD	?<br />	DeleteMethod		DWORD	?<br />	BeginMethodEnumeration	DWORD	?<br />	NextMethod			DWORD	?<br />	EndMethodEnumeration	DWORD	?<br />	GetMethodQualifierSet	DWORD	?<br />	GetMethodOrigin		DWORD	?<br />	<br />IWbemClassObjectVtbl ENDS<br /><br />.data<br /><br />; located in WbemCli.h<br /><br />WBEM_FLAG_CONNECT_USE_MAX_WAIT	EQU	80h<br />WBEM_FLAG_FORWARD_ONLY			EQU	20h<br />WBEM_INFINITE				EQU	-1<br />WBEM_E_INVALID_QUERY			EQU	80041017h<br />WBEM_E_INVALID_QUERY_TYPE		EQU	80041018h<br /><br />IID_IWbemLocator	\	<br />	GUID2	&lt;0dc12a687h,0737fh,011cfh,088h,04dh,000h,0aah,000h,04bh,02eh,024h&gt;<br /><br />IID_IEnumWbemClassObject	\<br />	GUID2	&lt;027947e1h,0d731h,011ceh,0a3h,057h,000h,000h,000h,000h,000h,001h&gt;<br /><br />IID_IWbemClassObject	\<br />	GUID2	&lt;0dc12a681h,0737fh,011cfh,088h,04dh,000h,0aah,000h,04bh,02eh,024h&gt;<br /><br />; located in WbemProv.h<br /><br />CLSID_WbemAdministrativeLocator	\<br />	GUID2	&lt;0cb8555cch,09128h,011d1h,0adh,09bh,000h,0c0h,04fh,0d8h,0fdh,0ffh&gt;<br /><br />locator	IWbemLocator		&lt;&gt;<br />service	IWbemServices		&lt;&gt;<br />enumerator	IEnumWbemClassObject	&lt;&gt;<br />processor	IWbemClassObject		&lt;&gt;<br /><br />retCount	DWORD	?<br /><br />var_val	DWORD	?&nbsp; &nbsp; &nbsp;  ; not sure what these for<br />		DWORD	?<br />		DWORD	?<br /><br />WSTR	wstrNameSpace, &quot;root\cimv2&quot;<br />;WSTR	wstrQuery, &quot;SELECT * FROM Win32_Processor&quot;<br />;WSTR	wstrQueryLanguage, &quot;WQL&quot;<br /><br />;wstrQuery	dw	&quot;S&quot;,&quot;E&quot;,&quot;L&quot;,&quot;E&quot;,&quot;C&quot;,&quot;T&quot;,&quot; &quot;,&quot;*&quot;,&quot; &quot;,&quot;F&quot;,&quot;R&quot;,&quot;O&quot;,&quot;M&quot;,&quot; &quot;,&quot;W&quot;,&quot;i&quot;,&quot;n&quot;,&quot;3&quot;,&quot;2&quot;,&quot;_&quot;,&quot;D&quot;,&quot;i&quot;,&quot;s&quot;,&quot;k&quot;,&quot;D&quot;,&quot;r&quot;,&quot;i&quot;,&quot;v&quot;,&quot;e&quot;,00<br />wstrQuery	dw	&quot;S&quot;,&quot;E&quot;,&quot;L&quot;,&quot;E&quot;,&quot;C&quot;,&quot;T&quot;,&quot; &quot;,&quot;*&quot;,&quot; &quot;,&quot;F&quot;,&quot;R&quot;,&quot;O&quot;,&quot;M&quot;,&quot; &quot;,&quot;W&quot;,&quot;i&quot;,&quot;n&quot;,&quot;3&quot;,&quot;2&quot;,&quot;_&quot;,&quot;P&quot;,&quot;h&quot;,&quot;y&quot;,&quot;s&quot;,&quot;i&quot;,&quot;c&quot;,&quot;a&quot;,&quot;l&quot;,&quot;M&quot;,&quot;e&quot;,&quot;d&quot;,&quot;i&quot;,&quot;a&quot;,00<br />;wstrQuery	dw	&quot;S&quot;,&quot;E&quot;,&quot;L&quot;,&quot;E&quot;,&quot;C&quot;,&quot;T&quot;,&quot; &quot;,&quot;*&quot;,&quot; &quot;,&quot;F&quot;,&quot;R&quot;,&quot;O&quot;,&quot;M&quot;,&quot; &quot;,&quot;W&quot;,&quot;i&quot;,&quot;n&quot;,&quot;3&quot;,&quot;2&quot;,&quot;_&quot;,&quot;P&quot;,&quot;r&quot;,&quot;o&quot;,&quot;c&quot;,&quot;e&quot;,&quot;s&quot;,&quot;s&quot;,&quot;o&quot;,&quot;r&quot;,00<br /><br />wstrQueryLanguage	dw	&quot;W&quot;,&quot;Q&quot;,&quot;L&quot;,00<br /><br />;wstrCPUName		dw	&quot;P&quot;,&quot;r&quot;,&quot;o&quot;,&quot;c&quot;,&quot;e&quot;,&quot;s&quot;,&quot;s&quot;,&quot;o&quot;,&quot;r&quot;,&quot; &quot;,&quot;N&quot;,&quot;a&quot;,&quot;m&quot;,&quot;e&quot;,&quot;:&quot;,&quot;%&quot;,&quot;s&quot;,00<br /><br />;WSTR	wstrName, &quot;Name&quot;<br />WSTR	wstrName, &quot;SerialNumber&quot;<br />;WSTR	wstrName, &quot;Model&quot;<br /><br />.code<br />;<br />; Get info from hardware via WMI , return a string into bufferSQL<br />;<br />GetWmiInfo proc<br />	invoke CoInitializeEx,<br />			NULL,<br />			COINIT_MULTITHREADED<br />	<br />	invoke CoInitializeSecurity,<br />			NULL,<br />			-1,<br />			NULL,<br />			NULL,<br />			RPC_C_AUTHN_LEVEL_DEFAULT,<br />			RPC_C_IMP_LEVEL_IMPERSONATE,<br />			NULL,<br />			EOAC_NONE,<br />			NULL<br />		<br />	invoke CoCreateInstance,<br />			addr CLSID_WbemAdministrativeLocator,<br />			NULL,<br />			CLSCTX_INPROC_SERVER,<br />			addr IID_IWbemLocator,<br />			addr locator<br />	<br />	mov	esi, <br />	lodsd<br />	push	offset service<br />	push	NULL<br />	push	NULL<br />	push	WBEM_FLAG_CONNECT_USE_MAX_WAIT<br />	push	NULL<br />	push	NULL<br />	push	NULL<br />	push	offset wstrNameSpace<br />	push	dword ptr <br />	call	dword ptr <br /><br />	mov	esi, <br />	lodsd<br />	push	offset enumerator<br />	push	NULL<br />	push	WBEM_FLAG_FORWARD_ONLY<br />	push	offset wstrQuery<br />	push	offset wstrQueryLanguage<br />	push	dword ptr <br />	call	dword ptr <br /><br />	mov	esi, <br />	lodsd<br />	push	offset retCount<br />	push	offset processor<br />	push	TRUE<br />	push	WBEM_INFINITE<br />	push	dword ptr <br />	call	dword ptr <br />	<br />	mov	esi, <br />	lodsd<br />	push	NULL<br />	push	NULL<br />	push	offset var_val<br />	push	0<br />	push	offset wstrName<br />	push	dword ptr <br />	call	dword ptr <br />	<br />	mov	ecx, <br />	invoke WideCharToMultiByte,CP_ACP,0,,-1,addr numbuf,255,NULL,NULL<br />	invoke CoUninitialize<br />	ret<br />GetWmiInfo endp<br /></code></pre><br />Thanks to Kernel_Gaddafi from www.masmforum.com to share his wmi code example<br /><a target="_blank" href="http://www.masmforum.com/simple/index.php?topic=2594.0">http://www.masmforum.com/simple/index.php?topic=2594.0</a><br />Now i can compare hdd serial to the list of valid numbers (stored in my exe), and if not found,exit app.<br />Yes i store valid numbers in my exe but i encrypt it. With hexeditor you cannot see numbers in my exe.<br />New user must send me a little file (generated my app) which contains his hdd serial, i pick up his number to my list and i send modified exe.<br />This is my method to protect my app.<br />If someone knows better or want to share his method i appreciate it. thanks<br /></div>
    <div class="meta">Posted on 2006-02-28 01:42:24 by s5vi</div>
   </div>
   <div class="post" id="post-170079">
    <div class="subject"><a href="#post-170079">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">A quick question, not knowing what your app is, and what its popularity would be, wouldn&#39;t you&#39;re copy protection scheme unnecessarily bloat the exe of the 1000th, 10000th customer?<br />Depending on your method of encrypting the serial no.?<br />regards,<br />Rags</div>
    <div class="meta">Posted on 2006-02-28 08:02:22 by rags</div>
   </div>
   <div class="post" id="post-170082">
    <div class="subject"><a href="#post-170082">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">lenght of Hdd serialnumber is 20 byte (10000*20byte=200k) but my exe is encrypted and packed by a pecompressor.<br />Sizes:&nbsp; &nbsp; <br />app: 45k<br />sqlite dll: 250k<br />jpg pictures: 10k (for decent look)<br />small database: 50k<br />these packed with pebundle and encrypted by Yoda&#39;s crypter1.3 into one exe (260k)<br />(to crack it you need: decrypt my exe, find hdd serial, write your HDD number)<br /><br />Anyway users of my app is a closed group (2-10 users)<br /></div>
    <div class="meta">Posted on 2006-02-28 09:28:50 by s5vi</div>
   </div>
   <div class="post" id="post-170128">
    <div class="subject"><a href="#post-170128">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">Hrm, there must be some non-direct-IO solution for 9x too. I mean, ATA vs. SATA vs. SCSI vs. USB storage (external HDD or even a large pendrive would do). Direct hardware access for this just isn&#39;t a very good idea.<br /></div>
    <div class="meta">Posted on 2006-03-01 15:50:16 by f0dder</div>
   </div>
   <div class="post" id="post-170135">
    <div class="subject"><a href="#post-170135">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">Yes, You&#39;re right, F0dder<br />This win9x method works ONLY with primary master ata hdd (but not too hard to code all ide channels)<br />But i think these simple old machines which running Win9x have simple ata disk. (Probably)<br />I&#39;ve never seen a win9x running on sata hdd (is it possible? is there a win9x driver for sata chipsets?)<br />Anyway,i call functions in ntkern.vxd, i really dont know if ntkern.vxd uses direct i/o instructions?<br />I hope ntkern.vxd manage correctly this i/o operations, isnt it?<br />I found info on ntkern.vxd <a target="_blank" href="http://vx.netlux.org/lib/vzo25.html">http://vx.netlux.org/lib/vzo25.html</a><br />There are another solution , wmi for win9x is available, and we can use it on win9x also, but it need to make an istaller which detects lack of wmi, and install it (and of course i must pack wmi whit my app)</div>
    <div class="meta">Posted on 2006-03-02 01:26:46 by s5vi</div>
   </div>
   <div class="post" id="post-170140">
    <div class="subject"><a href="#post-170140">Re: getting serial number of HDD (copy protection)</a></div>
    <div class="body">Well, if nothing else win9x COULD run on SATA by using &quot;legacy&quot; (int13) access for the drive... but I&#39;m fairly certain there&#39;s ought to be someone running 9x on SCSI.<br /></div>
    <div class="meta">Posted on 2006-03-02 07:36:00 by f0dder</div>
   </div>
  </div>
 </body>
</html>