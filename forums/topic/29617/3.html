<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>3D Engine and related developments - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29617" />
  <link rel="prev" href="../?id=29617&amp;page=2" />  <link rel="next" href="../?id=29617&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29617">3D Engine and related developments</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29617&amp;page=1" style="">&laquo;</a><a href="../?id=29617&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29617" /><input type="number" name="page" min="1" max="11" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29617&amp;page=4">&gt;</a><a href="../?id=29617&amp;page=11">&raquo;</a></form>   <div class="post" id="post-209852">
    <div class="subject"><a href="#post-209852">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote"><br />Is there any reason write your own JPEG and PNG decompression, except for the educational purpose (D3DX accepts both these formats and if you want a portable solution you can use open-source libraries) ?.<br /></div><br /><br />As I say, I started it 10 years ago... back then I didn&#039;t even use D3D yet. The open source libraries were really slow back then (probably still are), and really terse code and clumsy to use. I used part of my JPG decoder at one point to accelerate a histogram application for a Canon PowerShot camera... It was originally based on the IJG implementation.<br />I just never completed my JPG decoder, so I figured I&#039;d take care of the unfinished business. At least now I can REALLY say that I fully understand the JPG format. I have verified it myself.<br /><br />PNG can probably be done in just a few hours... so why not? At least I&#039;d have &#039;the complete set&#039; then.</div>
    <div class="meta">Posted on 2009-12-07 11:34:44 by Scali</div>
   </div>
   <div class="post" id="post-209853">
    <div class="subject"><a href="#post-209853">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote">ti_mo_n : DXT-class formats generally render that useless, but a &nbsp;jpg_decode+dxt_compress on gpu could be a nice feature for projects that load from slow DVD/BD (8-10MB/s). </div><br />Yes, true. Using JPEG is still better in some/many situations, but I wanted to know about the idea of writing one&#039;s own jpeg decompression instead of using the already available solutions. Just can&#039;t think of any reason for that (except education).<br /><br /><div class="quote">As I say, I started it 10 years ago... back then I didn&#039;t even use D3D yet. The open source libraries were really slow back then (probably still are), and really terse code and clumsy to use. I used part of my JPG decoder at one point to accelerate a histogram application for a Canon PowerShot camera... It was originally based on the IJG implementation.<br />I just never completed my JPG decoder, so I figured I&#039;d take care of the unfinished business. At least now I can REALLY say that I fully understand the JPG format. I have verified it myself.<br /><br />PNG can probably be done in just a few hours... so why not? At least I&#039;d have &#039;the complete set&#039; then.</div><br />Sure, I understand the educational idea and the &quot;I just want to finish my job&quot; idea. I just wanted to know if there is -generally- any good reason that one should write their own JPEG/PNG decompression? I thought about writing my own (actually I already have, but it was slow), but seeing that DX supports it, GDI+ supports it, open-source libs support it, I can&#039;t find any good reason. So maybe you guys have tested this or that and found any real flaws that can be written better? You know - some &#039;objective&#039; reasons for writing one&#039;s own decompressor, like speed, space, bugs, etc.<br /><br />That&#039;s actually what I meant in my question. Sorry for any confusion ^^&#039;</div>
    <div class="meta">Posted on 2009-12-07 13:27:01 by ti_mo_n</div>
   </div>
   <div class="post" id="post-209854">
    <div class="subject"><a href="#post-209854">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote">Sure, I understand the educational idea and the &quot;I just want to finish my job&quot; idea. I just wanted to know if there is -generally- any good reason that one should write their own JPEG/PNG decompression? I thought about writing my own (actually I already have, but it was slow), but seeing that DX supports it, GDI+ supports it, open-source libs support it, I can&#039;t find any good reason. So maybe you guys have tested this or that and found any real flaws that can be written better? You know - some &#039;objective&#039; reasons for writing one&#039;s own decompressor, like speed, space, bugs, etc.<br /><br />That&#039;s actually what I meant in my question. Sorry for any confusion ^^&#039;</div><br /><br />Depends on what you want to do with it. In the case of the Canon Powershot... It was an 80186 processor with 1 mb of memory.<br />Clearly this asked for a custom-made JPG solution, as the regular IJG library was just not efficient enough for such a simple 16-bit processor. So by understanding both the JPG algorithm and the shortcomings of the processor, we could build a special JPG decoder for the job (since we were only interested in a histogram, we didn&#039;t even have to do a full decode either. Just decoding the Y-channel and accumulating the results directly was enough).<br /><br />Another reason could be quality. Many JPG decoders have very limited precision (same goes for mp3 by the way). By building your own decoder, you can make sure that you get maximum decode quality.<br /><br />I originally wrote my GIF decoder because I wanted to write my own intros... I could fit my decoder in about 2k of code... a standard GIF library would be much larger, and slower to boot (which actually matter back in those days, when I used 486 and Pentium machines). Since GIF was limited to 256 colour images, I wanted JPG support aswell, for truecolour.<br /><br />I probably won&#039;t be using it for any of my D3D code, in case you&#039;re wondering. I&#039;ve always used D3DX, and haven&#039;t seen any reason to use anything else.</div>
    <div class="meta">Posted on 2009-12-07 14:09:07 by Scali</div>
   </div>
   <div class="post" id="post-209869">
    <div class="subject"><a href="#post-209869">Re: 3D Engine and related developments</a></div>
    <div class="body">Well, I&#039;ve now worked out the &#039;proper&#039; way to upsample the Cb and Cr components stored in a JPG file... and I&#039;d say I currently have a &#039;reference&#039; implementation of a JPG decoder.<br />I do full upsampling with bilinear filter and I use double precision for the iDCT and YCbCr-&gt;RGB conversion. So the results are pretty much the highest possible quality, no corners are cut anywhere. I&#039;ll do a bit more refinement of the memory allocation here and there, as some buffers are just the maximum size rather than the smallest possible size. Then I may play around a bit with a less bruteforce iDCT and perhaps an SSE-optimized YCbCr-&gt;RGB conversion or such. Considering the speed of execution I&#039;m already getting with the current &#039;bruteforce&#039; solution, it&#039;s purely a toy project at this point... Making it faster won&#039;t serve much of a practical use, I suppose. So at any rate I won&#039;t be using optimizations that compromise quality.<br /><br />I wonder what the status of decompressors is these days. The IJG implementation contains a fast integer-based iDCT solution, which has only limited precision (meant for 16-bit processors). In the early days of JPG, such fast solutions were often used, because a full solution would be too slow. Decoders would also skimp on the upsampling, as it&#039;s a reasonably costly operation when you don&#039;t have great caching and fast multiplies that we have today.<br />Likewise, in the early days of mp3/mpg decoding, they&#039;d often use fast iDCT approximations and other trickery to speed it up (Intel actually provided a sample iDCT implementation for MMX, which was notorious for its limited precision (MMX only allowing 16-bit, unless you pulled some trickery), but was just copy-pasted into many decoders at the time).<br /><br />I recall that WinAMP would take about 20-25% CPU when I played a 128 kbit mp3 on my Pentium 133. Another player, Sonique, would take up to 60-70% on the same machine wiht the same mp3. The sound quality was significantly better though. It just wasn&#039;t practical for playing music in the background.<br /><br />So I wonder... obviously those old applications will still have limited precision when decoding... but did they ever improve the precision in newer versions, now that CPUs no longer have a problem with them? What do I get exactly, when I want to load a JPG file or an mp3 through a standard Windows decoder today?<br /><br />I know video has improved lots since GPUs started accelerating them. The earliest improvement I can recall is when I got my Matrox Mystique. It had an overlay which could do hardware-accelerated upscaling of YUY2 and convert it on-the-fly.<br />Not only did this make playback of MPG files much less CPU-intensive, and allowed higher resolutions, but it also applied a bilinear filter, so you&#039;d get a much smoother image (before MMX, nobody did bilinear filtering yet, it was just too expensive).<br />Everytime I bought a new videocard, the playback quality of my videos has improved. I suppose that makes sense, as it&#039;s one of the selling points of the videocards. There&#039;s no point in being &#039;the fastest&#039;, as the framerate for a video is fixed anyway. The only thing that matters is to extract as much quality as possible from the video stream.<br /><br />So... I wonder if the people writing/using these lossy software decoders have paid any attention to quality, and bumped it up to the maximum, now that CPUs can handle it with ease... or do we still get the crippled decoders that were once optimized for our 486/Pentium class CPUs?<br /><br />On another note... I just saw this the other day:<br />http://www.brightsideofnews.com/news/2009/12/8/nvidia-gf100fermi-sli-powered-maingear-pc-pictured.aspx<br /><br />If these specs are correct, they sound quite good to me. The GTX380 will have about the same theoretical processing power as the GTX295. The GTX295 can outperform the HD5870 in pretty much all cases. With the GTX380 being a single-chip solution rather than SLI, and having a more modern architecture and higher bandwidth memory, I wouldn&#039;t be surprised if it was significantly faster than the GTX295 and the HD5870.<br />If they do, and the price and power consumption aren&#039;t excessive, I&#039;ll probaby get the GTX360 for myself.</div>
    <div class="meta">Posted on 2009-12-10 03:51:45 by Scali</div>
   </div>
   <div class="post" id="post-209880">
    <div class="subject"><a href="#post-209880">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote">So I wonder... obviously those old applications will still have limited precision when decoding... but did they ever improve the precision in newer versions, now that CPUs no longer have a problem with them? What do I get exactly, when I want to load a JPG file or an mp3 through a standard Windows decoder today?</div><br />The only way to find out, I guess, is to write a high-quality decompression and compare it to a tool which uses, for example, GDI+ (which is VERY fast at decompression , so it most probably uses some trickery). I can quickly make a tool like that so we can compare produced images.<br /><br />As for the upscaling: Isn&#039;t bicubic or lanczos filter better than bilinear one? I&#039;m really interested in seeing the highest quality decompressor possible and comparing it to some known decompressors (D3DX, GDI+, etc).<br /><br />The same goes to mp3: Comparing super high quality mp3 decompressor to winamp on my X-Fi card would be interesting at the very least ^^</div>
    <div class="meta">Posted on 2009-12-10 11:56:09 by ti_mo_n</div>
   </div>
   <div class="post" id="post-209881">
    <div class="subject"><a href="#post-209881">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote"><br />As for the upscaling: Isn&#039;t bicubic or lanczos filter better than bilinear one? I&#039;m really interested in seeing the highest quality decompressor possible and comparing it to some known decompressors (D3DX, GDI+, etc).</div><br /><br />Well sure, theoretically you can always think of a filter that is better... at the very least you can always add an extra order.<br />But I&#039;ve never heard of anyone applying anything more than a bilinear filter for regular images/video.<br />Bicubic or b-spline is interesting for extreme zoom-in... but in this case you just need to scale up the Cb/Cr componenents. The filter is more about subpixel correction than about the scaling really. You get one Cb/Cr sample for every 4 Y samples. This one sample is exactly in the center of those 4. So you only need to &#039;move&#039; the sample a relatively small amount, namely half a pixel (and the other &#039;nearest&#039; samples are 2 pixels away). This means that a higher order filter probably won&#039;t have that much of an effect.</div>
    <div class="meta">Posted on 2009-12-10 12:20:47 by Scali</div>
   </div>
   <div class="post" id="post-209890">
    <div class="subject"><a href="#post-209890">Re: 3D Engine and related developments</a></div>
    <div class="body">I think I&#039;ve covered most of the rough edges in my code now...<br />The only problem I currently have is that my upscaler is hardwired for the 4:1:1 case. Theoretically, JPG supports a wide variety of scaling. However, I don&#039;t think you&#039;ll find anything other than 4:1:1 (colour) images in the wild...<br />Likewise I only support the baseline lossy compression method. In theory JPG also supports some progressive formats and a lossless mode.<br /><br />So there may be images that produce wrong results or even crash the decoder, but I think the chance of running into one is VERY small.<br /><br />Perhaps I can put the library and my simple test program online... If you want, you can then do some quality comparisons against other decoders.<br />Could be a good test for my library aswell... I *think* it decodes properly, but I could be wrong :)<br />And even if mine decodes properly, it could still be that other decoders have better quality, so it might be interesting to study them, and see if I can improve mine further.<br />Perhaps a comparison against libjpeg (the IJG implementation) is also interesting. I&#039;m not sure which one Microsoft uses... Perhaps they use the IJG one aswell, or they rolled their own.<br /><br />I wonder if it is possible to reduce JPG artifacts on images with low quality encoding... eg, what if you use something like lanczos to scale it up, and then boxfilter the result down to the original size? Would the lanczos smooth out the JPG artifacts?</div>
    <div class="meta">Posted on 2009-12-11 05:01:29 by Scali</div>
   </div>
   <div class="post" id="post-209924">
    <div class="subject"><a href="#post-209924">Re: 3D Engine and related developments</a></div>
    <div class="body">After playing around with a few simple test-images and custom compression quality settings, I found that there are still some corner cases that I don&#039;t handle correctly.<br />One case is when I generated a green 32x32 image with &#039;0%&#039; quality in Paint.NET.<br />For some reason the entire quantization table comes up as -256, while it looks like 255 or 256 would be the desired result. I haven&#039;t quite figured out yet why the quantization table is not loaded correctly in that case. As far as I knew, it was just stored as an array of short ints, and with most images the quantization tables just work fine.<br /><br />Another thing is that the last 2 8x8 blocks in an all-red or all-blue 32x32 image have some kind of gradient, even though I see no sign of that in the encoded data (all blocks should be the same, and I decode them all the same aswell). Could be that the DC component somehow doesn&#039;t work correctly. Again, with most images, I don&#039;t see a sign of this problem...<br /><br />They are just minor issues though (that is, not too much impact, although the problems don&#039;t seem easy to find), so I could release a library/test app as-is, so ti_mo_n could try to do some comparisons.</div>
    <div class="meta">Posted on 2009-12-17 05:00:01 by Scali</div>
   </div>
   <div class="post" id="post-209958">
    <div class="subject"><a href="#post-209958">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote">I wonder if it is possible to reduce JPG artifacts on images with low quality encoding... eg, what if you use something like lanczos to scale it up, and then boxfilter the result down to the original size? Would the lanczos smooth out the JPG artifacts?</div><br />As <a target="_blank" href="http://blog.forret.com/2007/01/to-upsize-a-picture-use-the-b-spline-algorithm/">this</a> page shows, b-spline filter is much better at blurring blockiness and ringing. Lanczos seems to preserve edges, which is not what you&#039;d want in a blocky and ringy image.<br /><br /><div class="quote">Another thing is that the last 2 8x8 blocks in an all-red or all-blue 32x32 image have some kind of gradient, even though I see no sign of that in the encoded data (all blocks should be the same, and I decode them all the same aswell). Could be that the DC component somehow doesn&#039;t work correctly. Again, with most images, I don&#039;t see a sign of this problem...</div><br />DC coeff stores the average value of ALL pixels in a block. Gradients are formed by AC coefficients. If you&#039;re getting gradients in places where they aren&#039;t supposed to be, then it&#039;s most probably either a bug in IDCT or in reading AC coefficients. Might be a &quot;it&#039;s not reading the last byte&quot; bug, which is quite commonly made.<br /><br />Anyway, give a link, so I&#039;ll compare qualities with GDI+ and Intel&#039;s JPEG lib (which is discontinued, unfortunately - now it&#039;s a part of IPP).</div>
    <div class="meta">Posted on 2009-12-18 08:48:48 by ti_mo_n</div>
   </div>
   <div class="post" id="post-209979">
    <div class="subject"><a href="#post-209979">Re: 3D Engine and related developments</a></div>
    <div class="body">Well, that&#039;s interesting... I wonder if it is a bug in my JPG decoder at all.<br />The problem of the last 2 blocks having a strange gradient occurs with both red.jpg and blue.jpg.<br />I&#039;ve made my JPG Loader spit out all 8x8 blocks, before and after DCT. I can see that all blocks are the same, except for the last two Y blocks.<br />Since these are not the last blocks in the stream, and the subsequent Cb and Cr blocks are correct again, I don&#039;t think there is a problem with missing the last byte. The error doesn&#039;t occur at the end.<br />All blocks contain only the first value, the rest is all 0, except for those last two Y blocks. I wonder why there aren&#039;t any zeros. Why did the decoder not set the zero decoding like in the other blocks? They should be identical.<br />And why don&#039;t other files seem to suffer from problems in the last two blocks, or any blocks at all?<br /><br />Anyway, I&#039;ll attach what I have so far.<br />The DLL uses this header:<br /><pre><code>// Datastructures...<br />typedef struct<br />{<br />	unsigned short width;<br />	unsigned short height;<br />	unsigned int *pixels;<br />} TrueColorBitmap;<br /><br />// Function prototypes...<br />int WINAPI LoadJPG(char *fileName, TrueColorBitmap *bmp);</code></pre><br /><br />Edit: Nevermind, I found the problem with those red and blue images. Just before the last two blocks, there was a new segment marker (so it wasn&#039;t the end of the stream, but it was the end of a segment). I&#039;ve modified my bitstream reader to handle that situation correctly (or at least, I hope it does now... These two images now decode correctly, and the other test-images seem unaffected).<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2984" target="_blank">red.jpg</a></li>
      <li><a href="../../attachments/?id=2985" target="_blank">green.jpg</a></li>
      <li><a href="../../attachments/?id=2986" target="_blank">blue.jpg</a></li>
      <li><a href="../../attachments/?id=2987" target="_blank">testimg.jpg</a></li>
      <li><a href="../../attachments/?id=2989" target="_blank">JPGLoader.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-12-19 08:44:13 by Scali</div>
   </div>
   <div class="post" id="post-209981">
    <div class="subject"><a href="#post-209981">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote"><br />As <a target="_blank" href="http://blog.forret.com/2007/01/to-upsize-a-picture-use-the-b-spline-algorithm/">this</a> page shows, b-spline filter is much better at blurring blockiness and ringing. Lanczos seems to preserve edges, which is not what you&#039;d want in a blocky and ringy image.</div><br /><br />I&#039;ve used a bilinear filter to scale them back down to their original 100x100 size.<br />Not sure which one is the best. B-spline has a very smooth, soft look, but it appears to have lost quite a bit of detail.<br /><br />Another thing I found... The author used IrfanView... on another blog of his I found this quote:<br />&quot;Finally, the popular freeware IrfanView (Version 3.92) offers a Lanczos resizing option which uses too few sample points and therefore can produce an unwanted shadow pattern in some images. (from enlargingsplugins)&quot;.<br /><br />So perhaps you could get better quality from a Lanczos filter if you used a better implementation than this one.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2990" target="_blank">Downscaled.png</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-12-20 08:26:27 by Scali</div>
   </div>
   <div class="post" id="post-210062">
    <div class="subject"><a href="#post-210062">Re: 3D Engine and related developments</a></div>
    <div class="body">My brother liked my Radeon HD5770 so much that yesterday he bought not one, but two of them.<br />He had bought a Core i7 860 system recently, but hadn&#039;t upgraded his videocard yet, still using a 512 mb GeForce 9800GTX. This card severely bottlenecked the rest of the system, and in most cases, my Core2Duo E6600 with Radeon 5770 actually ran games faster and with higher visual quality.<br /><br />It&#039;s the first time I&#039;ve played around with a multi-GPU setup. There were some problems installing them at first, but those were caused by us, not by the GPUs/drivers themselves. My brother didn&#039;t plug in one of the power connectors properly, so it booted with only one card. Then when I noticed why the second card didn&#039;t work, and I plugged it in, Windows installed a standard driver via Windows Update, which didn&#039;t match the latest Catalyst drivers that we already installed for the other card.<br />After the drivers were installed properly, CrossFireX was immediately enabled, and worked fine in a game of Crysis: Warhead. The framerates were excellent on his 1280x1024 screen, even with everything maxed out, including 8xAA. It was generally in the 35-60 fps region, averaging around 50 fps.<br /><br />Video playback and his digital cable TV tuner didn&#039;t work quite as smoothly. At first, it seemed like the hardware deinterlacing was broken... But perhaps it was because the settings for the nVidia card still &#039;stuck&#039;. After meddling with the codec settings, things started to look better.<br />With the Terratec software for his TV tuner, we saw some really nasty deinterlacing bugs. When you were watching a HD channel in a window, you got huge blocky artifacts... as if the deinterlacing was applied AFTER rescaling rather than BEFORE... or something like that.<br />As it turned out, it wasn&#039;t a codec problem, but the video renderer used (which I suppose is the thing that adds subtitles, OSD and that sort of thing). It was set to Windows Media 9 or something (which my brother claims to have worked fine on nVidia... I wouldn&#039;t know, never saw it). When we changed it to the &quot;Enhanced renderer&quot; setting, all looked great.<br />When the card is working properly, it really does have amazing mpg decoding quality. It looked better than the Samsung set-top box that I use at home, and that one already has very good image quality. The main weakness of the Samsung seems to be in YUV-&gt;RGB conversion... There&#039;s this channel that has a diamond-shaped red logo in the top-right corner. The diagonal red edges usually have bleeding from the underlying image. We could detect nothing of the sort on the ATi card.<br /><img src="http://www.hardware.info/downloads/2008-06-09-NL1HD/Nederland1HD-8-6-2008-1.jpg" /></div>
    <div class="meta">Posted on 2009-12-24 06:29:57 by Scali</div>
   </div>
   <div class="post" id="post-210112">
    <div class="subject"><a href="#post-210112">Re: 3D Engine and related developments</a></div>
    <div class="body">Images:<br />test01_orig.png - the original image. Gradient-filled balls to show the blocking artifacts and sharp crosses/stars to show the ringing artifacts.<br /><br />test01_75.jpg - image @ Q:75<br />test01_75.jpg.GDIP.png - the above image decompressed by GDI+<br /><br />test01_75_down.jpg - image @ Q:75, with subsampling<br />test01_75_down.jpg.GDIP.png -decompressed by GDI+ <br />test01_75_down.jpg.scali.png - decompressed by Scali&#039;s loader<br /><br />Scali&#039;s loader hasn&#039;t been tested with images that don&#039;t have subsampling because it doesn&#039;t support such images ^^&#039;<br /><br />Q means relative quality. Goes from 0 (very poor image) to 100 (super-high quality)<br /><br />Anyway, the conclusions:<br />1. Subsampling further degrades image quality while offering very little difference in file size.<br />2. GDI+ decompression produces higher quality images than Scali&#039;s loader (esp. much less ringing) when the Q factor is very low.<br />3. Scali&#039;s loader produces a little bit darker images.<br /><br />#2 and #3 suggest that there is a bug in Scali&#039;s loader.<br /><br />The code doesn&#039;t use any magic: The image is simply created using <strong>Gdiplus::Image::Image(WCHAR*,BOOL)</strong> constructor and then saved as PNG with <strong>Gdiplus::Image::Save(WCHAR*,CLSID*,EncoderParameters*)</strong> method.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3001" target="_blank">test01_orig.png</a></li>
      <li><a href="../../attachments/?id=3003" target="_blank">test01_75_down.jpg</a></li>
      <li><a href="../../attachments/?id=3005" target="_blank">test01_75_down.jpg.GDIP.png</a></li>
      <li><a href="../../attachments/?id=3007" target="_blank">test01_75_down.jpg.scali.png</a></li>
      <li><a href="../../attachments/?id=3009" target="_blank">test01_75.jpg</a></li>
      <li><a href="../../attachments/?id=3011" target="_blank">test01_75.jpg.GDIP.png</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-12-29 21:23:04 by ti_mo_n</div>
   </div>
   <div class="post" id="post-210113">
    <div class="subject"><a href="#post-210113">Re: 3D Engine and related developments</a></div>
    <div class="body">Remaining images:<br /><br />test01_25.jpg - image @ Q:25<br />test01_25.jpg.GDIP.png - decompressed by GDI+<br /><br />test01_25_down.jpg - image @ Q:25, with subsamling.<br />test01_25_down.jpg.GDIP.png - decompressed by GDI+<br />test01_25_down.jpg.scali.png - decompressed by Scali&#039;s loader<br /><br />test01_0.jpg - image @ Q:0<br />test01_0.jpg.GDIP.png - decompressed by GDI+<br /><br />test01_0_down.jpg - image @ Q:0, with subsampling<br />test01_0_down.jpg.GDIP.png - decompressed by GDI+<br />test01_0_down.jpg.scali.png - decompressed by Scali&#039;s loader</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3013" target="_blank">test01_25.jpg</a></li>
      <li><a href="../../attachments/?id=3015" target="_blank">test01_25.jpg.GDIP.png</a></li>
      <li><a href="../../attachments/?id=3017" target="_blank">test01_25_down.jpg</a></li>
      <li><a href="../../attachments/?id=3019" target="_blank">test01_25_down.jpg.GDIP.png</a></li>
      <li><a href="../../attachments/?id=3021" target="_blank">test01_25_down.jpg.scali.png</a></li>
      <li><a href="../../attachments/?id=3023" target="_blank">test01_0.jpg</a></li>
      <li><a href="../../attachments/?id=3025" target="_blank">test01_0.jpg.GDIP.png</a></li>
      <li><a href="../../attachments/?id=3027" target="_blank">test01_0_down.jpg</a></li>
      <li><a href="../../attachments/?id=3029" target="_blank">test01_0_down.jpg.GDIP.png</a></li>
      <li><a href="../../attachments/?id=3031" target="_blank">test01_0_down.jpg.scali.png</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-12-29 21:24:26 by ti_mo_n</div>
   </div>
   <div class="post" id="post-210123">
    <div class="subject"><a href="#post-210123">Re: 3D Engine and related developments</a></div>
    <div class="body">I&#039;ve noticed #3, but I use the official ITU-R BT.601 coefficients for converting YCbCr to RGB, as defined by the JPG standard. I don&#039;t think there&#039;s any other way that could explain differences in colours (I use a reference &#039;bruteforce&#039; IDCT with double precision, so that can&#039;t be it).<br />So is it me who&#039;s doing it wrong, or is it GDI+? I have read that especially with MPG/MP4 decoders, the conversion is often not entirely &#039;correct&#039; for speed considerations. I&#039;m not sure if that also goes for JPG though, and GDI+ in particular.<br />Unless... it&#039;s just darker by a constant factor... perhaps I need to change my rounding mode?<br />But I&#039;ve seen some applications that just have totally different shades of red for example, with the rose image. Weird.<br /><br />As for the &#039;ringing&#039;.... There may be some additional filtering going on in GDI+?<br />As I say, mine is a &#039;reference&#039; implementation, I do everything by the book, and no additional post-processing.<br />I don&#039;t actually see what you mean with &#039;less ringing&#039; though.<br />I see the same type of aliasing on both.<br />The aliasing itself differs slightly... but perhaps GDI+ doesn&#039;t use a bilinear filter... it could explain why the ringing has slightly different patterns.<br />Although... since it seems to be dependent on the quality of compression, it looks more like it&#039;s a result of dequantization. After all, the bilinear filter always works the same, regardless of the quality mode. It&#039;s dependent on the input from the YCbCr blocks.<br />Why didn&#039;t you just overlay the decoded images and subtract them or such? It would give a better idea of how large the differences are and where they are exactly. See attached.<br /><br />And yes, I know I currently only support 4:1:1 formats. I hardcoded the bilinear filter. It wouldn&#039;t be very difficult to add 4:4:4, but it&#039;s an extremely rare format. Theoretically I should support every possible permutation, but I wonder if any JPG decoder really does. Things get quite tricky if you want to support every possible permutation and still deliver good filtering quality.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3039" target="_blank">test01_75_down.jpg.difference.png</a></li>
      <li><a href="../../attachments/?id=3035" target="_blank">test01_25_down.jpg.difference.png</a></li>
      <li><a href="../../attachments/?id=3037" target="_blank">test01_0_down.jpg.difference.png</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-12-30 05:17:45 by Scali</div>
   </div>
   <div class="post" id="post-210126">
    <div class="subject"><a href="#post-210126">Re: 3D Engine and related developments</a></div>
    <div class="body">I&#039;ve changed the rounding on the YCbCr-&gt;RGB routine, so all colours should be slightly brighter.<br />I&#039;ve also added a simple handler for both 4:1:1 and 1:1:1 formats, so now the non-downsampled JPGs can be decoded aswell.<br /><br />I have extended the bitmap structure to this:<br /><pre><code>typedef struct<br />{<br />	unsigned short width;<br />	unsigned short height;<br />	unsigned short padWidth;<br />	unsigned short padHeight;<br />	unsigned int *pixels;<br />} TrueColorBitmap;</code></pre><br /><br />This way it&#039;s easier to handle the decompression of any width... the decompressed bitmap is always a multiple of 8, and depends on the scale factor. Not all pixels at the edges may actually belong to the image. Width and height are the actual image size, and padWidth and padHeight are the dimensions of the decompressed image, which may be larger. So padWidth is the actual width of a scanline in memory.<br /><br />Initial tests with the non-subsampled images reveal the same differences in the &#039;ringing&#039; as the subsampled images... So I think that reinforces my theory that it&#039;s not the bilinear filter (these images not having any filtering applied, since all components have the same sample frequencies), but either the quantization stage that&#039;s doing something slightly different with GDI+, or there&#039;s some kind of additional processing going on with GDI+.<br />It would appear that the difference is the largest with the blue and black &#039;star&#039; patterns. These also have the largest contrast differences (white -&gt; blue and white -&gt; black). So it could have something to do with some kind of filtering or gamma correction or such.<br />It seems to affect the diagonal components in particular... and more in some places than in others. Could relate to the position in the 8x8 block, which would affect the amount of quantization applied...</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3041" target="_blank">JPGLoader.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-12-30 16:16:34 by Scali</div>
   </div>
   <div class="post" id="post-210186">
    <div class="subject"><a href="#post-210186">Re: 3D Engine and related developments</a></div>
    <div class="body">Getting back to the 3D engine... The way I currently dispatch multiple DLLs for different versions of D3D isn&#039;t really a good long-term solution.<br />I&#039;ll have to do a proper redesign of it, which sadly is blocking my progress with the rest of the engine.<br />So I&#039;m warming up to the idea of building a new OpenGL framework, which I was planning for my BHM file format. At least I would be starting from scratch, and that may be a welcome breath of fresh air after tinkering with D3D engine for such a long time while not really getting anywhere.<br /></div>
    <div class="meta">Posted on 2010-01-06 08:47:49 by Scali</div>
   </div>
   <div class="post" id="post-210188">
    <div class="subject"><a href="#post-210188">Re: 3D Engine and related developments</a></div>
    <div class="body">Well, I&#039;m watching, this affects me, and it&#039;s not an issue I&#039;ve dealt with yet.<br />Most people can&#039;t keep up with us, I&#039;ve been told so.<br />I know that game development covers a wide range of programming fields - perhaps more than any other digital pursuit, however that should not be a discouragement for novices, the programmer in them should respond in kind!</div>
    <div class="meta">Posted on 2010-01-06 09:22:40 by Homer</div>
   </div>
   <div class="post" id="post-210324">
    <div class="subject"><a href="#post-210324">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote">this affects me</div><br /><br />Probably not, as the issue I&#039;m not happy with is with the MFC framework I&#039;m using.</div>
    <div class="meta">Posted on 2010-01-22 06:37:44 by Scali</div>
   </div>
   <div class="post" id="post-210329">
    <div class="subject"><a href="#post-210329">Re: 3D Engine and related developments</a></div>
    <div class="body">That&#039;s exactly what I thought, and rallied against, creating my own until Biterider decided to write a better one.<br />The application framework I currently use for dx stuff is essentially his.<br />It&#039;s far better than any of mine.<br />But it also has some deep seated issues that need addressing.<br />I&#039;m just too lazy to do it until someone other than me notices!<br /></div>
    <div class="meta">Posted on 2010-01-22 08:15:45 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29617&amp;page=1" style="">&laquo;</a><a href="../?id=29617&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29617" /><input type="number" name="page" min="1" max="11" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29617&amp;page=4">&gt;</a><a href="../?id=29617&amp;page=11">&raquo;</a></form>  </div>
 </body>
</html>