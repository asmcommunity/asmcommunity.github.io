<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>3D Engine and related developments - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29617" />
  <link rel="prev" href="../?id=29617&amp;page=9" />  <link rel="next" href="../?id=29617&amp;page=11" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29617">3D Engine and related developments</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29617&amp;page=1" style="">&laquo;</a><a href="../?id=29617&amp;page=9" style="">&lt;</a><input type="hidden" name="id" value="29617" /><input type="number" name="page" min="1" max="11" step="1" value="10" onchange="this.form.submit();" /><a href="../?id=29617&amp;page=11">&gt;</a><a href="../?id=29617&amp;page=11">&raquo;</a></form>   <div class="post" id="post-214328">
    <div class="subject"><a href="#post-214328">Re: 3D Engine and related developments</a></div>
    <div class="body">Thanks, but we already have a hardware-based solution for that: a Matrox TripleHead2Go.<br />Besides, it doesn&#039;t solve the problem that a single GPU needs to render all screens.<br />We&#039;ll get a nice solution implemented eventually (multiple videocards per PC and multiple PCs in a network), it&#039;s just not very high on the list right now.<br />We&#039;re planning for a show in a few months, where we will use 3 displays max, so we can rely on the TripleHead2Go, if we don&#039;t have a better solution by then.<br />For now we are concentrating mostly on getting the required rendering tricks implemented, and building a good user interface for that. Once we have that done, we will spend the remaining time on the standalone player, and the networking functionality.<br /><br />We also want to do some tests with multiple videocards... especially with anisotropic filtering, quality can differ quite a lot between different types of cards. And the colours may also be off. So we&#039;d like to see what the actual effect will be in practice, and how much of that we may be able to compensate by tweaking the colours and filter parameters per system.</div>
    <div class="meta">Posted on 2011-04-25 09:41:50 by Scali</div>
   </div>
   <div class="post" id="post-214334">
    <div class="subject"><a href="#post-214334">Re: 3D Engine and related developments</a></div>
    <div class="body">If I&#039;m not mistaken th2go cant go ultra high in resolution ; plus it&#039;s not exactly cheap. BTW there seem to be alternatives to this, chinese hardware I think, maybe higher specs.<br /><br />There are forums about this and there seem to have been quite some trouble about getting these things to work depending on your monitors your OS and your luck.<br /><br />SoftTH needs tweaking too, but it was my first bang with multiscreen rendering, and I owe it this.<br />Oh, and I think softTH might have a networking subsystem already so you might not want to miss this.<br />With the (user, not dev) experience I had, I would absolutely not say implementing your own multi GPU multi board multiscreen solution, be it single or multi rendertarget, will be a walk in the park...At all.<br /><br />I&#039;d say a 295-style(tri-output) or two nvidia 4xx or 5xx SLI with surround 2D will provide the most robust (&quot;professional&quot;) setup. Don&#039;t forget you ~SHOULD (...) &nbsp;then be using all the power you have under the hood if needed, due to nvidia system automagically balancing the load on the sli. If you&#039;re not lucky any three monitors wont work though. There are workarounds though. Not absolutely guaranteed though. I succeeded, but I battled for very long.<br /><br />Then you&#039;ve got the red side of GPUs which has got some promising and potentially more powerful Eyefinity, but me sir, I don&#039;t wander in those type of places :)<br /><br />Welcome to the land of freaking huge resolutions. It&#039;s indeed quite an amazing blast. Google Maps Google Earth-style in five mega f___ing pixels, or FSX 5040 pixels wide, or Just Cause 2... Oh my, JC2 has eaten so many of my nights I should not even tell.<br /><br />Virtual worlds they say.<br /><br />Billions of transistors of floating points FMADD and sheer processing power giving life to somehow real universes.<br /><br /></div>
    <div class="meta">Posted on 2011-04-29 13:49:03 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214335">
    <div class="subject"><a href="#post-214335">Re: 3D Engine and related developments</a></div>
    <div class="body">Well, I&#039;m not sure what your definition of &#039;ultra high&#039; is... but my friend/co-coder on this project has a th2go (which I now borrowed to play around with... with &quot;we already have a hardware-based solution for that&quot; I meant that we, as in my friend and I, have the th2go, not that &quot;a device exists in general&quot; :) ), and he drives 3 screens of 1280x1024 with it, for a virtual 3840*1024 screen. Not sure if it can go any higher than that, but 1280x1024 is quite high resolution for beamer-related stuff. Generally the VJ-ing is done at PAL resolution (720x576) or lower, and beamers that can do high resolutions are very expensive, especially if they also need to be powerful (large distances/large projection surface).<br />So it&#039;s looking good so far.<br /><br />Thing with SLI is that it is not very cost-efficient... The videcards themselves need to be reasonably high-end, because the cheap ones don&#039;t support it. Then there&#039;s the motherboards that need support. And you&#039;ll need a more powerful CPU to drive the two cards as well.<br />So if we can achieve the same with a number of cheaper systems in a network environment, that would be very interesting. Imagine a network of low-end off-the-shelf systems with just an Intel or AMD IGP, each driving one beamer.<br /><br />It&#039;s also more interesting from a logistic point-of-view: we may be doing shows at very large venues. The beamers need to be at fixed positions. Having a central computer system driving all the beamers poses a big problem: HDMI/DVI can&#039;t really travel distances of more than ~5 metres. VGA can go larger distances, but still, not recommended over say ~15 metres, as the cables will become too expensive, and quality dropoff will be too large.<br />Generally in such situations they will convert the signal to a composite PAL signal, because it&#039;s easy to transport that over large distances. This loses quality and resolution however.<br />With a network, you could just place a small slave PC next to the beamer, and run a network cable up to it: cheap, reliable and with no loss of quality.<br /><br />Anyway, we&#039;re just going to work out our current plan first. If it fails, we can always go back to more expensive solutions with SLI or Crossfire.</div>
    <div class="meta">Posted on 2011-04-29 14:46:14 by Scali</div>
   </div>
   <div class="post" id="post-214336">
    <div class="subject"><a href="#post-214336">Re: 3D Engine and related developments</a></div>
    <div class="body">Of course, your needs are different. I have 3 22&#039;&#039; 1680.1050, thats more than 5 MP.<br />However nowadays you can find ultramassive setups on the net that easily make this pale ; I remember a forum post dating from years that said a friend had a triple 30&#039;&#039;.<br />But the same 3D world on such a wide surface that takes _more_ than _your_ viewing angle is a blast. FSX was breathtaking first times, as in, you dont breathe.<br /><br />TH2Go does maybe tri1680 but probably not tri1920, but I reckon that for projectors you don&#039;t care.<br />However keep in mind that TH2Go seems to be like, 300€, and secondhand 295s seem to be leaving ebay at few more than 150€, however not many have 3 outputs. But this card is indeed a very special case (great). Also only needs one PCIe slot. Also draws a HUGE amount of electric power :) , which also means you need corresponding PSU, and in the cases the sli cant operate, you lose a bunch of processing power. But a unique card nonetheless. <br /><br />Apparently one 460 would be like, 120€ now, so you wont convince me that the TH2Go is a good deal against such an sli (unless I missed something about the price of the device). Of course you need the motherboard and the PSU still.<br />But I see your point, you dont need tri1920 Crysis.<br />An I can see how three little notebooks near three projectors linked by rj45 is apealing.<br /><br />I dont know if what you&#039;re displaying are 3D worlds or winamp-style effects.<br />If it&#039;s 3D and the three screens form an angle between them you can indeed have a big advantage if you develop your rendering middleware, with three rendertargets. That way you could even do the render on your several low-end pcs and only graphic commands and textures would need to be transmitted across the three machines, with one master, instead of transmitting the video stream (but then only your application could work instead of any 3D app). In fact I&#039;m not sure you could transfer that much goodlooking videostream at high framerates. Theres a reason why signal cables cant be that long. But I would say, coding things yourself maybe wont be that easy.<br /><br />I&#039;m thinking of something else : lag. Even with softTH and three screens on two non-sli cards, and you blit the last third of the framebuffer from the main geforce ram to the secondary across the bus, you barely had enough bandwidth to avoid desynchronisation. It depends on what you&#039;re displaying, but a lagging 3D world (especially on big projected screens) must alter the experience. Then add a network to that...I suspect a few milliseconds will hurt &quot;quite some much&quot;. Ah, someone just tells me you were planning to do large, fast rotozooms?<br />Then again maybe lag&#039;s not a concern to you.<br /><br />Then again (again) tri720 is another story than tri full hd bandwidthwise, I might have it wrong. Just thinking loud.<br /><br />Have a nice night.<br /></div>
    <div class="meta">Posted on 2011-04-29 18:17:09 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214337">
    <div class="subject"><a href="#post-214337">Re: 3D Engine and related developments</a></div>
    <div class="body">Well, we already have the th2go, so at this point it&#039;s a good thing to use :)<br />One problem with a card like the GTX295 is that it&#039;s very large. I can&#039;t fit it in my PC case without removing the entire HDD assembly, and putting the HDDs in the 5.25&quot; slots with adapters. I guess in some cases it won&#039;t fit at all. I specifically selected my last two graphics cards on their length :)<br />I wanted to have one that allowed my HDDs to sit at their regular place.<br /><br />What we will be displaying is a combination of 3D worlds and winamp-style effects. We already have a system to stream live videocaptures on 3D geometry in realtime. Basically we can do a variety of things with our software. We can use it to replace a large number of physical devices, such as video mixers, colour correctors and various effect devices. We just use video capture and shaders to do the same in realtime.<br /><br />We can actually &#039;host&#039; applications as well. We have developed a system to capture a texture from a desktop window (originally developed for hosting Flash, but it works on anything). So it can work for other applications, although the size of the window limits the performance. But if all else fails, we can also run the application on a second computer and just capture its output onto a texture on the main machine. So any 2D or 3D app can work.<br />The only problem is if you want to use a capture on more than one PC. The easiest way is probably to duplicate the signal by analog means, and have all PCs capture it simultaneously. But that is probably not something we&#039;ll be using often. Having a capture on only one of the displays should be good enough most of the time.<br />In most cases, we just stream pre-captured videos to textures and render them into 3D scenes etc. All the content will be stored locally, so we only need to send commands to the slave PCs from the master.<br /><br />We will use a network timing scheme where the master will broadcast a clock signal, and the clients will be compensated for both lag and drift. We should be able to get all of them within the same frame at 50 fps (PAL refresh). That would leave a window of 20 ms per frame. Network latency will probably be &lt; 1 ms, as we can use a small dedicated gbit LAN with just 1 switch, with no other traffic than our own. The lag will probably be negligible anyway, and we&#039;d mostly be compensating for drift.<br />I&#039;m pretty sure it&#039;s all going to work out in the end :)</div>
    <div class="meta">Posted on 2011-04-29 19:25:57 by Scali</div>
   </div>
   <div class="post" id="post-214338">
    <div class="subject"><a href="#post-214338">Re: 3D Engine and related developments</a></div>
    <div class="body">You seem to have thought quite a bit about it :)</div>
    <div class="meta">Posted on 2011-04-29 22:02:13 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214339">
    <div class="subject"><a href="#post-214339">Re: 3D Engine and related developments</a></div>
    <div class="body">Well, mostly my friend :)<br />He&#039;s been a VJ for years, and has developed tools for himself.<br />I&#039;m more of an &#039;enabler of technology&#039;, as I am more experienced with C++ and Direct3D and all that. So most of the ideas come from him, I just try to integrate them into my engine code.</div>
    <div class="meta">Posted on 2011-04-30 09:17:39 by Scali</div>
   </div>
   <div class="post" id="post-214345">
    <div class="subject"><a href="#post-214345">Re: 3D Engine and related developments</a></div>
    <div class="body">Okay, I&#039;ve installed my old GeForce 7600GT as a second adapter in my system, and did some experimenting with driving two GPUs from a single application.<br /><br />I already did most of the groundwork in an earlier attempt to run on two GPUs. I had removed all global variables from my engine, so that each instance of the engine would be a completely self-contained resource management system for that particular GPU. However, at the earlier attempt, we had two identical GPUs, and it was quite difficult to tell what was going on exactly.<br />This time the framerate alone would be a tell-tale sign of which GPU was being used to render, as the 7600GT is at least 3 times as slow as the GTX460 on even the simplest stuff.<br /><br />And although the last attempt didn&#039;t actually work, we did read up on the documentation, to find out why it didn&#039;t work, and what should go where.<br />So this time around, I actually got it working in Direct3D9 quite quickly. I just had to move a few things around and introduce a few singleton variables, because some things have to be shared between all adapters. I also had to make proper use of the window handles. The Direct3D9 object is connected to a &#039;focus window&#039;, where the devices/swapchains are connected to &#039;device windows&#039;. In most cases you just ignore the difference, since you only have one window.<br /><br />Anyway, with all that in place, I managed to get two devices going, which each could be switched to fullscreen on the connected monitor at the same time.<br />I also tried it in XP, and although it&#039;s a bit more fussy there (it resets your devices more often), it does work.<br />Another funny thing in XP is that windowed mode also works... just not very well :)<br />That is, the D3D device will always render on the same GPU... but if you move the window to a monitor connected to another GPU, it will do a very slow copy, and your framerate will drop like mad. In Windows 7, the copying is far more efficient. It&#039;s still not as fast as the window being on the &#039;right&#039; monitor. But if I drag a window rendered on my GTX460 over to the monitor on my 7600GT, the framerate is still more than twice as high as when the 7600GT renders it itself :) In XP you&#039;re lucky to get more than 100 fps with even the simplest of windows. A fullscreen window will drop to below 30 fps.<br /><br />Anyway, I figured D3D9 would be the most difficult one... so from here on it should be a cakewalk to also support D3D10 and D3D11.<br />But no... No matter what I did, I couldn&#039;t get both windows to stay fullscreen. The rendering on two GPUs worked okay... rendering on a single GPU and switching windowed-fullscreen also worked okay... I could even get a single GPU to render fullscreen while the other was rendering windowed... But no matter what I tried, I couldn&#039;t get them both to stay fullscreen. The window also didn&#039;t quite switch back to windowed mode properly, most of the time. So you&#039;d get a borderless, non-movable popup-style window with no mouse cursor, somewhere on your desktop.<br /><br />After a lot of searching, we found this:<br />http://forums.create.msdn.com/forums/t/79803.aspx<br /><div class="quote">This is a known issue with DXGI 1.1 I&#039;m afraid...<br /><br />It is not possible to create two exclusive full-screen devices each with their own output monitor on two different adapters. One of them will always be forced to windowed mode. This limitation does not apply to drive two outputs from the same adapter, or multi-adapter scenarios that are virtualized to a single device (SLI/Crossfire).</div><br /><br />Well, crap!<br />Apparently it just is not possible. As soon as you switch the second window to fullscreen, the first one is forced back to windowed mode.<br />However, the way the guy phrased it, I was wondering: is that specific to Win7 then? So I fired up my copy of Vista x64 and tested there... Well, crap! It worked in one go! My code was working all along, Win7 just couldn&#039;t do it. I think I&#039;ll file a bug report on this, just in case. I hope it will be fixed soon.<br /><br />Other than that, I guess my work here is done: I can render with multiple GPUs to multiple fullscreen monitors.<br />I haven&#039;t actually implemented multiple swapchains on a single GPU yet, to drive multiple monitors that way, but that should be trivial, as it&#039;s barely any different from render-to-texture: Render screen 1 to buffer 1, render screen 2 to buffer 2, present.</div>
    <div class="meta">Posted on 2011-05-03 18:05:47 by Scali</div>
   </div>
   <div class="post" id="post-214435">
    <div class="subject"><a href="#post-214435">Re: 3D Engine and related developments</a></div>
    <div class="body">Things are looking up.<br />We have a gig planned this Friday. This will be the debut of our newly developed technology.<br /><br />In short we will be using two capture devices to capture two analog streams in realtime. These will be streamed onto textures in Direct3D.<br />Then they are put into a cubemap, which is applied to some 3D objects.<br />We will be driving 4 beamers to project the images onto 4 objects.<br /><br />For this purpose we have built a machine with 3 videocards with 2 outputs each. Two videocards will drive the beamers, and the third will be for the desktop, so we can have the controller UI on there.<br /><br />We haven&#039;t implemented multithreading yet, so all GPUs are currently driven by a single core in a sequential fashion. Early tests showed that we could still get about 700 fps with 4 outputs, so performance is not an issue at this time. We will probably postpone multithreading until after the gig.<br /><br />When driving all 6 outputs, we got 150 fps, but that probably has more to do with the fact that the third videocard is my old GeForce 7600GT, which is considerably slower than the other two Radeon 4850s. If I implement an asynchronous mode in the multithreading scheme, the slowest videocard won&#039;t necessarily have to pull down the performance of the others. That may be interesting as a benchmarking tool: just have each GPU render as quickly as possible.</div>
    <div class="meta">Posted on 2011-05-30 06:12:37 by Scali</div>
   </div>
   <div class="post" id="post-214436">
    <div class="subject"><a href="#post-214436">Re: 3D Engine and related developments</a></div>
    <div class="body">Here&#039;s a quick recording of the app running with two capture devices in a feedback loop, on 4 screens simultaneously:<br />http://www.youtube.com/watch?v=4IooujifRaQ</div>
    <div class="meta">Posted on 2011-05-30 18:33:57 by Scali</div>
   </div>
   <div class="post" id="post-214437">
    <div class="subject"><a href="#post-214437">Re: 3D Engine and related developments</a></div>
    <div class="body">And here we have them projected on actual half-sphere objects: http://www.youtube.com/watch?v=bjZ8hlFPu0I</div>
    <div class="meta">Posted on 2011-05-31 14:45:06 by Scali</div>
   </div>
   <div class="post" id="post-214440">
    <div class="subject"><a href="#post-214440">Re: 3D Engine and related developments</a></div>
    <div class="body">Very interesting.<br /></div>
    <div class="meta">Posted on 2011-06-01 16:08:22 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214441">
    <div class="subject"><a href="#post-214441">Re: 3D Engine and related developments</a></div>
    <div class="body">With what you&#039;ve done you could maybe have something similar to what the softTH guy did.<br />Render on one card on a large buffer and present on three outputs.<br />But for this you have to make a fake d3d_.dll that redirects all the calls the application makes to your layer, I don&#039;t know how difficult this is. Plus it seems there are several ways to do the copy and subtilities with mouse cursor. By the way softTH manages to have multi fullscreen on windows 7, I think it&#039;s a trick using a topmost borderless windowed wiewport.<br /><br />Then with your system you could also render locally on each card separately with different viewport matrixes which could be a big benefit, minus the fact that the cpu has to send all commands N times. But then you could for example have different camera orientation on each display for &quot;free&quot;, and this my friend, would be awesome and unprecedented. Although I suspect that there would be many things in the way of making this work, like the application doing too much things by itself regarding the camera or postprocessing effects assuming a the center of the screen is the center of the view, or hud on each display, or...things I didnt think of.<br /><br />But with the advent of stereoscopic 3D it is likely that there will be an effort from nvidia and the developers to have more separate distinct layers in the rendering pipeline, so that the lower layers &quot;know&quot; wtf they are doing (this is an object, this is the world, this is the camera, maybe this is the hud, this is a light), and the programmer has less freedom to write its own engine and do tricks to render things in a &quot;creative&quot; (bad, dirty!) way. I don&#039;t know if this is a good thing. I also think the evolution of gpus(more and more genericity) actually goes against this separation of layers : raytracing, raymarching, point cloud renderning, screenspace effects, distance field rendering, deferred rendering etc...I think the future best way of doing things seems less certain now than it did a few years ago. And with all these different ways of doing things the hardware or even the lower layers of the software stack have no way of figuring wtf you&#039;re trying to do and wtf these numbers you&#039;re crunching represent. Only in the end you&#039;ve got something nice in a buffer.<br /><br />Anyway Nvidia surround support seem to be improving, but still I&#039;m not certain it fully makes use of all the gpus.<br />Must not be an trivial thing though.<br /><br />Reminds me of these things<br />http://www.wideview.it/steve/<br />hehe. Times they are changin :)<br /><br />(man were these 90&#039;s tower ugly)<br /></div>
    <div class="meta">Posted on 2011-06-01 18:03:39 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214442">
    <div class="subject"><a href="#post-214442">Re: 3D Engine and related developments</a></div>
    <div class="body">Well yes, we could do something like SoftTH, but our focus is on developing our own software. We aren&#039;t aiming at running existing software in higher resolutions or anything.<br />And yes, it&#039;s going to be quite difficult to make anything more advanced work for a large set of applications. When using shaders, you never quite know where your matrices are going. They are just sent directly to some shader variables. The classic SetTransform() API is bypassed altogether.<br /><br />But for our own software we now have a pretty nice high-performance solution.<br />We are currently using the &#039;borderless window&#039; trick as well. Although DirectX 9 seems to work okay with multiple fullscreen windows on Windows 7, it&#039;s still rather delicate. So just to be on the safe side for now, we stick to the fake fullscreen trick.<br />We&#039;ll experiment with fullscreen mode in DX9 a bit more after the gig. Then we&#039;ll also work out the multithreading. I already did a quick-and-dirty test where all GPUs were being fed by their own thread (and thus core), so that they would all render in parallel. The idea works, but it was still very rough around the edges... window procs weren&#039;t working yet, etc. Threads would also fight for CPU time, one display would starve the others for some reason (could be a C#-related threading issue, should really do threading in native code).<br /><br />And there&#039;s plenty of other ideas that we have, which we will work on after the gig.<br />One idea I particularly like is to use the VideoLAN code to broadcast live video data over the network, and render with multiple PCs at a time.</div>
    <div class="meta">Posted on 2011-06-02 08:35:28 by Scali</div>
   </div>
   <div class="post" id="post-214643">
    <div class="subject"><a href="#post-214643">Re: 3D Engine and related developments</a></div>
    <div class="body">Right, getting back to the D3D side of things...<br />I&#039;m currently trying to build some more interaction into the engine, so that you can tweak shaders, materials, textures etc on the fly. In a way it will be something like RenderMonkey... only not as limited.<br />One of the biggest problems is regarding the inputs and outputs of shaders. Eg, texture lookups implicitly encode the type of texture... so if you write your shader to do a lookup in a cubemap, it can only use a cubemap for that texture input.<br />Then there are the constant buffers in the shader... What kind of inputs does it expect from the engine, and where?<br /><br />I am thinking of designing some comment tags that the engine can recognize. So it will scan the shader code to learn what the shader wants. Then it can give the user some hints as to what he should be using as inputs.<br /><br />C# has a nice feature in that the compiler is always available, and can be invoked from your own application. So I have made a simple proof-of-concept where I write a bit of code in a textbox of the application, and then compile it on-the-fly, and instance the resulting object.<br />This seems to work quite nicely, doesn&#039;t even require me to have the compiler write the output files to disk... and it could be used as an advanced scripting tool in the engine (the custom-written code can have full access to the engine&#039;s internals, and perform any D3D function you may desire).<br />The engine could generate part of the code to drive the shaders, based on the hints it scanned from the shader comments. Then it can allow the user to inspect and edit the code... and once it&#039;s done, it can be compiled and used right away.<br /><br />If I can get that working nicely in practice, it should make writing new shader and effects much nicer.</div>
    <div class="meta">Posted on 2011-07-18 11:05:03 by Scali</div>
   </div>
   <div class="post" id="post-214644">
    <div class="subject"><a href="#post-214644">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote">C# has a nice feature in that the compiler is always available, and can be invoked from your own application. So I have made a simple proof-of-concept where I write a bit of code in a textbox of the application, and then compile it on-the-fly, and instance the resulting object.<br />This seems to work quite nicely, doesn&#039;t even require me to have the compiler write the output files to disk...</div><br /><br />Do I understand correctly?<br /><br />This is f**cking SMC brought to the masses...Just not self modifyng machine or bytecode...It&#039;s in the execution environment.<br />Maybe we&#039;re going to witness never-seen heights of obfuscation...<br /><br />Maybe it&#039;ll bring new levels of genericity and abstraction in the source...<br />The revenge of the preprocessor over the templates...Just, it&#039;s not only a preprocessor anymore...Same language, and you can mix and match what exists and what you just created...again and again...Till the thing wakes up and want to kill you :)<br />Less and less difference between the compiler and the environment execution...and your program, which can be seen as an extension of the compiler compiling higher level concepts when it generates the C# code.<br /><br />En a way one can consider you can ship opensource programs now by only supplying your source.<br /><br />Of course it&#039;s still not like you can insert a bunch of bytecodes or C# statements just before the execution point and jump back, but still...<br /><br />Wondering.<br /></div>
    <div class="meta">Posted on 2011-07-18 17:37:09 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214647">
    <div class="subject"><a href="#post-214647">Re: 3D Engine and related developments</a></div>
    <div class="body"><div class="quote"><br />Do I understand correctly?<br /><br />This is f**cking SMC brought to the masses...Just not self modifyng machine or bytecode...It&#039;s in the execution environment.<br />Maybe we&#039;re going to witness never-seen heights of obfuscation...</div><br /><br />Well, it&#039;s somewhere between scripting and SMC I suppose.<br /><br /><div class="quote"><br />and your program, which can be seen as an extension of the compiler compiling higher level concepts when it generates the C# code.</div><br /><br />Yes, I think one interesting application would be to generate C# code to optimize your application at runtime.<br />Say, rather than having to check a number of state variables at every iteration, you just generate C# code for the current state once, then execute it without any conditional jumps.<br />Something a bit like what SoftWire used to do, except you use C# code instead of an assembly macro language. The end result is still going to be native code, with optimizations applied.<br /><br /><div class="quote"><br />En a way one can consider you can ship opensource programs now by only supplying your source.</div><br /><br />You could, but I wouldn&#039;t go there myself.<br />You&#039;d still need to provide a simple program that does the compiling for you (I don&#039;t think you get the actual csc.exe compiler executable if you don&#039;t have the .NET SDK, so you&#039;d need to build your own compiler).<br />Aside from that, source code is considerably larger than the compiled code, and it also takes much longer to compile from source than to compile the assembly bytecode to native.<br />So for convenience and bandwidth-savings, I&#039;d still distribute a compiled version, and have the source code as an optional download (unless eg in the case of BHM where the source code itself is what it&#039;s about, and the binaries are just included for convenience... much like the DirectX SDK for example... full source code for the samples is included, but they have included prebuilt binaries as well, so you can just point-and-click to see what it does).<br /><br />Semi-related: Microsoft is working on their own open source repository. Since Windows-ports of open source programs are generally buggy and perform relatively poorly, Microsoft has decided to do something similar to what FreeBSD does: maintain your own ports.<br />This includes a build environment for Windows, so users can download and build the latest version from source.<br />So if this project takes off, then a standardized build environment for Windows may become a reality, and then it will be more feasible to distribute Windows programs in source form.<br />I made a topic on that a while ago: http://www.asmcommunity.net/board/index.php?topic=30181.0<br />Haven&#039;t really followed it since, but who knows.</div>
    <div class="meta">Posted on 2011-07-19 03:11:08 by Scali</div>
   </div>
   <div class="post" id="post-215487">
    <div class="subject"><a href="#post-215487">Re: 3D Engine and related developments</a></div>
    <div class="body">Yo guys, this is the place perfect for me to show you my 3D renderer engine. I&#039;ll rearrange the code so it is neat enough and will not harm your eyes. I think it is good enough for a average low end card. <br /><br />http://ompldr.org/vYmZnZw/OGLE.zip (The demo, about 5 MB)<br /><br /><img src="http://ompldr.org/vYmY5dQ/pkr.JPG" /><br /><br />I&#039;ll tell you all I know. I heard OpenGL is obsolete, but care not, I&#039;ll invent a new one if necessary.</div>
    <div class="meta">Posted on 2011-12-03 04:53:35 by Farabi</div>
   </div>
   <div class="post" id="post-215571">
    <div class="subject"><a href="#post-215571">Re: 3D Engine and related developments</a></div>
    <div class="body">1998 called, they want their demo back !<br />sorry, had to do it :)</div>
    <div class="meta">Posted on 2011-12-11 18:13:42 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-215640">
    <div class="subject"><a href="#post-215640">Re: 3D Engine and related developments</a></div>
    <div class="body">Small update on the D3D stuff...<br />We&#039;re now working on dome projections (sorta like imax/omnimax theaters).<br />I have developed a player which can play 360 degree movie formats in realtime.<br />http://www.youtube.com/watch?v=y2imUeEMoq0<br />It first &#039;unwraps&#039; the movie to a cubemap, and then it can be projected on any shape with the use of a mesh and some shaders. In this case I use a sphere. Our dome projection works by using a spherical mirror (sphemir) in the center of the dome, and a conventional projector aimed at it. So the sphere is the correct mapping to project onto the dome.<br />But many other configurations are possible.</div>
    <div class="meta">Posted on 2011-12-31 14:58:23 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29617&amp;page=1" style="">&laquo;</a><a href="../?id=29617&amp;page=9" style="">&lt;</a><input type="hidden" name="id" value="29617" /><input type="number" name="page" min="1" max="11" step="1" value="10" onchange="this.form.submit();" /><a href="../?id=29617&amp;page=11">&gt;</a><a href="../?id=29617&amp;page=11">&raquo;</a></form>  </div>
 </body>
</html>