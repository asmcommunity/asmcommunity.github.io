<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Precise Timing of Small Code: - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3951" />
    <link rel="next" href="../?id=3951&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=3951">Precise Timing of Small Code:</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=3951&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=3951&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="3951" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=3951&amp;page=2">&gt;</a><a href="../?id=3951&amp;page=2">&raquo;</a></form>   <div class="post" id="post-26853">
    <div class="subject"><a href="#post-26853">Precise Timing of Small Code:</a></div>
    <div class="body">Precise because we are trying to measure the number of cycles executed within an interval of code.  Small code because we are under windows and are not in control.<br /><br />Attached is a RadASM project for timing code fragments, and I'd be interested if others could try it out to let me know if I've made some errors.  The code should return a measurement of zero on all systems.<br /><br />This is nothing great or new - just an example of how to time code.  Agner Fog, Michael Abrash, and others have created libraries to time code.  I have consulted the sources at Intel and AMD as well.<br /><br />It takes 21000 cycles to load a code cache line from memory on my PC (ouch!).  This is why the timing loop is executed once before the actual timing.  Hence, you could not do this and time your memory.  I was able to time single instructions with a great deal of repeatablity.<br /><br />(Use version below.)</div>
    <div class="meta">Posted on 2002-03-02 23:24:12 by bitRAKE</div>
   </div>
   <div class="post" id="post-26856">
    <div class="subject"><a href="#post-26856">Precise Timing of Small Code:</a></div>
    <div class="body">This is the results on my PC(800mhz 256mb ram):<br /><br />First Try:<br /><br />OverHead: 243 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -91000 cycles<br /><br />Second Try:<br /><br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 3 cycles<br /><br />Third Try:<br /><br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 1 cycles<br /><br />:) Nice Tool :)</div>
    <div class="meta">Posted on 2002-03-02 23:47:54 by stryker</div>
   </div>
   <div class="post" id="post-26857">
    <div class="subject"><a href="#post-26857">Precise Timing of Small Code:</a></div>
    <div class="body">The tool is <strong>vkim</strong>'s, yes it is very nice!<br /><br />Don't close the debug window and run the program several times?  That is strange that the timing is off by a couple cycles in 1000 loops?  Should be a multiple of 1000 if there is a timing error in the loop calculation.  Is any value occur more often than others?<br /><br />Here is what I get (Athlon TB):<pre><code>OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles</code></pre>This means the timing overhead is 77 cycles and is being subtracted everytime a timing is made.  Also after 1000 itterations, there was no error - nothing is being timed.</div>
    <div class="meta">Posted on 2002-03-02 23:50:38 by bitRAKE</div>
   </div>
   <div class="post" id="post-26858">
    <div class="subject"><a href="#post-26858">Precise Timing of Small Code:</a></div>
    <div class="body">Actually, I close it everytime it finished its job :). Sometimes I get 0 cycles. Yes, 1 2 and 3 are the usual values that pops up.<br /><br />Here's another one:<br /><br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 3 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 4 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 2 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 1 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 1 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 3 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 3 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 4 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 3 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 0 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 1 cycles<br />OverHead: 271 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -118997 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 0 cycles<br />OverHead: 152 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 0 cycles<br /><br />I must have a buggy PC :). I downloaded SiSandra Soft a few months back and it turns out, I always have different speed at different times(especially RAM) :)</div>
    <div class="meta">Posted on 2002-03-02 23:53:28 by stryker</div>
   </div>
   <div class="post" id="post-26860">
    <div class="subject"><a href="#post-26860">Precise Timing of Small Code:</a></div>
    <div class="body">No, means I have to fix the code for Pentiums.  :)  What OS are you running.  I know how to fix the OverHead calculation being off, but I don't know about the 1-4 cycles over?  That is strange.</div>
    <div class="meta">Posted on 2002-03-02 23:59:29 by bitRAKE</div>
   </div>
   <div class="post" id="post-26865">
    <div class="subject"><a href="#post-26865">Precise Timing of Small Code:</a></div>
    <div class="body">Intel P3 800 mhz<br />256mb RAM<br />Windows 2000 SP2 (*Not needed: all patches too :) *)</div>
    <div class="meta">Posted on 2002-03-03 00:12:57 by stryker</div>
   </div>
   <div class="post" id="post-26886">
    <div class="subject"><a href="#post-26886">Precise Timing of Small Code:</a></div>
    <div class="body">bitRAKE: I get exactly the same result as you, on an athlon TB as well.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-03 03:35:01 by Thomas</div>
   </div>
   <div class="post" id="post-26887">
    <div class="subject"><a href="#post-26887">Precise Timing of Small Code:</a></div>
    <div class="body">*ahem*<br /><br />Here we go:<br /><br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, 11384 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br />OverHead: 80 cycles/byte<br />MyPROC: 1 bytes, 1000 loops, -3000 cycles<br /><br />This looks... weerd.<br /><br />I have a AMD Athlon Thunderbird at 1333 mHz<br /><br />PS: Of course I forgot to mention this will be a great tool when finished :alright:</div>
    <div class="meta">Posted on 2002-03-03 03:40:48 by Qweerdy</div>
   </div>
   <div class="post" id="post-26888">
    <div class="subject"><a href="#post-26888">Precise Timing of Small Code:</a></div>
    <div class="body">- Athlon 800mhz, 1536MB RAM<br /><pre><code><br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 41 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br />OverHead&#58; 77 cycles/byte<br />MyPROC&#58; 1 bytes, 1000 loops, 0 cycles<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-03 04:25:31 by bazik</div>
   </div>
   <div class="post" id="post-26891">
    <div class="subject"><a href="#post-26891">Precise Timing of Small Code:</a></div>
    <div class="body">Hi bitRAKE,<br />Today I don't do C/C++ anymore.. so please do not expect too much support from this code. But it worked perfectly CPU after CPU.. originally I wrote it on my first Pentium.<br /><br />The fact that it tests several times the same function is not casual.<br /><br />Use it this way:<br /><br /><pre><code><br />        &lt; set up any register as you wish &gt;<br />        &lt; set up stack as you wish &gt;<br />        MOV     &#91;PROFILEROUTINE&#93;,OFFSET YourRoutineToBeTested<br />        CALL    PROFILE<br />        &lt; now your registers and stack will be just like if you called YourRoutineToBeTested directly, &gt;<br />        &lt; instead of going through PROFILE. Also, also, the number of CPU cycles it took to execute &gt;<br />        &lt; YourRoutineToBeTested is stored in the unsigned 64 bit &#91;PROFILECYCLES&#93; &gt;<br /></code></pre><br /><br />PROFILE will then call YourRoutineToBeTested, and return in PROFILECYCLES how many CPU cycles it took.<br />This is the main quality of this code: it is very transparent. Accross each call to the routine to be tested (there will be several calls, to &quot;stabilize&quot; caches and all), your registers and stack will be preserved, and when PROFILE returns, the registers and stack will be in the same state as they would have been if you called your routine directly. PROFILE is very transparent.<br />I like tools which are easy to use and powerful at the same time.<br /> <br />NOTE: add or remove the WBINVD instruction to test cached or uncached situations (you can't use WBINVD in Windows, but in Dos you can).<br /><br />Disclaimer: THIS IS VERY OLD CODE. It was originally written for WatcomC++ 10.x, using #pragma, then rewritten to work with WatcomC++ 11.x, using inline asm and 64bit results instead of 32bit. That should have made it work also on VisualC++, but I never tested it. It was abandoned in my hard disk.. I hope though it's useful to you and/or/xor anybody else.<br />It wasn't designed for performance *but* for accuracy, reliability and consistency. It will self-adapt to any future CPU.. it did it flawlessly as far as I know until now anyway.<br /><br />Greets,<br />Maverick<br /><br /><br /><pre><code><br />unsigned __int64    PROFILECYCLES;<br />unsigned __int64    PROFILEEMPTY;<br />unsigned long       PROFILEROUTINE;<br />unsigned long       PROFILERETURN;<br />unsigned long       PROFILEINEAX;<br />unsigned long       PROFILEINEBX;<br />unsigned long       PROFILEINECX;<br />unsigned long       PROFILEINEDX;<br />unsigned long       PROFILEINEFL;<br />unsigned long       PROFILEOUTEAX;<br />unsigned long       PROFILEOUTEBX;<br />unsigned long       PROFILEOUTECX;<br />unsigned long       PROFILEOUTEDX;<br />unsigned long       PROFILEOUTEFL;<br />unsigned long       PROFILERETADDR;<br /><br />__declspec&#40;naked&#41; void PROFILE&#40;char* Address&#41; &#123;<br />   asm &#123;<br />        mov     &#91;PROFILEINEAX&#93;,eax     ; saves INPUT EAX &#40;will be trashed by CPUID&#41;<br />        mov     &#91;PROFILEINEBX&#93;,ebx     ; saves INPUT EBX &#40;will be trashed by CPUID&#41;<br />        mov     &#91;PROFILEINECX&#93;,ecx     ; saves INPUT ECX &#40;will be trashed by CPUID&#41;<br />        mov     &#91;PROFILEINEDX&#93;,edx     ; saves INPUT EDX &#40;will be trashed by CPUID&#41;<br />        pushfd<br />        pop     &#91;PROFILEINEFL&#93;         ; saves INPUT CPU EFLAGS<br />        pop     &#91;PROFILERETURN&#93;        ; saves return address<br />        call    @geteip1<br />@geteip1&#58;<br />        jmp     @skip1<br />        ret<br />@skip1&#58; pop     eax<br />        add     eax,2<br />        push    &#91;PROFILEROUTINE&#93;       ; saves requested PROFILEROUTINE<br />        mov     &#91;PROFILEROUTINE&#93;,eax   ; first we'll profile a simple RET<br />        ;<br />        call    @geteip2<br />@geteip2&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp2&#58;  jmp     @jmp3                  ; make sure it gets cached<br />        ;<br />        call    @geteip3<br />@geteip3&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp3&#58;  jmp     @jmp4                  ; profile for real &#40;well, let it set up&#41;<br />        ;<br />        call    @geteip4<br />@geteip4&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp4&#58;  jmp     @jmp5                  ; profile for real &#40;well, let it set up again&#41;<br />        ;<br />        call    @geteip5<br />@geteip5&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp5&#58;  jmp     @jmp6                  ; profile for real &#40;well, let it set up one final time&#41;<br />        ;<br />        call    @geteip6<br />@geteip6&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp6&#58;  jmp     @jmp7                  ; profile for real<br />        ;<br />        mov     eax,&#91;PROFILECYCLES+0&#93;<br />        mov     edx,&#91;PROFILECYCLES+4&#93;<br />        mov     &#91;PROFILEEMPTY+0&#93;,eax   ; saves RET cycles count<br />        mov     &#91;PROFILEEMPTY+4&#93;,edx<br />        pop     &#91;PROFILEROUTINE&#93;       ; restores requested PROFILEROUTINE<br />        ;<br />        call    @geteip7<br />@geteip7&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp7&#58;  jmp     @jmp8                  ; make sure it gets cached<br />        ;<br />        call    @geteip8<br />@geteip8&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp8&#58;  jmp     @jmp9                  ; profile for real<br />        ;<br />        call    @geteip9<br />@geteip9&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp9&#58;  jmp     @jmp10                 ; make sure it gets cached<br />        ;<br />        call    @geteip10<br />@geteip10&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp10&#58; jmp     @jmp11                 ; profile for real<br />        ;<br />        call    @geteip11<br />@geteip11&#58;<br />        pop     eax<br />        add     eax,11<br />        mov     &#91;PROFILERETADDR&#93;,eax<br />@jmp11&#58; jmp     @profile               ; make sure it gets cached<br />        ;<br />        mov     eax,&#91;PROFILEEMPTY+0&#93;   ; subtracts simple RET overhead<br />        mov     edx,&#91;PROFILEEMPTY+4&#93;<br />        sub     &#91;PROFILECYCLES+0&#93;,eax  ; saves cycles, low 32bit<br />        sbb     &#91;PROFILECYCLES+4&#93;,edx  ; saves cycles, high 32bit<br />        mov     eax,&#91;PROFILEOUTEAX&#93;    ; gives OUTPUT EAX<br />        mov     ebx,&#91;PROFILEOUTEBX&#93;    ; gives OUTPUT EBX<br />        mov     ecx,&#91;PROFILEOUTECX&#93;    ; gives OUTPUT ECX<br />        mov     edx,&#91;PROFILEOUTEDX&#93;    ; gives OUTPUT EDX<br />        push    &#91;PROFILEOUTEFL&#93;<br />        popfd                          ; gives CPU EFLAGS<br />        jmp     &#91;PROFILERETURN&#93;        ; returns to caller<br />@profile&#58;<br />       ;wbinvd<br />        mov     eax,&#91;PROFILECYCLES+0&#93;  ; touches caches<br />        mov     edx,&#91;PROFILECYCLES+4&#93;<br />        mov     eax,&#91;PROFILEINEAX&#93;<br />        mov     ebx,&#91;PROFILEINEBX&#93;<br />        mov     ecx,&#91;PROFILEINECX&#93;<br />        mov     edx,&#91;PROFILEINEDX&#93;<br />        mov     eax,&#91;PROFILEINEFL&#93;<br />        mov     eax,&#91;PROFILEOUTEAX&#93;<br />        mov     ebx,&#91;PROFILEOUTEBX&#93;<br />        mov     ecx,&#91;PROFILEOUTECX&#93;<br />        mov     edx,&#91;PROFILEOUTEDX&#93;<br />        mov     eax,&#91;PROFILEOUTEFL&#93;<br />        mov     eax,&#91;PROFILEROUTINE&#93;<br />        mov     ecx,32<br />@stack&#58; push    eax<br />        loop    @stack<br />        add     esp,128<br />        xor     eax,eax<br />        cpuid                          ; flush pipelines<br />        rdtsc<br />        mov     &#91;PROFILECYCLES+0&#93;,eax  ; saves TSC, low 32bit<br />        mov     &#91;PROFILECYCLES+4&#93;,edx  ; saves TSC, high 32bit<br />        xor     eax,eax<br />        cpuid                          ; flush pipelines<br />        mov     eax,&#91;PROFILEINEAX&#93;     ; restores INPUT EAX<br />        mov     ebx,&#91;PROFILEINEBX&#93;     ; restores INPUT EBX<br />        mov     ecx,&#91;PROFILEINECX&#93;     ; restores INPUT ECX<br />        mov     edx,&#91;PROFILEINEDX&#93;     ; restores INPUT EDX<br />        push    &#91;PROFILEINEFL&#93;<br />        popfd                                    ; restores CPU EFLAGS<br />        call    &#91;PROFILEROUTINE&#93;       ; calls routine to be tested<br />        mov     &#91;PROFILEOUTEAX&#93;,eax    ; saves OUTPUT EAX<br />        mov     &#91;PROFILEOUTEBX&#93;,ebx    ; saves OUTPUT EBX<br />        mov     &#91;PROFILEOUTECX&#93;,ecx    ; saves OUTPUT ECX<br />        mov     &#91;PROFILEOUTEDX&#93;,edx    ; saves OUTPUT EDX<br />        pushfd<br />        pop     &#91;PROFILEOUTEFL&#93;        ; saves OUTPUT CPU EFLAGS<br />        xor     eax,eax<br />        cpuid                          ; flush pipelines<br />        rdtsc<br />        xchg    &#91;PROFILECYCLES+0&#93;,eax<br />        xchg    &#91;PROFILECYCLES+4&#93;,edx<br />        sub     &#91;PROFILECYCLES+0&#93;,eax  ; saves TSC, low 32bit<br />        sbb     &#91;PROFILECYCLES+4&#93;,edx  ; saves TSC, high 32bit<br />        jmp     &#91;PROFILERETADDR&#93;<br />   &#125;<br />&#125;<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-03 05:54:48 by Maverick</div>
   </div>
   <div class="post" id="post-26892">
    <div class="subject"><a href="#post-26892">Precise Timing of Small Code:</a></div>
    <div class="body">I looked at my code.<br /><br />Doesn't make a difference.. but:<br /><br />__declspec(naked) void PROFILE(char* Address)  {<br /><br />should be changed to:<br /><br />__declspec(naked) void PROFILE()  {<br /><br />I said it was C/C++ but it's really pure asm.. and I've always used it from inline asm, so..<br /><br />Also, I said that today I don't do C/C++ anymore. It's not correct, since I'm under contract and working with C/C++. I just meant that when I have a choice I stay away from these languages, nowadays. :)</div>
    <div class="meta">Posted on 2002-03-03 06:01:32 by Maverick</div>
   </div>
   <div class="post" id="post-26893">
    <div class="subject"><a href="#post-26893">At the time I was a lazy kid.</a></div>
    <div class="body">Wow.. how much time passed. I looked with some interest at my code, and I noticed all those funny jmps.. it's because WatcomC++'s inline asm won't let you do 32bit relative jmps, but only 8 bit.<br />Some jmps in the code would have needed 32 bit, so I didn't want to bother to hardcode the instructions using db (jmp @profile).<br />Other jmps would have been 8bit relative offset direct to @profile, but then I would have had to calculate the EIP+x necessary to return to the caller (without a CALL/RET, but with a jmp/jmp), and I was too lazy to do it for each of the 10 calls to the real profile routine. :D<br />So I didn't bother and just used one scheme for all &quot;calls&quot;. No real performance difference, anyway. The code is hard to read, but works perfectly.</div>
    <div class="meta">Posted on 2002-03-03 06:13:09 by Maverick</div>
   </div>
   <div class="post" id="post-26900">
    <div class="subject"><a href="#post-26900">Precise Timing of Small Code:</a></div>
    <div class="body">Hi bitRAKE, on my PIII 700mhz with Win2k it always settles on 6 cycles after a couple if runs.<br /><br />If anyones interested I always used Agner Fogs suggestion for timing code;<br /><br />Initilizations Macro<br />&amp;nbsp &amp;nbsp fldpi<br />EndM<br /><br />CodeToTime Macro<br />&amp;nbsp &amp;nbsp fmul st,st<br />EndM<br /><br />Finalizeations Macro<br />&amp;nbsp &amp;nbsp fstp st<br />EndM<br /><br />.data?<br />tVal dd 32 dup (?)<br /><br />.code<br />mov edx,31<br />tLp:mov i,edx<br />&amp;nbsp &amp;nbsp rdtsc<br />&amp;nbsp &amp;nbsp cpuid<br />&amp;nbsp &amp;nbsp and v,0<br />	<br />Initilizations<br />	<br />&amp;nbsp &amp;nbsp rdtsc<br />&amp;nbsp &amp;nbsp mov t,eax<br />&amp;nbsp &amp;nbsp cld<br />&amp;nbsp &amp;nbsp REPT 8		<br />&amp;nbsp &amp;nbsp nop<br />&amp;nbsp &amp;nbsp EnDM<br />		<br />CodeToTime<br /><br />&amp;nbsp &amp;nbsp clc<br />&amp;nbsp &amp;nbsp rdtsc	<br />&amp;nbsp &amp;nbsp sub eax,t<br />&amp;nbsp &amp;nbsp mov edx,i<br />&amp;nbsp &amp;nbsp sub eax,42<br />&amp;nbsp &amp;nbsp mov tVal,eax<br />		<br />Finalizeations<br />	<br />dec edx<br />jns tLp<br /><br />The  sub eax,42 line removes the overhead on my PC and therefore nothing in the CodeToTime macro will return 0.<br /><br />You simply need a seperate display procedure to output the 32 values in the tVal array.</div>
    <div class="meta">Posted on 2002-03-03 07:37:45 by Eóin</div>
   </div>
   <div class="post" id="post-26902">
    <div class="subject"><a href="#post-26902">Precise Timing of Small Code:</a></div>
    <div class="body">Don't want to &quot;sell&quot; my code, but honestly I think that it's much more comfortable than having to use separate &quot;initialization&quot; and such routines, and to have to subtract some cycles depending on what machine it's running on. Also, there's the issue of stability of results accross repeated tests.<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-03-03 08:02:21 by Maverick</div>
   </div>
   <div class="post" id="post-26924">
    <div class="subject"><a href="#post-26924">Precise Timing of Small Code:</a></div>
    <div class="body">Thanks for the replies.  I did want to have something that determined the adjustment time without having to fudge the figures to make them work.  It needs some work.  :)<br /><br /><strong>Qweerdy</strong>, your results are very odd.  If the OverHead was 77 then it would produce the correct timing of zero, but for some reason it's consistently producing and OverHead calculation of 80.  ???I don't know???<br /><br />So far it only works for some Athlon TB's.</div>
    <div class="meta">Posted on 2002-03-03 10:26:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-26925">
    <div class="subject"><a href="#post-26925">Precise Timing of Small Code:</a></div>
    <div class="body">My routine automatically calculates the overhead, if it is of any help.<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-03-03 10:29:10 by Maverick</div>
   </div>
   <div class="post" id="post-26939">
    <div class="subject"><a href="#post-26939">Precise Timing of Small Code:</a></div>
    <div class="body">Thanks for the code <strong>Maverick</strong> and <strong>E?in</strong> - I was hoping to get some feedback on the methods others were using.  I like <strong>vkim</strong>'s debug window, so I thought it'd be cool to write a timing layer in macros.<br /><br />Here is another version that insures the prep code is in the instruction cache - this doesn't seem to be required of Athlon TB's. :)  Also, I clear EAX before CPUID.</div>
    <div class="meta">Posted on 2002-03-03 12:31:20 by bitRAKE</div>
   </div>
   <div class="post" id="post-26996">
    <div class="subject"><a href="#post-26996">Precise Timing of Small Code:</a></div>
    <div class="body">BiTRAKE,<br /><br />I would be interested to see if the variations that occur in ring3 are handled when performing timings on small sections of code on a one pass basis.<br /><br />I worked with a number of techniques over time, RDTSC, API timing functions etc .... but they all suffered the same percentage variation due to ring3 suffering priority problems from the OS.<br /><br />I ended up using large samples to get the duration up so that this variation was reduced to 1% or lower.<br /><br />I will be interested to see what the results are with this method.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-03 15:08:10 by hutch--</div>
   </div>
   <div class="post" id="post-27060">
    <div class="subject"><a href="#post-27060">Precise Timing of Small Code:</a></div>
    <div class="body">Eagle's Eye View:<br /><br />OFFTOPIC - Aha!!! so this is the reason why your asking on how to clear the cache. :)</div>
    <div class="meta">Posted on 2002-03-03 19:29:45 by stryker</div>
   </div>
   <div class="post" id="post-27156">
    <div class="subject"><a href="#post-27156">Precise Timing of Small Code:</a></div>
    <div class="body">On my old p166 mmx I consistently get this:<br /><br />OverHead: 57 cycles/byte<br />MyPROC: 1 bytes, 100 loops, 100 cycles<br /><br />I wasn't able to get a single different result! Nice!<br /><br />I'll test it again on my Athlon TB, but I think you said you solved that problem.</div>
    <div class="meta">Posted on 2002-03-04 10:52:37 by Qweerdy</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=3951&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=3951&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="3951" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=3951&amp;page=2">&gt;</a><a href="../?id=3951&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>