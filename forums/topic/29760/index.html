<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>MOVMSKPS Not Working Correctly? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29760" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29760">MOVMSKPS Not Working Correctly?</a></p>
   <div class="post" id="post-210219">
    <div class="subject"><a href="#post-210219">MOVMSKPS Not Working Correctly?</a></div>
    <div class="body">Either MOVMSKPS - Extract Packed Single-Precision Floating-Point Sign Mask - isn&#039;t following the specification correctly, or I am misunderstanding something. When I use it, it reverses the order of the bits that it extracts from the XMM register before putting them in the low order bits of the general purpose register. The Intel manual and every source I can find online says that the order should be preserved and not reversed, as shown in this extraction:<pre><code>DEST[0] ? SRC[31];<br />DEST[1] ? SRC[63];<br />DEST[2] ? SRC[95];<br />DEST[3] ? SRC[127];</code></pre>To illustrate the ordering being reversed that I&#039;m seeing, here is some sample code:<pre><code>section .data&nbsp;  align=16<br />&nbsp; &nbsp; &nbsp;  align&nbsp;  16<br />fzzz&nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; 0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00<br />section .bss<br />section .text<br />&nbsp; &nbsp; &nbsp;  global&nbsp; main<br />main:<br />&nbsp; &nbsp; &nbsp;  movdqa&nbsp; xmm0,<br />&nbsp; &nbsp; &nbsp;  movmskps&nbsp; &nbsp; &nbsp; &nbsp; eax,xmm0<br />&nbsp; &nbsp; &nbsp;  mov&nbsp; &nbsp;  eax,1<br />&nbsp; &nbsp; &nbsp;  mov&nbsp; &nbsp;  ebx,0<br />&nbsp; &nbsp; &nbsp;  int&nbsp; &nbsp;  80h</code></pre>What I use in the terminal in Linux (Ubuntu 9.10) to compile and debug it:<pre><code>nasm -f elf -g -l movmskps.lst movmskps.asm<br />gcc -g -o movmskps.out movmskps.o<br />gdb movmskps.out</code></pre>And the debugger&#039;s output:<pre><code>8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  movdqa&nbsp; xmm0,<br />(gdb) x/16xb &amp;fzzz<br />0x804a020 &lt;fzzz&gt;:&nbsp; &nbsp; &nbsp;  0xff&nbsp; &nbsp; 0xff&nbsp; &nbsp; 0xff&nbsp; &nbsp; 0xff&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00<br />0x804a028:&nbsp; &nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00&nbsp; &nbsp; 0x00<br />(gdb) next<br />9&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  movmskps&nbsp; &nbsp; &nbsp; &nbsp; eax,xmm0<br />(gdb) print/x $xmm0<br />$1 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0xff, 0xff, 0xff, 0xff, 0x0 &lt;repeats 12 times&gt;},<br />&nbsp; &nbsp; v8_int16 = {0xffff, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0xffffffff, 0x0, 0x0, 0x0},<br />&nbsp; &nbsp; v2_int64 = {0xffffffff, 0x0}, uint128 = 0x000000000000000000000000ffffffff}<br />(gdb) next<br />10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax,1<br />(gdb) print/x $eax<br />$2 = 0x1</code></pre>I&#039;ve done some further testing, and confirmed that the order of the mask bits is consistently reversed before being placed in the general purpose register.<br /><br />I can work with it like this if it continues to and reliably works like this, but I&#039;d like to make sure this is what&#039;s supposed to be happening. I imagine that I am having a little-endian problem in my understanding somewhere, but I&#039;ve more than triple checked, and it really does look like the Intel manual is wrong in this case, or my processor is wrong :shock: (Oh, it&#039;s an Intel Core 2 Duo E8400 Wolfdale).</div>
    <div class="meta">Posted on 2010-01-14 14:12:26 by pgn674</div>
   </div>
   <div class="post" id="post-210220">
    <div class="subject"><a href="#post-210220">Re: MOVMSKPS Not Working Correctly?</a></div>
    <div class="body">Endian &quot;changes&quot; on the x86 tend to happen when transferring data between memory and registers, so I would look closer at what <strong>movdqa</strong> is really doing.<br /><br />In fact, within the following...<br /><br /><div class="quote"><br />(gdb) print/x $xmm0<br />$1 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0xff, 0xff, 0xff, 0xff, 0x0 &lt;repeats 12 times&gt;},<br />&nbsp; &nbsp; v8_int16 = {0xffff, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0xffffffff, 0x0, 0x0, 0x0},<br />&nbsp; &nbsp; v2_int64 = {0xffffffff, 0x0}, uint128 = 0x000000000000000000000000ffffffff}<br /></div><br /><br /><strong>uint128</strong> would suggest that <strong>movdqa</strong> is indeed reversing the byte order, and this sounds consistent for memory/register data transfer operations on the x86, especially since you are using successive <strong>db</strong>&#039;s instead of something like <strong>do</strong>.</div>
    <div class="meta">Posted on 2010-01-14 15:56:27 by SpooK</div>
   </div>
   <div class="post" id="post-210221">
    <div class="subject"><a href="#post-210221">Re: MOVMSKPS Not Working Correctly?</a></div>
    <div class="body">I was considering that too, but look at what v16_int8 shows. Seeing that, I was thinking that when GDB does a print for an XMM register, it might format the appearance of uint128 to match as it would appear if you placed it back in memory, due to little-endianness. I might be wrong there, though.<br /><br />I&#039;ll try some more tests to see if I can figure out the exact operation and endianness of MOVDQA when I get back to my machine. If it really is little-endian and I&#039;ve been reading GDB&#039;s &quot;print/x $xmm0&quot; incorrectly all this time, then I have to question how on earth the rest of my program works.</div>
    <div class="meta">Posted on 2010-01-14 16:14:39 by pgn674</div>
   </div>
   <div class="post" id="post-210222">
    <div class="subject"><a href="#post-210222">Re: MOVMSKPS Not Working Correctly?</a></div>
    <div class="body"><div class="quote"><br />If it really is little-endian and I&#039;ve been reading GDB&#039;s &quot;print/x $xmm0&quot; incorrectly all this time, then I have to question how on earth the rest of my program works.<br /></div><br /><br />Based on examples found <a target="_blank" href="http://sourceware.org/gdb/current/onlinedocs/gdb/Registers.html">here</a> and <a target="_blank" href="http://osdir.com/ml/gdb.patches/2002-10/msg00148.html">here</a>, and the explanation <a target="_blank" href="http://developer.apple.com/hardwaredrivers/ve/sse.html#Translation_LSU_ByteOrdering">here</a>, I would say that this is the case.</div>
    <div class="meta">Posted on 2010-01-14 16:49:55 by SpooK</div>
   </div>
   <div class="post" id="post-210226">
    <div class="subject"><a href="#post-210226">Re: MOVMSKPS Not Working Correctly?</a></div>
    <div class="body">But in the end it&#039;s just PEBKAC happens to the best of us (so I&#039;ve been told :D).<br />I prefer good old fashioned  statements everywhere for debugging.<br /><br /><pre><code><br />jmp start<br />align 16<br />make0001&nbsp; dd -1.0, 0.0, 0.0, 0.0 ;; -1.0 is loaded into XMM0[0-31]<br />make1000&nbsp; dd 0.0, 0.0, 0.0, -1.0 ;; -1.0 is loaded into XMM0[96-127]<br />start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; MOVDQA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmm0, dqword<br />&nbsp; &nbsp; &nbsp; &nbsp; MOVMSKPS&nbsp; &nbsp; &nbsp; &nbsp; eax, xmm0<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; szFormat<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;; &quot;1&quot; will be printed<br />&nbsp; &nbsp; &nbsp; &nbsp; MOVDQA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmm0, dqword<br />&nbsp; &nbsp; &nbsp; &nbsp; MOVMSKPS&nbsp; &nbsp; &nbsp; &nbsp; eax, xmm0<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; szFormat<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;; &quot;8&quot; will be printed<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _pause<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br /></code></pre></div>
    <div class="meta">Posted on 2010-01-15 12:29:55 by r22</div>
   </div>
   <div class="post" id="post-210472">
    <div class="subject"><a href="#post-210472">Re: MOVMSKPS Not Working Correctly?</a></div>
    <div class="body">OK, I did a bit of testing, and I was indeed reading the debugger&#039;s output incorrectly. Instead of looking at &quot;print/x $xmm0&quot;&#039;s v16_int8, I should have been looking at its uint128. Also, little endian does take place for XMM registers. I&#039;ll probably have to watch out for whether the little-endianess is reversing the order for all 16 bytes as one chunk, or for smaller chunks, depending on what kind of data the instruction I&#039;m using thinks it&#039;s dealing with.<br /><br />To help me test, I used MOVLPD (Move Low Packed Double-Precision Floating-Point Value) and PEXTRB (Extract Byte). I learned that the low order bytes are on the right side of what uint128 shows, and that an offset starts from the right side of what uint128 shows. I&#039;m all good now; thank you for your help.</div>
    <div class="meta">Posted on 2010-01-29 01:16:12 by pgn674</div>
   </div>
  </div>
 </body>
</html>