<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>GetPixel alternatives anyone? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17462" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17462">GetPixel alternatives anyone?</a></p>
   <div class="post" id="post-135197">
    <div class="subject"><a href="#post-135197">GetPixel alternatives anyone?</a></div>
    <div class="body">Hi, I'm writing code that unfortunately has to use a GetPixel call to check the color of every pixel on a fairly large 600x600 bitmap. The inner loop is fairly optimized but the big time spender is the call to GetPixel. I've seen many people using it, but I was wondering if there was code available or if someone has written an 'optimized' alternative? I'm sure others will be interested in it, and I've searched the board with no luck!<br /><br />Thanx in advance!</div>
    <div class="meta">Posted on 2004-03-03 12:44:31 by SubEvil</div>
   </div>
   <div class="post" id="post-135200">
    <div class="subject"><a href="#post-135200">GetPixel alternatives anyone?</a></div>
    <div class="body">GetPixel and SetPixel are both very slow when you need max speed. What I use in such cases is CreateDIBSection which will return the memory address for the bitmap data. I then have direct memory access to each pixel without having to use the slow APIs. (You will also need other API functions to load your bitmap into that DIB section.)<br /><br />Just remember that, if the biHeight member of the BITMAPINFOHEADER structure is positive, the bitmap will be  a bottom-up DIB and its origin will be the lower left corner when you check each pixel.<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-03-03 14:13:00 by Raymond</div>
   </div>
   <div class="post" id="post-135215">
    <div class="subject"><a href="#post-135215">GetPixel alternatives anyone?</a></div>
    <div class="body">I totally agree with the above - my own GetPixel function (from my CTexture class) is merely a wrapper to allow direct access to the image color data in the context of textures loaded via DirectX.<br />I used IDirect3DTexture8_LockRect to obtain the same result as CreateDIBSection, ie, return a ptr to the image color data.<br />I wonder why the gdi functions are so slow :P</div>
    <div class="meta">Posted on 2004-03-03 22:24:51 by Homer</div>
   </div>
   <div class="post" id="post-135286">
    <div class="subject"><a href="#post-135286">Need help on bug fixing</a></div>
    <div class="body">I deffinately need help on this one! This Proc causes a GPF on procedure exit (ret instruction), all the functions execute with the proper return values except the one listed near the end. I've left my own (untidy) comments, hope it's not too difficult to understand. What the hell am I doing wrong? Is the stack reset properly (should be automatic)? Am I freeing all DC's and Bitmaps and other &quot;objects&quot; correctly? Am I accessing variables and pointers correctly? It works without a GPF, until the last line! But it crashes when code execution passes back to the calling procedure!<br /><br /><br /><pre><code><br />EnterGetPixel PROTO &#58;DWORD<br /><br />BITMAPINFOEX STRUCT<br />  BMI BITMAPINFO &lt;&gt;<br />  pDIB DD 0 ;; Address of Bitmap bits allocated by CreateDIBSection and later used by GetDIBits<br />  hBM DD 0 ;; Handle to newly created Bitmap, returned by CreateDIBSection, needs to be freed later!<br />BITMAPINFOEX ENDS<br /><br />EnterGetPixel PROC hDC &#58;DWORD ;; DC with a BMP used to make a replica that NewGetPixel will be called upon!<br />  LOCAL Alloc &#58;DWORD ;; Pointer to a BitmapInfoEx structure, allocated on Heap and becomes the return address.<br />  LOCAL tmpDC &#58;DWORD ;; A temporary DC compatible with hDC<br />  LOCAL tmpBM &#58;DWORD ;; Stock object initially assigned to tmpDC<br />  LOCAL hBM   &#58;DWORD ;; Handle to the currently selected object in hDC<br />  LOCAL BM    &#58;BITMAP<br /><br />  call GetProcessHeap<br />  INVOKE HeapAlloc, eax, HEAP_GENERATE_EXCEPTIONS or HEAP_ZERO_MEMORY, SIZEOF&#40;BITMAPINFOEX&#41; ;; We need the BITMAPINFO structure in NewGetPixel to get the Height for subtraction<br />  mov Alloc, eax ;; Alloc will store our BITMAPINFOEX structure<br /><br />  INVOKE CreateCompatibleDC, hDC<br />  mov tmpDC, eax<br /><br />  INVOKE GetCurrentObject, hDC, OBJ_BITMAP<br />  mov hBM, eax<br /><br />;  mov hBM, mCall&#40;SelectObject, hDC, hbmBackground&#41;<br /><br />  INVOKE GetObject, hBM, SIZEOF&#40;BITMAP&#41;, ADDR BM<br />  mov &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biSize, SIZEOF&#40;BITMAPINFO&#41;<br />  m2m &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biWidth, BM.bmWidth<br />  m2m &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biHeight, BM.bmHeight<br />  m2m &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biPlanes, BM.bmPlanes ;; Must be set to 1<br />  m2m &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biBitCount, BM.bmBitsPixel ;; Should be 32!<br />  mov &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biCompression, BI_RGB<br />  ;; The remaining structure members are cleared in the call to HeapAlloc<br />;  mov &#40;BITMAPINFO PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biSizeImage, NULL ;; Must be set to 0 for BI_RGB<br />;  mov &#40;BITMAPINFO PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biXPelsPerMeter, NULL<br />;  mov &#40;BITMAPINFO PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biYPelsPerMeter, NULL<br />;  mov &#40;BITMAPINFO PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biClrUsed, NULL<br />;  mov &#40;BITMAPINFO PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biClrImportant, NULL<br /><br />  ;;mov &#40;BITMAPINFO PTR &#91;Alloc&#93;&#41;.BMI.bmiColors, 0 ;; No need to clear the RGB colors array, done in call to HeapAlloc!<br /><br />  INVOKE CreateDIBSection, tmpDC, ADDR &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI, DIB_RGB_COLORS, ADDR &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.pDIB, NULL, NULL<br />  mov &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.hBM, eax<br /><br />  INVOKE SelectObject, tmpDC, &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.hBM<br />  mov tmpBM, eax<br />  INVOKE SelectObject, hDC, eax ;; eax is the return value from the above SelectObject<br />  ;; Because SelectObject returns the previously held object in the DC, we use the hDC as a temporary storage for<br />  ;; the old object in tmpDC, we need to remove hBM from hDC because hBM must not be in a DC when we call GetDIBits<br />  ;; And since we already have the handle to the bitmap in hDC, which is hBM, we don't need to store the return value<br />  ;; of the second call to SelectObject<br /><br />  INVOKE GetDIBits, tmpDC, hBM, 0, &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI.bmiHeader.biHeight, &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.pDIB, ADDR &#40;BITMAPINFOEX PTR &#91;Alloc&#93;&#41;.BMI, NULL ;; The bitmap identified by the hbmp parameter must not be selected into a device context when the application calls this function.<br /><br />  INVOKE SelectObject, hDC, hBM ;; Seems to be failing as it returns a value of 0<br />  INVOKE SelectObject, tmpDC, tmpBM<br /><br />  INVOKE DeleteDC, tmpDC<br /><br />  mov eax, Alloc<br />  ret<br />EnterGetPixel ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-06 14:12:28 by SubEvil</div>
   </div>
   <div class="post" id="post-135288">
    <div class="subject"><a href="#post-135288">GetPixel alternatives anyone?</a></div>
    <div class="body">Raymond, do you think you could send me a code snipet of yours demonstrating your use of CreateDIBSection (and especially the other API's you mentioned!) I'm pretty sure you're talking about GetDIBits here, but I'd really appreciate to see someone else's implementation!<br /><br />Regards</div>
    <div class="meta">Posted on 2004-03-06 14:50:18 by SubEvil</div>
   </div>
   <div class="post" id="post-135294">
    <div class="subject"><a href="#post-135294">GetPixel alternatives anyone?</a></div>
    <div class="body">Any code would depend on numerous factors such as:<br />- Has the bitmap been modified by the user or is it simply a static bitmap on file (most unclear from your original post).<br />- If it is after some modification by the user, what would be the extent of it and how is it controlled.<br />- What is the intent of checking the color of every pixel.<br /><br />Answers to the above would probably raise other questions. Every program usually has a specific purpose which often guides on how it should be developed.<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-03-06 23:39:22 by Raymond</div>
   </div>
   <div class="post" id="post-135295">
    <div class="subject"><a href="#post-135295">GetPixel alternatives anyone?</a></div>
    <div class="body">Hi Raymond, thanks in advance for your interest! The code I'm developing, is VERY similar to MOB's form reshaping code except that I use MASM HL syntax, but the algorithm is functionally the same. Using a bitmap mask (usually a mono bitmap), it determines the regions of a form by checking every pixel of your Mask bitmap. No data in the Mask bitmap needs to be changed, so I only need a fast GetPixel, because it's damn slow and it needs to check every pixel of the Mask bitmap for the transparency color (white) to determine the new shape of the form/window. Other functions of this process of changing the region of the window are also slower, but GetPixel is called so many times that it contributes greatly to the overall speed of the process. <br /><br />My idea was, in regards to the above code sample, to &quot;initialize&quot; this bitmap, by copying the necessary BITMAPINFO header, and RGB color bits into a buffer (Check my BITMAPINFOEX Structure), making each call to GetPixel much faster. So instead of providing GetPixel with a DC, do everything for GetPixel, upto the point where it needs to check the specific color of a specific pixel, leaving that to each individual call to GetPixel.<br /><br />I'd like to ask if my above program flow is correct: to initialize a new bitmap (CreateDIBSection), and copy the color data (32 bit longs with GetDIBits) into a buffer provided by CreateDIBSection. Is there a faster way of doing this? Can a person access the per pixel color data of a Bitmap directly from the DC? Also note, that I'm going to change from a Mono Mask Bitmap, to the bitmap I use to draw on the form, because after reshaping the form, I'll Bitblt a 24-bit color bitmap onto it. I'm going to use this bitmap as the mask bitmap as well, so I can pull RGB values directly from it, speading the call to GetPixel up.<br /><br />So, in conclusion, all I need is a fast way to determine the shape of a new form, by checking the pixels on a form, and thereby changing the region data of that form.<br /><br />Hope you understood my poor explinations.<br /><br />Thanx again!</div>
    <div class="meta">Posted on 2004-03-07 00:28:45 by SubEvil</div>
   </div>
   <div class="post" id="post-135314">
    <div class="subject"><a href="#post-135314">GetPixel alternatives anyone?</a></div>
    <div class="body"><div class="quote"><br />I wonder why the gdi functions are so slow :P<br /></div><br />Color conversion etc (taking gamma and other shit into account). GDI batching, transitions to kernel, etc. Anything using Get/PutPixel is doomed to be slow anyway, graphics routines (GDI or not) should work on large objects...</div>
    <div class="meta">Posted on 2004-03-07 15:19:16 by f0dder</div>
   </div>
   <div class="post" id="post-135318">
    <div class="subject"><a href="#post-135318">GetPixel alternatives anyone?</a></div>
    <div class="body">SubEvil<br /><br />The following is not tested but you may want to consider it if your bitmap is dynamic. It is assumed that the original bitmap would have 32-bit colors so that you don't have to load a color table.<br /><br />After you load the bitmap, use GetDIBits with the lpvBits member set to 0. This would fill a BITMAPINFO struc based on that bitmap.<br /><br />Then use CreateDIBSection using the above BITMAPINFO struc. This will return the address of the bit values into a memory variable.<br /><br />Use GetDIBits again but with the lpvBits member set to that address. <br />This should transfer the bitmap data to the DIB section. You can then create a compatible DC and select that DIB section into it.<br /><br />The DIB section is then available for direct modification and direct retrieval of data without using the slow SetPixel or GetPixel functions. You only have to use the BitBlt function to transfer new data to the screen.<br /><br />If that works, remember that the bit data would be bottom-up if the bitmap height is positive.<br /><br />Hope this helps.<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-03-07 15:32:23 by Raymond</div>
   </div>
  </div>
 </body>
</html>