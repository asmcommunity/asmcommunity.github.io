<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Write a CPU with assembly or C - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16002" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16002">Write a CPU with assembly or C</a></p>
   <div class="post" id="post-124037">
    <div class="subject"><a href="#post-124037">Write a CPU with assembly or C</a></div>
    <div class="body">Try my ProEmulator. It's powerful yet free. You can even write a CPU for it (in the form of a DLL, using asm or C, more like a plug-in) . I use win32 assembly to write the 8051 CPU core. It's under busy development. So try it and give me some suggestions.<br /><br /><a target="_blank" href="http://member.netease.com/~huangyc/chip/">http://member.netease.com/~huangyc/chip/</a></div>
    <div class="meta">Posted on 2003-11-11 09:08:29 by optimus</div>
   </div>
   <div class="post" id="post-124225">
    <div class="subject"><a href="#post-124225">Need a CPU emulator?</a></div>
    <div class="body">This is a sample 8-bit CPU core written in C, which can be implemented in ProEmulator.<br /><br /><pre><code>#include &lt;windows.h&gt;<br /><br />#define CPU_ID			1500<br />#define CPU_Name		&quot;Sample CPU Core&quot;<br />#define PC_After_Reset	0<br />#define CodeMemSize		256			/* size of code memory in bytes */<br />#define DataMemSize		256			/* size of data memory in bytes */<br />#define SFR_Count		5			/* number of Special Function Registers */<br />#define REG_Count		4			/* number of registers */<br />#define REG_Bank		1			/* number of register banks */<br />#define PSW_Bits		8			/* number of PSW bits */<br />#define Code_Bits		8			/* 8 bit, 16 bit etc. */<br />#define Data_Bits		8<br /><br />#define REG_Names		&quot;B0&quot;<br />#define SFR_Names		&quot;PC  PSW ACC SP  B   &quot;<br />#define PSW_Names		&quot;CY  AC  F1  S1  S0  OV  F0  P   &quot;<br /><br />#define API_Init		0<br />#define API_StepRun		1<br />#define API_RunRealtime	2<br />#define API_StartRun	3<br />#define API_StopRun		4<br />#define API_GetMem		5<br />#define API_SetMem		6<br />#define API_DumpMemory	7<br />#define API_FlushMemory	8<br />#define API_GetBit		9<br />#define API_SetBit		10<br />#define API_SetMapping	11<br />#define API_GetReg		12<br />#define API_SetReg		13<br />#define API_GetCPUInfo	14<br />#define API_SetHiLiteWord 15<br />#define API_GetSFR		16<br />#define API_SetSFR		17<br />#define API_ResetSystem	18<br /><br />#define SFR_PC	0<br />#define SFR_PSW	1<br />#define SFR_ACC	2<br />#define SFR_SP	3<br />#define SFR_B	4<br /><br />#define PC SFR&#91;SFR_PC&#93;<br />#define ACC SFR&#91;SFR_ACC&#93;<br />#define SP SFR&#91;SFR_SP&#93;<br />#define PSW SFR&#91;SFR_PSW&#93;<br />#define NEXTCODE CodeMem&#91;PC++&#93;<br /><br />#define REM_SETHILITEWORDS 0x400+1000<br /><br />typedef struct MEMOP_STRUCT&#123;<br />	    long MemType;<br />    	long lpData;<br />    	long lpHexData;<br />    	long StartAddr;<br />    	long NumOfBytes;<br />    	long lpCallBack;<br />&#125;MEMOP;<br /><br />BYTE CodeMem&#91;CodeMemSize-1&#93;;		/* Code memory space */<br />BYTE DataMem&#91;DataMemSize-1&#93;;		/* Data memory space */<br />BYTE SFR&#91;SFR_Count-1&#93;;				/* SFR space */<br />BYTE REG&#91;REG_Count-1&#93;;				/* Register space */<br /><br />BOOL WINAPI __declspec&#40;dllexport&#41; LibMain&#40;HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved&#41;<br />&#123;<br />    switch &#40;fdwReason&#41;<br />    &#123;<br />        case DLL_PROCESS_ATTACH&#58;<br />            break;<br />        case DLL_PROCESS_DETACH&#58;<br />            break;<br />    &#125;<br />    return TRUE;<br />&#125;<br /><br />long StartRun&#40;&#41;	&#123;return&#40;0&#41;;&#125;<br />long StopRun&#40;&#41;	&#123;return&#40;0&#41;;&#125;<br />long RunRealtime&#40;&#41;	&#123;return&#40;0&#41;;&#125;<br />long GetBit&#40;&#41;	&#123;return&#40;0&#41;;&#125;<br />long SetBit&#40;&#41;	&#123;return&#40;0&#41;;&#125;<br /><br /><br />long ResetSystem &#40;&#41;<br />&#123;<br />	PC=PC_After_Reset;	/* Initializing PC */<br />	ACC=0;<br />	SP=7;				/* Initializing stack pointer */<br />	PSW=0;<br />	return&#40;1&#41;;<br />&#125;<br /><br />long Init&#40;long CPUFreq&#41;		/* CPUFreq is the detected host CPU frequency */<br />&#123;<br />	return&#40;ResetSystem&#40;&#41;&#41;;	/* Nothing really to initialize for this simple CPU */<br />&#125;<br /><br />long GetCPUInfo &#40;long InfoType,DWORD lpBuf&#41;<br />&#123;<br />	switch &#40;InfoType&#41; &#123;<br />	case 0&#58;<br />		return&#40;CPU_ID&#41;;<br />	case 1&#58;<br />		return&#40;PC_After_Reset&#41;;<br />	case 3&#58;<br />		strcpy&#40;&#40;char *&#41;lpBuf,CPU_Name&#41;;<br />		return&#40;strlen&#40;CPU_Name&#41;&#41;;<br />	case 4&#58;<br />		strcpy&#40;&#40;char *&#41;lpBuf,REG_Names&#41;;<br />		return&#40;REG_Bank&#41;;<br />	case 5&#58;<br />		strcpy&#40;&#40;char *&#41;lpBuf,SFR_Names&#41;;<br />		return&#40;SFR_Count&#41;;<br />	case 6&#58;<br />		strcpy&#40;&#40;char *&#41;lpBuf,PSW_Names&#41;;<br />		return&#40;PSW_Bits&#41;;<br />	case 7&#58;<br />		return&#40;Code_Bits&#41;;<br />	case 8&#58;<br />		return&#40;Data_Bits&#41;;<br />	case 10&#58;<br />		return&#40;CodeMemSize&#41;;<br />	case 11&#58;<br />		return&#40;DataMemSize&#41;;<br />	case 15&#58;<br />		return&#40;SFR_Count&#41;;<br />	case 16&#58;<br />		return&#40;REG_Count&#41;;<br />	case 17&#58;<br />		return&#40;REG_Bank&#41;;<br />	case 20&#58;<br />		return&#40;&#40;long&#41;CodeMem&#41;;<br />	case 21&#58;<br />		return&#40;&#40;long&#41;DataMem&#41;;<br />	case 22&#58;<br />		return&#40;0&#41;;<br />	&#125;<br />	return&#40;-1&#41;;<br />&#125;<br /><br />long GetReg &#40;long RegBank, long RegNo&#41;<br />&#123;<br />	if &#40;RegNo&lt;REG_Count&#41; return&#40;REG&#91;RegNo&#93;&#41;;<br />	return&#40;-1&#41;;<br />&#125;<br /><br />long SetReg &#40;long RegBank, long RegNo, long RegVal&#41;<br />&#123;<br />	if &#40;RegNo&lt;REG_Count&#41; return&#40;REG&#91;RegNo&#93;=&#40;BYTE&#41;RegVal&#41;;<br />	return&#40;-1&#41;;<br />&#125;<br /><br />long GetSFR &#40;long SFRNo&#41;<br />&#123;<br />	if &#40;SFRNo&lt;SFR_Count&#41; return&#40;SFR&#91;SFRNo&#93;&#41;;<br />	return&#40;0&#41;;<br />&#125;<br /><br />long SetSFR &#40;long SFRNo,BYTE SFRVal&#41;<br />&#123;<br />	if &#40;SFRNo&lt;SFR_Count&#41; return&#40;SFR&#91;SFRNo&#93;=SFRVal&#41;;<br />	return&#40;-1&#41;;<br />&#125;<br /><br />long GetMem &#40;long MemType,long MemAddr&#41;<br />&#123;<br />	switch &#40;MemType&#41;&#123;<br />	case 0&#58;			/* addressing code memory */<br />		if &#40;MemAddr&lt;CodeMemSize&#41; return&#40;CodeMem&#91;MemAddr&#93;&#41;;<br />		break;<br />	case 1&#58;			/* addressing data memory */<br />		if &#40;MemAddr&lt;DataMemSize&#41; return&#40;DataMem&#91;MemAddr&#93;&#41;;<br />		break;<br />	&#125;<br />	return&#40;-1&#41;;<br />&#125;<br /><br />long SetMem &#40;long MemType,long MemAddr,BYTE MemData&#41;<br />&#123;<br />	switch &#40;MemType&#41;&#123;<br />	case 0&#58;			/* addressing code memory */<br />		if &#40;MemAddr&lt;CodeMemSize&#41; return&#40;CodeMem&#91;MemAddr&#93;=MemData&#41;;<br />		break;<br />	case 1&#58;			/* addressing data memory */<br />		if &#40;MemAddr&lt;DataMemSize&#41; return&#40;DataMem&#91;MemAddr&#93;=MemData&#41;;<br />		break;<br />	&#125;<br />	return&#40;-1&#41;;<br />&#125;<br /><br />long DumpMemory &#40;MEMOP *lpMemOp&#41;<br />&#123;<br />	switch &#40;lpMemOp-&gt;MemType&#41;&#123;<br />	case 0&#58;			/* addressing code memory */<br />		RtlMoveMemory&#40;&#40;void*&#41;lpMemOp-&gt;lpData,CodeMem,lpMemOp-&gt;NumOfBytes&#41;;<br />		break;<br />	case 1&#58;			/* addressing data memory */<br />		RtlMoveMemory&#40;&#40;void*&#41;lpMemOp-&gt;lpData,DataMem,lpMemOp-&gt;NumOfBytes&#41;;<br />		break;<br />	default&#58;<br />		lpMemOp-&gt;NumOfBytes=-1;		/* no other memory type */<br />		break;<br />	&#125;<br />	return&#40;lpMemOp-&gt;NumOfBytes&#41;;<br />&#125;<br /><br />long FlushMemory &#40;MEMOP *lpMemOp&#41;<br />&#123;<br />	switch &#40;lpMemOp-&gt;MemType&#41;&#123;<br />	case 0&#58;			/* addressing code memory */<br />		RtlMoveMemory&#40;CodeMem,&#40;void*&#41;lpMemOp-&gt;lpData,lpMemOp-&gt;NumOfBytes&#41;;<br />		break;<br />	case 1&#58;			/* addressing data memory */<br />		RtlMoveMemory&#40;DataMem,&#40;void*&#41;lpMemOp-&gt;lpData,lpMemOp-&gt;NumOfBytes&#41;;<br />		break;<br />	default&#58;<br />		lpMemOp-&gt;NumOfBytes=-1;		/* no other memory type */<br />		break;<br />	&#125;<br />	return&#40;lpMemOp-&gt;NumOfBytes&#41;;<br />&#125;<br /><br />long SetHiliteWords&#40;long hRed&#41;<br />&#123;<br />		/* This routine sets the highlighted keywords in code editor */<br />		char *szRegs=&quot;PC ACC SP PSW B&quot;;<br />		char *szInst=&quot;MOV ADD INC NOP DEC SUB JMP&quot;;<br />		char *szAsm=&quot;&quot;;<br /><br />		SendMessage&#40;&#40;HWND&#41;hRed,REM_SETHILITEWORDS,0x0A00000,&#40;long&#41;szRegs&#41;;<br />		SendMessage&#40;&#40;HWND&#41;hRed,REM_SETHILITEWORDS,0x40A000,&#40;long&#41;szInst&#41;;<br />		SendMessage&#40;&#40;HWND&#41;hRed,REM_SETHILITEWORDS,0x4040A0,&#40;long&#41;szAsm&#41;;<br />		return&#40;1&#41;;<br />&#125;<br /><br />void OP_NOP&#40;&#41;			&#123;&#125;							/* NOP */<br />void OP_MOV_ACC_Data&#40;&#41;	&#123;ACC=NEXTCODE;&#125;				/* MOV ACC,Data */<br />void OP_MOV_ACC_Mem&#40;&#41;	&#123;ACC=DataMem&#91;NEXTCODE&#93;;&#125;	/* MOV ACC,Mem */<br />void OP_MOV_Mem_ACC&#40;&#41;	&#123;DataMem&#91;NEXTCODE&#93;=ACC;&#125;	/* MOV Mem,ACC */<br />void OP_INC_ACC&#40;&#41;		&#123;ACC++;&#125;					/* INC ACC */<br />void OP_DEC_ACC&#40;&#41;		&#123;ACC--;&#125;					/* DEC ACC */<br />void OP_INC_Mem&#40;&#41;		&#123;DataMem&#91;NEXTCODE&#93;++;&#125;		/* INC Mem */<br />void OP_DEC_Mem&#40;&#41;		&#123;DataMem&#91;NEXTCODE&#93;--;&#125;		/* DEC Mem */<br />void OP_ADD_A_Data&#40;&#41;	&#123;ACC+=NEXTCODE;&#125;			/* ADD A,Data */<br />void OP_ADD_A_Mem&#40;&#41;		&#123;ACC+=DataMem&#91;NEXTCODE&#93;;&#125;	/* ADD A,Mem */<br />void OP_SUB_A_Data&#40;&#41;	&#123;ACC-=NEXTCODE;&#125;			/* SUB A,Data */<br />void OP_SUB_A_Mem&#40;&#41;		&#123;ACC-=DataMem&#91;NEXTCODE&#93;;&#125;	/* SUB A,Mem */<br />void OP_JMP_PC&#40;&#41;		&#123;PC=NEXTCODE;&#125;				/* JMP PC */<br />void OP_PUSH_Mem&#40;&#41;		&#123;DataMem&#91;++SP&#93;=DataMem&#91;NEXTCODE&#93;;&#125;	/* PUSH Mem */<br />void OP_POP_Mem&#40;&#41;		&#123;DataMem&#91;NEXTCODE&#93;=DataMem&#91;SP--&#93;;&#125;	/* POP Mem */<br /><br /><br />void* lpOpProc&#91;15&#93;=&#123;<br />OP_NOP,OP_MOV_ACC_Data,OP_MOV_ACC_Mem,OP_MOV_Mem_ACC,OP_INC_ACC,<br />OP_DEC_ACC,OP_INC_Mem,OP_DEC_Mem,OP_ADD_A_Data,OP_ADD_A_Mem,<br />OP_SUB_A_Data,OP_SUB_A_Mem,OP_JMP_PC,OP_PUSH_Mem,OP_POP_Mem<br />&#125;;<br /><br />long RunOP&#40;long &#40;*f&#41;&#40;&#41;&#41;&#123;<br />  return &#40;*f&#41;&#40;&#41;;<br />&#125;<br /><br /><br />long StepRun &#40;&#41;<br />&#123;<br />	/* This routine emulates the CPU behavior */<br />	BYTE OpCode=NEXTCODE;<br />	if &#40;OpCode&lt;15&#41; RunOP&#40;lpOpProc&#91;OpCode&#93;&#41;;<br />	return&#40;PC&#41;;<br />&#125;<br /><br />__declspec&#40;dllexport&#41; long CallAPI&#40;DWORD API,DWORD arg1,DWORD arg2,DWORD arg3&#41;<br />&#123;<br />	/* This is the only exported function */<br />	switch&#40;API&#41;<br />	&#123;<br />	case API_Init&#58;<br />		return&#40;Init&#40;arg1&#41;&#41;;<br />	case API_StepRun&#58;<br />		return&#40;StepRun&#40;&#41;&#41;;<br />	case API_StartRun&#58;<br />		break;<br />	case API_StopRun&#58;<br />		break;<br />	case API_GetMem&#58;<br />		return&#40;GetMem&#40;arg1,arg2&#41;&#41;;<br />	case API_SetMem&#58;<br />		return&#40;SetMem&#40;arg1,arg2,arg3&#41;&#41;;<br />	case API_GetReg&#58;<br />		return&#40;GetReg&#40;arg1,arg2&#41;&#41;;<br />	case API_SetReg&#58;<br />		return&#40;SetReg&#40;arg1,arg2,arg3&#41;&#41;;<br />	case API_GetCPUInfo&#58;<br />		return&#40;GetCPUInfo&#40;arg1,arg2&#41;&#41;;<br />	case API_SetHiLiteWord&#58;<br />		return&#40;SetHiliteWords&#40;arg1&#41;&#41;;<br />	case API_GetSFR&#58;<br />		return&#40;GetSFR&#40;arg1&#41;&#41;;<br />	case API_SetSFR&#58;<br />		return&#40;SetSFR&#40;arg1,arg2&#41;&#41;;<br />	case API_ResetSystem&#58;<br />		return&#40;ResetSystem&#40;&#41;&#41;;<br />	case API_SetBit&#58;<br />		return&#40;SetBit&#40;&#41;&#41;;<br />	case API_GetBit&#58;<br />		return&#40;GetBit&#40;&#41;&#41;;<br />	case API_DumpMemory&#58;<br />		return&#40;DumpMemory&#40;&#40;MEMOP *&#41;arg1&#41;&#41;;<br />	case API_FlushMemory&#58;<br />		return&#40;FlushMemory&#40;&#40;MEMOP *&#41;arg1&#41;&#41;;<br />	&#125;<br />	return&#40;-1&#41;;<br />&#125;<br /></code></pre><br /><br />The following is the virtual CPU running code in ProEmulator. As u can see the result is correct.<br /><br /><img src="http://member.netease.com/~huangyc/chip/samplecpu.gif" /></div>
    <div class="meta">Posted on 2003-11-12 22:51:40 by optimus</div>
   </div>
   <div class="post" id="post-124496">
    <div class="subject"><a href="#post-124496">x86</a></div>
    <div class="body">Hi Optimus<br /><br />Well most of us here use the x86 IS, so if it were possible could you write one for x86 with 32-bit support. If you do, I would try to use it in our wiki book as a teaching aid. Thanks.<br /><br />Regards,<br />Art</div>
    <div class="meta">Posted on 2003-11-16 05:10:09 by art_sands</div>
   </div>
   <div class="post" id="post-124544">
    <div class="subject"><a href="#post-124544">Re: Write a CPU with assembly or C</a></div>
    <div class="body"><div class="quote"><br />Try my ProEmulator. It's powerful yet free. You can even write a CPU for it (in the form of a DLL, using asm or C, more like a plug-in) . I use win32 assembly to write the 8051 CPU core. It's under busy development. So try it and give me some suggestions.<br /><br /><a target="_blank" href="http://member.netease.com/~huangyc/chip/">http://member.netease.com/~huangyc/chip/</a> </div><br /><br />Nice work optimus, I will play with it :D</div>
    <div class="meta">Posted on 2003-11-16 17:04:51 by x86asm</div>
   </div>
   <div class="post" id="post-124564">
    <div class="subject"><a href="#post-124564">Re: x86</a></div>
    <div class="body">Well I'd like to support x86 IS. But that won't be called emulation running x86 code on a x86, right? Emulating x86 on x86 requires another algorithm for better performance, like what VirtualPC or VMWare do. Usually RISC CPUs are easier to emulate because of their fixed instruction length (e.g. 32 bits). I've been think of emulating x86 16-bit mode, cause we learn that in our college, and that might be useful for debugging 16-bit code in 32-bit os which everybody uses. If anybody familiar with x86 opcodes can write a x86 emulation module, I would very glad.<br /><br />ps: currently ProEmulator only handles 8-bit CPU well. I will improve it soon so that 32-bit CPU can be well emulated.<br /><br /><div class="quote"><br />Hi Optimus<br /><br />Well most of us here use the x86 IS, so if it were possible could you write one for x86 with 32-bit support. If you do, I would try to use it in our wiki book as a teaching aid. Thanks.<br /><br />Regards,<br />Art </div></div>
    <div class="meta">Posted on 2003-11-16 20:31:45 by optimus</div>
   </div>
   <div class="post" id="post-124565">
    <div class="subject"><a href="#post-124565">Need a CPU emulator?</a></div>
    <div class="body">I've updated the CPU code above and placed a screenshot of the CPU written by that code emulated by ProEmulator.</div>
    <div class="meta">Posted on 2003-11-16 20:35:14 by optimus</div>
   </div>
   <div class="post" id="post-124679">
    <div class="subject"><a href="#post-124679">Re: Re: x86</a></div>
    <div class="body"><div class="quote"><br />Well I'd like to support x86 IS. But that won't be called emulation running x86 code on a x86, right? Emulating x86 on x86 requires another algorithm for better performance, like what VirtualPC or VMWare do. Usually RISC CPUs are easier to emulate because of their fixed instruction length (e.g. 32 bits). I've been think of emulating x86 16-bit mode, cause we learn that in our college, and that might be useful for debugging 16-bit code in 32-bit os which everybody uses. If anybody familiar with x86 opcodes can write a x86 emulation module, I would very glad.<br /><br />ps: currently ProEmulator only handles 8-bit CPU well. I will improve it soon so that 32-bit CPU can be well emulated.<br /><br /> </div><br /><br />Actually, it's not that bad. Just turn on the trace bit and let the CPU decode the instruction lengths for you. Then all you've got to do is trap all the addresses and respond accordingly.<br />Not trivial, but not as difficult as you're thinking, either.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-18 11:16:50 by rhyde</div>
   </div>
   <div class="post" id="post-124723">
    <div class="subject"><a href="#post-124723">Need a CPU emulator?</a></div>
    <div class="body">does that work in protected os like windows?</div>
    <div class="meta">Posted on 2003-11-18 19:29:51 by optimus</div>
   </div>
   <div class="post" id="post-125269">
    <div class="subject"><a href="#post-125269">Need a CPU emulator?</a></div>
    <div class="body">A new screenshot of my emulator. Implemented with KetilO's three asm custom controls.<br />btw: the code at top has been updated also.<br /><br /><br /><img src="http://member.netease.com/~huangyc/chip/Screenshot_full.gif" /></div>
    <div class="meta">Posted on 2003-11-24 02:42:46 by optimus</div>
   </div>
  </div>
 </body>
</html>