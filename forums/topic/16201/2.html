<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Extensible ParticleEngine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16201" />
  <link rel="prev" href="../?id=16201&amp;page=1" />  <link rel="next" href="../?id=16201&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=16201">Extensible ParticleEngine</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16201&amp;page=1" style="">&laquo;</a><a href="../?id=16201&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16201" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=16201&amp;page=3">&gt;</a><a href="../?id=16201&amp;page=3">&raquo;</a></form>   <div class="post" id="post-127494">
    <div class="subject"><a href="#post-127494">Extensible ParticleEngine</a></div>
    <div class="body">Afternoon, .<br /><br />That surely is the most weirdest message pump I've seen in a while:tongue: :grin: :alright: .<br /><br />This improves it a little:<br /><pre><code><br />;=====&lt;&lt; CAPP_PROCESS_MESSAGES &gt;&gt;===\<br />CApp_ProcessMessages proc<br />        LOCAL msg &#58;MSG<br />        mov ecx,CApp_OnlyInstance<br /><br />;       // loop until s_bWait is false<br />  ;      .repeat<br />                .if &#91;ecx&#93;.CApp.bWait != TRUE<br />;			// if g_bWait is false do not wait in the loop, so check the<br />;			// existance of messages and processes them if available<br />                        .if $invoke &#40;PeekMessage, addr msg, PM_NOREMOVE, 0, 0, 0 &#41; <br />                                .if !$invoke &#40;GetMessage, addr msg, NULL, 0, 0 &#41;<br />                                        return FALSE<br />                                .else<br />                                        invoke TranslateMessage, addr msg <br />                                        invoke DispatchMessage, addr msg <br />                                .endif<br />                        .endif<br />		<br />                .else<br />;			// if g_bWait is true use GetMessage to return control to the operating system<br />                    .if !$invoke &#40;GetMessage,addr msg, NULL, 0, 0 &#41; <br />                        return FALSE<br />                    .else<br />                        invoke TranslateMessage, addr msg <br />                        invoke DispatchMessage,addr msg <br />                    .endif<br /><br />                .endif<br />                mov ecx,CApp_OnlyInstance<br />;	.until  &#91;ecx&#93;.CApp.bWait == FALSE<br />;	// all messages are processed and no quit message was recieved so return true<br />	return TRUE<br />CApp_ProcessMessages         ENDP<br />;=======/<br /></code></pre><br /><br />However...<br />If you're going to be dispatching any waiting messages in the queue anyway, then you might as well do this:<br /><pre><code><br />;=====&lt;&lt; CAPP_PROCESS_MESSAGES &gt;&gt;===\<br />CApp_ProcessMessages proc<br />LOCAL msg &#58;MSG<br /><br />    invoke  PeekMessage, ADDR msg, NULL, 0, 0, PM_REMOVE<br />    .IF eax != 0<br />        .IF msg.message == WM_QUIT<br />            return FALSE<br />        .ELSE<br />            INVOKE TranslateMessage, ADDR msg<br />            INVOKE DispatchMessage, ADDR msg<br />        .ENDIF<br /><br />    .ENDIF<br /><br />;	// all messages are processed and no quit message was recieved so return true<br />	return TRUE<br />CApp_ProcessMessages         ENDP<br />;=======/<br /></code></pre><br />Which seems to work just the same.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-12 06:29:53 by Scronty</div>
   </div>
   <div class="post" id="post-127496">
    <div class="subject"><a href="#post-127496">Extensible ParticleEngine</a></div>
    <div class="body">Cheers, I merely translated the original from c++, I assumed they knew something I didn't ... lol , again, what you get for not having faith in urself.</div>
    <div class="meta">Posted on 2003-12-12 06:33:43 by Homer</div>
   </div>
   <div class="post" id="post-127620">
    <div class="subject"><a href="#post-127620">Extensible ParticleEngine</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Adjusted the CApp_Run proc so that elapsed time is never zero:<br /><pre><code><br />CApp_Run proc uses ecx<br />        icall CApp_OnlyInstance, CApp, ProcessMessages<br />        .while eax!=FALSE<br />            @@&#58;<br />                mov g_dCurTime      , $invoke &#40;timeGetTime&#41;<br />                fild g_dCurTime<br />                fild g_dLastTime<br />                fcompp<br />                GetFPUFlags<br />                je @B                   ; if no time has elapsed, then just loop back &#40;do nothing&#41;<br />                fild g_dCurTime<br />                fisub g_dLastTime<br />                fmul fp0pt001           ; /1000<br />                fstp g_fElapsedTime     ; &#40;float&#41;&#40;&#40;g_dCurTime - g_dLastTime&#41; * 0.001&#41;;<br />                m2m g_dLastTime    , g_dCurTime<br />                icall CApp_OnlyInstance, CApp, Render<br />                icall CApp_OnlyInstance, CApp, ProcessMessages<br />        .endw<br />        ret<br />CApp_Run endp<br /></code></pre><br /><br />Also:<br />inside demo_render.inc file:<br />render proc:<br />Changed the &quot;fElapsedTime = &quot; text so that it'll display the FPS (updated once per second so that there's no flicker):<br /><pre><code><br />.data<br />    fpFPStime   FLOAT   0.0f<br />    dwFPSinc    dd      0<br />    dwFPS       dd      0<br />.code<br /><br />        add dwFPSinc, 1<br />        fld g_fElapsedTime      ; update the elapsed-time over a second<br />        fadd fpFPStime<br />        fst fpFPStime<br />        fld1<br />        fcompp                  ; see whether it's reached one second<br />        GetFPUFlags<br />        ja @F                   ; still under a second, so don't update text<br />        <br />        fld fpFPStime           ; subtract one &#40;1&#41; second from the counter<br />        fldz<br />        fstp fpFPStime<br /><br />        m2m dwFPS, dwFPSinc<br />        mov dwFPSinc, 0<br /><br />        @@&#58;<br />        invoke wsprintf,addr ErrBuf,CTEXT&#40;&quot;fElapsedTime = %d&quot;&#41;,dwFPS<br />        invoke DrawTextLine ,pFont, addr MyVerticalPosition,addr ErrBuf, -1<br /></code></pre><br /><br />NOTE:<br />I changed the speeling of g_fElpasedTime to g_fElapsedTime ;) .<br />Plus added the GetFPUFlags macro to the MACROS.inc file:<br /><pre><code><br />GetFPUFlags MACRO<br /> fnstsw ax<br /> sahf<br />ENDM<br /></code></pre><br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-12 21:36:13 by Scronty</div>
   </div>
   <div class="post" id="post-127625">
    <div class="subject"><a href="#post-127625">Extensible ParticleEngine</a></div>
    <div class="body">I've implemented the changes posted above.<br />Well that certainly looks nicer, and seems to behave better (messagepump).<br />I certainly appreciate your input :)<br />For some reason now, the ParticleSystem_Update procedure is no longer emitting any new particles, and the #particles active remains at zero :(<br />Considering that activities in Update are based on the ElapsedTime (passed to it in the call made from CApp_Render), there would appear to be an inconsistancy which wasnt there before these changes were implemented...<br />I guess now it's time to go back to the Update proc and try to figure out why it's not behaving itself.. maybe I should skip Update when fElapsed is zero.<br /><br />Also, seems that macro is included in one of the other inc files since I did not need to add it as a macro, and for that matter, I generally use the __FJ?? macros in Caleb's &quot;FKT&quot; include when it comes to floating compares, same thing really.<br /><br />Thanks once more for taking the time to help with some aspects of this code, it seems very few of us are interested in this field of programming, at least in terms of asm, which is a shame. (Scronty was added to the credits as a contributing author)</div>
    <div class="meta">Posted on 2003-12-13 00:26:04 by Homer</div>
   </div>
   <div class="post" id="post-127626">
    <div class="subject"><a href="#post-127626">Extensible ParticleEngine</a></div>
    <div class="body">Latest update for anyone who is interested.</div>
    <div class="meta">Posted on 2003-12-13 00:47:38 by Homer</div>
   </div>
   <div class="post" id="post-127628">
    <div class="subject"><a href="#post-127628">Extensible ParticleEngine</a></div>
    <div class="body">Thanks to Roticv for bringing this small &quot;feature&quot; to my attention.<br />In the CApp_CApp Constructor:<br /><br />invoke ShowWindow,.CApp.hWnd,SW_SHOW<br />mov ecx,me         ;&lt;---- under NT systems, api sometimes alter ecx, sometimes not - be safe :)<br />invoke UpdateWindow,.CApp.hWnd<br />mov eax,CApp_OnlyInstance<br />ret<br /><br />I now refresh value of ecx after call to ShowWindow, in case NT messes up ecx during that call, which only happens SOMETIMES and not ALWAYS, heh.<br />It caused a nasty GPF which was rare but now is fixed.</div>
    <div class="meta">Posted on 2003-12-13 01:23:37 by Homer</div>
   </div>
   <div class="post" id="post-127728">
    <div class="subject"><a href="#post-127728">Extensible ParticleEngine</a></div>
    <div class="body">I've been drinking beer all weekend and haven't had a chance to get to the bottom of the mystery of the missing particles, but I tell you this: when I removed the param fElapsedTime from the procedure ParticleSystem_Update and used the global g_fElapsedTime instead, the particles reappear - magic? The localized fElapsedTime param is the freaking global anyway, passed from the main Render proc, so this is bizarre and indicates stack issues, yet no crash is occuring...</div>
    <div class="meta">Posted on 2003-12-14 05:17:38 by Homer</div>
   </div>
   <div class="post" id="post-127839">
    <div class="subject"><a href="#post-127839">Extensible ParticleEngine</a></div>
    <div class="body">Today I implemented the &quot;nice&quot; method of calculating the random vector used for the direction and speed of particles...so here's another update :)</div>
    <div class="meta">Posted on 2003-12-15 07:09:28 by Homer</div>
   </div>
   <div class="post" id="post-127845">
    <div class="subject"><a href="#post-127845">Extensible ParticleEngine</a></div>
    <div class="body">Just added visual confirmation of the current particlesystem's fVelocityVar value, which is multiplied by the random vector (direction) of individual particles to give them the same velocity but different directions.<br />I'll wait until tomorrow to repost, kinda tired.</div>
    <div class="meta">Posted on 2003-12-15 07:33:37 by Homer</div>
   </div>
   <div class="post" id="post-127959">
    <div class="subject"><a href="#post-127959">Extensible ParticleEngine</a></div>
    <div class="body">Let's make a closer examination of the code used to update the position of particles over time, because something is horribly wrong :(<br /><br />Here is the current update of my source for this procedure, whittled down to only show the relevant code section...<br />Please assume that the vectors for Gravity and Wind are zero, because that's the case for the default ParticleSystem.<br />This means we can effectively skip down to the code following the comment &quot; Finally, update position with respect to velocity&quot;.<br />Now bear in mind that all particles have an initial Position value equal to that of their owner ParticleSystem (the Emitter), likewise for Velocity.<br />In the case of the default ParticleSystem, Velocity = 10.0f<br />So what could be wrong with this code?<br /><br /><br /><br />;========================================================<br />;Last Updated December 16, 2003, by Homer<br />;I've placed two parts of this three-part procedure in separate includes, so that<br />;the Reader (you) can concentrate on the most important code - updating Particles Positions over Time.<br />;========================================================<br />ParticleSystem_Update proc<br />local me:DWORD<br />local pParticle:ptr Particle<br />local ppParticle:ptr LPPARTICLE<br />local pPlane:ptr Plane<br />local ppPlane:ptr LPPLANE<br />local vOldPosition,Vn,Vp,Vt,temp:D3DXVECTOR3 <br />local Kr:FLOAT<br />local countie:DWORD<br /><br />        .if g_fElapsedTime==0                   ;if no time has passed (which seems improbable but it happens..)<br />                ret                                           ;simply get the hell out of here because everything is timebased<br />        .endif                                              ;and no time means no difference, so why waste our cycles?<br /><br />        mov me,ecx<br />        fld g_fElapsedTime    <br />        fadd .ParticleSystem.m_fCurrentTime<br />        fstp .ParticleSystem.m_fCurrentTime        ;     // Update our particle system timer...<br />        mov eax,.ParticleSystem.m_pActiveList<br />        mov ppParticle , eax; // Start at the head of the active list<br /><br />        .while ppParticle != NULL    <br />            mov ecx,me<br />            m2m pParticle , dword ptr ppParticle             ;     // Set a pointer to the head<br />    ;        // Calculate new position<br />            mov esi,pParticle<br />            fld .ParticleSystem.m_fCurrentTime<br />            fsub .Particle.m_fInitTime<br />            fstp .ParticleSystem.fTimePassed<br />    <br />            mov eax,.ParticleSystem.fTimePassed<br />            .if eax &gt;= .ParticleSystem.m_fLifeCycle         <br />    ;            // Time is up, put the particle back on the free list...<br />                mov esi,pParticle<br />                m2m ppParticle , .Particle.m_pNext<br />                m2m .Particle.m_pNext , .ParticleSystem.m_pFreeList<br />                m2m .ParticleSystem.m_pFreeList , pParticle<br />                dec .ParticleSystem.m_dwActiveCount<br />            .else        <br />    ;            // Update particle position and velocity<br />                 mov esi,pParticle<br /><br />    ;            // Update velocity with respect to Gravity (Constant Accelaration)<br />    ;           pParticle-&gt;m_vCurVel += m_vGravity * fElpasedTime;<br /><br />                fld g_fElapsedTime<br />                fmul .ParticleSystem.vGravity.x<br />                fadd .Particle.m_vCurVel.x<br />                fstp .Particle.m_vCurVel.x<br />                fld g_fElapsedTime<br />                fmul .ParticleSystem.vGravity.y<br />                fadd .Particle.m_vCurVel.y<br />                fstp  .Particle.m_vCurVel.y<br />                fld g_fElapsedTime<br />                fmul .ParticleSystem.vGravity.z<br />                fadd .Particle.m_vCurVel.z<br />                fstp .Particle.m_vCurVel.z<br /><br />    ;            // Update velocity with respect to Wind (Accelaration based on difference of vectors)<br />                .if .ParticleSystem.bAirResistence == TRUE<br />                    fld .ParticleSystem.vWind.x<br />                    fsub .Particle.m_vCurVel.x<br />                    fmul g_fElapsedTime<br />                    fadd .Particle.m_vCurVel.x<br />                    fstp .Particle.m_vCurVel.x<br />                    fld .ParticleSystem.vWind.y<br />                    fsub .Particle.m_vCurVel.y<br />                    fmul g_fElapsedTime<br />                    fadd .Particle.m_vCurVel.y<br />                    fstp .Particle.m_vCurVel.y<br />                    fld .ParticleSystem.vWind.z<br />                    fsub .Particle.m_vCurVel.z<br />                    fmul g_fElapsedTime<br />                    fadd .Particle.m_vCurVel.z<br />                    fstp .Particle.m_vCurVel.z<br />                .endif<br />    <br />    ;            // Finally, update position with respect to velocity<br />                __LoadFloat3 .Particle.m_vCurPos<br />                __StoreFloat3 vOldPosition<br />                fld .Particle.m_vCurVel.x<br />                fmul g_fElapsedTime<br />                fadd .Particle.m_vCurPos.x<br />                fstp .Particle.m_vCurPos.x<br />                fld .Particle.m_vCurVel.y<br />                fmul g_fElapsedTime<br />                fadd .Particle.m_vCurPos.y<br />                fstp .Particle.m_vCurPos.y<br />                fld .Particle.m_vCurVel.z<br />                fmul g_fElapsedTime<br />                fadd .Particle.m_vCurPos.z<br />                fstp .Particle.m_vCurPos.z<br /><br />;========================================================<br />include Planes_Collisions_Snippet.inc   ; 'inner loop' to check each particle against all 'Planes'<br />;========================================================<br /><br />            .endif<br />            mov esi,pParticle<br />            m2m ppParticle ,.Particle.m_pNext<br />        .endw<br />@@:<br />;========================================================<br />include Emit_Particles_Snippet.inc         ; not part of any Loop, this is always executed (unconditional)<br />@@:<br />;========================================================<br />    return S_OK<br />ParticleSystem_Update endp</div>
    <div class="meta">Posted on 2003-12-15 21:56:09 by Homer</div>
   </div>
   <div class="post" id="post-127988">
    <div class="subject"><a href="#post-127988">Extensible ParticleEngine</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Ummmm....<br />Excuse moi, n00b...<br /><br />but why isn't <strong>ESI</strong> being restored?:grin: <br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-16 05:39:58 by Scronty</div>
   </div>
   <div class="post" id="post-127990">
    <div class="subject"><a href="#post-127990">Extensible ParticleEngine</a></div>
    <div class="body">Huh? Excuse moi ignorance, but where is it NOT being restored? Did I post something incomplete? I edited this just before I posted ...<br />Man , now I have to stare at it again thru beer goggles, I hate that :(<br />I bet ur right too, and I'll kick myself if and when I spot it lol, maybe I should wait until I sober up .. :tongue: damn its hot here !! :grin:<br />As for the n00b thing, I'll let that slide since I am relatively new to x86, having avoided it for the past two decades...<br /><br /><br />Nope, beer goggles don't note any issue with esi not being restored in that code, unless u mean like at the end of the proc, which is not necessary.<br />All the same, I have respect for ur eagle eye and ur experience in this gear and I'll look again with my superb 20/20 hindsight and check in the morning, thanks for ur input, always appreciated.<br /></div>
    <div class="meta">Posted on 2003-12-16 06:08:29 by Homer</div>
   </div>
   <div class="post" id="post-128242">
    <div class="subject"><a href="#post-128242">Extensible ParticleEngine</a></div>
    <div class="body">Janis Joplin was absolutely correct - it IS all the same day, man.<br /><br />Here's an update with 100% working camera controls<br />(use mouse with leftbutton to rotate, cursor arrows to move around)<br /><br />ParticleUpdate is 99% working, will crash when you try to close down.<br />Key &quot;1&quot; to change active system.<br />No guarantees are made about anything but the default particlesystem.<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2003-12-17 23:43:34 by Homer</div>
   </div>
   <div class="post" id="post-128255">
    <div class="subject"><a href="#post-128255">Extensible ParticleEngine</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />In your last code posting on the previous page of this thread (ParticleSystem_Update proc):<br /><br />Scroll down until you get to:<br /><pre><code>; // Calculate new position</code></pre><br /><br />Immediately after that comment, you've got:<br /><pre><code>mov esi,pParticle</code></pre><br /><br />Now correct me if I'm wrong.... but you never <strong>push esi</strong>...<strong>pop esi</strong> within that proc anywhere. Nor have you got:<br /><pre><code>ParticleSystem_Update proc uses esi</code></pre><br />... which <strong>would</strong> allow you to get away with pushing/popping esi.<br /><br />All of us n00bs forget to restore esi/edi/ebx every now-and-then:grin: .<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-18 03:56:49 by Scronty</div>
   </div>
   <div class="post" id="post-128260">
    <div class="subject"><a href="#post-128260">Extensible ParticleEngine</a></div>
    <div class="body">True that Scronty, but I wasn't concerned about preserving the esi register. I tend to use it as a general purpose register and since NO API CALLS are made from within this procedure, there's little reason to want to preserve it. I know that's not &quot;the right way to do things&quot;, but I see little reason in this case.<br />Anyway, I managed to sort out the issues in the Update procedure, and here's a new post which is rock solid compared to the last one :tongue:<br /><br />The LinkedList Management works as follows:<br />We have an ActiveList, and we have a FreeList.<br />The FreeList is used to hold particles which have expired but are yet to be recycled.<br />Recycling of course happens in the EmitParticles section of code in the same proc.<br />When a particle expires, it gets removed from the ActiveList and chucked on the FreeList. In order to achieve this, we first determine if the expired particle is the current Head of the ActiveList (first node). If it is, we simply make the Next one the new Head. If not, we patch around it, from the Previous to the Next. Either way, we then attach the FreeList to the expired particle, and make it the new Head of the FreeList.<br />Just out of curiosity, why are you so pedantic about ESI?<br />Also, how can I get the cpu time down, now I'm using your simplified MessagePump, the cpu usage has shot to hell.<br />The Camera View code works nicely, I modified it to limit motion in Y for the purposes of this demo.</div>
    <div class="meta">Posted on 2003-12-18 06:03:44 by Homer</div>
   </div>
   <div class="post" id="post-128265">
    <div class="subject"><a href="#post-128265">Extensible ParticleEngine</a></div>
    <div class="body">... and here's another one with (finally!) the Textures of particles working. Also, Wind is working (&quot;air resistance&quot;)<br />YAYYYYYY :alright:<br />Only issue to fix now is the color, which is easy, but I'm tired now so too bad :tongue: oh yeah and also Planar collisions...<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2003-12-18 07:28:03 by Homer</div>
   </div>
   <div class="post" id="post-128268">
    <div class="subject"><a href="#post-128268">Extensible ParticleEngine</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />I guess if you never have esi loaded with something *before* calling ParticleSystem_Update, then not preserving esi is fine.<br />It's just that...<br />*if* esi is loaded with something before the call to ParticleSystem_Update, then esi would end up changed.<br /><br />I guess it's just the matter of:<br />If the procs are only ever called from within the particle system, you can use/abuse registers however you like. Anyone using the particle system would never call ParticleSystem_Update themselves, right?<br /><br />After looking through all your files, it seems you're correct. esi doesn't need preserving in that proc;) .<br /><br />As for the message pump:<br />I'll look into seeeing if that can be fixed.<br /><br />It may have something to do with adding to CApp_WndProc:<br /><pre><code><br />        .elseif msg == WM_SIZE<br />            .IF &#40;w == SIZE_MAXHIDE&#41; || &#40;w == SIZE_MINIMIZED&#41;<br />                        mov ecx,CApp_OnlyInstance<br />                        mov &#91;ecx&#93;.CApp.bWait , TRUE<br />            .ELSE<br />                        mov ecx,CApp_OnlyInstance<br />                        mov &#91;ecx&#93;.CApp.bWait , FALSE<br />            .ENDIF<br /></code></pre><br />and also getting the rendering to *not* run while bWait is TRUE.<br /><br />With regards to the Camera code:<br />I've built a library (dll currently, but going to be changed to a static lib) which has the equivalent of an OOP &quot;SSMovement&quot; thingy.<br /><br />At this current stage, you create a SSMovement object like so:<br />Inside .data section:<br /><pre><code><br />    gPlayerObject       LPSSMovementStruc       0       ; pointer to out player object<br />    gCameraObject       LPSSMovementStruc       0       ; pointer to out camera object<br /></code></pre><br />Inside any initialization proc:<br /><pre><code><br />    ; create our camera object<br />    invoke SSMovement_NewObject<br />    mov gCameraObject, eax<br /><br />    ; create our player object<br />    invoke SSMovement_NewObject<br />    mov gPlayerObject, eax<br /></code></pre><br />Inside any cleanup proc:<br /><pre><code><br />    ; destroy our player object<br />    invoke SSMovement_DeleteObject, gPlayerObject<br /><br />    ; destroy our camera object<br />    invoke SSMovement_DeleteObject, gCameraObject<br /></code></pre><br />I've been playing around with the <strong>Meshes</strong> example (#6), and have replaced the spacebuggy and view matrice update like so:<br /><pre><code><br />.DATA<br />    dwOldTime           dd          0<br />    dwNewTime           dd          0<br />    fp0pt001            FLOAT       0.001f<br />    fpRotationVelocity  FLOAT       3.1415926535897932384626433832795f  ; two rotations per second<br />.CODE<br /><br />    invoke timeGetTime<br />    mov dwNewTime, eax<br /><br />    fild dwNewTime<br />    fild dwOldTime<br />    fsub<br />    fmul fp0pt001               ; change elapsed time to seconds<br />    fstp gfpTimeElapsed<br /><br />    mov eax, dwNewTime<br />    mov dwOldTime, eax<br /><br />    fld fpRotationVelocity<br />    mov edx, gPlayerObject<br />    fstp &#91;edx&#93;.SSMovementStruc.Yaw<br />    <br />    invoke SSMovement_UpdateObject, gPlayerObject, gfpTimeElapsed<br /><br />    mov edx, gPlayerObject<br />    mcall &#91;g_pd3dDevice&#93;,IDirect3DDevice8_SetTransform, 256, ADDR &#91;edx&#93;.SSMovementStruc.matUpdated<br /><br />.DATA<br />    eye_vector          D3DXVECTOR3     &lt;0.0f, 30.0f,-50.0f&gt;<br />    lookat_vector       D3DXVECTOR3     &lt;0.0f, 0.0f, 0.0f&gt;<br />    up_vector           D3DXVECTOR3     &lt;0.0f, 1.0f, 0.0f&gt;<br />    rotateradians       D3DXVECTOR3     &lt;0.00001f, 0.0f, 0.0f&gt;<br />    initialrun          dd      0<br />    fp0pt0              FLOAT   0.0f<br />.CODE<br /><br />    invoke SSMovement_PositionObject, gCameraObject, eye_vector.x, eye_vector.y, eye_vector.z<br />    .if initialrun == 0<br />        mov initialrun, 1<br />        invoke SSMovement_RotateObject, gCameraObject, rotateradians.x, rotateradians.y, rotateradians.z<br />    .else<br />        invoke SSMovement_RotateObject, gCameraObject, fp0pt0, fp0pt0, fp0pt0<br />    .endif<br />    invoke SSMovement_UpdateObjectAsCamera, gCameraObject, gfpTimeElapsed<br /><br />    mov edx, gCameraObject<br />    mcall &#91;g_pd3dDevice&#93;,IDirect3DDevice8_SetTransform, D3DTS_VIEW, ADDR &#91;edx&#93;.SSMovementStruc.matUpdated<br /></code></pre><br />Note that for every normal object, I use SSMovement_UpdateObject. For any camera, I use SSMovement_UpdateObjectAsCamera.<br />Apart from those two procs, all othe rprocs are used for all moving objects.<br /><br />I still have to fill in the rest of the basic movment/rotate procs (will only take a few minutes really).<br />After that, I'll be able to add more complicated procs for movement.<br />i.e. <br />Something similar to D3DXMatrixLookAtLH, where you can point an object/camera at anything/anywhere.<br />Movement buffering, where any movement/rotation automagically slows down to a halt.<br />Target locking (similar to the D3DXMatrixLookAtLH above, except the object will always stay locked on target.<br />Path following, where the object will follow a curved path (after been supplied a list of waypoints).<br />etc, etc.<br /><br />Should be fun.<br /><br />I'll be keeping it as a lib/dll for now until it's robust enough to change to a static lib. Doing it this way means that people won't have to worry about any assembling/linking problems (i.e. people not having their inc/lib files set up the same as myself need nolonger worry about not being able to use this stuff).<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-18 07:52:17 by Scronty</div>
   </div>
   <div class="post" id="post-128374">
    <div class="subject"><a href="#post-128374">Extensible ParticleEngine</a></div>
    <div class="body">Scronty - Sounds like phun to me :)<br /><br />Arrrgh, having a problem with planar collision physics.<br />Anyone good at physics here?<br /><br />Assume that for a given Particle, we save the current position and velocity of that particle just before it gets updated. Now we have the Old Position &amp; Velocity, as well as the Current Position &amp; Velocity. We then test the Current values against one or more Planes and determine whether the Particle is on the &quot;back&quot; side of any of those Planes. Let's just talk about Bouncing for now. Assuming that we correctly determine we have passed a Plane, we then use the following formula (and code) to reset the current velocity, and we revert to the old position...<br />Physics people, please check my formula is correct.<br /><br />                        mov esi,pPlane<br />                        .if .Plane.m_nCollisionResult == CR_BOUNCE                            <br />    ;            //-----------------------------------------------------------------<br />    ;            //<br />    ;            // The new velocity vector of a particle that is bouncing off<br />    ;            // a plane is computed as follows:<br />    ;            //<br />    ;            // Vn = (N.V) * N<br />    ;            // Vt = V - Vn<br />    ;            // Vp = Vt - Kr * Vn<br />    ;            //<br />    ;            // Where:<br />    ;            // <br />    ;            // .  = Dot product operation<br />    ;            // N  = The normal of the plane from which we bounced<br />    ;            // V  = Velocity vector prior to bounce<br />    ;            // Vn = Normal force<br />    ;            // Kr = The coefficient of restitution ( Ex. 1 = Full Bounce,   0 = Particle Sticks )<br />    ;            // Vp = New velocity vector after bounce<br />    ;            //<br />    ;            //-----------------------------------------------------------------<br />    ;            *** NOTE Kr = .Plane.m_fBounceFactor<br />    <br />                            mov esi,pPlane<br />                        ;// FIRST WE CALCULATE Vn (=Normal Force) according to given formula<br />                            invoke D3DXVec3Dot, addr .Plane.m_vNormal, addr vOldVelocity<br />                            mov ftemp,eax                       ;store Dot Product result<br />                            mov esi,pPlane                      ;just in case api messes our registers<br />                            mov ecx,pParticle<br />                            fld .Plane.m_vNormal.x<br />                            fmul ftemp        <br />                            fstp Vn.x<br />                            fld .Plane.m_vNormal.y<br />                            fmul ftemp        <br />                            fstp Vn.y<br />                            fld .Plane.m_vNormal.z<br />                            fmul ftemp        <br />                            fstp Vn.z<br /><br />                        ;// NEXT WE CALCULATE Vt (=V-Vn)    <br />                            __LoadFloat3 vOldVelocity<br />                            __SubFloat3 Vn<br />                            __StoreFloat3 Vt<br /><br />                        ;// FINALLY WE CALCULATE Vp (=Vt - Kr * Vn)<br />                            fld Vt.x<br />                            fld .Plane.m_fBounceFactor<br />                            fmul Vn.x<br />                            fsub<br />                            fstp .Particle.m_vCurVel.x<br />                            fld Vt.y<br />                            fld .Plane.m_fBounceFactor<br />                            fmul Vn.y<br />                            fsub<br />                            fstp .Particle.m_vCurVel.y<br />                            fld Vt.z<br />                            fld .Plane.m_fBounceFactor<br />                            fmul Vn.z<br />                            fsub<br />                            fstp .Particle.m_vCurVel.z<br />                <br />                         ;// AND PUT THE PARTICLE BACK ON THE 'SAFE' SIDE OF THE PLANE<br />                            __LoadFloat3 vOldPosition<br />                            __StoreFloat3 .Particle.m_vCurPos<br /><br />Right now, the Particles continue on their merry way right through the plane, and for all purposes their Velocity (which incorporates Direction) is unaltered.<br />For example, if we enable Gravity and define a Floor Plane with a Normal pointing into Y+, the particles rain right through the floor and into eternity, until they time out.<br />Any ideas?</div>
    <div class="meta">Posted on 2003-12-18 22:30:38 by Homer</div>
   </div>
   <div class="post" id="post-128378">
    <div class="subject"><a href="#post-128378">Extensible ParticleEngine</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br /><pre><code><br />;=====&lt;&lt; CAPP_PROCESS_MESSAGES &gt;&gt;===\<br />CApp_ProcessMessages proc<br />LOCAL msg &#58;MSG<br />LOCAL bGotMsg&#58;DWORD<br /><br />    INVOKE PeekMessage, ADDR msg, NULL, 0, 0, PM_NOREMOVE<br /><br />;   Enter the message loop<br />    .WHILE msg.message != WM_QUIT<br /><br />        mov ecx,CApp_OnlyInstance<br />        .if &#91;ecx&#93;.CApp.bWait != TRUE<br />            INVOKE PeekMessage, ADDR msg, NULL, 0, 0, PM_REMOVE<br />            mov bGotMsg, eax<br />        .ELSE<br />            INVOKE GetMessage, ADDR msg, NULL, 0, 0<br />            mov bGotMsg, eax<br />        .ENDIF<br />    <br />        .IF bGotMsg<br />        <br />            INVOKE TranslateMessage, ADDR msg<br />            INVOKE DispatchMessage, ADDR msg<br /><br />        .ELSE<br /><br /><br />            ; Render a frame during idle time &#40;no messages are waiting&#41;<br />            mov ecx,CApp_OnlyInstance<br />            .if &#91;ecx&#93;.CApp.bWait != TRUE<br /><br />                invoke timeGetTime<br />                mov g_dCurTime, eax<br /><br />                fild g_dCurTime<br />                fild g_dLastTime<br />                fsub<br />                fmul fp0pt001               ; change elapsed time to seconds<br />                fstp g_fElapsedTime<br /><br />                mov eax, g_dCurTime<br />                mov g_dLastTime, eax<br /><br />                icall CApp_OnlyInstance, CApp, Render<br /><br /><br />            .ENDIF<br /><br />        .ENDIF<br />    .ENDW<br /><br /><br />;	// all messages are processed and no quit message was recieved so return true<br />	return TRUE<br />CApp_ProcessMessages         ENDP<br />;=======/<br /></code></pre><br /><pre><code><br />CApp_Run proc uses ecx<br />        icall CApp_OnlyInstance, CApp, ProcessMessages<br /><br />        ret<br />CApp_Run endp<br /></code></pre><br />Inside the &quot;render proc pd3dDevice:DWORD&quot; for CApp:<br /><pre><code><br />        add dwFPSinc, 1<br />        fld g_fElapsedTime      ; update the elapsed-time over a second<br />        fadd fpFPStime<br />        fst fpFPStime<br />        fld1<br />        fcompp                  ; see whether it's reached one second<br />        GetFPUFlags<br />        ja @F                   ; still under a second, so don't update text<br /><br />        fldz<br />        fstp fpFPStime<br /><br />        m2m dwFPS, dwFPSinc<br />        mov dwFPSinc, 0<br />        @@&#58;<br /><br />        invoke wsprintf,addr ErrBuf,CTEXT&#40;&quot;FrameRate = %d fps&quot;&#41;,dwFPS<br />        invoke DrawTextLine ,pFont, addr MyVerticalPosition,addr ErrBuf, -1<br /></code></pre><br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-18 22:51:29 by Scronty</div>
   </div>
   <div class="post" id="post-128383">
    <div class="subject"><a href="#post-128383">Extensible ParticleEngine</a></div>
    <div class="body">Hell yeah !!<br />cpu time down to practically zero...w00t !!<br />If I keep slapping my forehead like this, I'll end up with a permanent welt :tongue:<br /><br />As for the physics issue (reflection), I can't find any good examples which use the coplanar point method :( I'll keep looking, and hopefully in the meantime a physics student can point out that my formula is wrong. I'm assuming it's the formula because my implementation in code looks ok. I have verified that my ClassifyPoint procedure is correctly determining on which side of a plane (defined by a normal and coplanar point) a given point is sitting. Irritating. In a &quot;real app&quot; I would be using DX's intersection tests anyway, but I still wanna know what's wrong here, since we still have to perform the reflection ourselves. I don't wanna use a reflection matrix for this because it seems redundant - how often will multiple particles strike the same plane in a real game? I assume here that the world isn't nice and flat, and that the planes are all over the place, thinking in outdoor engine terms, not Quake1 terms.</div>
    <div class="meta">Posted on 2003-12-18 23:19:57 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16201&amp;page=1" style="">&laquo;</a><a href="../?id=16201&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16201" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=16201&amp;page=3">&gt;</a><a href="../?id=16201&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>