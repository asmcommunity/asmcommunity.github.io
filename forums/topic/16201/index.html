<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Extensible ParticleEngine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16201" />
    <link rel="next" href="../?id=16201&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=16201">Extensible ParticleEngine</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16201&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16201&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16201" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16201&amp;page=2">&gt;</a><a href="../?id=16201&amp;page=3">&raquo;</a></form>   <div class="post" id="post-125675">
    <div class="subject"><a href="#post-125675">Extensible ParticleEngine</a></div>
    <div class="body">Hey trendsetters, <br /><br />just had a lovely few days away from the keys, hope it did me some good...<br />I've shelved the oopskinmesh example (again) although I know what's got to be done to sort it out...<br />Since I just got back and was feeling a little bored, I've begun implementing an oop-based extensible <a target="_blank" href="http://www.geocities.com/foetsch/particles/particles.htm">ParticleSystem Demo</a> , theres the C source I am translating...<br />I'm using Ultrano's Class Support, our CApp baseclass, etc.<br />Everyone finished their Christmas wishlist ?? :)</div>
    <div class="meta">Posted on 2003-11-26 23:16:13 by Homer</div>
   </div>
   <div class="post" id="post-125875">
    <div class="subject"><a href="#post-125875">Extensible ParticleEngine</a></div>
    <div class="body">Here's a taste of what's to come - note this aint by any means complete.<br />.. thanks be to Ultrano for his OOP support module.</div>
    <div class="meta">Posted on 2003-11-29 00:20:21 by Homer</div>
   </div>
   <div class="post" id="post-126139">
    <div class="subject"><a href="#post-126139">Extensible ParticleEngine</a></div>
    <div class="body">thanks for the effort.  I'm checking out the code.</div>
    <div class="meta">Posted on 2003-12-01 10:47:07 by Porkster</div>
   </div>
   <div class="post" id="post-126346">
    <div class="subject"><a href="#post-126346">Extensible ParticleEngine</a></div>
    <div class="body">That source I was basing that on is relatively unsuitable for a D3D example, because it is quite dated and uses a combination of DirectDraw7 and Direct3D8.<br />I've since found a better example written for DX9, available C source zip <a target="_blank" href="http://www.codesampler.com/source/dx9_particle_system.zip">here</a> (also contains exe), I am rewriting that one for DX8.1, and it's almost complete. <br />Why have I done this?<br />Because the earlier one had some dubious mechanism whereby inheriting classes could manipulate the vtable of the inherited class (their owner), which was not straight forward &quot;overloading&quot; of class methods, and had some other weirdness, and did not contain any optimization of rendering.<br />This second example is easier to understand, slightly more powerful, and just as flexible as the old one, albeit not as oop-friendly in terms of extensions.<br />It is however a much better example in modern terms, and uses PointSprites to accomplish its rending of alphablended rectangles which means that vertexbuffers hold just one vertex per sprite rather than four.<br />I've almost completed the translation to MASM for dx8.1, I'll post it soon.</div>
    <div class="meta">Posted on 2003-12-02 21:52:17 by Homer</div>
   </div>
   <div class="post" id="post-126542">
    <div class="subject"><a href="#post-126542">oops...</a></div>
    <div class="body">I think PointSprites aren't supported on anything less than GF3. Looks very nice anyway ;]</div>
    <div class="meta">Posted on 2003-12-04 09:45:33 by panoramix</div>
   </div>
   <div class="post" id="post-126779">
    <div class="subject"><a href="#post-126779">Extensible ParticleEngine</a></div>
    <div class="body">Thats true, PointSprites are not handled by some cards, and as such, this demo should really check the capabilities of the local hardware, and resort to using textured quads for rending sprites when the hardware isn't capable of PointSprites... speaking of which, I'm stuck at the moment with a minor bug in creation of vertex buffers for holding pointsprites...<br />I'm getting a return value of &quot;1&quot; from my call to create the vertexbuffer, and checking msdn docs for this call, the value &quot;1&quot; is not even enumerated as a possible return value !! What The?<br />Note the following function is Class based, using Ultrano's macros, and assumes that ecx=pThis on entry. Anyone got a clue? I really don't wanna use software vertex processing, this is the whole point !<br /><br />ParticleSystem_RestoreDeviceObjects proc uses ecx pd3dDevice:LPDIRECT3DDEVICE8<br /><br />local me:DWORD<br />local ErrBuf[256]:BYTE<br />local pVB:DWORD<br />;    // Create a vertex buffer for the particle system.  The size of this buffer<br />;    // does not relate to the number of particles that exist.  Rather, the<br />;    // buffer is used as a communication channel with the device. we fill in <br />;    // a chunck, and tell the device to draw. While the device is drawing, we<br />;    // fill in the next chunck using NOOVERWRITE. We continue doing this until <br />;    // we run out of vertex buffer space, and are forced to DISCARD the buffer<br />;    // and start over at the beginning.<br />        mov me,ecx<br />        DebugValue addr ErrBuf,CTEXT(&quot;(m_dwDiscard = %lu)&quot;,13,10),.ParticleSystem.m_dwDiscard<br />        mov ecx,me<br />        mov ebx,.ParticleSystem.m_dwDiscard<br />        imul ebx,  sizeof PointVertex<br />        PARTICLE_USAGE equ (D3DUSAGE_DYNAMIC or D3DUSAGE_WRITEONLY or D3DUSAGE_POINTS)<br />        FVF_POINTVERTEX equ D3DFVF_XYZ or D3DFVF_DIFFUSE<br />        mcall pd3dDevice,IDirect3DDevice8_CreateVertexBuffer,  ebx,PARTICLE_USAGE,  FVF_POINTVERTEX, 0,  addr pVB <br />        push eax<br />        .if eax!=D3D_OK<br />                Debug CTEXT(&quot;Failed to (re?)-Create VertexBuffer... &quot;)<br />                pop eax<br />                .if eax==D3DERR_INVALIDCALL<br />                        Debug CTEXT(&quot;Reason = 'INVALIDCALL'&quot;,13,10)<br />                .elseif eax==D3DERR_OUTOFVIDEOMEMORY<br />                        Debug CTEXT(&quot;Reason = 'OUTOFVIDEOMEMORY'&quot;,13,10)<br />                .elseif eax==E_OUTOFMEMORY<br />                        Debug CTEXT(&quot;Reason = 'OUTOFMEMORY'&quot;,13,10)<br />                .else<br />                        DebugValue addr ErrBuf,  CTEXT(&quot;, Error=0x%lX&quot;,13,10),eax<br />                        return E_FAIL<br />                .endif<br />        .else                <br />                pop eax<br />                mov ecx,me<br />                DebugValue addr ErrBuf, CTEXT(&quot;(re?)-Created VertexBuffer @ 0x%lX&quot;,13,10),pVB<br />                return S_OK<br />        .endif<br />ParticleSystem_RestoreDeviceObjects endp</div>
    <div class="meta">Posted on 2003-12-06 04:42:07 by Homer</div>
   </div>
   <div class="post" id="post-126780">
    <div class="subject"><a href="#post-126780">Extensible ParticleEngine</a></div>
    <div class="body">I just tried changing that line to:<br />mcall pd3dDevice,IDirect3DDevice8_CreateVertexBuffer,  ebx,PARTICLE_USAGE,  FVF_POINTVERTEX,  D3DPOOL_DEFAULT,  addr pVB<br /><br /><br />I still get a return value of 1, and no result in my pVB..</div>
    <div class="meta">Posted on 2003-12-06 04:58:26 by Homer</div>
   </div>
   <div class="post" id="post-126850">
    <div class="subject"><a href="#post-126850">Extensible ParticleEngine</a></div>
    <div class="body">Heya :)<br />Here is the complete translation of the DX9 ParticleSystem Demo, rewritten for MASM and DX8.1<br />It is 99% complete and apparently bugfree (I have not, for example, implemented any of the keyboard or mouse controls) but alas is refusing to render anything to the screen !! I know there's not much wrong, and would love to know what I missed :) If you can spot the render issue, I'll be more than grateful. Again, this demo is not my own work per se, I claim no legal ownership in any respect. Do whatever you like with it :) Finally, I have deliberately left out the two files UUID.LIB and LIBCI.LIB due to size restrictions more than any respect for m$'s EULA :tongue:</div>
    <div class="meta">Posted on 2003-12-06 20:25:00 by Homer</div>
   </div>
   <div class="post" id="post-126876">
    <div class="subject"><a href="#post-126876">Extensible ParticleEngine</a></div>
    <div class="body">I've cleaned up that source a little, but I've made no real changes to it.<br />I've commented out the call to update the view matrix for now.<br />I've implemented the escape and F-Key switches.<br />Can anyone help me get the single textured quad &quot;FloorPlane&quot; to render?<br />I've done this stuff before, I can't see what the problem is :(</div>
    <div class="meta">Posted on 2003-12-07 06:31:58 by Homer</div>
   </div>
   <div class="post" id="post-126979">
    <div class="subject"><a href="#post-126979">Extensible ParticleEngine</a></div>
    <div class="body">Thanks to Scronty for taking time to have a peek at my rubbish and awaiting a definite answer to the dilemma of (at the least) why I can't see the Floor.</div>
    <div class="meta">Posted on 2003-12-07 23:55:48 by Homer</div>
   </div>
   <div class="post" id="post-127098">
    <div class="subject"><a href="#post-127098">Extensible ParticleEngine</a></div>
    <div class="body">Well, I have disabled the function &quot;updateViewMatrix&quot; and replaced it with a fixed view matrix for now, and lo and behold, the floor appears :)<br />Obviously there is a problem with my translation of that function, but I'm not really concerned so much with the Camera at the moment as I am with the fact that not a single Particle is being rendered... hmmz... I'm going to look into this now.<br />I'd appreciate some help with this - do my Render states look ok? There's two places where the problem could lie, either the RenderStates are bad, or the Particles are not being correctly updated in terms of their position over time...</div>
    <div class="meta">Posted on 2003-12-08 23:36:29 by Homer</div>
   </div>
   <div class="post" id="post-127104">
    <div class="subject"><a href="#post-127104">Extensible ParticleEngine</a></div>
    <div class="body">Hmmz, well, here is the latest version, I found a couple more issues and fixed them up, one of the main ones being that since I use WM_CHAR for keyboard input I cannot detect F-Keys like F1... please note I am currently using key &quot;1&quot; for changing the current ParticleSystem.<br /><br />Now, I have two questions on things which are bothering me.<br />The first is that I am only getting screen updates when a WM happens, I implemented a visual means of checking the &quot;Elapsed Time&quot; which proves this is true. There's a big problem with my MessagePump !! My first question therefore is - what is wrong with my MessagePump? It's meant to fall through and return if no messages are in the queue, and thus only render when nothing is happening, this is not what we are seeing, is it?<br /><br />My second question is probably related - the app currently operates in Windowed Mode, but if I switch to another window, I cannot switch back - the application window simply stops getting any input and does not get focus back. This means you can't even hit escape to quit anymore. Why?</div>
    <div class="meta">Posted on 2003-12-09 00:16:31 by Homer</div>
   </div>
   <div class="post" id="post-127207">
    <div class="subject"><a href="#post-127207">Extensible ParticleEngine</a></div>
    <div class="body">I've fixed the MessagePump issue - now I'm going to try to figure out where my truant particles are hiding... <br /><br />The issue in the messagepump was the line:<br />  .if $invoke (PeekMessage, addr msg, PM_NOREMOVE, 0, 0, 0 ) <br /><br />I had altered it to follow the C source, which is actually wrong.<br />That's what you get for not having faith in yourself.</div>
    <div class="meta">Posted on 2003-12-09 22:08:15 by Homer</div>
   </div>
   <div class="post" id="post-127216">
    <div class="subject"><a href="#post-127216">Extensible ParticleEngine</a></div>
    <div class="body">Progress Report : I've found that the Particle issues stem from the ParticleSystem_Update procedure - in fact, no particles were even being created.<br />Now particles are being created, but subsequent calls to Update crash the application, so I'll have to look more closely at the first part of that procedure (the second part is where they are created). Therefore I have disabled the call to ParticleSystem_Render until my phantom particles are being created and updating over time and behaving themselves :)<br />On a side note, when I claimed to have fixed the problems with my MessagePump, I should have said I fixed the issue of the Window losing and not regaining focus. There's still a problem in terms of the Render function only being called when a WM is processed, which is irritating me.<br />Bugs:2 , Homer:1</div>
    <div class="meta">Posted on 2003-12-10 02:06:32 by Homer</div>
   </div>
   <div class="post" id="post-127344">
    <div class="subject"><a href="#post-127344">Extensible ParticleEngine</a></div>
    <div class="body">Actually, there's no issue with the MessagePump - for some reason, with no changes from me, it's now showing the true ElapsedTime when all I have done is correct the issues in the second half of the particle Update procedure... weird.<br />Ok now, particles are being created over time correctly, and I can confirm this with a visual examination of the #particles in current system being viewed (realtime).<br />Still there is an issue in the first part of same procedure.<br />Specifically, when attempting to update the linkedlist of Particles owned by a given system, we enter an infinite loop, never finding a null pNext at the end.<br />Considering the method used for creating links between particles, I find this odd.<br />Bear in mind that the system's pActiveList is initialized to zero when it is created (see the contructor for the class, ParticleSystem_ParticleSystem for proof)...<br /><br />; //Attach Old Head to new Particle<br />m2m .Particle.m_pNext , .ParticleSystem.m_pActiveList<br />; // Make it the new head...    <br />m2m .ParticleSystem.m_pActiveList , pParticle <br /><br />What is happening here is that when we make a new particle, it automatically becomes the head of the list, and the old head is attached under it.<br />Considering the initial head is zero, the last pNext should be zero !!<br /><br />Therefore, it seems strange to never find it, right?<br />Anyone have any feedback on this issue?</div>
    <div class="meta">Posted on 2003-12-10 22:10:26 by Homer</div>
   </div>
   <div class="post" id="post-127346">
    <div class="subject"><a href="#post-127346">Extensible ParticleEngine</a></div>
    <div class="body">(just to prove the issue is in the Particles update loop, I commented out the inner loop checking the particle against all Planes...)</div>
    <div class="meta">Posted on 2003-12-10 22:21:44 by Homer</div>
   </div>
   <div class="post" id="post-127355">
    <div class="subject"><a href="#post-127355">Extensible ParticleEngine</a></div>
    <div class="body">heh - fixed the infinite loop issue, only one more to go in this section of code, the &quot;inner loop&quot; where we &quot;check if the current particle has passed any of our Planes&quot;, contains a bug, theres no default plane lol, I think I'll be posting a 100% version of this demo before this day is out :)</div>
    <div class="meta">Posted on 2003-12-10 23:06:26 by Homer</div>
   </div>
   <div class="post" id="post-127359">
    <div class="subject"><a href="#post-127359">Extensible ParticleEngine</a></div>
    <div class="body">One last issue: there is a problem inthe particle rendering proc, when I try to lock the VB, even though it returns D3D_OK, the pointer it returns is bad.<br />I'll try to solve this as soon as possible, I for one am keen to see some particles on my screen :)</div>
    <div class="meta">Posted on 2003-12-11 01:08:10 by Homer</div>
   </div>
   <div class="post" id="post-127368">
    <div class="subject"><a href="#post-127368">Extensible ParticleEngine</a></div>
    <div class="body">Well, now I render a frame which shows a particle, but subsequently the application hangs. It's still apparently a Render issue, because if I disable ONLY the ParticleSystem_Render proc, everything is peachy.<br /><br />Here's the current code for that procedure:<br />Can anyone see a problem in it? It returns the first time...<br /><br />ParticleSystem_Render proc uses ecx pd3dDevice:LPDIRECT3DDEVICE8<br />local me:DWORD<br />local pParticle:DWORD<br />local pVertices:ptr PointVertex <br />local vPos:D3DXVECTOR3<br />local vVel:D3DXVECTOR3<br />local m_pVB:DWORD<br />local ErrBuf[256]:BYTE<br /><br />;//-----------------------------------------------------------------------------<br />;// Name: Render()<br />;// Desc: Renders the particle system using pointsprites loaded in a vertex <br />;//       buffer.<br />;//<br />;// Note: D3DLOCK_DISCARD:<br />;//<br />;//       The application overwrites, with a write-only operation, the entire <br />;//       index buffer. This enables Direct3D to return a pointer to a new <br />;//       memory area so that the dynamic memory access (DMA) and rendering <br />;//       from the old area do not stall.<br />;//<br />;//       D3DLOCK_NOOVERWRITE:<br />;//<br />;//       Indicates that no vertices that were referred to in drawing calls <br />;//       since the start of the frame or the last lock without this flag will <br />;//       be modified during the lock. This can enable optimizations when the <br />;//       application is appending data only to the vertex buffer. <br />;//-----------------------------------------------------------------------------<br />    mov me,ecx                                                                   ; As always, preserve pThis<br />    m2m m_pVB,.ParticleSystem.m_pVB             <br /><br /><br /><br />;       //<br />;      // Set the render states for using point sprites..<br />;     //<br />	<br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSPRITEENABLE, TRUE ;       // Turn on point sprites<br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSCALEENABLE,  TRUE ;       // Allow sprites to be scaled with distance<br />    mov ecx,me<br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSIZE,     .ParticleSystem.m_fSize ; // Float value that specifies the size to use for point size computation in cases where point size is not specified for each vertex.<br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSIZE_MIN, fp1 ;    // Float value that specifies the minimum size of point primitives. Point primitives are clamped to this size during rendering. <br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSCALE_A, 0 ;    // Default 1.0<br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSCALE_B,  0 ;    // Default 0.0<br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSCALE_C,  fp1 ;    // Default 0.0<br />    mov ecx,me<br />    m2m pParticle , .ParticleSystem.m_pActiveList;<br />    mov .ParticleSystem.dwNumParticlesToRender , 0<br /><br />;    // Lock the vertex buffer.  We fill the vertex buffer in small<br />;    // chunks, using D3DLOCK_NOOVERWRITE.  When we are done filling<br />;    // each chunk, we call DrawPrim, and lock the next chunk.  When<br />;    // we run out of space in the vertex buffer, we start over at<br />;    // the beginning, using D3DLOCK_DISCARD.<br /><br />;    // Move the offset forward so we can fill the next chunk of the vertex buffer<br />    mov eax,.ParticleSystem.m_dwFlush<br />    add .ParticleSystem.m_dwVBOffset ,eax<br /><br />;    // If we're about to overflow the buffer, reset the offset counter back to 0<br />    mov eax, .ParticleSystem.m_dwVBOffset<br />    .if eax &gt;= .ParticleSystem.m_dwDiscard<br />        mov .ParticleSystem.m_dwVBOffset , 0<br />    .endif<br /><br />    mov ebx,.ParticleSystem.m_dwVBOffset           ;calc offset to lock<br />    imul ebx,sizeof PointVertex<br />    mov ecx,.ParticleSystem.m_dwFlush                ;calc size to lock<br />    imul ecx,sizeof PointVertex<br /><br />    .if ebx!=0<br />           mcall m_pVB,IDirect3DVertexBuffer8_Lock, ebx, ecx, addr pVertices, D3DLOCK_NOOVERWRITE <br />    .else<br />           mcall m_pVB,IDirect3DVertexBuffer8_Lock, ebx, ecx, addr pVertices, D3DLOCK_DISCARD<br />    .endif<br />    .if eax==D3DERR_INVALIDCALL<br />          Debug CTEXT(&quot;Failed to Render ParticleSystem due to failed Lock.&quot;,13,10,&quot;Reason=INVALIDCALL&quot;,13,10)<br />          ret<br />    .endif<br /><br />;     int 3<br />;    // Render each particle<br />    .while pParticle <br /><br /><br />        mov esi,pParticle<br />        __LoadFloat3 .Particle.m_vCurPos<br />        __StoreFloat3 vPos<br />        __LoadFloat3 .Particle.m_vCurVel<br />        __StoreFloat3 vVel<br /><br />        mov esi,pVertices<br />        __LoadFloat3 vPos<br />        __StoreFloat3 .PointVertex.posit <br />        __LoadFloat4 .ParticleSystem.m_clrColor<br />        __StoreFloat4 .PointVertex.color <br />        add pVertices,sizeof PointVertex<br /><br />        mov ecx,me<br />        inc .ParticleSystem.dwNumParticlesToRender <br />        mov eax,.ParticleSystem.m_dwFlush<br />        .if( .ParticleSystem.dwNumParticlesToRender  == eax )<br /> ;           // Done filling this chunk of the vertex buffer.  Lets unlock and<br /> ;           // draw this portion so we can begin filling the next chunk.<br />                mcall m_pVB, IDirect3DVertexBuffer8_Unlock<br />                mcall pd3dDevice, IDirect3DDevice8_SetStreamSource, 0, m_pVB,  sizeof PointVertex <br />                mcall pd3dDevice,IDirect3DDevice8_SetVertexShader, FVF_POINTVERTEX<br />                mov ecx,me        <br />                mcall pd3dDevice,IDirect3DDevice8_DrawPrimitive, D3DPT_POINTLIST,  .ParticleSystem.m_dwVBOffset, .ParticleSystem.dwNumParticlesToRender<br />                .if eax!=D3D_OK<br />                   ret<br />                .endif<br /><br />;            // Lock the next chunk of the vertex buffer.  If we are at the <br />;            // end of the vertex buffer, DISCARD the vertex buffer and start<br />;            // at the beginning.  Otherwise, specify NOOVERWRITE, so we can<br />;            // continue filling the VB while the previous chunk is drawing.<br />                mov ecx,me<br />                mov eax,.ParticleSystem.m_dwFlush<br />                add .ParticleSystem.m_dwVBOffset ,eax<br /><br />;            // If we're about to overflow the buffer, reset the offset counter back to 0<br />                mov eax,.ParticleSystem.m_dwDiscard<br />                .if .ParticleSystem.m_dwVBOffset &gt;= eax<br />                        mov .ParticleSystem.m_dwVBOffset , 0<br />                .endif<br /><br />                mov ebx,.ParticleSystem.m_dwVBOffset<br />                imul ebx,sizeof PointVertex<br />                mov ecx,.ParticleSystem.m_dwFlush<br />                imul ecx,sizeof PointVertex<br />                .if ebx!=0<br />                        mcall m_pVB,IDirect3DVertexBuffer8_Lock,ebx, ecx, addr pVertices, D3DLOCK_NOOVERWRITE<br />                .else<br />                        mcall m_pVB,IDirect3DVertexBuffer8_Lock,ebx, ecx, addr pVertices, D3DLOCK_DISCARD<br />                .endif<br />                 .if eax!=D3D_OK<br />                        ret<br />                .endif<br />            mov ecx,me<br />            mov .ParticleSystem.dwNumParticlesToRender , 0<br />        .endif<br />        mov esi,pParticle<br />        m2m pParticle , .Particle.m_pNext        <br />    .endw<br /><br />;    // Unlock the vertex buffer<br />    mcall m_pVB,IDirect3DVertexBuffer8_Unlock<br /><br />;    // Render any remaining particles<br />    mov ecx,me<br />    .if .ParticleSystem.dwNumParticlesToRender <br />        mcall pd3dDevice,IDirect3DDevice8_SetStreamSource, 0, m_pVB,  sizeof PointVertex<br />        mcall pd3dDevice,IDirect3DDevice8_SetVertexShader, FVF_POINTVERTEX <br />        mov ecx,me<br />        mcall pd3dDevice,IDirect3DDevice8_DrawPrimitive, D3DPT_POINTLIST, .ParticleSystem.m_dwVBOffset, .ParticleSystem.dwNumParticlesToRender<br />        .if eax!=D3D_OK<br />            ret<br />        .endif<br />    .endif<br /><br />;	//<br />;    // Reset render states...<br />;	//<br /><br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSPRITEENABLE, FALSE <br />    mcall pd3dDevice,IDirect3DDevice8_SetRenderState, D3DRS_POINTSCALEENABLE,  FALSE <br />    mcall pd3dDevice,IDirect3DDevice8_SetVertexShader,NULL<br /><br />    ret<br />ParticleSystem_Render endp</div>
    <div class="meta">Posted on 2003-12-11 04:35:13 by Homer</div>
   </div>
   <div class="post" id="post-127463">
    <div class="subject"><a href="#post-127463">Extensible ParticleEngine</a></div>
    <div class="body">Here is the current version, which is working, albeit not as it should be.<br />You will see what I mean.<br /><br /><br />After I posted THIS release, small changes were made..<br />I've cleanup up some of the lower ParticleSystem procs where I have replaced the RtlMoveMemory calls with Caleb's fpu macros, much more appropriate. I've implemented the ParticleSystem_Init function which was missing, not that it made any difference...<br /></div>
    <div class="meta">Posted on 2003-12-11 21:55:16 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16201&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16201&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16201" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16201&amp;page=2">&gt;</a><a href="../?id=16201&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>