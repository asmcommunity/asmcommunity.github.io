<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>decimal to binary conversion - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29086" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29086">decimal to binary conversion</a></p>
   <div class="post" id="post-205507">
    <div class="subject"><a href="#post-205507">decimal to binary conversion</a></div>
    <div class="body">Hi<br />I am very new to assembly.&nbsp; I am trying to convert some numbers to binary.&nbsp; I have written most of the code so far, but can&#039;t figure out how to convert to binary.&nbsp; The user enters a number that number is stored in one register in another final register initialized to 0 the value is multiplied by 10 and the stored number is added so that if the user enters 1 the answer is one if they then enter a 2 the answer is 12, and so on.&nbsp; I then have to convert the final number entered to binary.&nbsp; That is where I am stuck.&nbsp; Here is what I have so far...I have been trying test, but that doesnt seem to work.&nbsp; <br /><pre><code> mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,char_prompt<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; print_string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; request a char. input<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; print_nl<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  edx,0<br /><br />L1:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Loop 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; get_kb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; read input character<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp&nbsp; &nbsp; &nbsp; &nbsp;  AL, 0Dh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; compare the key entered to CR<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; je&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false2<br />true:<br />&nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp&nbsp; &nbsp; &nbsp; &nbsp;  AL, &#039;0&#039;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; compare AL to 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no match do second else<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp&nbsp; &nbsp; &nbsp; &nbsp;  Al, &#039;9&#039;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;compare AL to 9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;no match do second else<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp; &nbsp;  al,&#039;0&#039;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; subtract 0 from what ever is in AL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  ,al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;move whatever is in AL to inputdigit<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imul&nbsp; &nbsp; &nbsp; &nbsp;  edx,10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;multiply edx by 10<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp; &nbsp; &nbsp;  edx,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;add value in input1 to value in edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;move value in edx to eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; print_int<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; print_nl<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop&nbsp; &nbsp; &nbsp; &nbsp; L1<br />false2:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  eax,out_msg3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; print_string&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;jump to error statement<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; print_nl</code></pre></div>
    <div class="meta">Posted on 2008-06-20 00:47:35 by cannsyl</div>
   </div>
   <div class="post" id="post-205508">
    <div class="subject"><a href="#post-205508">Re: decimal to binary conversion</a></div>
    <div class="body">When you have the decimal number in a DWORD var or a register,&nbsp; to show that into binary, for the 32 bits you just have to test whether the highest bit is set and print &quot;0&quot; or &quot;1&quot;. <br /><pre><code><br />mov eax,value<br /><br />mov ecx,0<br />.while ecx&lt;32<br />&nbsp; &nbsp;  .if eax &amp; 80000000h ; is highest bit set?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  print &quot;1&quot;<br />&nbsp; &nbsp;  .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  print &quot;0&quot;<br />&nbsp; &nbsp;  .endif<br />&nbsp; &nbsp;  shl eax,1 ; make bit 30 become bit 31<br /><br />&nbsp; &nbsp;  inc ecx<br />.endw<br /></code></pre><br /><br />But this will always print 32 bits, won&#039;t skip the leading zeroes. So, let&#039;s skip them:<br /><br /><pre><code><br />mov eax,value<br />	.if !eax<br />		print &quot;0&quot;<br />		ret<br />	.endif<br />	<br />	xor ecx,ecx<br />	.while !(eax &amp; 80000000h)<br />		shl eax,1<br />	inc ecx<br />	.endw<br /><br />next_bit:<br />&nbsp; &nbsp; .if eax &amp; 80000000h<br />&nbsp; &nbsp; &nbsp; &nbsp; print &quot;1&quot;<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; print &quot;0&quot;<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; shl eax,1<br />&nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; cmp ecx,32<br />&nbsp; &nbsp; jl next_bit<br /><br /></code></pre><br /><br />Of course, many tricks spawn as optimizations or fun around that code</div>
    <div class="meta">Posted on 2008-06-20 10:11:12 by Ultrano</div>
   </div>
   <div class="post" id="post-205513">
    <div class="subject"><a href="#post-205513">Re: decimal to binary conversion</a></div>
    <div class="body">Thanks so much for the help.&nbsp; I kind of understand the concept you gave, but I can&#039;t use .if how would I do a !eax in assembly with gvim?&nbsp; Thanks</div>
    <div class="meta">Posted on 2008-06-23 10:12:06 by cannsyl</div>
   </div>
   <div class="post" id="post-205515">
    <div class="subject"><a href="#post-205515">Re: decimal to binary conversion</a></div>
    <div class="body">test eax,eax<br />jnz _notZero<br /><br />So, the second code I posted above can be transformed with Carry-flag tricks like this:<br /><pre><code><br />PrintBinary proc uses edi Value,lpszText<br />	mov edx,Value<br />	mov edi,lpszText<br />	test edx,edx<br />	jz _onZero<br />	xor ecx,ecx<br />	<br />	mov ecx,32<br />	;----[ find the first &#039;1&#039; bit ]----[<br />	@@:<br />		dec ecx<br />		shl edx,1<br />		jnc @B<br />	<br />	;----------------------------------/<br />	<br />	;----[ restore that &#039;1&#039; bit we took-away ]---[<br />	shr edx,1<br />	or edx,80000000h<br />	;--------------------------------------------/<br />	<br />	<br />	;---[ for each next bit ]----[<br />	next_bit:<br />		shl edx,1&nbsp; ; move highest bit into Carry-Flag<br />		mov al,&#039;0&#039; ; we want to print &quot;0&quot; or &quot;1&quot;, so put &quot;0&quot; into AL<br />		adc al,0&nbsp; &nbsp;; this will add 0 or 1 to al, depending on CarryFlag. So, if(CarryFlag==false)al=&quot;0&quot;; else al=&quot;1&quot;;<br />		stosb&nbsp; &nbsp; &nbsp; ; equals &quot;mov ,al | inc edi&quot;<br />		dec ecx&nbsp; &nbsp; ; decrese number of bits left to check<br />		jge next_bit	; repeat code if bits_left_to_check &gt;=0 . (we had decremented ecx once too much while searching for the first &quot;1&quot;, so we use &quot;&gt;=0&quot; instead of &quot;&gt;0&quot;)<br />	;----------------------------/<br />	<br />	<br />	<br />	mov byte ptr,0 ;zero-terminate<br />	ret<br />	_onZero:<br />	mov word ptr,&#039;0&#039; ; put &#039;0&#039; in string, and zero-terminate<br />	ret<br />PrintBinary endp<br />...<br /><br />.data?<br />MyStringResult db 100 dup (?)<br />.code<br />invoke PrintBinary,0FFh,addr MyStringResult<br /><br />invoke MessageBox,0,addr MyStringResult,0,0<br /></code></pre></div>
    <div class="meta">Posted on 2008-06-23 11:54:50 by Ultrano</div>
   </div>
   <div class="post" id="post-205542">
    <div class="subject"><a href="#post-205542">Re: decimal to binary conversion</a></div>
    <div class="body">I just wrote this one in NASM. It returns the number of bytes copied to the destination string.<br /><br /><pre><code>; ——————————————————————————————————————————————————&nbsp; <br />&nbsp; __DecToBinStr:<br />&nbsp; &nbsp; ; DWORD __DecToBinStr (DWORD DecimalValue, char* DestinationString, Boolean SkipTrailingZeros); StdCall;<br />&nbsp; &nbsp; ; Returns the number of bytes copied to the  string (Including the null-terminator)<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; &nbsp; EBX<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; &nbsp; ECX<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; &nbsp; EDX<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; &nbsp; ESI<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; &nbsp; EDI<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; &nbsp; EBP<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EBP , ESP<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;  = DecimalValue<br />&nbsp; &nbsp; ;  = DestinationString<br />&nbsp; &nbsp; ;  = SkipTrailingZeros<br /><br />&nbsp; &nbsp; .PredictReturnValue:<br />&nbsp; &nbsp; &nbsp; XOR&nbsp; &nbsp; &nbsp;  ECX , ECX<br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .GetParameterValues:<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EDI , DWORD PTR  ; <br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  ESI , DWORD PTR  ; <br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EDX , DWORD PTR  ; <br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EAX , 0x00000020<br /><br />&nbsp; &nbsp; &nbsp; ; EDI = <br />&nbsp; &nbsp; &nbsp; ; ESI = <br />&nbsp; &nbsp; &nbsp; ; EDX = <br /><br />&nbsp; &nbsp; .CheckForNULLDestinationString:<br />&nbsp; &nbsp; &nbsp; TEST&nbsp; &nbsp; &nbsp; EDI , EDI<br />&nbsp; &nbsp; &nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; .EP<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .CheckForZeroInput:<br />&nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;  ECX<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EBX , 0x00000030<br />&nbsp; &nbsp; &nbsp; TEST&nbsp; &nbsp; &nbsp; ESI , ESI<br />&nbsp; &nbsp; &nbsp; JNZ&nbsp; &nbsp; &nbsp;  .CheckForSkippingTrailingZeros<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  DWORD PTR  , EBX&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; JMP&nbsp; &nbsp; &nbsp;  .SetResult <br /><br />&nbsp; &nbsp; .CheckForSkippingTrailingZeros:<br />&nbsp; &nbsp; &nbsp; TEST&nbsp; &nbsp; &nbsp; EDX , EDX<br />&nbsp; &nbsp; &nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; .PrepareToTransfer<br />&nbsp; &nbsp; &nbsp; .RemoveLeadingZeros:<br />&nbsp; &nbsp; &nbsp; &nbsp; DEC&nbsp; &nbsp; &nbsp;  EAX<br />&nbsp; &nbsp; &nbsp; &nbsp; SHL&nbsp; &nbsp; &nbsp;  ESI , 0x00000001<br />&nbsp; &nbsp; &nbsp; &nbsp; JNC&nbsp; &nbsp; &nbsp;  .RemoveLeadingZeros<br />&nbsp; &nbsp; &nbsp; &nbsp; RCR&nbsp; &nbsp; &nbsp;  ESI , 0x00000001<br />&nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;  EDX<br /><br />&nbsp; &nbsp; ; EDX = Free<br />&nbsp; &nbsp; ; ECX = Return Value<br />&nbsp; &nbsp; ; EBX = &#039;0&#039;, 0, 0, 0<br />&nbsp; &nbsp; ; EDI = <br />&nbsp; &nbsp; ; ESI = <br />&nbsp; &nbsp; ; EAX = Number of bits that we have to transfer to the destination string<br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .PrepareToTransfer:<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  DWORD PTR  , EBX<br />&nbsp; &nbsp; &nbsp; SHL&nbsp; &nbsp; &nbsp;  ESI , 0x00000001<br />&nbsp; &nbsp; &nbsp; JNC&nbsp; &nbsp; &nbsp;  .MoveForward<br />&nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;  DWORD PTR <br />&nbsp; &nbsp; &nbsp; .MoveForward:<br />&nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;  EDI<br />&nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;  ECX<br />&nbsp; &nbsp; &nbsp; &nbsp; DEC&nbsp; &nbsp; &nbsp;  EAX<br />&nbsp; &nbsp; &nbsp; &nbsp; JNZ&nbsp; &nbsp; &nbsp;  .PrepareToTransfer<br /><br />&nbsp; &nbsp; .SetResult:<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EAX , ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .EP:<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;  EAX , ECX<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;  EBP<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;  EDI<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;  ESI<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;  EDX<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;  ECX<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;  EBX<br />&nbsp; &nbsp; RET&nbsp; &nbsp; &nbsp;  (0x03 * 0x04)<br />; ——————————————————————————————————————————————————</code></pre></div>
    <div class="meta">Posted on 2008-06-28 15:13:56 by XCHG</div>
   </div>
  </div>
 </body>
</html>