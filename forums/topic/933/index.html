<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>UrlDecode - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=933" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=933">UrlDecode</a></p>
   <div class="post" id="post-6035">
    <div class="subject"><a href="#post-6035">UrlDecode</a></div>
    <div class="body">Hi,<br />I'm very new to this and after reading a few tutorials (thanks a lot for the exagone-tuts!) I now wanted to get a little practical. <br />So this is the first task I gave me. Writing an UrlDecode-DLL.<br />It took me a while but now it works :)!<br />But to me it looks very unstructured.<br />As you may see, I know very little opcodes and know very little about them. I'd really like to get to know better Assembler than that. Please teach me how to!<br />There are a few question:<br /><ul><br />[*]Is there an easyer way to convert 2 HexCars to a number?<br />[*]Does that &quot;cld&quot; have any relevance in this context?<br />[*]Is there a good way to take advantage of the &quot;rep&quot; command<br />[*]I feel very limited with creating a string of fixed length; Is there any other way but using the SysAllocStringByteLen?<br /><br /><br /><pre><code><br />UrlDecode proc  uses ecx , text&#58;DWORD<br />	LOCAL ReturnString$	&#58;DWORD<br />	LOCAL ln		&#58;DWORD<br />	LOCAL Occurencys	&#58;DWORD<br /><br />	push esi				;save esi and edi<br />	push edi<br /><br />	mov ecx, text<br />	xor eax, eax<br /><br />StartLengthLoop&#58;<br />	mov dl, &#91;ecx&#93;<br />	inc ecx					;GetStringLength<br />	cmp dl, &quot;%&quot;<br />	jne CharNotFound<br />	inc eax					;Count Occurency of &quot;%&quot;<br />CharNotFound&#58;<br />	cmp dl, 0<br />	jne StartLengthLoop<br /><br />	mov Occurencys, eax			;save &quot;%&quot;-Count as Occurencys<br />	sub ecx, text				;correct StringLength<br />	dec ecx<br />	shl eax, 1				;calculate NewStringLength<br />	sub ecx, eax<br /><br />	jns DontZeroEcx				;end if negative<br />	mov ecx, 0<br />DontZeroEcx&#58;<br /><br />	mov ln, ecx<br />	invoke SysAllocStringByteLen,0,ln	;Allocate Space for the resultString<br />	mov ReturnString$, eax<br />	<br />	cmp ln, 0				;End if Length is 0<br />	je TheEnd<br /><br />	mov esi, text				;Set Pointers to StringVars<br />	mov edi, ReturnString$<br />	mov ecx, ln				;zero ecx to use as counter<br />	cld<br /><br />	add ln, edi<br />	cmp Occurencys, 0			;Check whether there need to be made any replacements<br />	je NoHex<br /><br />StartLoop&#58;					;Start of the ReplacmentLoop<br />	mov al, &#91;esi&#93;				;copy current char<br />	cmp al, &quot;%&quot;				;compare to &quot;%&quot;<br />	jne CharNotFound2<br /><br />	xor eax, eax<br />	inc esi<br />	mov al, &#91;esi&#93;				;GetFirst HexChar<br /><br />	cmp al, 48				;Starting the HexConversion<br />	jl  NoValidHex<br />	cmp al, 57<br />	jg  HexChar<br />	sub al, 48<br />	jmp NextChar<br />HexChar&#58;<br />	cmp al, 65<br />	jl NoValidHex<br />	cmp al, 70<br />	jg SmallHex<br />	sub al, 55<br />	jmp NextChar<br />SmallHex&#58;<br />	cmp al, 97<br />	jl NoValidHex<br />	cmp al, 102<br />	jg NoValidHex<br />	sub al, 87<br />NextChar&#58;<br />	inc esi<br />	mov ah, &#91;esi&#93;				;Proceed with the next char<br /><br />	cmp ah, 48<br />	jl  NoValidHex2<br />	cmp ah, 57<br />	jg  HexChar2<br />	sub ah, 48<br />	jmp EndHex<br />HexChar2&#58;<br />	cmp ah, 65<br />	jl NoValidHex2<br />	cmp ah, 70<br />	jg SmallHex2<br />	sub ah, 55<br />	jmp EndHex<br />SmallHex2&#58;<br />	cmp ah, 97<br />	jl NoValidHex2<br />	cmp ah, 102<br />	jg NoValidHex2<br />	sub ah, 87<br />EndHex&#58;<br />	shl al, 4				;Put Results in the correct position<br />	add al, ah<br />	mov &#91;edi&#93;, al				;save<br />	jmp EndLoop<br />NoValidHex&#58;					;Char was no valid HexChar<br />	inc esi					;Correct the stringPointerPosition for correct StringLength<br />NoValidHex2&#58;<br />	mov al, &quot;%&quot;				;Just save an &quot;%&quot; if HexChars weren't valid<br />	mov &#91;edi&#93;, al<br />	jmp EndLoop<br />CharNotFound2&#58;<br />	cmp al, &quot;+&quot;				;if regular Char<br />	je ReplacePlus<br />	mov &#91;edi&#93;, al<br />	jmp EndLoop<br />ReplacePlus&#58;					;replace &quot;+&quot; with space<br />	mov al, 32<br />	mov &#91;edi&#93;, al<br />EndLoop&#58;<br />	inc esi					;StringPointer erh?hen<br />	inc edi<br />	cmp ln, edi				;end if OutputStringLength reached<br />	jg StartLoop<br />	jmp TheEnd<br />NoHex&#58;						;No &quot;%&quot; replaceing necessary<br />	;rep movsb<br />	mov al, &#91;esi&#93;<br />	cmp al, &quot;+&quot;				;Replacing of &quot;+&quot;s only<br />	je ReplacePlus2<br />	mov &#91;edi&#93;, al<br />	jmp NoPlus<br />ReplacePlus2&#58;<br />	mov al, 32<br />	mov &#91;edi&#93;, al<br />NoPlus&#58;<br />	inc esi<br />	inc edi<br />	cmp ln, edi<br />	jg NoHex<br />	jmp TheEnd<br />TheEnd&#58;<br />	mov al, 0				;terminate String<br />	mov &#91;edi&#93;, al<br /><br />	mov eax, ReturnString$			;return String<br /><br />	pop edi<br />	pop esi<br />	ret <br />UrlDecode endp <br /></code></pre></div>
    <div class="meta">Posted on 2001-09-04 03:44:54 by Butch77</div>
   </div>
   <div class="post" id="post-6101">
    <div class="subject"><a href="#post-6101">little update:</a></div>
    <div class="body">I replaced the HexConversion with this:<br /><br /><pre><code><br />	xor eax, eax<br />	inc esi<br />	mov ax, &#91;esi&#93;				;Get the 2 HexChars<br /><br />	mov dx,  ax				;Convert To Hex<br />	and dx,  16448				;01000000 01000000<br />	shr dx,  3<br />	add ax,  dx<br />	shr dx,  3<br />	add ax,  dx<br />	and eax, 3855				;00001111 00001111<br />	shl al,  4<br />	add al,  ah<br /><br />	mov &#91;edi&#93;, al<br />	inc esi<br />	jmp EndLoop<br /></code></pre><br /><br />I thought this would make it much faster. But it doesn't!<br />It just differs by 1%...<br />What takes the whole time?<br />I really need some good advices.<br /><br />Thanks</div>
    <div class="meta">Posted on 2001-09-04 10:26:37 by Butch77</div>
   </div>
   <div class="post" id="post-6380">
    <div class="subject"><a href="#post-6380">Algorithms::UrlDecode</a></div>
    <div class="body">Dang, I wish I could help you dude,  but I have no idea how to do what you are doing.</div>
    <div class="meta">Posted on 2001-09-06 15:18:39 by Kenny</div>
   </div>
   <div class="post" id="post-6393">
    <div class="subject"><a href="#post-6393">Algorithms::UrlDecode</a></div>
    <div class="body">Is there an easyer way to convert 2 HexCars to a number?  <br /><pre><code><br />; assumptions&#58; esi == addr to source info<br />; assumptions&#58; edi == addr to dest buffer.<br />  xor eax, eax<br />  xor ebx, ebx    ; used as a flag.. for leading zero's<br />  xor edx, edx<br />  mov ax, &#91;esi&#93;<br />  mov cx, 10000<br />@@&#58;<br />  div cx ; dx &lt; 10000, 1000, 100  etc. etc.<br />            ; ax == n in the set &#123;0-6&#125;<br />            ; ax == n in the set &#123;0-9&#125; for all else &#40;all other iterations&#41;<br />                      <br />  .if&#40; bx == 0&#41;&amp;&amp;&#40;ax != 0&#41;  ; leading 0's removal..<br />    mov ebx, 1<br />  .endif<br /><br />  .if&#40; bx==1 &#41;<br />     and ax, 30h    ; make it an ascii #<br />     mov &#91;edi&#93;, ax  ; save it<br />     inc edi<br />  .endif<br /><br />  push edx        ; save the remainder..<br /><br />  mov ax, dx      ; divide the divisor by 10.. ie do 1000's, 100's etc.<br />  xor edx, edx<br />  mov cx, 10<br />  div cx ; ax = cx / 10<br />  mov ecx, eax  ; update the divisor  <br /><br />  xor edx, edx   ; prepare for next loop<br />  pop eax          ; set the remainder to be divided..<br /><br />  cmp ecx, 0      ; see if were done... &#40; ie&#41; last div/10 was a fraction &#41;<br />  jne @B<br /></code></pre><br /><br />Didnt test this, but it should work...<br /><br />Does that &quot;cld&quot; have any relevance in this context?  <br /><br />None that i can tell.. expecially since you commented out the &quot;rep movsb&quot; command..<br /><br /><br />Is there a good way to take advantage of the &quot;rep&quot; command  <br /><br />Yes, expecially if you study the MemCopy fucntion in the MASM32Lib... <pre><code><br />MemCopy proc public uses esi edi Source&#58;PTR BYTE,Dest&#58;PTR BYTE,ln&#58;DWORD<br /><br />    ; ---------------------------------------------------------<br />    ; Copy ln bytes of memory from Source buffer to Dest buffer<br />    ;      ~~                      ~~~~~~           ~~~~<br />    ; USAGE&#58;<br />    ; invoke MemCopy,ADDR Source,ADDR Dest,4096<br />    ;<br />    ; NOTE&#58; Dest buffer must be at least as large as the source<br />    ;       buffer otherwise a page fault will be generated.<br />    ; ---------------------------------------------------------<br /><br />    cld<br />    mov esi, &#91;Source&#93;  ; Get source data addr<br />    mov edi, &#91;Dest&#93;     ; Get Dest data addr<br />    mov ecx, &#91;ln&#93;         ; total bytes to copy..<br /><br />    shr ecx, 2            ; divide total bytes/4 &#40;since DWORD loads 4 bytes&#41;<br />    rep movsd        ; copy from esi -&gt; edi, 4 byte incraments of data<br />                            ; untill ecx == 0 &#40;cld makes ecx count down by 1/rep&#41;<br /><br /><br />    mov ecx, &#91;ln&#93;  ; what about the remainder from origional div/4?<br />                          ; we cant forget to copy this as well.. so do by copy<br />                          ; up to 3 bytes..  so first load # again..<br />    and ecx, 3      ; and out all but the values less than 4 &#40;get remainder&#41;<br />    rep movsb     ; Perform remaining data copy of data with BYTES<br /><br />    ret                 ; done.. all copied from source to dest..<br /><br />MemCopy endp</code></pre><br /><br />I feel very limited with creating a string of fixed length; Is there any other way but using the SysAllocStringByteLen?  <br /><br />Never used it myself.. so i could tell you.. but you could allocate from the Heap or global memory if you want lots of room...  not sure which one.. but i believe one can be growable.. if you max it out.<br /><br />Hope this helps... <br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-06 18:06:43 by NaN</div>
   </div>
   <div class="post" id="post-6429">
    <div class="subject"><a href="#post-6429">Algorithms::UrlDecode</a></div>
    <div class="body">Thanks for the explanation! :alright:<br /><br />but you could allocate from the Heap or global memory <br />how does that work? Do you have any examples on that?<br /><br />Thanks</div>
    <div class="meta">Posted on 2001-09-07 02:58:37 by Butch77</div>
   </div>
   <div class="post" id="post-6457">
    <div class="subject"><a href="#post-6457">Algorithms::UrlDecode</a></div>
    <div class="body">Heap stuff...     <br /><br />invoke GetProcessHeap<br />invoke HeapAlloc, eax, NULL, # of bytes<br /><br />and to free the Heap mem...<br /><br />     invoke GetProcessHeap<br />     invoke HeapFree, eax, NULL, heap_mem_handle<br /><br /><br /><br />Global Mem.. see <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=14">this thread....</a> <br /><br /><br />Again, look up these API's to see which one is &quot;growable&quot;<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-07 09:52:52 by NaN</div>
   </div>
  </div>
 </body>
</html>