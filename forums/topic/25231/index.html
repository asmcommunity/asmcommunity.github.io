<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>The memory could not be &quot;written&quot;. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25231" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25231">The memory could not be &quot;written&quot;.</a></p>
   <div class="post" id="post-184603">
    <div class="subject"><a href="#post-184603">The memory could not be &quot;written&quot;.</a></div>
    <div class="body">The instruction at &quot;0x00401189&quot; referenced memory at &quot;0x00404000&quot;. The memory could not be &quot;written&quot;.<br /><br />I&#39;m not good enough at debugging, just observed this is the offending line:<br /><br /><pre><code>mov , eax</code></pre><br /><br />...and here is the whole code, help?<br /><br />...or http://wolfshade.home.ro/project.asm<br /><br />project.asm<br /><pre><code>.386<br /><br />.model flat,stdcall<br /><br />option casemap:none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\gdi32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />includelib \masm32\lib\gdi32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br /><br /><br />WinMain proto :DWORD, :DWORD, :DWORD, :DWORD<br />ChildWndProc proto :DWORD, :DWORD, :DWORD, :DWORD<br /><br />.data<br />ClassName db &quot;Parent&quot;, 0<br />ChildClassName db &quot;Child&quot;, 0<br />AppName db &quot;Project&quot;, 0<br /><br />.data?<br />hInstance dd ?<br />CommandLine dd ?<br />cxClient dd ?<br />cyClient dd ?<br />ChildIDsArray dd 13 dup(?)<br />i dd ?<br />temp1 dd ?<br />temp2 dd ?<br />temp3 dd ?<br /><br />.code<br />start:<br />	invoke GetModuleHandle, NULL<br />	mov?&nbsp; ?&nbsp; hInstance, eax<br /><br />	invoke GetCommandLine<br />	mov?&nbsp; ?&nbsp; CommandLine, eax<br /><br />	invoke WinMain, hInstance, NULL, CommandLine, SW_SHOWDEFAULT<br />	invoke ExitProcess, eax<br /><br />WinMain PROC hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:DWORD<br />	LOCAL wc:WNDCLASSEX<br />	LOCAL msg:MSG<br />	LOCAL hwnd:HWND<br />	<br />	mov wc.cbSize, SIZEOF WNDCLASSEX<br />	mov wc.style, CS_HREDRAW or CS_VREDRAW<br />	mov wc.lpfnWndProc, OFFSET WndProc<br />	mov wc.cbClsExtra, NULL<br />	mov wc.cbWndExtra, NULL<br />	push hInst<br />	pop wc.hInstance<br />	mov wc.hbrBackground, COLOR_WINDOW+1<br />	mov wc.lpszMenuName, NULL<br />	mov wc.lpszClassName, OFFSET ClassName<br />	invoke LoadIcon, NULL, IDI_APPLICATION<br />	mov wc.hIcon, eax<br />	mov wc.hIconSm, eax<br />	invoke LoadCursor, NULL, IDC_ARROW<br />	mov wc.hCursor, eax<br /><br />	invoke RegisterClassEx, ADDR wc<br /><br />	mov wc.lpfnWndProc, OFFSET ChildWndProc<br />	mov wc.cbWndExtra, 4<br />	mov wc.lpszClassName, OFFSET ChildClassName<br />	mov wc.hIcon, NULL<br /><br />	invoke RegisterClassEx, ADDR wc<br /><br />	invoke CreateWindowEx, NULL, ADDR ClassName, ADDR AppName,\<br />			WS_OVERLAPPEDWINDOW,\<br />			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\<br />			NULL, NULL, hInst, NULL<br />	mov hwnd, eax<br /><br />	invoke ShowWindow, hwnd, SW_SHOWNORMAL<br />	invoke UpdateWindow, hwnd<br /><br />	.WHILE TRUE<br />		invoke GetMessage, ADDR msg, NULL, 0, 0<br />		.BREAK .IF (!eax)<br />		invoke TranslateMessage, ADDR msg<br />		invoke DispatchMessage, ADDR msg<br />	.ENDW<br /><br />	mov?&nbsp; ?&nbsp; ?&nbsp;eax, msg.wParam<br />	ret<br />WinMain endp<br /><br />WndProc PROC hwnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />	.if uMsg==WM_CREATE<br />		xor ecx, ecx<br />		mov ecx, 12; i = 12<br />		push esi<br />		xor esi, esi<br />	label1::<br />		xor edx, edx<br />		mov edx, 13000<br />		add edx, ecx<br />		invoke CreateWindowEx, NULL, ADDR ChildClassName, NULL,\<br />			WS_CHILDWINDOW + WS_VISIBLE,\<br />			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\<br />			hwnd, edx, hInstance, NULL<br />		mov , eax<br />		add esi, 4<br />		loop label1<br />		pop esi<br /><br />	.elseif uMsg==WM_SIZE<br />		mov edx, lParam<br />		and lParam, 0FFFFh<br />		push lParam<br />		pop cxClient; Client width<br />		mov lParam, edx<br />		shr lParam, 16<br />		push lParam<br />		pop cyClient; Client height<br /><br />		mov temp2, 4<br />		fld temp2			; 4<br />		fld1 				; 1, 4<br />		fdivp ST(1), ST(0)	; 1/4<br />		fld cxClient		; cxClient, 1/4<br />		fmulp ST(1), ST(0)	; cxClient*(1/4)<br />		fstp temp2			; temp2 = ST(0), FPU stack balanced<br /><br />		mov temp3, 7<br />		fld temp3			; 7<br />		fld1 				; 1, 7<br />		fdivp ST(1), ST(0)	; 1/7<br />		fld cxClient		; cxClient, 1/7<br />		fmulp ST(1), ST(0)	; cxClient*(1/7)<br />		fstp temp3			; temp3 = ST(0), FPU stack balanced<br /><br />		xor ecx, ecx<br />		mov ecx, 4<br />		push esi<br />		xor esi, esi<br />	label2::<br />		mov i, esi<br /><br />		mov temp1, 3<br />		fld temp1			; 4<br />		fld i				; i, 4<br />		fdivp ST(1), ST(0)	; i/4<br />		fld cxClient		; cxClient, i/4<br />		fmulp ST(1), ST(0)	; cxClient*(i/4)<br />		fstp temp1			; temp1 = ST(0), FPU stack balanced<br /><br />		invoke MoveWindow, , temp1, 0, temp2, temp3, TRUE<br />		inc esi<br />		loop label2<br />		pop esi<br /><br />?&nbsp; ?&nbsp; .elseif uMsg==WM_DESTROY<br />		invoke PostQuitMessage, NULL<br /><br />	.else<br />		invoke DefWindowProc, hwnd, uMsg, wParam, lParam<br />		ret<br />	.endif<br />	xor eax,eax<br />	ret<br />WndProc endp<br /><br />ChildWndProc PROC hwnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />	LOCAL temp:DWORD<br />	LOCAL hdc:HDC<br />	LOCAL ps:PAINTSTRUCT<br />	LOCAL rect:RECT<br /><br />	.if uMsg==WM_CREATE<br />		invoke SetWindowLong,hwnd, 0, 0<br /><br />	.elseif uMsg==WM_LBUTTONDOWN<br />		invoke GetWindowLong, hwnd, 0<br />		xor eax, 1<br />		invoke SetWindowLong, hwnd, 0, eax<br />		invoke InvalidateRect, hwnd, NULL, FALSE<br />		<br />	.elseif uMsg==WM_PAINT<br />		invoke BeginPaint, hwnd, ADDR ps<br />		mov hdc, eax<br />		invoke GetClientRect, hwnd, addr rect<br />		invoke Rectangle, hdc, 0, 0, rect.right, rect.bottom<br />		<br />		invoke GetWindowLong, hwnd, 0<br />		.if eax<br />			invoke MoveToEx, hdc, 0, 0, NULL<br />			invoke LineTo, hdc, rect.right, rect.bottom<br />			invoke MoveToEx, hdc, 0, rect.bottom, NULL<br />			invoke LineTo, hdc, rect.right, 0<br />		.endif<br />		invoke EndPaint, hdc , ADDR ps<br />		<br />	.else<br />		invoke DefWindowProc, hwnd, uMsg, wParam, lParam<br />	<br />	.endif<br />	xor eax, eax<br />	ret<br />ChildWndProc endp<br />end start</code></pre></div>
    <div class="meta">Posted on 2006-08-20 06:45:44 by w0lfshad3</div>
   </div>
   <div class="post" id="post-184605">
    <div class="subject"><a href="#post-184605">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">Classic example of register preservation problem :)<br /><br />Whenever you call a piece of external code, you should assume that EAX,ECX,EDX are destroyed - this means that ECX, your loop counter, is not reliable after the call to CreateWindowEx. Either push/pop it, or use a non-volatile register (EBX,ESI,EDI) for loop control.<br /><br />And remember that EBX,ESI,EDI need to be preserved in callbacks, so if you use any of them you need either manual push/pop, or add the register(s) to the &quot;USES&quot; clause of the proc.<br /></div>
    <div class="meta">Posted on 2006-08-20 06:57:20 by f0dder</div>
   </div>
   <div class="post" id="post-184607">
    <div class="subject"><a href="#post-184607">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">changed this: now all registers i use are push/pop but i get same error only it sais it can&#39;t &quot;read&quot; at that memory location; temp is a local double word variable, ChildIDsArray changed type to HWND wich is still a double word as before i think.<br /><br /><pre><code>label1::<br />		mov edx, 13000<br />		add edx, ecx<br />		mov temp, edx<br />		push ecx<br />		push esi<br />		invoke CreateWindowEx, NULL, ADDR ChildClassName, NULL,\<br />			WS_CHILDWINDOW + WS_VISIBLE,\<br />			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\<br />			hwnd, , hInstance, NULL<br />		pop esi<br />		mov , eax<br />		add esi, 4<br />		pop ecx<br />		loop label1<br />		pop esi</code></pre><br /><br />In Petzold example the ChildIDsArray(wich are handles but still DWORD integers) are defined as static at file scope wich still means global i think in asm terms except for c it means they can only be accesed directly at that file scope.<br />I can&#39;t see the problem now, array memory is &quot;reserved&quot; for use at run-time, and everything else should work.</div>
    <div class="meta">Posted on 2006-08-20 07:37:32 by w0lfshad3</div>
   </div>
   <div class="post" id="post-184608">
    <div class="subject"><a href="#post-184608">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">I&#39;m in the process of fixing up your code, will post a bit later, if the thunder doesn&#39;t nuke my computer ;)<br /></div>
    <div class="meta">Posted on 2006-08-20 08:10:45 by f0dder</div>
   </div>
   <div class="post" id="post-184612">
    <div class="subject"><a href="#post-184612">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">lol k thank you very much, (thunder go away please :) well actually i will check again tomorrow.<br />I don&#39;t think i know to use a debugger properly(thank godness for VC7 catching it).<br />so i always see a tooltip when i look at that particular array+esp where esp is 4503 or such always, is that the real value that it holds when it gets there?, and that means my push/pops were useless?</div>
    <div class="meta">Posted on 2006-08-20 08:57:56 by w0lfshad3</div>
   </div>
   <div class="post" id="post-184613">
    <div class="subject"><a href="#post-184613">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">Visual Studio has a pretty decent debugger, but you&#39;ll probably be better off with OllyDebug for debugging your own assembly apps.<br /><br />There&#39;s more problems with your code than just a few push/pop issues, I&#39;m going to upload &quot;fixed&quot; source file + highlighted diffs of the changes once I&#39;m done. Be patient :)<br /></div>
    <div class="meta">Posted on 2006-08-20 09:07:23 by f0dder</div>
   </div>
   <div class="post" id="post-184625">
    <div class="subject"><a href="#post-184625">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">Yes :) like having DWORD variables to store floating point values instead of QWORD, and after all that needing to pass the values truncated to an integer actually to the function; and the same problem with MoveWindow like i have in this one.<br />I really need to learn to track my variables values in code.<br /><br />EDIT: still stuck learned to debug a bit i can&#39;t tell yet whats the prob except ESI doesn&#39;t contain what i want at that time alltough in the debugger the code appears as i intended it to work.</div>
    <div class="meta">Posted on 2006-08-20 18:24:26 by w0lfshad3</div>
   </div>
   <div class="post" id="post-184688">
    <div class="subject"><a href="#post-184688">Re: The memory could not be &quot;written&quot;.</a></div>
    <div class="body">This did the trick however my code doesn&#39;t do what its suppose to do; make each child window appear as a rectangle and when it gets a mouse click draw an &quot;X&quot; on it, it uses a flag made out of window extra bytes; the code is made after i learned the &quot;checker3&quot; program of Charles Petzold&#39;s Programming Windows.<br /><br />Think you can point me to what going wrong?<br /><br /><pre><code>mov ecx, 4<br />		push esi<br />		xor esi, esi<br />		push edi<br />		xor edi, edi<br />	label2::<br />		mov i, edi<br /><br />		mov temp1, 3<br />		fld temp1			; 4<br />		fld i				; i, 4<br />		fdivp ST(1), ST(0)	; i/4<br />		fld cxClient		; cxClient, i/4<br />		fmulp ST(1), ST(0)	; cxClient*(i/4)<br />		fstp temp1			; temp1 = ST(0), FPU stack balanced<br />		<br />		push ecx<br />		push esi<br />		push edi<br />		invoke MoveWindow, , temp1, 0, temp2, temp3, TRUE<br />		pop edi<br />		inc edi<br />		pop esi<br />		add esi, 4<br />		pop ecx<br />		loop label2<br />		pop esi</code></pre></div>
    <div class="meta">Posted on 2006-08-21 20:36:37 by w0lfshad3</div>
   </div>
  </div>
 </body>
</html>