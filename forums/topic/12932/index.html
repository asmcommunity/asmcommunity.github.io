<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Stack - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12932" />
    <link rel="next" href="../?id=12932&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12932">Stack</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12932&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12932&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12932" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12932&amp;page=2">&gt;</a><a href="../?id=12932&amp;page=2">&raquo;</a></form>   <div class="post" id="post-100455">
    <div class="subject"><a href="#post-100455">Stack</a></div>
    <div class="body">Okay I just wrote something on the stack....<br /><br />Stack<br />The stack is a place where data could be stored and revived (well, sort of), and place where parameters, local variables are stored. esp and ebp are stack-related pointers. esp is the stack pointer, while ebp is the base pointer. When you enter/step into most functions, usually a stack frame would be created, and you can use ebp to access parameters and local variables. However functions can be created without the creating of a stack frame. An *important* point to note is that the stack should be aligned to DWORD (align to 4), if not it would raise some general protection fault (or simply known as GPF), and *NT* are extremely touchy to stack alignment issue. <br /><br />Furthermore it is stated on an intel document that &quot;A misaligned access in the data cache or on the bus costs at least three extra clock cycles on boundary, costs nine to twelve clock cycles on Pentium Pro and Pentium II processors. Intel recommends that data be aligned on the following boundaries for the best execution performance on all processors:<br />1) Align 8-bit data on any boundary<br />2) Align 16-bit data to be contained within an aligned 4-byte word<br />3) Align 64-bit data on any boundary which is a multiple of eight<br />4) Align 80-bit data on a 128-bit boundary (that is, any boundary which is a multiple of 16 bytes)&quot;<br /><br />Example (MASM):<br />.386<br />.model flat,stdcall<br />option casemap:none<br />include /masm32/include/user32.inc<br />include /masm32/include/kernel32.inc<br />includelib /masm32/lib/user32.lib<br />includelib /masm32/lib/kernel32.lib<br />.code<br />start:<br />jmp @F<br />testing db &quot;Stack needs to be aligned to dword&quot;<br />@@:<br />sub esp,2 ;remove the dword align, the code would definitely crash on *NT* system<br />invoke MessageBox,0,OFFSET testing,0,0<br />invoke ExitProcess,0<br />end start<br /><br />Now, more about stacks and its related opcodes. The most common opcodes related to the stack are 'push' and 'pop'. The usage is something like push eax, as in you push the data on eax to the stack. The esp (which holds the pointer to the stack) is then decemented by the size of data you pushed onto the stack. Similarly,when you pop eax, the data to the stack is moved to eax. The esp is then incremented by the size of the data moved from the stack.<br /><br />Example<br />push eax ; = mov ,eax sub esp,4<br />pop eax ; = mov eax, add esp,4<br /><br />However, it is said that mov is faster than pushes and pops. Thus some member (stryker/arkane) at the forums (win32asm) have camed out with the xcall marco which is supposed to be faster than invokes, as it replaces all the pushes with mov and sub. Of course there are some limitations which are that the marco cannot handle direct memory and cannot handle BYTE, WORD, QWORD, TBYTE size parameters (Well, who uses parameters other than DWORD nowadays?).<br /><br />;by gfalen<br />@str MACRO _str:VARARG<br />    LOCAL @@1<br />    IF @InStr(1, &lt;_str&gt;, &lt;!&quot;&gt; )<br />        .DATA<br />            @@1 DB _str, 0<br />        .CODE<br />        EXITM &lt;OFFSET @@1&gt;<br />    ELSE<br />        EXITM &lt;_str&gt;<br />    ENDIF<br />ENDM<br /><br />;by stryker<br />xcall MACRO function:REQ, parameters:VARARG<br />    LOCAL psize, paddr, plen<br />    IFNB &lt;parameters&gt;<br />        psize = 0<br />        FOR param, &lt;parameters&gt;<br />            psize = psize + 4<br />        ENDM<br />        IF psize EQ 4<br />            push parameters<br />        ELSE<br />            sub esp, psize<br />            psize = 0<br />            FOR param, &lt;parameters&gt;<br />                IF @SizeStr(&lt;param&gt; ) GT 4<br />                    paddr SUBSTR &lt;param&gt;, 1, 5<br />                    IFIDNI paddr, &lt;ADDR &gt;<br />                        paddr SUBSTR &lt;param&gt;, 6, @SizeStr(&lt;param&gt; ) - 5<br />                        lea eax, paddr<br />                        mov DWORD PTR , eax<br />                    ELSE<br />                        mov DWORD PTR , @str(&lt;param&gt; )<br />                    ENDIF<br />                ELSE<br />                    mov DWORD PTR , @str(&lt;param&gt; )<br />                ENDIF<br />                psize = psize + 1<br />            ENDM<br />        ENDIF<br />    ENDIF<br />    call function<br />ENDM<br /><br />The uses of push and pop are to store data temporarily (store data on the stack) and to pass parameter (pop are not used though). There are some opcodes that help to store and later restore values in the registers. They are namely pushad (pusha being the 16bit version), popad (popa being the 16bit version), pushfd (pushf being the 16bit version) and popfd (popf being the 16bit version). For pushad, all general registers are pushed onto the stack in the following order: eax, ecx, edx, ebx, esp ,ebp, esi and edi. For popad, the registers are popped off the stack in the following order: edi, esi, ebp, esp, edx, ecx, eax. For pushfd, the Flags register (EFLAGS) is transferred onto the stack. For popfd, the data from the stack are popped into the Flags register (EFLAGS). <br /><br />Stack frame<br />Eariler on, I have mentioned that ebp is the base pointer and its uses are to access the local variables and parameters passed to the function. Below I have listed a sample MASM code (MASM have certain internal macro, one of it is to create an internal stack frame) and the code produced (viewed from a disassembler). The following codes shows how parameters can be access, and how a stack frame is created so as to access the parameter with ebp.<br /><br />test47 proc par1:DWORD,para2,para3,para4<br />mov eax,par1<br />mov ecx,par2<br />mov edx,par3<br />mov ebx,par4<br />ret<br />test47 endp<br /><br />*becomes* this after compiling (due to some MASM internal macros, which sets up the stack frame)<br /><br />test47:<br />push ebp ; store value of ebp on stack<br />mov ebp,esp ; copy value of esp to ebp<br />mov eax, ; original value of ebp stored at , DWORD PTR = par1<br />mov ecx, ; DWORD PTR  = par2<br />mov edx, ; DWORD PTR  = par3<br />mov ebx, ; DWORD PTR  = par4<br />leave<br />ret 10h ; sizeof parameters * number of parameters = 4*4<br /><br />The code &quot;push ebp&quot; and &quot;mov ebp,esp&quot; creates a stack frame. The instruction &quot;leave&quot; removes the stack frame by esp and ebp back to their condition before the stack frame is initialized. the &quot;ret 10h&quot; tells the processor to transfers control from the procedure back to the instruction address saved on the stack (surprise, surprise the stack is used to store the initial value of ip when &quot;calling&quot; a function. The the address of the function is loaded to eip and code continues with excution according to eip), and then 'release' 16 bytes. One may ask why the first parameter is stored in DWORD PTR and not DWORD PTR. This is due to the fact that ebp is pushed onto the stack, thus DWORD PTR contains the original value of ebp. Parameters could be accessed via DWORD PTR <br /><br />The above code shows how a stack frame is created and how ebp is used to access the parameters passed to the functions. The following code (MASM) would show how ebp can be used to access local variables (Local variables are acutally data *stored* on the stack).<br /><br />test124 proc par1:DWORD,para2,para3,para4<br />LOCAL buffer[32]:BYTE<br />LOCAL dd1:DWORD<br />LOCAL dd2:DWORD<br />mov eax,dd1<br />mov dd2,eax<br />lea eax,buffer<br />ret<br />test124 endp<br /><br />*becomes* this after compiling (due to some MASM internal macros, which sets up the stack frame)<br /><br />test124:<br />push ebp<br />mov ebp,esp<br />add esp, -28h ; to ensure that the local variables are not corrupted by data pushed onto the stack<br />mov eax, ; DWORD PTR  = dd1<br />mov ,eax ; DWORD PTR  = dd2<br />lea eax, ;  = address of first byte in the array<br />leave<br />ret 10h ; sizeof parameters * number of parameters = 4*4<br /><br />Okay, so the code is almost similar to the above code, creating a stack frame. The instruction &quot;add esp,-28h&quot; might seem weird, but it has its purpose. It is to ensure the values stored in local variables are not corrupted any data when something is pushed onto the stack. (Hopefully I do make some sense.) However I cannot comprehend why MASM produce &quot;add esp,-28h&quot; instead of &quot;sub esp,28h&quot;. Maybe it is due to some macro defined deep into MASM. Local variables differ from parameters in the fact that they are accessed by negative displacement (Remember the fact that when you push something, the value of esp would decrease). I think it would be easier to understand how to access local variables by examining how to calculate the displacement needed to access a certain local variable (by looking at the above example) than my explanation. <br /><br />Some code *gurus* definitely cares about how big the code size and how fast their code runs. To optimise their code, they might even not have a stack frame in their functions (Yes, it is possible and I would show you how). Removing stack frame can shave off some clocks and some bytes (push ebp = 1byte, mov ebp,esp = 2 byte, leave = 1 byte, total bytes saved = 4). When stack frame is removed, remember that pushing data would cause a change in the value of esp. You need to manually adjust the offsets from esp. Also, if you don't have a stack frame you don't want 'leave'. The following codes are ways to create functions without stack frame. <br /><br />call function1<br />...<br />function1:<br />nop ; to represent whatever code present <br />ret 4*numberofparameter<br /><br />or<br /><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />function2 proc par1:DWORD,par2,par3,par4<br />nop ; to represent whatever code present <br />ret 4*4<br />function2 endp<br />OPTION PROLOGUE:PROLOGUEDEF<br />OPTION EPILOGUE:EPILOGUEDEF<br /><br />or<br /><br />function3 proc<br />par1 equ &lt;esp+4&gt;<br />par2 equ &lt;esp+8&gt;<br />par3 equ &lt;esp+12&gt;<br />par4 equ &lt;esp+16&gt;<br />nop ; to represent whatever code present <br />ret 4*4<br />function3 endp<br /><br />And so this concludes my discussion on stack. Thank you and have a nice day.<br /><br /></div>
    <div class="meta">Posted on 2003-05-01 01:58:41 by roticv</div>
   </div>
   <div class="post" id="post-100483">
    <div class="subject"><a href="#post-100483">Stack</a></div>
    <div class="body">Nice work roticv, even if the order things are presented is a bit messy :) - you cover a good amount of things though. Misaligned stack doesn't necessarily give GPF, but it does have weird effects - and it's true that especially NT is _very_ picky.<br /><br />Since you're also covering data alignment a bit, it's worth noting that SSE2 requires 16byte data alignment - unless you use the much slower non-aligned instructions. Using the standard load/store on nonaligned adresses gives an exception (privileged instruction, iirc).<br /><br />It's worth mentioning that you shouldn't push word-sized data to the stack, as you get the dreaded misalign that way.<br /><br />It's worth mentioning that &quot;ret 10h&quot; is because of the STDCALL calling convention, while C calling convention would only do &quot;ret&quot; and leave it to the caller to adjust esp. Instead of &quot;release 16 bytes&quot;, perhaps say &quot;add esp, 16 - thereby removing function parameters from the stack&quot;.<br /><br />Perhaps rewrite the whole &quot;It is to ensure the values stored in local variables are not corrupted any data when something is pushed onto the stack.&quot; thing as &quot;reserve stack space for local variables&quot;... might still be worth explaining the &quot;to avoid push trashing local variables&quot; thing.<br /><br />Usually, the reason for not using a stack frame is either that you don't need it, or that you want to use EBP as a general purpose register - not so much to save the push ebp :). Push/pop ebp would still be needed if you want to use EBP as a general purpose register, since you have to return it in it's original state.<br /><br />You should also add that if you don't use a stack frame, you cannot use local variables (in the automated masm way), nor can you access function parameters the usual way - you have to handcode (well, unless somebody has macros) all ESP references, and remember to further adjust these if you do push/pop.</div>
    <div class="meta">Posted on 2003-05-01 03:50:25 by f0dder</div>
   </div>
   <div class="post" id="post-100484">
    <div class="subject"><a href="#post-100484">Stack</a></div>
    <div class="body">roticv,<br /><br />If you are worried about stack alignment to 4, this macro will probably do the job OK.<br /><br /><pre><code><br />      align_4 MACRO reg<br />        add reg, 3<br />        shr reg, 2<br />        shl reg, 2<br />      ENDM<br /><br />    align_4 esp<br /><br /></code></pre><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-05-01 03:54:09 by hutch--</div>
   </div>
   <div class="post" id="post-100485">
    <div class="subject"><a href="#post-100485">Stack</a></div>
    <div class="body">hutch, the stack alignment problem is more an issue with &quot;push wordsized_variable&quot; - under normal operation, you don't really need to do any stack alignment, except perhaps if you're 16-byte aligning your local stack variables for speed and/or SSE2 compliance.</div>
    <div class="meta">Posted on 2003-05-01 03:56:30 by f0dder</div>
   </div>
   <div class="post" id="post-100491">
    <div class="subject"><a href="#post-100491">Stack</a></div>
    <div class="body">f0dder,<br /><br />I am sure roticv know how to use any suggestion I make without assistance.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-05-01 04:20:36 by hutch--</div>
   </div>
   <div class="post" id="post-100502">
    <div class="subject"><a href="#post-100502">Stack</a></div>
    <div class="body"><div class="quote"><br />roticv,<br /><br />If you are worried about stack alignment to 4, this macro will probably do the job OK.<br /><br /><pre><code><br />      align_4 MACRO reg<br />        add reg, 3<br />        shr reg, 2<br />        shl reg, 2<br />      ENDM<br /><br />    align_4 esp<br /><br /></code></pre><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a> </div>Why not instead:<br /><pre><code><br />      align_4 MACRO reg<br />        add reg, 3<br />        and reg, 0FFFFFFFCh<br />      ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2003-05-01 05:01:37 by Maverick</div>
   </div>
   <div class="post" id="post-100508">
    <div class="subject"><a href="#post-100508">Stack</a></div>
    <div class="body">maverick,<br /><br />I like it. :alright: <br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-05-01 05:09:27 by hutch--</div>
   </div>
   <div class="post" id="post-100509">
    <div class="subject"><a href="#post-100509">Stack</a></div>
    <div class="body">Maverick, what about a generic align (well, only powers of two are necessary).<br />Manually aligning stack to 4 is a bit silly, since it automatically is under normal circumstances.<br />The problem with unaligned stack that roticv is describing comes from pushing word-sized variables - a &quot;no-no&quot; under win32, which should be fixed instead of doing symptomatic treatment.<br /><br />A general align macro is useful though, and could be used for aligning locals to, say, 16 byte alignment as required by SSE2 data.</div>
    <div class="meta">Posted on 2003-05-01 05:14:43 by f0dder</div>
   </div>
   <div class="post" id="post-100512">
    <div class="subject"><a href="#post-100512">Stack</a></div>
    <div class="body"><strong></strong><br />a general ALIGN macro would be extremely simple, but too much assembler-dependent, that's why I'll refrain from showing any.<br /><br />In any case, it's just a simple:<br /><pre><code><br />        ADD     Reg,Alignment + AlignmentOffset - 1<br />        AND     Reg,-Alignment<br /></code></pre><br />I see aligning stack on arbitrary  boundaries as a very useful feature, in some situations. The way I visualize it is just &quot;stack is local memory, quickly allocable/freeable&quot;. So it's natural that in some weird, rare but certainly possible cases, one may need a certain alignment.<br />I used to align to e.g. 256 in some gfx routines, when the partial register stalls typical of the P6 core were still a thing to come. But there's still some need left in specifying arbitrary Alignment and AlignmentOffset heap and stack allocations.</div>
    <div class="meta">Posted on 2003-05-01 05:34:16 by Maverick</div>
   </div>
   <div class="post" id="post-100513">
    <div class="subject"><a href="#post-100513">Stack</a></div>
    <div class="body">Thanks for your comments :) I will make neccessary change s and addition.:alright: I almost thought no one read this thread... hehehe</div>
    <div class="meta">Posted on 2003-05-01 06:25:40 by roticv</div>
   </div>
   <div class="post" id="post-100514">
    <div class="subject"><a href="#post-100514">Stack</a></div>
    <div class="body">Roticv, after some work is done on it, this could end up a pretty useful addition to the FAQ section.<br />:alright:</div>
    <div class="meta">Posted on 2003-05-01 06:27:16 by f0dder</div>
   </div>
   <div class="post" id="post-100520">
    <div class="subject"><a href="#post-100520">Stack</a></div>
    <div class="body">roticv,<br /><br />&quot;surprise, surprise the stack is used to store the <strong>initial value of ip</strong> when &quot;calling&quot; a function. &quot;<br /><br />and here:<br />&quot;This is due to the fact that ebp is pushed onto the stack, thus DWORD PTR contains the <strong>original value of ebp.</strong>&quot;<br />and here:<br />push eax ; =<strong>mov ,eax sub esp,4</strong><br /><br />Are you sure?<br />What is better for <strong>you</strong>: to have a stack frame or to haven't?<br /><br /><br />&quot;DWORD PTR &quot;<br />What is positionofparameter? 0,1,2,3   or 1,2,3, 4<br /><br />&quot;(Local variables are acutally data *stored* on the stack).&quot;<pre><code><br /><br />test124 proc par1&#58;DWORD,para2,para3,para4<br />LOCAL buffer&#91;32&#93;&#58;BYTE<br />LOCAL dd1&#58;DWORD<br />LOCAL dd2&#58;DWORD<br />mov eax,dd1	; in eax -&gt;garbage due to dd1 isn't initialized<br />mov dd2,eax              ; you must write something in dd1<br />lea eax,buffer	; before reading <br />ret                                 <br />test124 endp</code></pre><br /><br />&quot;However I cannot comprehend why MASM produce &quot;add esp,-28h&quot; instead of &quot;sub esp,28h&quot;.<br />Maybe it is due to some macro defined deep into MASM. &quot;<br /><br />and<br /><br />&quot;Of course there are some limitations which are that the marco cannot handle direct memory and cannot handle BYTE, WORD, QWORD, TBYTE size parameters..&quot;<br /><br />Just don't use macros and other HLL stuff (due to it &quot;hides&quot; and limits the things)<br />and you will have the freedom  to write what you want including non 286asm code! It is assembly...<br /><br />&quot;(Well, who uses parameters other than DWORD nowadays?).&quot;<br />Who uses sub/mov rather then push/pop! The stack is just a memory...<br /><br />&quot;This is due to the fact that ebp is pushed onto the stack, thus DWORD PTR contains the original value of ebp&quot;<br />What do you have at  DWORD PTR?<br /><br />&quot;The uses of push and pop are to store data temporarily (store data on the stack) and to pass parameter (<strong>pop are not used though</strong>).&quot;<br />Why not?<pre><code><br />strlen&#58;<br />           pop  ecx	; ecx = return address	<br />          &#91;B&#93;pop eax	; eax = parameter-&gt;lpstr&#91;/B&#93;<br />           push  ecx	; ecx = return address	<br />           .....	; strlen code<br />           ....	 	<br />            ret 	   ; rather then &#91;B&#93;ret 4&#91;/B&#93;</code></pre><br /><br />You can substitute:<br /><br />&quot;code *gurus*&quot; <br />with &quot;people&quot;<br /><br />&quot;And so this concludes my discussion on stack. Thank you and have a nice day.&quot;<br />with &quot;To be continued...&quot;<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-01 06:55:19 by lingo12</div>
   </div>
   <div class="post" id="post-100628">
    <div class="subject"><a href="#post-100628">Stack</a></div>
    <div class="body">hutch,<br />you can find the original here:<br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=7342&amp;perpage=15&amp;highlight=and%20eax%200FFFFFFFCh&amp;pagenumber=2">http://www.asmcommunity.net/board/showthread.php?threadid=7342&amp;perpage=15&amp;highlight=and%20eax%200FFFFFFFCh&amp;pagenumber=2</a><br /><pre><code><br />&quot;Huh try this instead&#58;<br />add eax, 3<br />and eax, 0FFFFFFFCh<br /><br />Mirno&quot;<br /><br /><br />&quot;A more general solution would be this&#58;<br />add eax, R-1<br />and eax, -R<br />where R is the power of two you want to round up to.<br /><br />Gliptic&quot;</code></pre><br /><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-01 17:34:23 by lingo12</div>
   </div>
   <div class="post" id="post-100647">
    <div class="subject"><a href="#post-100647">Stack</a></div>
    <div class="body"><div class="quote"><br />Now, more about stacks and its related opcodes. The most common opcodes related to the stack are 'push' and 'pop'. The usage is something like push eax, as in you push the data on eax to the stack. The esp (which holds the pointer to the stack) is then decemented by the size of data you pushed onto the stack. Similarly,when you pop eax, the data to the stack is moved to eax. The esp is then incremented by the size of the data moved from the stack.<br /><br />Example<br />push eax ; = mov ,eax sub esp,4<br />pop eax ; = mov eax, add esp,4<br /></div><br /><br />A slight error it seems... <br />Actually, push decrements the stack pointer and then stores the data at the new pointer location... <br /><br /><pre><code><br />         push eax ;<br />                         ; = sub esp,4<br />                         ;  mov &#91;esp&#93;,eax <br />         pop eax ;<br />                         ; = mov eax,&#91;esp&#93;<br />                         ;   add esp,4<br /></code></pre></div>
    <div class="meta">Posted on 2003-05-01 21:59:55 by V Coder</div>
   </div>
   <div class="post" id="post-100771">
    <div class="subject"><a href="#post-100771">Hey...,</a></div>
    <div class="body">What about word push? will it crashes on NT?.<br /><br />So Ret 4 is releasing 4 byte at stack is not it ?<br /><br /><pre><code><br /><br />Push X    ; Sub ESP, 4<br />push Y    ; Sub ESP,4 , so ESP is Sub by 8<br />mov eax,&#91;esp&#93; ; Test the values<br />ret 8   ;Release 8 byte.<br /></code></pre><br /><br />huh ?</div>
    <div class="meta">Posted on 2003-05-02 09:59:15 by realvampire</div>
   </div>
   <div class="post" id="post-100777">
    <div class="subject"><a href="#post-100777">Stack</a></div>
    <div class="body">Lingo,<br /><br />Thanks for the link to the old thread, my head always blocked to any &quot;magic number&quot; type algos but the two examples do make sense of how it works.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-05-02 10:14:43 by hutch--</div>
   </div>
   <div class="post" id="post-100812">
    <div class="subject"><a href="#post-100812">Re: Hey...,</a></div>
    <div class="body"><div class="quote"><br />What about word push? will it crashes on NT?.<br /><br />So Ret 4 is releasing 4 byte at stack is not it ?<br /><br /><pre><code><br /><br />Push X    ; Sub ESP, 4<br />push Y    ; Sub ESP,4 , so ESP is Sub by 8<br />mov eax,&#91;esp&#93; ; Test the values<br />ret 8   ;Release 8 byte.<br /></code></pre></div>PUSH won't crash. But the above code will. RET will attempt to use Y as the return address.<br /><br />RET n works this way:<br /><br />Step 1: pop the EIP value first<br />Step 2: pop n bytes (assumed to be the function arguments)</div>
    <div class="meta">Posted on 2003-05-02 15:30:31 by tenkey</div>
   </div>
   <div class="post" id="post-100913">
    <div class="subject"><a href="#post-100913">Stack</a></div>
    <div class="body">word-sized pushes (ie, unaligned stack) won't necessarily _crash_ on NT - though there's a good chance it might. However, stuff will &quot;work very weird&quot; - the easiest example is to &quot;sub esp, 2&quot; and show a MessageBox.</div>
    <div class="meta">Posted on 2003-05-03 06:35:17 by f0dder</div>
   </div>
   <div class="post" id="post-102142">
    <div class="subject"><a href="#post-102142">Stack</a></div>
    <div class="body">Yes I was mistaken. push eax = sub esp, 4 mov ,eax<br /><div class="quote"><br />&quot;This is due to the fact that ebp is pushed onto the stack, thus DWORD PTR contains the original value of ebp&quot;<br />What do you have at DWORD PTR?<br /></div><br />dword ptr  = return address</div>
    <div class="meta">Posted on 2003-05-09 09:17:53 by roticv</div>
   </div>
   <div class="post" id="post-102148">
    <div class="subject"><a href="#post-102148">Ahah...</a></div>
    <div class="body">So it will work<br /><br /><pre><code><br /><br />push eax<br />push ecx<br />mov esp,ebp<br />ret<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-05-09 09:44:08 by realvampire</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12932&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12932&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12932" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12932&amp;page=2">&gt;</a><a href="../?id=12932&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>