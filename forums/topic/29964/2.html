<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Assembler Engine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29964" />
  <link rel="prev" href="../?id=29964&amp;page=1" />  <link rel="next" href="../?id=29964&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29964">Assembler Engine</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29964&amp;page=1" style="">&laquo;</a><a href="../?id=29964&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29964" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29964&amp;page=3">&gt;</a><a href="../?id=29964&amp;page=4">&raquo;</a></form>   <div class="post" id="post-211733">
    <div class="subject"><a href="#post-211733">Re: First successful selection of Opcode Encoding Rule</a></div>
    <div class="body">A crapload more screwing around with type-tagging, and some light editing of the two grammar files, and I&#039;ve finally got the assembler finding a matching encoding for my example input opcode statement :D<br /><br />For the input &quot;mov dword ptr,0&quot;<br /><br />the program is telling me I should be using this encoding:<br /><div class="quote"><br />#Identifier# MOV Tag0&nbsp;  #r/m32# r/m32 Tag7&nbsp;  #,# , Tag0&nbsp;  #imm32# imm32 Tag10&nbsp;  #;# ; Tag0&nbsp;  #o32# o32 Tag0&nbsp;  #Hex# C7 Tag0&nbsp;  #/# / Tag0&nbsp;  #Int# 0 Tag0&nbsp;  #id# id Tag0&nbsp;  #[# [ Tag0&nbsp;  #386# 386 Tag0&nbsp;  #]# ] Tag0&nbsp;  #NewLine# <br /> Tag0&nbsp;  <br /></div><br />which if you look closely, the opcode is C7.<br /><br />MASM assembles this statement to:<br />C7 00 00000000<br /><br />That 00 by itself is the R/M byte - and again, the encoding shows us that the encoding expects that the first operand be encoded using the r/m32 encoding table.<br /><br />So - although I don&#039;t yet emit the actual encoding as per the descriptor, I am damn close, and I am a happy man.<br /></div>
    <div class="meta">Posted on 2010-05-16 07:18:01 by Homer</div>
   </div>
   <div class="post" id="post-211750">
    <div class="subject"><a href="#post-211750">Re: Assembler Engine</a></div>
    <div class="body"><br />I&#039;ve decided to make some dramatic changes to the Opcode grammar rules in the Main grammar.<br />I want to be a lot more expressive and descriptive in my opcode rules.<br /><br /><div class="quote"><br />&lt;reg8&gt;&nbsp; ::= AL | CL | DL | BL | AH | CH | DH | BH | R8<br />&lt;reg16&gt; ::= AX | CX | DX | BX | SP | BP | SI | DI | R16<br />&lt;reg32&gt; ::= EAX | ECX | EDX | EBX | ESP | EBP | ESI | EDI | R32<br />&lt;reg64&gt; ::= RAX | RCX | RDX | RBX | RSP | RBP | RSI | RDI | R64<br />&lt;regfpu&gt; ::= ST0 | ST1 | ST2 | ST3 | ST4 | ST5 | ST6 | ST7<br />&lt;segreg&gt; ::= CS | DS | ES&nbsp; | FS | GS | SS | segreg<br />&lt;creg&gt; ::= CR0 | CR2 | CR3 | CR4 | &#039;CR0/2/3/4&#039;<br />&lt;dreg&gt; ::= DR0 | DR1 | DR2 | DR3 | DR6 | DR7 | &#039;DR0/1/2/3/6/7&#039;<br />&lt;treg&gt; ::= TR3 | TR4 | TR5 | TR6 | TR7 | &#039;TR3/4/5/6/7&#039;<br />&lt;mmxreg&gt; ::= mmxreg !need to define these<br /><br />&lt;Mem8&gt;&nbsp; ::= byte ptr &#039;[&#039; &lt;reg16&gt; &#039;]&#039; | byte ptr &#039;[&#039; &lt;reg32&gt; &#039;]&#039; | byte ptr&#039;[&#039; ID &#039;]&#039; | &#039;[&#039; ID &#039;]&#039;<br />&lt;Mem16&gt; ::= word ptr &#039;[&#039; &lt;reg16&gt; &#039;]&#039; | word ptr &#039;[&#039; &lt;reg32&gt; &#039;]&#039; | word ptr&#039;[&#039; ID &#039;]&#039; | &#039;[&#039; ID &#039;]&#039;<br />&lt;Mem32&gt; ::= dword ptr &#039;[&#039; &lt;reg16&gt; &#039;]&#039; | dword ptr &#039;[&#039; &lt;reg32&gt; &#039;]&#039; | dword ptr&#039;[&#039; ID &#039;]&#039; | &#039;[&#039; ID &#039;]&#039;<br />&lt;Mem64&gt; ::= qword ptr &#039;[&#039; &lt;reg16&gt; &#039;]&#039; | qword ptr &#039;[&#039; &lt;reg32&gt; &#039;]&#039; | qword ptr&#039;[&#039; ID &#039;]&#039; | &#039;[&#039; ID &#039;]&#039;<br />&lt;Mem80&gt; ::= tword ptr &#039;[&#039; &lt;reg16&gt; &#039;]&#039; | tword ptr &#039;[&#039; &lt;reg32&gt; &#039;]&#039; | tword ptr&#039;[&#039; ID &#039;]&#039; | &#039;[&#039; ID &#039;]&#039;<br /><br /><br /><br /><br />&lt;RegToReg8&gt; ::= &lt;reg8&gt; &#039;,&#039; &lt;reg8&gt;<br />&lt;RegToReg16&gt; ::= &lt;reg16&gt; &#039;,&#039; &lt;reg16&gt;<br />&lt;RegToReg32&gt; ::= &lt;reg32&gt; &#039;,&#039; &lt;reg32&gt;<br /><br />&lt;RegToMem8&gt;&nbsp; ::=	&lt;Mem8&gt;&nbsp; &#039;,&#039; &lt;reg8&gt;<br />&lt;RegToMem16&gt;	::=	&lt;Mem16&gt; &#039;,&#039; &lt;reg16&gt;<br />&lt;RegToMem32&gt;	::=	&lt;Mem32&gt; &#039;,&#039; &lt;reg32&gt;<br /><br />&lt;MemToReg8&gt; ::=	&lt;reg8&gt;&nbsp; &#039;,&#039; &lt;Mem8&gt;<br />&lt;MemToReg16&gt;	::=	&lt;reg16&gt; &#039;,&#039; &lt;Mem16&gt;<br />&lt;MemToReg32&gt;	::=	&lt;reg32&gt; &#039;,&#039; &lt;Mem32&gt;<br /><br /><br /><br />&lt;RegMem8&gt;&nbsp; ::= &lt;Reg8&gt; | &lt;Mem8&gt;<br />&lt;RegMem16&gt; ::= &lt;Reg16&gt; | &lt;Mem16&gt;<br />&lt;RegMem32&gt; ::= &lt;Reg32&gt; | &lt;Mem32&gt;<br /><br />&lt;ImmToRegMem8&gt;&nbsp;  ::=	 &lt;RegMem8&gt;&nbsp; &#039;,&#039; &lt;imm8&gt;<br />&lt;ImmToRegMem16&gt;&nbsp; ::=&nbsp; &lt;RegMem16&gt; &#039;,&#039; &lt;imm16&gt;<br />&lt;Imm8ToRegMem16&gt; ::=&nbsp; &lt;RegMem16&gt; &#039;,&#039; &lt;imm8&gt;<br />&lt;ImmToRegMem32&gt;&nbsp; ::=&nbsp; &lt;RegMem32&gt; &#039;,&#039; &lt;imm32&gt;<br />&lt;Imm8ToRegMem32&gt; ::=&nbsp; &lt;RegMem32&gt; &#039;,&#039; &lt;imm8&gt;<br /><br />&lt;RegMemToMem16&gt; ::= &lt;Mem16&gt; &#039;,&#039; &lt;RegMem16&gt;<br />&lt;RegMemToReg8&gt;&nbsp; ::= &lt;Reg8&gt;&nbsp; &#039;,&#039; &lt;RegMem8&gt;<br />&lt;RegMemToReg16&gt; ::= &lt;Reg16&gt; &#039;,&#039; &lt;RegMem16&gt;<br />&lt;RegMemToReg32&gt; ::= &lt;Reg32&gt; &#039;,&#039; &lt;RegMem32&gt;<br /><br />&lt;RegToRegMem8&gt; ::=&nbsp; &lt;RegMem8&gt; &#039;,&#039;&nbsp; &lt;Reg8&gt;				!r/m8,reg8<br />&lt;RegToRegMem16&gt; ::= &lt;RegMem16&gt; &#039;,&#039; &lt;Reg16&gt;			!r/m16,reg16<br />&lt;RegToRegMem32&gt; ::= &lt;RegMem32&gt; &#039;,&#039; &lt;Reg32&gt;			!r/m32,reg32<br /><br />&lt;Operands&gt; ::= &lt;RegToRegMem8&gt; <br />&lt;imm8&gt; ::= &lt;Immediate&gt;		;I cant tell how large an integer is during the input parse stage<br />&lt;imm16&gt;::= &lt;Immediate&gt;		;so I will leave these tags in the parsetree<br />&lt;imm32&gt;::= &lt;immediate&gt;		;and make the comparison in the parsetree resolver<br /><br /></div><br /><br />allows me to express my opcodes more clearly as:<br /><br /><div class="quote"><br />&lt;OpCode&gt; ::=		AAA<br />		|	AAS <br />		|	AAD <br />		|	AAD &lt;imm8&gt;<br />		|	AAM <br />		|&nbsp; &nbsp; &nbsp; AAM &lt;imm8&gt;<br />		|	ADC &lt;RegToRegMem8&gt;<br />		|	ADC &lt;RegToRegMem16&gt;<br />		|	ADC &lt;RegToRegMem32&gt;<br />		|	ADC &lt;RegMemToReg8&gt;<br />		|	ADC &lt;RegMemToReg16&gt;<br />		|	ADC &lt;RegMemToReg32&gt;<br />		|	ADC &lt;ImmToRegMem8&gt;<br />		|	ADC &lt;ImmToRegMem16&gt;<br />		|	ADC &lt;ImmToRegMem32&gt;<br />		|	ADC &lt;Imm8ToRegMem16&gt;<br />		|	ADC &lt;Imm8ToRegMem32&gt;<br />		|	ADC AL&nbsp; &#039;,&#039; &lt;imm8&gt;	!Immediate size assumed by register size<br />		|	ADC AX&nbsp; &#039;,&#039; &lt;imm16&gt;<br />		|	ADC EAX &#039;,&#039; &lt;imm32&gt;<br /></div><br /><br /><br /></div>
    <div class="meta">Posted on 2010-05-17 06:16:12 by Homer</div>
   </div>
   <div class="post" id="post-211751">
    <div class="subject"><a href="#post-211751">Re: Assembler Engine</a></div>
    <div class="body"><br />Argh, huge problems with the new grammar!<br />I am getting a lot of complaints from the compiler - they&#039;re not terminal errors (they are shift-reduce conflicts), but I&#039;d rather they were not there.<br /><br />There are a lot of ambiguities caused by the opcode encodings, heres a clear example:<br /><div class="quote"><br />			ADC &lt;RegMem16&gt;&nbsp; &#039;,&#039; &lt;reg16&gt; &lt;Terminator&gt;<br />			ADC &lt;reg16&gt; &#039;,&#039; &lt;RegMem16&gt;&nbsp; &lt;Terminator&gt;<br /></div><br />Since &lt;RegMem16&gt;::= &lt;reg16&gt; | &lt;Mem16&gt; , the grammar compiler detects an ambiguity when it analyzes the second rule. Let&#039;s expand those so its even clearer:<br /><br /><div class="quote"><br />			ADC &lt;reg16&gt; | &lt;Mem16&gt;&nbsp; &#039;,&#039; &lt;reg16&gt; &lt;Terminator&gt;<br />			ADC &lt;reg16&gt; &#039;,&#039; &lt;reg16&gt; | &lt;Mem16&gt;&nbsp; &lt;Terminator&gt;<br /></div><br /><br />It should be clear that BOTH rules cover the case &quot;&lt;reg16&gt; &#039;,&#039; &lt;reg16&gt;&quot;<br />This is the ambiguity the compiler is complaining about.<br />One way around it, although I don&#039;t like ANY of the workarounds I&#039;ve found, is to clearly define the three cases separately.<br /><div class="quote"><br />			ADC &lt;reg&gt;&nbsp; &#039;,&#039; &lt;reg16&gt; &lt;Terminator&gt;<br />			ADC &lt;reg16&gt; &#039;,&#039; &lt;Mem16&gt;&nbsp; &lt;Terminator&gt;<br />			ADC &lt;Mem16&gt; &#039;,&#039; &lt;Reg16&gt;&nbsp; &lt;Terminator&gt;<br /></div><br /><br />Now we&#039;ve gotten rid of the ambiguity - but now our opcode grammars dont exactly match the encodings.<br />We will have to rely on our opcode-encoding matching function to perform the necessary &#039;wildcarding&#039; that will be needed to find a match for the opcode encodings&#039; defined by the above three rules.<br /><br />You&#039;ll notice the &lt;terminator&gt; symbol - that&#039;s new :)<br />Opcode statements can be delimited by the &#039;;&#039; character (multiple opcodes per line), and/or terminated by CRLF.<br />So you can have a single line with an opcode, optionally followed by &#039;;&#039;, optionally followed by more opcodes.<br />This was actually required to eliminate some nasty Reduce-Reduce conflicts (those are terminal errors, ouchies) - I needed to stick something after opcodes - being able to delimit multiple opcodes on a single line is a nice side effect.<br /></div>
    <div class="meta">Posted on 2010-05-17 10:31:55 by Homer</div>
   </div>
   <div class="post" id="post-211759">
    <div class="subject"><a href="#post-211759">Re: Assembler Engine</a></div>
    <div class="body"><br />That was an almost complete waste of one day of my life - I&#039;ve reverted to the previously-posted Main Grammar.<br /><br />Just spent an entire day battling reduce-shift and reduce-reduce conflicts in the grammar compiler.<br />Learned a few things, some &quot;tricks&quot; for evading/avoiding ambiguities etc, but the bottom line is clear.<br />It was impossible to write a grammar that defined ALL of the components of ALL the opcodes without producing a LOT of shift-reduce conflicts, and since the main grammar is still quite slim, I thought lots of conflicts was a bad idea - could begin to prevent me from reaching parts of the grammar later on.<br />And I figured that if I can&#039;t have ALL the components &#039;typed&#039; for me by the LALR stage of the parser, then I have to perform my own analysis of input statements for SOME components - and if I have to do that, I may as well do it ALL myself, and have NO ambiguities in my grammar - I will allow very flexible and often &quot;illegal syntax&quot; sourcecode to pass the DFA/LALR stage, and catch it myself in the Interpreter stage.<br /><br />So tonight I&#039;ll be writing a function whose job is to &#039;crack&#039; an expanded OpCode reduction, analyze the form of the input in terms of the number, type and order of the components, and reformat the expression to a standard format when necessary, BEFORE passing it on to the opcode encoding matcher function.<br /><br /></div>
    <div class="meta">Posted on 2010-05-18 02:16:56 by Homer</div>
   </div>
   <div class="post" id="post-211761">
    <div class="subject"><a href="#post-211761">Re: Assembler Engine</a></div>
    <div class="body">I&#039;ve just been twiddling with the Main Grammar again (update attached), and while doing so, as an experiment, I decided to replace all the instances of NewLine with &lt;Terminator&gt;.<br /><br />If you recall, NewLine is a terminal symbol that represents CRLF, a while back I made the grammar &#039;line based&#039; by appending a NewLine symbol to the end of some of my grammar rules, to indicate the end of logical statements.<br /><br />Well, &lt;Terminator&gt; is defined as follows:<br /><br /><div class="quote"><br />&lt;Terminator&gt; ::= &#039;;&#039; | NewLine | &#039;;&#039; NewLine<br /></div><br /><br />ie, &lt;Terminator&gt; equals a semicolon, or a crlf, or a semicolon followed by a crlf.<br /><br />Now that I&#039;ve replaced all my NewLine references with &lt;Terminator&gt;, we are much more free to place our statements on single lines if we choose, example:<br /><br /><div class="quote"><br />nop;if x==5;g=5;add dword ptr,2;x=x+2;endif<br /></div><br /><br />Again - we can use EITHER delimiter, so the last thing on a line does not require a trailing semicolon.<br />You can put one there if you want, but you don&#039;t have to.<br /><br />So you can see that extending this &lt;Terminator&gt; rule across the grammar as a general delimiter has some interesting consequences.<br /><br />There was also a subtle change to the expression evaluation rules in regards to Assignments (ie, meddling with buildtime variables via the =, +=, etc operators)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3142" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-18 05:25:23 by Homer</div>
   </div>
   <div class="post" id="post-211762">
    <div class="subject"><a href="#post-211762">Re: Assembler Engine</a></div>
    <div class="body">I figured my next logical step was to be able to emit raw data to a segment (whether its code or data being irrelevant at that level... its all just bytes, yeah?)<br />With much hair-pulling, trial and error, I managed to find an EASY way to declare the grammar rules for &quot;Data Declarations&quot;, for all the machine data types. ... it took me hours, and in the end, I did it with just THREE SMALL GRAMMAR RULES :D<br /><br /><br />The following example parses just fine using the attached update.<br /><br /><div class="quote"><br />heya db &quot;this&quot;;db &quot;that&quot;,13,10,0;dword 200<br />byte 20,21,23<br />dw 10,9,8,4<br /></div><br /><br />So - it took a while, but it wasn&#039;t a total waste of a day to screw around with the grammar some more.<br />Next will be to implement the handler for the new nonterminal &lt;DefineData&gt; (see Main Grammar)</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3143" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-18 10:03:10 by Homer</div>
   </div>
   <div class="post" id="post-211777">
    <div class="subject"><a href="#post-211777">Re: Assembler Engine</a></div>
    <div class="body">I&#039;ve implemented code for interpreting the &#039;data declarations&#039; (with/without labels).<br />Very soon I will have to stop using the parsetree-evaluator for executing stuff.<br />In fact, I may already have overstepped the mark.<br />Anything that may only appear once in our sourcecode can be dealt with here.<br />Things like named data declarations are unique - so dealing with them now is ok.<br />We&#039;ll see when I begin to implement the macro engine, but I get the feeling that at some point, I&#039;m going to be expanding token sequences and interpreting them flat like that - I hope not, because we&#039;re sure to lose a lot of contextual information that is implied by the tree structure. <br />It really depends how my parser feels about me forcefeeding it sequences of tokens to re-interpret.<br />I&#039;m pretty sure that I can simply shove all my tokens onto the parser&#039;s Input Stack, and then call my Parse method to generate a parsetree - as long as the input stack is not empty, the DFA input stage will simply be bypassed - we already have the tokens, we just want the parser to parse them into a tree for us.<br />If its as easy to re-parse tokens as I think it is, then I won&#039;t ever have to deal with &#039;flat token sequences&#039; unless I actually want to.... and it means that the macro engine will be able to spit out flat token sequences directly to the parser&#039;s input stack, without a care in the world about what they represent.<br /><br />The Main Grammar received a little more work today too, mostly a tidy-up, removal of some unnecessary rules (simplification), and otherwise subtle changes designed to format the parsetree nicely - fewer and less-complex handlers for the nonterminals.<br /><br />This brings up a good point - for anyone who intends to use my parser code at any stage, you may note your interest in a symbol of either termin or nonterminal type (or both) , declaring the type you are interested in if both exist by the same name.<br />But you can only register a Handler function for a NONTERMINAL grammar.<br />These represent the nodes of our parsetree - terminal tokens don&#039;t lead anywhere, so we don&#039;t need handlers for them.<br />Makes sense?<br /><br />If you REALLY wish to catch terminal tokens, you need to write a handler for their nonterminal parent reduction.<br />IE, if you wanted to catch &quot;StringLiteral&quot;, you would need to handle &lt;Literal&gt;, and in that handler, examine the child terminal token. So, it can be done, but if you have multiple Rules that contain the same terminal, you&#039;d have to deal with all of those Rules in order to catch the terminal in all cases.<br />Not that I see any reason for wanting to pay so much attention to a terminal token.<br />If it was that important, we&#039;d have replaced it with a nonterminal rule and handled it as usual.<br /><br /></div>
    <div class="meta">Posted on 2010-05-19 07:30:02 by Homer</div>
   </div>
   <div class="post" id="post-211783">
    <div class="subject"><a href="#post-211783">Re: Assembler Engine</a></div>
    <div class="body">Did a bit more work on the data declarations stuff, its pretty complete now.<br />Supports string literals expressed as byte or word data, supports reals, qwords, etc, implemented code to check if numerical literals are within the binary range of the expressed datatype&#039;s size, etc.<br /><br />Limitations:<br />I&#039;m building this using OA32 / MASM.<br />MASM supports REAL10, but not TWORD.<br /><br />Since my internal representation of integers is QWORD (and REAL8 for floats), I can&#039;t currently support 10-byte types with full numerical precision for internal maths (such as expression evaluation). <br />TWORD integers aren&#039;t even supported at the cpu level - but that does not mean that we can&#039;t implement them, or even larger datatypes - it just means that operations using them will require multiple instructions.<br /><br /><br /><br />Currently I have three outstanding areas of work<br />#1 is the opcode encoder matching function - there&#039;s some code, but its quite incomplete, especially in the light of all the newly-supported symbols in the grammar for datatyping etc.<br />#2 is the COFF/OMF backend, which includes the Segment class... this has been receiving some work already.<br />The Segment class is absolutely naive as to the backend, which seemed to work well for Randy - it&#039;s just a mechanism for creating lists of elements , similar in some ways to his pretty-printer, but geared for runtime.<br />#3 is the macro engine, which currently does not exist as such - but I&#039;ve written one of these before... I just have to be careful not to let my previous experience cloud my judgement wrt the current work.<br /><br />OK, so I will be posting another demo + sourcecode within the next few days.<br />This time, the sourcecode will be complete and current.<br />At this time, I will ask anyone who has any passing interest in this thread to have a look over the code, get a feel for for what I&#039;m doing and how I&#039;m doing it, and make a few suggestions!<br /><br />I do NOT want to write another macro assembler that implements existing syntaxes with their nuances - I believe it&#039;s high time we had something new and cool, and if it has to come from our own community, so much the better.<br /></div>
    <div class="meta">Posted on 2010-05-20 02:39:55 by Homer</div>
   </div>
   <div class="post" id="post-211785">
    <div class="subject"><a href="#post-211785">Re: Assembler Engine</a></div>
    <div class="body"><div class="quote">&lt;reg8&gt;&nbsp; ::= AL | CL | DL | BL | AH | CH | DH | BH | R8</div><br />Seems like using R8 would conflict with the 64bit register R8.<br />I assume you&#039;re not dealing with the R[8-15][|b|w|d] stuff yet.</div>
    <div class="meta">Posted on 2010-05-20 11:42:38 by r22</div>
   </div>
   <div class="post" id="post-211789">
    <div class="subject"><a href="#post-211789">Re: Assembler Engine</a></div>
    <div class="body"><br />Nice catch - that&#039;s just a remnant from when I backported part of the OpCode Encodings grammar back into the Main grammar. r8 Is an operand in opcode encodings as defined by intel... not meant to appear in the main grammar at all.<br /><br /></div>
    <div class="meta">Posted on 2010-05-21 07:59:48 by Homer</div>
   </div>
   <div class="post" id="post-211790">
    <div class="subject"><a href="#post-211790">Re: Assembler Engine</a></div>
    <div class="body">Here&#039;s a small update to the Main Grammar, implementing support for Nested Macro Declarations, and some rules for dealing with multiple CRLF&#039;s (one or more empty lines).<br /><br />To implement nested macro declarations, all I&#039;ve done is move the macro declaration rule into the &lt;Statement&gt; group. Macro declarations contain statements - and statements can be macro declarations.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3144" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-21 09:46:48 by Homer</div>
   </div>
   <div class="post" id="post-211795">
    <div class="subject"><a href="#post-211795">Re: Assembler Engine</a></div>
    <div class="body">Currently, I&#039;m working on implementing handlers for Macro Declarations and their component nonterminals.<br />One idea I&#039;ve adopted from my previous work is to keep a stack of pointers to macro declaration objects that we&#039;re still parsing (ie, a Context Heap - but just for macro declarations). This allows macro declarations to be implemented with a scope that is local to its parent declaration (if any).<br />The same logic can be applied when I implement structure declarations, and the counterpart is when I implement macro EXECUTIONS... here the scoping comes into its own, because we can ensure that a macro execution is only valid within the scope of the execution of its parent macro declaration &nbsp;8)<br />And the fun part will be implementing switches to disable scoping :)<br /><br />Anyway, progress is good, seems to be in the right direction, is methodical and hierarchical and most of all, consistant.<br />I&#039;ll be proud to show this sourcecode to the public in the coming days.<br /><br /><div class="quote"><br />7:21:21 PM&nbsp; _H_: im building a stack of pointers to macro declarations which are still being parsed, so that i can implement scoping of macro declarations, and thus their executions<br />7:22:04 PM&nbsp; _H_: macro executions which have non-root scope must then occur within the execution scope of their parent macro declaration, or one of its ancestors<br /></div><br /></div>
    <div class="meta">Posted on 2010-05-22 03:57:56 by Homer</div>
   </div>
   <div class="post" id="post-211806">
    <div class="subject"><a href="#post-211806">Re: Assembler Engine</a></div>
    <div class="body">OK its been implemented...<br /><br />The assembler keeps a list of &#039;macros which have Root Scope&#039; - this simply means that they appeared in the sourcecode alongside other stuff as usual - not nested inside another macro declaration.<br />Each &#039;root macro&#039; can act as the head of a tree structure , where each Node is another macro declaration object.<br />This happens if we try to declare a macro from inside another macro declaration - ie, nested macros declarations.<br /><br />Each &#039;root macro&#039; acts as the head of a NAMESPACE.<br />If we are defining a nested macro, its name only needs to be unique to the namespace (subtree) it belongs to.<br /><br />As for macro executions: when a macro is executed, the assembler will check if the execution is nested or not.<br />If it is, the search for a macro declaration by name will be restricted to the namespace of the macro whose execution we&#039;re already within, and its ancestors back to root.<br /><br />I haven&#039;t yet introduced a switch to disable this scoping behavior.<br />Anyway guys, what ya think?<br /></div>
    <div class="meta">Posted on 2010-05-22 22:02:22 by Homer</div>
   </div>
   <div class="post" id="post-211815">
    <div class="subject"><a href="#post-211815">Re: Assembler Engine</a></div>
    <div class="body">Today I implemented the rules for Structs and Unions in the Main Grammar.<br />This took absolutely hours, I can&#039;t begin to describe how tedious it was, although the result looks so elegant (easy).<br />The main problem I had was trying to describe a masm-style &quot;&lt;ID&gt; ends&quot; rule.<br />After many hours, I was unable to find any way to do it cleanly, so I gave up and accepted a more simple syntax, as shown below. There is a way around it, the newest version of Gold supports something called &#039;Virtual Terminals&#039; - but I wanted to avoid using that &#039;expert&#039; mechanism, at least as long as possible.<br /><br />Struct fields of &#039;known&#039; type may end in (?), &nbsp;? &nbsp;, () or nothing.<br />Struct fields of &#039;compound&#039; type may end in &lt;?&gt;, &lt;&gt; or nothing.<br />Struct fields may be named, or not.<br />Union fields MUST be named - but otherwise are just like regular Struct fields.<br /><br /><br />The following example input is acceptable:<br /><div class="quote"><br /><br />goose struct<br />myfield db ?<br />union<br />myfield2 dw<br />myfield3 dw<br />ends<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;byte<br /> &nbsp; &nbsp; &nbsp; &nbsp;byte<br />ends<br /><br />gander struct<br />grr goose <br />nose dive &lt;&gt;<br />ends<br /></div><br /><br />As you can see, it&#039;s pretty flexible.<br />Next will be to implement the code handlers for this new grammar.<br />Some of the work has already been done with a fledgeling &quot;_Struct object&quot;.<br /><br />I am going to allow both Structs and Macros to use the same &quot;work stack&quot; for tracing nested declarations.<br />This is because I think my grammar rules already make it impossible for the declarations to ever become interleaved - we can say that we can only ever be inside one struct/union declaration at a time, so its safe to share the same stack.<br /><br />The last rule - that union fields must be named - was an afterthought - we don&#039;t really need this, do we?<br />It just seemed pointless to have a bunch of unnamed fields who share the same physical data.<br /><br />Why would you want an unnamed field in a union? Any takers?<br /><br /><br />Attached is an update of the Main Grammar containing the new stuff.<br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3148" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-23 07:27:34 by Homer</div>
   </div>
   <div class="post" id="post-211821">
    <div class="subject"><a href="#post-211821">Re: Assembler Engine</a></div>
    <div class="body">Another small update to the Main Grammar... changes are to allow the Struct Declarations to contain nested struct and macro declarations, in addition to the usual fields and unions.<br />Macro declarations could already allow nested struct declarations, since a macro contains a bunch of &lt;Statement&gt;&#039;s<br /><br /><div class="quote"><br />gander struct<br />	hello struct<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;monza macro; echo mybum; endm<br />		monza db ?<br />	ends<br />	grr goose <br />	nose dive &lt;&gt;<br />ends<br /></div><br />I&#039;m trying to implement scoping of searches for nested declaration entities.. <br />I&#039;ve switched to keeping separate stacks for struct and macro declarations.<br />This lets me know that, in the example above, the macro called &quot;monza&quot; is in fact a root-level macro... its not nested inside another macro, so its not nested at all !!!<br />The structure called &quot;hello&quot; is nested within the structure called &quot;gander&quot;. The idea is that &quot;gander&quot; is the root of a namespace, and that &quot;hello&quot; must be a unique name within the &quot;gander&quot; namespace - but otherwise could be duplicated.<br /><br />I&#039;ve implemented code for handling most of the new nonterminals, currently looking for a bug in my overly-complex storage scheme ... hopefully its something small (usually the case).<br />I&#039;m quite happy to tear that storage scheme apart and rebuild it at this point, since I now need it &#039;online&#039;.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3151" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-24 02:12:25 by Homer</div>
   </div>
   <div class="post" id="post-211822">
    <div class="subject"><a href="#post-211822">Re: Assembler Engine</a></div>
    <div class="body"><br />The bug was fixed, and the namespacing is working great :)<br /><br /><div class="quote"><br />gander struct<br />	hello struct<br />		monza db ?<br />	ends<br />&nbsp; &nbsp; &nbsp; &nbsp; gday hello &lt;&gt;<br />	grr goose <br />	nose dive &lt;&gt;<br />ends<br /><br />hello struct<br />bbb db ?<br />ends<br /></div><br /><br />In the above example, the struct &quot;hello&quot; is NOT being redefined - nor is there any name collision.<br />The first instance is being declared as a &quot;child of the gander namespace&quot;.<br />And the second is being declared as a root entity, alongside &quot;gander&quot;.<br />Note that the nested structure declaration is actually being implemented in the next line... and that this structure definition is ONLY valid within the context of this structure, or its more-deeply-nested substructures.<br />That is to say, a structure declaration has access to the declarations of structures within the same scope, or higher, up to the root of the tree it is stored within (ie, root of a namespace).<br /><br />I currently throw to an int3 if a name collision is detected for structs (no support yet for redefinition of anything) - macros need to be brought to the same stage as structs.<br /><br /><br />YAYYYYY ITS WORKING !!! (And so it should, it&#039;s a re-implementation of an approach I&#039;ve used in another project).<br /><br /><br /></div>
    <div class="meta">Posted on 2010-05-24 03:00:29 by Homer</div>
   </div>
   <div class="post" id="post-211824">
    <div class="subject"><a href="#post-211824">Re: Assembler Engine</a></div>
    <div class="body">Macros now enjoy similar NameSpacing to structs.<br />Just finished implementing code handlers for the remaining new nonterminals ie &lt;Union&gt; and family.<br />Unions are not retained in my structures - rather, I collect their fields along with all the other fields of the struct, but I flag the unioned fields. This is not ideal and may change - I think I&#039;d rather have a real container object for unions, which shares enough similarities with a &lt;StructField&gt; that it can be safely stored in the same list.<br /><br /><br /> - Changed storage scheme for Unions..<br /><br />Unions are containers for fields (like structs) and appear inside structs (like struct fields).<br />Structs now contain a list of two possible kinds of fields - union or structfield.<br />This is made possible simply by ensuring that both object classes contain an identifying marker at a common location.<br />Size and Offsets of all fields within a struct (including unioned fields) are calculated as each new field is added - the size of a union is assumed to be that of the largest member field in the union, with all its fields starting at the same offset, relative to start of struct.<br /><br /></div>
    <div class="meta">Posted on 2010-05-24 07:39:24 by Homer</div>
   </div>
   <div class="post" id="post-211827">
    <div class="subject"><a href="#post-211827">Re: Assembler Engine</a></div>
    <div class="body">Another small update to the Main Grammar.<br />This time, I had noticed that a couple of grammars were causing problems with the Identifier Terminal... specifically, I was no longer able to declare names that are just one letter long.<br /><br />You see, one of my rules in the Math Expressions mentions the character &#039;e&#039;, used for Exponents.<br />And my definition of the Identifier terminal was such that the parser could not distinguish between &#039;e&#039; and &#039;Id&#039;.<br />So now I have a quite elaborate definition for the Id terminal which prevents the user specifically from using the lone character &#039;e&#039; (or E) as a naming identifier (at all), but allows any other single letter to be used alone, and generally allows all other number/letter/decorative combinations.<br /><br />I was able to implement this stuff all within the &#039;Character Sets&#039; par of the grammar (DFA part of the parser), so no new nonterminals were generated, although theres a couple of new terminals, but theyre just used internally, and are not particularly interesting, except as a cool example.<br /><br />Sorry for the delay in posting an updated demo, I keep finding things to fix, and with frequency that I&#039;ve found a little alarming. However, I suspect that is almost over.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3152" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-25 04:10:31 by Homer</div>
   </div>
   <div class="post" id="post-211828">
    <div class="subject"><a href="#post-211828">Re: Assembler Engine</a></div>
    <div class="body">Yet another minor update to the Main Grammar.<br />This time, I noticed that I had not supported nested sharp braces in data declarations eg:<br /><br /><div class="quote"><br />.data<br />MyThing SomeKindaStruct &lt;27,&lt;&quot;Escape&quot;,0&quot;&gt;&gt;<br /></div><br /><br />Another thing that caused a problem was the &lt;&lt; and &gt;&gt; symbols, which were used for binary shifting.<br />Even though the rules for binaryshifting are in a totally different area of the grammar to those for data declarations, nonetheless the grammar compiler was claiming at least one &#039;ambiguity&#039; existed - so the &lt;&lt; and &gt;&gt; symbols just had to go. I&#039;ve replaced them with shl/shr (as immediate operators, these are not opcodes).<br /><br />If I hadn&#039;t,&nbsp; we would have to whitespace our sourcecode to eliminate double sharp braces:<br />MyThing SomeKindaStruct &lt;27,&lt;&quot;Escape&quot;,0&quot;&gt; &gt;<br /><br /><br />I&#039;d rather be lazy thanks.<br />Now I&#039;ll be able to implement some code to check the types and sizes of the input fields of initialized data structs.<br />For any Type, the size won&#039;t have to match, but it will have to be the same or less.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3153" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-25 07:06:34 by Homer</div>
   </div>
   <div class="post" id="post-211829">
    <div class="subject"><a href="#post-211829">Second public demo is ready</a></div>
    <div class="body">At long last, here&#039;s the entire project, with all files up to date.<br />You can play with the demo executable although its best to have DebugCenter installed if you wanna see much.<br />Essentially, the demo reads &quot;test.txt&quot; and if it parses correctly, a little application window will appear (empty window).<br />If your sourcecode has something wrong, or that my grammar does not yet handle (at all, or partially), then you just won&#039;t get an application window - thats why you really need to have debugcenter installed.<br /><br />It&#039;s possible to load the resource files into the previous project, which has a GUI that lets you step through the parsing process, but we are way beyond parsing now, and deep into the interpreting of the parser output.<br /><br />If I&#039;ve forgotten to include any files, I apologize profusely, and for that reason have included the binary executable of the project demo so you don&#039;t absolutely HAVE to build the project yourself - however I&#039;d like to know that there&#039;s no problems in doing so if you can spare the 5 seconds or so it takes to build ;)<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3154" target="_blank">Assembler100526.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-25 09:37:51 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29964&amp;page=1" style="">&laquo;</a><a href="../?id=29964&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29964" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29964&amp;page=3">&gt;</a><a href="../?id=29964&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>