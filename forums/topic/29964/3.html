<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Assembler Engine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29964" />
  <link rel="prev" href="../?id=29964&amp;page=2" />  <link rel="next" href="../?id=29964&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29964">Assembler Engine</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29964&amp;page=1" style="">&laquo;</a><a href="../?id=29964&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29964" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29964&amp;page=4">&gt;</a><a href="../?id=29964&amp;page=4">&raquo;</a></form>   <div class="post" id="post-211831">
    <div class="subject"><a href="#post-211831">Re: Assembler Engine</a></div>
    <div class="body">Well guys, any major dramas?<br />If you messed with the test sourcecode file, chances are you managed to trigger an int 3 trap - I&#039;ve left dozens of them throughout the project specifically to alert me to unhandled cases.<br />Does anyone have any questions (or even suggestions) in regards to the project source?<br /></div>
    <div class="meta">Posted on 2010-05-25 23:40:11 by Homer</div>
   </div>
   <div class="post" id="post-211832">
    <div class="subject"><a href="#post-211832">Re: Assembler Engine</a></div>
    <div class="body">I&#039;ll make it a point to check it out this weekend :)</div>
    <div class="meta">Posted on 2010-05-26 10:24:52 by SpooK</div>
   </div>
   <div class="post" id="post-211833">
    <div class="subject"><a href="#post-211833">Re: Assembler Engine</a></div>
    <div class="body">Just wanted to report that it works fine on Win7 64-bit.<br />It&#039;s a shame I don&#039;t have more time for thorough tests.</div>
    <div class="meta">Posted on 2010-05-26 16:46:14 by ti_mo_n</div>
   </div>
   <div class="post" id="post-211862">
    <div class="subject"><a href="#post-211862">Re: Assembler Engine</a></div>
    <div class="body">Thanks for the feedback, good to know theres no HUGE problems already!<br /><br />Next mission is to write code for the data declaractions that have all the nested braces like this:<br /><br />MyData SomeKindaStruct &lt;ThisData, ThatData, &lt;Some other embedded thing, a few zeroes maybe&gt;, couldbemore&gt;<br /><br />I&#039;ve thought for a couple days about the two ways to do it.<br />One of them is to do it during parsetree recursion, using a heap pointer to the current reference struct.<br />The other is to expand the whole thing into a statement similar to the example, and analyze it linearly, which could involve using the procedure stackframe as a heap for struct pointers.<br />After some soulsearching, I&#039;m inclined to go with the latter, even though it&#039;s &#039;less cool&#039;, it does conform more closely to the structure declaration field formatting, and should be easier to implement.<br />I&#039;m struggling to find the motivation to get much done, kinda taking a breather.<br /></div>
    <div class="meta">Posted on 2010-05-29 03:23:46 by Homer</div>
   </div>
   <div class="post" id="post-211866">
    <div class="subject"><a href="#post-211866">Re: Assembler Engine</a></div>
    <div class="body">I&#039;ve implemented code to express data declarations from simple structures:<br /><br /><div class="quote"><br />viking struct<br />x db ?<br />y dw ?<br />ends<br /><br />.data<br />mydata viking &lt;255,255&gt;<br /></div><br /><br />Where possible, the assembler will attempt to conform the user&#039;s declared data to the datatype expressed by the associated reference structure field:<br /><div class="quote"><br />viking struct<br />x db ?<br />y dw ?<br />ends<br /><br />.data<br />mydata viking &lt;&quot;h&quot;,&quot;i&quot;&gt;<br /></div><br /><br />Not yet handled is the case of a struct reference appearing as a field of the current reference struct.<br />This will require some kind of local stack push, as mentioned in the previous post.<br />But since all the simple cases are now handled, I should be able to implement this last thing relatively cleanly.<br /><br />Also not done is to count the size of the labelled data declaration, and mark the label with that size.<br />This is important, since the Segment object will append any subsequent unlabelled data to the labelled data entity, so if we want to implement a &#039;sizeof&#039; directive, we&#039;re going to need a permanent record of the size of the labelled data entity, taken at the time that the entity was declared. It&#039;s ok to tag the Label itself with the sizeof value, as the label is created once only.<br /><br />Anyway, I&#039;ll hold back on posting more code until after the weekend, as I am still eager to hear from people who checked out the most recent demo I posted.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-05-30 00:54:56 by Homer</div>
   </div>
   <div class="post" id="post-211868">
    <div class="subject"><a href="#post-211868">Re: Assembler Engine</a></div>
    <div class="body">I&#039;ve implemented all the code to handle those complex data declarations of nested struct references.<br />You know, these horrible things:<br /><div class="quote"><br />mydata mystruct &lt;data,data,&lt;data,data,&lt;data&gt;,data&gt;,data,data&gt; <br /></div><br /><br />I did this by expanding the reduction completely into terminal tokens, and then analyzing the token sequence while simultaneously tracking the current reference struct and field.<br />The trick is to switch reference structs, using a stack to retain prior nesting levels.<br />In my case, I was able to just use the procedure stackframe, and PUSH/POP &nbsp;of current struct/fieldindex for that.<br /><br />The result is that I can detect when the user&#039;s data matches the struct declaration, and whether the user&#039;s input terminates earlier or later than dictated by the struct declaration.<br />All data is &quot;flexible&quot; in that user input will be conformed to the structfield type whenever possible (else error).<br />And it is not a terminal error for the user data to terminate earlier or later than dictated by the struct - the assembler will simply generate s suitable warning and deal with the situation.<br /><br />The code was completely hooked up to emit all data to the output Segment class via Assembler.pCurrentSegment, so I&#039;m happy to say that directives for &nbsp;data declarations of all types appear to be complete (probably missed a bunch of stuff, just haven&#039;t triggered any traps lately).<br /><br /></div>
    <div class="meta">Posted on 2010-05-30 03:53:32 by Homer</div>
   </div>
   <div class="post" id="post-211872">
    <div class="subject"><a href="#post-211872">Re: Assembler Engine</a></div>
    <div class="body">Corrected a small bug in Main Grammar (and corresponding handlers) which disallowed declaring a comma-delimited series of &#039;known&#039; (machine) datatype.<br />The Main Grammar was also modified to allow for UNLABELLED data declarations and struct fields.<br /><br />These example cases show what wasn&#039;t working, and is now allowed.<br /><div class="quote"><br />dat1 BYTE 0,0,0<br /> &nbsp; &nbsp; &nbsp; db &lt;0,&quot;hello&quot;,0,&lt;0,0&gt;,0,0&gt;<br /></div><br /><br />Note that for data declarations of &#039;known datatype&#039;, the &#039;&lt;&#039; and &#039;&gt;&#039; characters are essentially IGNORED.<br />There&#039;s no need to track thru ref structs or any of that complex stuff - I simply pretend they are not there.<br /><br /><br />So... what next?<br />If I have to ask that question, I must be getting somewhere :)<br /><br /></div>
    <div class="meta">Posted on 2010-05-30 08:46:23 by Homer</div>
   </div>
   <div class="post" id="post-211873">
    <div class="subject"><a href="#post-211873">Re: Assembler Engine</a></div>
    <div class="body">The sizeof() directive was implemented within the Complex Expressions part of the Main Grammar.<br />You can freely use sizeof(X) or sizeof X within expressions:<br /><br /><div class="quote"><br />x *= sizeof y*2+j<br />y += sizeof(j)+32<br /></div><br /><br />The code handler implemented only supports using sizeof with Structs - this needs extending to at least support sizeof &#039;known type&#039; .</div>
    <div class="meta">Posted on 2010-05-30 21:20:00 by Homer</div>
   </div>
   <div class="post" id="post-211880">
    <div class="subject"><a href="#post-211880">Re: Assembler Engine</a></div>
    <div class="body">The ++ and -- modifiers were implemented in the Evaluator class.<br />They can be used anywhere in an expression, except at the start.<br />EG<br />x = 3.14159<br />y = x++ / 2<br /><br />Precedence: all other math operators have precedence over the ++ and -- modifiers.<br />Thus, the above example will calculate y=x/2 , and then increment x.<br /><br />Currently, only &#039;literals&#039; (buildtime variables) of floating, integer and hex types can be modified, and only by +/- 1<br />It would be nice to extend this later, to be able to increment say, a pointer by the size of the type it points to.<br />I&#039;m sure the asm puritans out there are scoffing and shaking their heads solemnly.<br />Hey, you don&#039;t HAVE to use any of the high level directives I&#039;m implementing, that&#039;s your choice :P<br /><br /><br /></div>
    <div class="meta">Posted on 2010-05-31 02:04:40 by Homer</div>
   </div>
   <div class="post" id="post-211881">
    <div class="subject"><a href="#post-211881">Re: Assembler Engine</a></div>
    <div class="body">Implemented some COMMENT symbols.<br /><br />/* starts a block comment<br />*/ ends a block comment <br />// is comment for rest of line (equivalent to masm &#039;;&#039;)<br /><br />These were actually a little tricky to implement - my Parser needed some slight changes to the input stage in order to suppress activity within comment blocks.<br />It&#039;s done now.<br /><br />Here&#039;s the most current test sourcecode:<br /><div class="quote"><br /><br />.code<br />/*some comments<br /><br /><br /><br />ramble ramble<br /> */<br /><br /><br />x=10<br />y= x++ * 0.5 //im allowed to<br />z=x+1<br />.code<br />testing:<br />echo &quot;this&quot;<br /><br />moose struct<br />x db ?<br />ends<br />x = (sizeof moose*2)<br /><br />viking struct<br />x moose &lt;?&gt;<br />y dw ?<br />ends<br /><br />.data<br /> db &quot;hello&quot;,0, z<br />.code<br /></div><br /><br />Starting to look more like some sourcecode, yes?<br />And I mean, this is junk, it&#039;s just to test everything.<br />It was certainly gratifying to see that the data declaration at the bottom emits a byte with a value of 12 :)<br /><br />I may change the comment symbols later.<br /><br /></div>
    <div class="meta">Posted on 2010-05-31 05:10:46 by Homer</div>
   </div>
   <div class="post" id="post-211900">
    <div class="subject"><a href="#post-211900">Re: Assembler Engine</a></div>
    <div class="body">The Main Grammar was modified to implement data declarations of &#039;array&#039; type.<br /><br /><div class="quote"><br />.data<br />xxx db 32 dup(0)<br /> &nbsp; &nbsp; &nbsp; db 26 dup (&quot;repeat this string&quot;,13,10,0)<br /> &nbsp; &nbsp; &nbsp; real8 12 dup (13.2)<br />yyy viking dup (&lt;&gt;)<br /></div><br /><br />The handler to implement this is not coded yet, but should be a trivial extension of existing code.<br />Fun , fun !!<br /><br />Every time I sit down to this project, I add one more thing, or two.<br />It&#039;s like reading a chapter or two of a book.<br />It&#039;s been that linear.<br />How refreshingly sane to code within such a clean and progressive framework!<br /><br />Since I&#039;ve been steeped in MASM syntax for so long, the syntax I&#039;ve been implementing thus far is very masm-like.<br />But it&#039;s not the same - I can implement whatever I can imagine, so I&#039;m hoping to hear some suggestions when I get this thing to the point that it can emit object files ;)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3157" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-06-02 04:18:34 by Homer</div>
   </div>
   <div class="post" id="post-211917">
    <div class="subject"><a href="#post-211917">Re: Assembler Engine</a></div>
    <div class="body">Some slight changes were made to the &lt;DefineData&gt; rule, in the Main Grammar.<br />These were made so that the reductions for Array data declarations look very similar to reductions of regular data declarations.... so that my &lt;DefineData&gt; handler can deal with both array and non-array data declarations...<br /><br />Implemented the code for expressing data declarations of Array type, as previously discussed.<br />This was done by making some modifications to the &lt;DefineData&gt; handler, such that it can optionally iterate when evaluating the expanded version of the declared data values.<br />It&#039;s not as graceful as it could be, but it works just fine, and it works for arbitrarily complex inputs, while avoiding the need to deal with all kinds of special cases.<br /><br />One side-effect of implementing this code was the adding of a new method to the Interpreter ancestor class.<br />Interpreter.ClipTokens is able to eliminate one or more (terminal) tokens from anywhere within an (expanded) reduction. This is useful for forcing a &#039;recognized&#039; reduction to look like some similar, but more simple reduction... which in turn allows us to use existing code to do SOME of the work of resolving special cases.<br /><br />Also, the Evaluator.Get_Value method has been made a little more intelligent, as it can now recognize various kinds of literal tokens *without* having first evaluated them via the &lt;Literal&gt; handler. And the handler for tagging literal values was modified such that we tag them at a lower level in the grammar .. so we don&#039;t rely on passing through any particular handler to get our tokens correctly tagged for us - and so we can rely more on tag values in higher-order handlers.<br /><br />I&#039;ll do a little more testing, then I&#039;ll post another full update of the project.</div>
    <div class="meta">Posted on 2010-06-03 02:03:26 by Homer</div>
   </div>
   <div class="post" id="post-211918">
    <div class="subject"><a href="#post-211918">Re: Assembler Engine</a></div>
    <div class="body">OK, here is a full update of the sourcecode.<br />This time, I have *not* included a binary.<br />I&#039;d like to know if there&#039;s any problems building this project.<br /><br />Also attached is a tool I&#039;ve been playing with on the side, useful for exploring the internals of OBJ files.<br />Since that&#039;s my first target object file format, I needed to investigate what I&#039;m expected to emit.<br />This tool will continue to receive updates, but will only ever be an educational tool.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3158" target="_blank">Assembler100603.zip</a></li>
      <li><a href="../../attachments/?id=3159" target="_blank">COFF_VIEW.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-06-03 02:59:09 by Homer</div>
   </div>
   <div class="post" id="post-211923">
    <div class="subject"><a href="#post-211923">Re: Assembler Engine</a></div>
    <div class="body">Handler code for the &lt;MacroArgs&gt; symbol was implemented in the Assembler class.<br />I really like how NASM lets you refer to &quot;unnamed&quot; macro arguments, via the %n directive.<br />But I like them having meaningful names too.<br />So I want to support both.<br />Anyway, now I&#039;m correctly recording macro argument names , if present in a macro declaration.<br />I&#039;m almost ready to implement code for executing instances of macros - the heart of the macro engine!<br /></div>
    <div class="meta">Posted on 2010-06-03 06:42:57 by Homer</div>
   </div>
   <div class="post" id="post-211937">
    <div class="subject"><a href="#post-211937">Re: Assembler Engine</a></div>
    <div class="body">Late last night, I tried to implement the second of the two macro execution modes.<br />Let me explain how my thoughts are going.<br /><br />Theres two kinds of macros, and two kinds of macro executions.<br /><br />The first kind of macro is straightforward - it generates some lines of sourcecode, but does not &#039;return&#039; anything to its caller.<br />This kind of macro can only be executed as an entire statement - not as part of another statement. In masm, these take the form of MACRONAME <br /><br />The second kind of macro is able to return something to its caller (see masm&#039;s EXITM directive), and can only be executed as a subexpression of another statement. In masm, these take the form of MACRONAME [(ARG,ARGS)].<br />It is worth noting that the macro interpreter replaces the macro instance with the single token returned by the macro, and then reinterprets the affected subtree.<br /><br />I had absolutely no trouble implementing the execution grammar for the second kind of macro - I slipped the grammar rule into the set of rules used for complex expressions, seemed appropriate to handle these &#039;inline macros&#039; as subexpressions.<br /><br />But I had a heck of a time implementing the simpler, regular, statement-based macro execution grammar.<br />I ran into all kinds of ambiguities involving other parts of the grammar (such as data declarations and even structure field grammars).<br /><br />Then I was drawn by an error comment I generated in masm during experimentation.<br />It said something like &quot;statement must appear within segment block&quot;.<br /><br />I realized that masm has divided its grammar up into several groups of statements, each associated with one of the default segments (code, data, data?). This probably means that a lot of grammars are duplicated (which it turns out is an unavoidable consequence when implementing certain complex grammars) - but it also means that they are partitioned in a way that allows them to defeat a lot of the ambiguities which are plaguing me.<br /><br />There appeared to be two possible solutions.<br />One of them is to try rewriting the grammar starting with my Segment Selector directives near the top, which sounds like a heck of a lot of work, basically a full rewrite (its not too late!)<br />The other is just to bite the bullet and accept limitations in my grammar.<br />For example, I found that the form %MACRONAME  is acceptable as a statement execution.<br />This I suppose would make it look like nasm in terms of macros, which probably won&#039;t be too bad.<br /><br />Your thoughts?<br /><br /></div>
    <div class="meta">Posted on 2010-06-03 22:53:47 by Homer</div>
   </div>
   <div class="post" id="post-211939">
    <div class="subject"><a href="#post-211939">Re: Assembler Engine</a></div>
    <div class="body"><br />OK, I have implemented a pretty flexible EXITM directive.<br /><br />- EXITM is a Statement, but can only appear inside a Macro.<br />- EXITM can return a list of one or more comma-delimited names, values or registers inside sharp braces.<br />- EXITM can alternatively return nothing at all, expressed as &lt;&gt; a pair of empty sharp braces, or nothing.<br />- EXITM can alternatively return a Complex Expression inside regular round braces.<br />&nbsp; This last one allows us to return Literal Strings to the interpreter to be &#039;subparsed&#039; - it allows us to use macros to &#039;construct&#039; (possibly multiline) sentential sourcecode statements that will be interpreted as IF they appeared in the sourcecode directly - just for example, we could write a macro that literally writes a declaration for another macro at buildtime, based on some buildtime switches etc.<br />This is a VERY powerful feature which is lacking in some macro engines.<br /><br />Anyway, here&#039;s some example EXITM statements that might appear in a macro:<br /><div class="quote"><br />EXITM &lt;eax&gt;<br />EXITM &lt;j, counter, eax&gt;<br />EXITM (x=x+j/2)<br />EXITM &lt;(&quot;mov eax,&quot;),j&gt;<br />EXITM &lt;&gt;<br />EXITM<br /></div><br /><br />Any macro can contain zero or more EXITM statements, so any macro can return something.<br />If the macro is executed in &#039;statement form&#039;, the data returned by EXITM will be ignored.<br />But if the macro is executed in &#039;expression form&#039;, the data returned by EXITM will replace the macro execution tokens inline, and the resulting statement will be reparsed and reinterpreted inline...<br />Well, if we returned a literal string it needs to be reparsed - otherwise we can skip that part since we&#039;re not working with anything &#039;new&#039;. <br /><br />Sound good?<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-06-04 01:02:27 by Homer</div>
   </div>
   <div class="post" id="post-211940">
    <div class="subject"><a href="#post-211940">Re: Assembler Engine</a></div>
    <div class="body"><br />In the end, the grammar for EXITM became even more flexible.<br />The surrounding &lt;&gt; are optional.<br />Braces are required around complex expressions, but not needed for literal strings.<br />Of course - I&#039;m yet to code the handler for EXITM, but I have begun writing code to perform a macro execution - so far I&#039;m able to search for and find the macro by name with respect to its declaration scope (namespacing), and I have expanded the list of macro arguments (if any) given with the macro execution statement.<br />Now I need to clone the macro&#039;s payload of statements, and for each statement, perform any &#039;replacements&#039; (of macro arg name references) and finally throw the statement to the Interpret() method.<br />Once I&#039;m able to &#039;expand a macro&#039; in this way, I&#039;ll be interested in handling the EXITM directive.<br /><br />All smooth sailing!<br /><br />Attached is an update of the Main Grammar, showing some new stuff for Macros.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3160" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-06-04 01:38:33 by Homer</div>
   </div>
   <div class="post" id="post-211941">
    <div class="subject"><a href="#post-211941">Re: Assembler Engine</a></div>
    <div class="body"><br />Successfully implemented code to execute (expand and interpret) &quot;macro execution statements&quot;, complete with a mechanism for returning EXITM tokens (which I currently do nothing with).<br />But hey, it&#039;s a HUGE step fowards!<br />I&#039;ll probably now implement the code for handling &quot;macro execution expressions&quot;, expecting to use at least some of the same code.<br /><br />What I&#039;ve really done is collect up the statements inside macro declarations (as a single, unexpanded reduction, equivalent to one token called &lt;MacroStatements&gt;), deferring their interpretation until the macro is actually executed. At that point I clone a copy of the macro&#039;s (still unexpanded) statements reduction.<br />I pass this copy of the unexpanded macro statements, along with a copy of the execution args, to a utility method whose purpose is to perform &#039;argument name replacements&#039;, before passing the (STILL unexpanded) statements to the default handler for standard interpretation.<br /><br />Our macros can contain two kinds of statements.<br />They can contain &lt;Statement&gt;, and they can contain :<br />&nbsp;  &#039;exitm&#039; &lt;MacroExit&gt; &lt;Terminator&gt;<br /><br />Normal &lt;Statement&gt; reductions never return any tokens - statements are wholly consumed by the interpreter.<br />But the exitm statement MAY return some tokens - so if we see a MacroExit statement, we need to:<br /><br />#1 - stop expanding the macro statements<br />#2 - expand and return the &lt;MacroExit&gt; reduction.<br /><br /></div>
    <div class="meta">Posted on 2010-06-04 03:04:04 by Homer</div>
   </div>
   <div class="post" id="post-211942">
    <div class="subject"><a href="#post-211942">Re: Assembler Engine</a></div>
    <div class="body">Modified the grammar slightly - attached update.<br /><br />Especially, see this:<br /><div class="quote"><br />&lt;MacroX&gt; ::= &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#039;%&#039; &lt;ID&gt; &nbsp;&lt;ArgList&gt;						!Execute Macro statement<br />&lt;Macro Execute InLine&gt; ::= &#039;%&#039; &lt;ID&gt; &#039;(&#039; &lt;ArgList&gt; &#039;)&#039;			!Execute Macro expression<br />				 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;&lt;ID&gt; &#039;(&#039; &lt;ArgList&gt; &#039;)&#039;			! % is optional for expression-based macro executions<br /><br />&lt;ArgList&gt; ::= &lt;Value&gt; &#039;,&#039; &lt;ArgList&gt; | &lt;Value&gt; | &nbsp;!&lt;--Can be nothing<br /></div><br /><br />There&#039;s our two forms of macro execution.<br />As you can see, I&#039;ve decided that both kinds of macro executions should be able to begin with a &#039;%&#039; (for consistancy), but that for &#039;expression based&#039; macro executions, the &#039;%&#039; is entirely optional.<br />You can also see that I&#039;ve gone to some effort to make these two reductions (MacroX and Macro Execute Inline) look very much like each other - I intend to use my new ClipTokens method to force one of them to conform strictly to the other and so be able to use the same code to handle the conformed reductions.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3161" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-06-04 04:29:09 by Homer</div>
   </div>
   <div class="post" id="post-211944">
    <div class="subject"><a href="#post-211944">Re: Assembler Engine</a></div>
    <div class="body"><br />Both statement and expression-based macros have been implemented, with the exception of a missing function for performing &#039;argument-name replacements&#039; prior to macro expansion and interpretation.<br /><br />It&#039;s worth talking briefly about the behavior of the IF directive with respect to macros.<br /><br />Normally, when the interpreter sees an IF directive, it will conditionally follow one of the blocks of casecode associated with the IF directive - that means it will always ignore the sourcecode in the cases that it did not follow - possibly all of them! And our interpreter is destructive - we&#039;ll never see this IF directive ever again (and we should not need to).<br /><br />But macros defer the interpretation of any statements they contain.<br />So when the assembler sees our macro declaration and &#039;scoops up&#039; the statements inside it, it ALSO scoops up any IF directives that are in there.<br />In turn, this means that the IF directives inside our macros are &#039;persistant&#039; in that they exist permanently as statements of the macro, thus they will be interpreted every time the macro is executed.<br /><br />Even though our interpreter is destructive, this won&#039;t destroy the content of a macro, because we hand a cloned copy of the content to the interpreter, rather than the original... thus, &quot;permanent IFs&quot;.<br /><br />This is a good thing, because although an IF condition may not be true at one point in time, it MAY be true at a later point in time, so a macro containing one or more IF directives can &#039;unfold&#039; in more than one way, depending on some condition that we define.<br /><br /></div>
    <div class="meta">Posted on 2010-06-04 07:04:41 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29964&amp;page=1" style="">&laquo;</a><a href="../?id=29964&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29964" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29964&amp;page=4">&gt;</a><a href="../?id=29964&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>