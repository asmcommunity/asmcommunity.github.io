<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Assembler Engine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29964" />
    <link rel="next" href="../?id=29964&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29964">Assembler Engine</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29964&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29964&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29964" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29964&amp;page=2">&gt;</a><a href="../?id=29964&amp;page=4">&raquo;</a></form>   <div class="post" id="post-211567">
    <div class="subject"><a href="#post-211567">Assembler Engine</a></div>
    <div class="body"><br />Hello once again!<br /><br />This thread will document my implementation of a general-purpose x86 assembler.<br />The AssemblerEngine class derives directly from MacroEngine.<br />Its main job is to select a binary encoding for an input opcode reduction, and emit that data to an output segment.. but it also needs to generate labels, etc.<br /><br />The grammar defines the opcodes very loosely: just as a mnemonic and a number of operands.<br />It&#039;s up to the AssemblerEngine to observe operand types, and attempt to select an opcode that matches.<br />The opcode encodings themselves are parsed (by AssemblerEngine) from a custom text file into a searchable array. <br /></div>
    <div class="meta">Posted on 2010-05-04 05:19:40 by Homer</div>
   </div>
   <div class="post" id="post-211571">
    <div class="subject"><a href="#post-211571">Re: Assembler Engine</a></div>
    <div class="body">You might want to take a look at the &quot;HLA Back Engine&quot; (HLABE) while working on this project.&nbsp; The HLABE program is an x86 object-code formatter than takes an intermediate format (mostly byte statements plus certain variable-sized instructions like conditional jumps) and translates the result into PE/COFF .obj files (Windows), ELF files (Linux and FreeBSD, among others), and Mach-O (Mac OSX).&nbsp; If you conform your object output to what HLABE expects, you can automatically generate code for Windows, Mac OSX, Linux, and FreeBSD.<br />You can find all the source code to the HLABE on SourceForge here:<br />http://sourceforge.net/projects/hlabe/<br /><br />Cheers,<br />Randy Hyde<br /></div>
    <div class="meta">Posted on 2010-05-04 18:36:23 by rhyde</div>
   </div>
   <div class="post" id="post-211578">
    <div class="subject"><a href="#post-211578">Re: Assembler Engine</a></div>
    <div class="body">Thanks Randy, I&#039;ll be sure to take a good look at what you&#039;ve been up to :)<br />It&#039;s interesting that you too have decided to distance your work from MASM.<br />I&#039;m guessing it&#039;s for the same reason - the license restrictions regarding output for non-windows (and os2) platforms.<br />You didn&#039;t call it an assembler - but an object emitter ... an interesting choice.. I&#039;m already curious to find out exactly what it provides - and what kind of license you chose.<br />I&#039;ve already begun working on my own back end, as you can imagine.. so I&#039;m quite looking forwards to taking a peek.<br /><br /><br />Must be VERY new, there&#039;s no binary or source files available on the sourceforge page... although I didn&#039;t check SVN.<br /></div>
    <div class="meta">Posted on 2010-05-04 23:26:40 by Homer</div>
   </div>
   <div class="post" id="post-211579">
    <div class="subject"><a href="#post-211579">Re: Assembler Engine</a></div>
    <div class="body"><div class="quote"><br />Thanks Randy, I&#039;ll be sure to take a good look at what you&#039;ve been up to :)<br />It&#039;s interesting that you too have decided to distance your work from MASM.<br />I&#039;m guessing it&#039;s for the same reason - the license restrictions regarding output for non-windows (and os2) platforms.<br /></div><br />Well, I originally moved away from MASM because MASM didn&#039;t run on Linux, FreeBSD, and Mac OSX (the other platforms that HLA supports). However, as time passed, I finally got tired of listening to people complain that &quot;HLA isn&#039;t a *true* assembler because it doesn&#039;t directly emit object code.&quot; This was largely a historical misconception. Sometime around 2005 or 2006 I modified HLA to emit the actual opcodes for the instructions as BYTE statements in MASM/Gas/FASM/etc., so all that HLA was using the back-end assemblers for was as an object code file formatter (i.e., producing PECOFF, Elf, and Mach-O files from the binary data I&#039;d generated) and as a jump displacement optimizer. A year or two ago, however, I bit the bullet and wrote my own back-end (HLABE) that converted an HLABE internal format directly into object output.<br /><br />As for being concerned about the MASM license restrictions -- I stopped caring about that issue when I ported HLA to emit FASM, TASM, NASM, and Gas code many, many years ago. &nbsp;Today, HLA&#039;s ability to emit source file for these assemblers is mainly educational -- sometimes it&#039;s nice to see what the HLA code looks like when compiled into the syntax of these other assemblers.<br /><br /><div class="quote"><br />You didn&#039;t call it an assembler - but an object emitter ... an interesting choice.. I&#039;m already curious to find out exactly what it provides - and what kind of license you chose.<br />I&#039;ve already begun working on my own back end, as you can imagine.. so I&#039;m quite looking forwards to taking a peek.<br /></div><br /><br /><div class="quote"><br /><br />Must be VERY new, there&#039;s no binary or source files available on the sourceforge page... although I didn&#039;t check SVN.<br /><br /></div><br />Sorry, it&#039;s all in SVN. &nbsp;You can also grab a copy of HLABE as part of the HLA source code at this link:<br />http://homepage.mac.com/randyhyde/webster.cs.ucr.edu/HighLevelAsm/WinDownload.html<br /><br />There is no documentation for HLABE other than what is in the comments. Here is the basic format of the HLABE internal format (an ASCII memory file):<br /><pre><code><br />/////////////////////////////////////////////////////////////////////////////////<br />//<br />// Scan an HLABE (HLA back engine) assembly file. &nbsp;Such files contain the<br />// following statements:<br />//<br />// .a	&lt;x&gt;						Alignment<br />// .b	&lt;blist&gt;					Byte data<br />// .c							Code section<br />// .d	&lt;dlist&gt;					Dword data (includes relocatable)	<br />// .e	l1, l2					 &nbsp; &nbsp; &nbsp; &nbsp;Equate<br />// .f	l						End of function<br />// .l	&lt;llist&gt;					Lword data<br />// .o	&lt;string&gt;				 &nbsp; &nbsp; &nbsp; &nbsp;sOurce file name<br />// .p	l						Public symbol<br />// .q	&lt;qlist&gt;					Qword data<br />// .r	&lt;x&gt;						Reserve Storage<br />// .s							Static/Data section<br />// .t	&lt;tlist&gt;					TByte data<br />// .ub	&lt;x1&gt;,&lt;x2&gt;			Duplicated byte data<br />// .uw	&lt;x1&gt;,&lt;x2&gt;			Duplicated word data<br />// .ud	&lt;x1&gt;,&lt;x2&gt;			Duplicated dword data<br />// .v							BSS section<br />// .w	&lt;wlist&gt;					Word data<br />// .x	lbl						External symbol<br />// .y							READONLY/CONST section<br />// .z							End of source<br />//<br />// :lbl				Defines label at current program counter location.<br />//<br />// Except for label (which is terminated by a newline character), there<br />// is always at least one space between the statement and any operands.<br /><br />// Numbers beginning with &#039;$&#039; are hexadecimal values, decimal if no &#039;$&#039; prefix.<br />// Decimal numbers may contain chars 0..9 and &#039;_&#039;. Hexadecimal numbers may<br />// also contain &#039;a&#039;..&#039;f&#039; and &#039;A&#039;..&#039;F&#039;.<br />//<br />// Labels always begin with alpha or &#039;_&#039; character and may contain<br />// alphanumeric, &#039;_&#039;, &#039;$&#039;, &#039;?&#039;, and &quot;@&quot; characters after the first char.<br />// In general, labels can be any length, but the object file format or specific<br />// linkers may enforce their own limits. As a general rule, symbols should be<br />// unique within the first 32 characters.<br />//<br />//<br />// &lt;x&gt;, &lt;x1&gt;, &lt;x2&gt;, and &lt;x3&gt; are simplified (absolute) arithmetic expressions <br />// defined as follows:<br />//<br />//	$&lt;hex digits&gt;	-- Hexadecimal value<br />//	&lt;dec digits&gt;	-- Decimal (base 10) value<br />//	&lt;x1&gt; + &lt;x2&gt;	-- Sum of two subexpressions<br />//	&lt;x1&gt; - &lt;x2&gt;	-- Difference of two subexpressions<br />//<br />// Evaluation of subexpressions is strictly left-to-right with no precedence.<br />//<br />// Relocatable expressions are a vector with a label component and an<br />// absolute expression component. &nbsp;This is generally specified as &lt;r+x&gt;.<br />// The syntax for a relative expression is one of the following:<br />//<br />//	&lt;x&gt;			-- An absolute expression (which has a NULL relocatable value)<br />//	id			-- A relocatable identifier.<br />//	id + &lt;x&gt;		-- An identifier (relocatable) followed by an abs expr.<br />//	id - &lt;x&gt;		-- A relocatable identifier followed by an abs expr.<br />//<br />//<br />//<br />//<br />// Blank lines are permissible in the source file.<br />// Comments begin with a &#039;;&#039; and consume everything to the end of the line.<br />//<br />//<br />// .a &lt;expr&gt;<br />//<br />// The alignment statement will align the next byte emitted in the current<br />// section to some boundary that is a power of two. The operand is a single<br />// expression that evaluates to a small integer value. The alignment value <br />// must always be a power of two. It should also be in the range 1..16. &nbsp;<br />//<br />// Alignment statement will fill with zeros in static/data section, with no-<br />// operations in a code section (this could be &quot;multi-byte NOPs&quot;, not<br />// necessarily a sequence of individual NOP instructions), <br />// and will do a reserve storage operation in the BSS section.<br />//<br />// .c, .s, .v, .y<br />//<br />//	These four statements begin (or continue) a code (.c), readonly/const (.y),<br />// data/static (.s), BSS (.v) section in the program. Note that multiple <br />// instances of each section statement may appear within a single source file. <br />// When multiple instances of a given section in the source file exist, <br />// HLABE will combine the different instances into a single section.<br />//<br />// Within a section, order of data/code is strictly maintained, but if multiple<br />// section declarations for the same section appear in a source file, there is<br />// no guarantee of the order the subsections will be combined. If strict ordering<br />// is required, the caller should combine the sections and emit them as a single<br />// section when creating the HLABE source file.<br />//<br />// &nbsp;No explicit alignment is assumed when a section begins. Calling code<br />// must explicitly issue a &quot;.a&quot; statement if alignment is desired or required.<br />// <br />// .b, .w, .d, .q, .t, .l<br />//<br />// These directives	emit bytes, word, doublewords, quadwords, tbytes, or<br />// lbytes (128-bit values) to the current section (code or data/static, these<br />// directives cannot appear in a BSS section). &nbsp;These directives have the<br />// following syntax and semantics:<br />//<br />// .b &lt;blist&gt;	<br />//		&lt;blist&gt; is a list of one or more byte items. A byte item is either an<br />//		expression that evaluates to a value in the range 0..$ff<br />//		(or -128..+127) or a sequence of characters surrounded by<br />//		quotes. If more than one byte item appears in a &lt;blist&gt;, the<br />//		byte items are comma-separated. Note that quote<br />//		characters never appear within a string (they must be converted <br />//		to &#039;$22&#039; byte items). Also, only printable ASCII characters <br />//		may appear within a quoted string (characters whose codes are<br />//		in the range $20..$7e).	All other characters must be converted<br />//		to numeric byte item entries.<br />//<br />// .w &lt;wlist&gt;<br />//		A &lt;wlist&gt; is a list of one or more word items. Word items are <br />//		expressions that evaluate to 16-bit (or smaller) values. Multiple <br />//		items in a &lt;wlist&gt; are comma-separated. &nbsp;<br />//<br />// .d &lt;dlist&gt;	<br />//		A &lt;dlist&gt; is a list of one or more dword items. Dword items are <br />//		relocatable or absolute expressions that evaluate to 32-bit (or smaller) <br />//		values. Multiple items in a &lt;dlist&gt; are comma-separated. Pointer <br />//		constants (relocatable objects) are also valid dword items. &nbsp;A pointer <br />//		constant is one of the following:<br />//<br />//			lbl<br />//			lbl+&lt;x&gt;<br />//			lbl-&lt;x&gt;<br />//			(lbl+&lt;x&gt;)<br />//			(lbl-&lt;x&gt;)<br />//<br />//		where &quot;lbl&quot; is a relocatable statement label and &lt;x&gt;<br />//		is any valid dword expression. HLABE always emits a<br />//		relocatable offset value for these items ( &lt;r+x&gt; ).<br />//		Note that all dword constants are always a tuple. If<br />//		the dword constant is absolute, then the relocatable component (&lt;r&gt;)<br />//		is set to the NULL pointer. &nbsp;<br />//<br />// .q &lt;qlist&gt;	<br />//		A &lt;qlist&gt; is a list of one or more qword items. Qword items are <br />//		numeric operands that evaluate to 64-bit (or smaller) values. Multiple <br />//		items in a &lt;qlist&gt; are comma-separated. &nbsp;<br />//<br />// .t &lt;tlist&gt;<br />//		A &lt;tlist&gt; is a list of one or more tbyte items. TByte items are <br />//		numeric operands that evaluate to 80-bit (or smaller) values. Multiple <br />//		items in a &lt;tlist&gt; are comma-separated. &nbsp;<br />//<br />// .l &lt;llist&gt;<br />//		A &lt;llist&gt; is a list of one or more lword items. Lword items are <br />//		numeric operands that evaluate to 128-bit (or smaller) values. Multiple <br />//		items in an &lt;llist&gt; are comma-separated. <br />//<br />// .ub &lt;x1&gt;,&lt;x2&gt;<br />//		&lt;x1&gt; is a duplication count. &lt;x2&gt; &nbsp;is a data value, which should be<br />//		a byte. This directive, which is valid only in the<br />//		code and static/data sections (illegal in the BSS section) is used to<br />//		fill a block of memory with a specific value. The values must be<br />//		absolute.<br />//<br />// .uw &lt;x1&gt;,&lt;x2&gt;<br />//		&lt;x1&gt; is a duplication count. &lt;x2&gt; &nbsp;is a data value, which should be<br />//		a word. This directive, which is valid only in the<br />//		code and static/data sections (illegal in the BSS section) is used to<br />//		fill a block of memory with a specific value. The values must be<br />//		absolute.<br />//<br />// .ud &lt;x1&gt;,&lt;x2&gt;<br />//		&lt;x1&gt; is a duplication count. &lt;x2&gt; &nbsp;is a data value, which should be<br />//		a relocatable dword value. This directive, which is valid only in the<br />//		code and static/data sections (illegal in the BSS section) is used to<br />//		fill a block of memory with a specific value. The values can be<br />//		absolute or relative (absolute dword values are &lt;r+x&gt; values with<br />//		the relocatable field set to NULL).<br />//<br />// .r &lt;x&gt;<br />//		Reserves &lt;x&gt; bytes of data at the current program counter location in<br />//		the current section. If a code section, the reserved storage is filled<br />//		with NOP-style instructions, if a data/static section, the reserved<br />//		storage is filled with zeros. This statement is valid in, and is<br />//		mainly intended for use in, a BSS section.<br />//<br />//<br />// .e lbl, &lt;text&gt;<br />//<br />// Equates simply do a textual substitution of the &lt;text&gt; operand for the label<br />// operand. I.e., everywhere &quot;lbl&quot; appears (in the example above), HLABE <br />// substitutes the remaining text on the line (up to the end of the line or up<br />// to a comment beginning with a &quot;;&quot;) for the symbol. After substitution, HLABE<br />// continues processing the source line as though the &lt;text&gt; data originally<br />// appeared in place of the symbol. Note that if the &lt;text&gt; string contains <br />// other equate symbols, they will be processed as well. There is no check<br />// for infinite loops in the text substitution process. It is the responsibility<br />// of whomever created the equate(s) to ensure that a recursive definition<br />// does not exist. Note that only a single line of text substitution is<br />// possible (i.e., this is not a generalized macro facility).<br />//<br />//<br />// .f lbl<br />//<br />//	Marks the end of a function. When generating ELF code, this will<br />// change the symbol type (of the corresponding label) in the symbol<br />// table and set the length of the function.<br />//<br />//<br />// In addition to the above statements, an HLABE program may also contain<br />// jmp, call, and any of the following conditional jump instructions:<br />// ja, jae, jb, jbe, jc, je, jg, jge, jl, jle, jna, jnae, jnb, jnbe,		<br />// jnc, jne, jng, jnge, jnl, jnle, jno, jnp, jns, jnz, jo, jp, jpe, jpo,		<br />// js, jz, jcxz, jecxz, loop, loope, loopne, loopz, or loopnz.<br />//<br />// Any number of spaces and/or tabs may precede these statements. Any number<br />// of spaces and/or tabs may appear between the instruction mnemonic and<br />// the single label operand. After the label, at least one space will appear.<br />// After each jump, call, or conditional jump instruction, there will always<br />// be a comment of the form:<br />//<br />//	&quot;;filename, line#&quot;<br />//	&quot;;filename, line# ;filename line#; ...&quot;<br />//<br />// This is a list of filenames and line numbers in the original source<br />// file where the statement that emitted this code can be found. If the<br />// statement was emitted from a macro or include file, there will be more than<br />// one filename/line# pair (with the last entry being the file/line# of the<br />// actual statement within the macro or include file). The HLABE compiler<br />// should parse this information and display it if there is an error<br />// compiling the statement (e.g., branch out of range). &nbsp;Line numbers are always<br />// unsigned decimal integers.<br />//<br />// Note that call and jmp statements only appear in a source file for<br />// relative jumps and calls. Those that do indirect jumps or calls must be<br />// compiled directly to machine code by the caller.<br />//<br />// All reserved words use lower case characters only. Labels, however, may<br />// contain upper and lower case characters (and are case sensitive).<br /><br /></code></pre><br /><br /><br />If you run the HLA compiler, you can tell it to produce HLABE output (rather than object code) by using the -source -hlabe command line options. For example, here&#039;s a test file I had laying around:<br /><pre><code><br /><br />unit t; <br /><br />#includeonce (&quot;t.hhf&quot;) <br />#include(&quot;stdlib.hhf&quot;) <br /><br />?@nodisplay := true; <br />?@noalignstack := true; <br /><br /><br />//static <br />//	_VMT_tList___hla_	:dword; @external; <br /><br />const <br />listebx	:text := &quot;(type fileNode_t)&quot;; <br /><br /><br />method tFileList.remove ( var lNode:baseNode_t); <br />begin remove; <br />	//USE (EAX, EBX); <br />	mov (lNode, ebx); <br />	str.free (listebx.fname); <br />	if (listebx.iname &lt;&gt; 0) then <br />	str.free (listebx.iname); <br />	endif; <br />	if (listebx.ipath &lt;&gt; 0) then <br />	str.free (listebx.ipath); <br />	endif; <br />	//push (lNode); <br />	//call ( tListVMT [@offset ( tList.remove)]); <br />	super.remove( lNode ); <br />	//ENDUSE; <br />end remove; <br /><br />end t;<br /></code></pre><br />and here is the HLABE output that HLA produced for the above code using the -source -hlabe command line options:<br /><pre><code><br />; Assembly code emitted by HLA compiler<br />; Version 2.9 build 3590 (prototype)<br />; HLA compiler written by Randall Hyde<br />; HLA backend compatible output<br /><br /><br /><br />.p tFileList_remove<br />.c <br /><br />.x STR_FREE<br />.x HWexcept__hla_<br />.x abstract__hla_<br />.x Raise__hla_<br />.x shortDfltExcept__hla_<br /><br /><br /><br /><br />.c <br /><br />; procedure tFileList_remove<br /><br />:tFileList_remove<br />.b $55<br />.b $8b<br />.b $ec<br />.b $8b<br />.b $5d<br />.b $8<br />.b $ff<br />.b $73<br />.b $8<br />call STR_FREE ;t.hla,22<br />.b $83<br />.b $7b<br />.b $4<br />.b $0<br />je false__hla_1882 ;t.hla,23<br />.b $ff<br />.b $73<br />.b $4<br />call STR_FREE ;t.hla,24<br />:false__hla_1882<br />.b $83<br />.b $7b<br />.b $c<br />.b $0<br />je false__hla_1883 ;t.hla,26<br />.b $ff<br />.b $73<br />.b $c<br />call STR_FREE ;t.hla,27<br />:false__hla_1883<br />.b $ff<br />.b $75<br />.b $8<br />.b $8d<br />.b $3d<br />.d _VMT_tList_t___hla_<br />.b $ff<br />.b $17<br />:xtFileList_remove__hla_<br />.b $8b<br />.b $e5<br />.b $5d<br />.b $c2<br />.w $4<br />.f tFileList_remove<br /><br /><br /><br /><br /><br /><br /><br />.y <br /><br /><br />.s <br />.x __imp__MessageBoxA@16<br />.x _VMT_tFileList___hla_<br />.x __imp__ExitProcess@4<br />.x _VMT_tBase_t___hla_<br />.x _VMT_tList_t___hla_<br />.a $4<br /><br /><br /><br /><br /><br />.z <br /><br /></code></pre><br />One thing really nice about HLABE is that it does a really great job of optimizing branch displacements. Better than MASM, FASM, and most of the other assemblers I&#039;ve seen (on par with NASM, which also does a great job).<br /><br />BTW, HLABE is quite fast; you don&#039;t take a performance hit for using it to process the back end of your assembler&#039;s output. One of the main reasons the intermediate language is so simple is to make scanning and parsing each statement as trivial (and as fast) as possible.<br /><br />Cheers,<br />Randy Hyde<br /></div>
    <div class="meta">Posted on 2010-05-05 16:19:47 by rhyde</div>
   </div>
   <div class="post" id="post-211650">
    <div class="subject"><a href="#post-211650">Re: Assembler Engine</a></div>
    <div class="body"><br />The first step for building the assembler proper is to somehow load/import a description of how to form legal opcode encodings. For this, I have chosen to create a small textfile containing all the opcode encoding data, and a specialized parser just to read that file.<br />Here I have attached the opcodes file, and the grammar for parsing it.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3127" target="_blank">OpCodes.grm.txt</a></li>
      <li><a href="../../attachments/?id=3128" target="_blank">x86OpCodes.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-10 21:54:37 by Homer</div>
   </div>
   <div class="post" id="post-211652">
    <div class="subject"><a href="#post-211652">Re: Assembler Engine</a></div>
    <div class="body"><br />That&#039;s half the story.<br />Now we need a derived Parser class which implements handlers for the nonterminals in our grammar (well, the ones that are important to us).<br /><br />We want to expand each &lt;OpCode&gt; reduction in the parsetree, and store them out into some kind of runtime array of structs / objects. This will be the database from which we&#039;ll make opcode encoding selections later on.<br /><br />It&#039;s important that we eliminate each &lt;OpCode&gt; reduction from the tree as soon as we&#039;ve fully expanded it.<br />The reason is that if we don&#039;t, it will be handed back UP the tree to the parent &lt;OpCodes&gt; reduction, which will then do the same thing, effectively appending all the statements together into one massive statement.. that&#039;s not our goal.<br /></div>
    <div class="meta">Posted on 2010-05-11 07:10:03 by Homer</div>
   </div>
   <div class="post" id="post-211656">
    <div class="subject"><a href="#post-211656">Re: Assembler Engine</a></div>
    <div class="body"><br />I&#039;ve made a few more small improvements to make the parser framework rock solid.<br />There is now a direct descendance from Parser, through Interpreter, etc.<br />I&#039;ve just successfully tested a beta for the new derived &#039;OpCode Parser&#039; class.<br />It&#039;s not much to look at yet, so no demos.. took a bit of work to recover from the changes I made.<br />All for the greater good :)<br /><br />Anyway, I&#039;m now at the point where I&#039;m ready to store the parsed opcode encodings into some other form.<br />I&#039;m going to stop there, because I&#039;m not sure yet which form will prove to be most useful in terms of the pattern-matching required for selecting opcode encodings.<br /><br />It&#039;s probably time to turn my attention once more to the main grammar - which I&#039;m completely unhappy with right now.<br />I&#039;ll probably strip it right back to just try to implement what a crude assembler needs: opcodes, operands and little else.<br />This is mainly in response to some expected technical issues / implementation nightmares regarding the macro engine.<br /><br /></div>
    <div class="meta">Posted on 2010-05-11 08:29:54 by Homer</div>
   </div>
   <div class="post" id="post-211674">
    <div class="subject"><a href="#post-211674">Re: Assembler Engine</a></div>
    <div class="body">Attached is an improved version of the grammar for parsing the opcodes sourcefile - note that there are fewer cases for each nonterminal (rule)... and especially, there&#039;s only two cases for &lt;OpCode&gt;, and they&#039;re almost identical.<br />This makes for less complex (smaller and faster) handling code in the parsetree resolver, but has a more dramatic effect on the overall time for tree recursion: it can make a huge difference because it makes the parsetree smaller and less deep, and so faster to resolve. Of course, if not used appropriately, it can have the opposite effect :D<br /><br />Also attached is an update of the Parser baseclass, and Interpreter midclass.<br />Stability and speed have both been addressed, changes are minor but cumulative.<br /><br />I&#039;ve also extended the main grammar file, it now contains a simplified description of all of our opcodes.. in most cases, just the unique mnemonics, and number of operands. I&#039;m not at ALL enforcing types in the dfa/lalr stage of the parser, this could change, but for now I&#039;ll be happy to accept everything and have my code try to guess the operand types.<br />(Basically, I did try to explicitly describe a handful of opcode encodings in the main grammar rules, and it caused so many ambiguities in the grammar that I decided this wasn&#039;t the place to handle it).<br /><br />Also, the main grammar has been modified into a LINE BASED GRAMMAR.<br />Essentially, all that means is that we define a rule for &#039;new line&#039;, which we can use within our rules at our discretion, and we&#039;ll expect to see it appear as a token in our parsetree, at the end of logical statements and soforth.<br />(I found that a few well-placed &lt;NewLine&gt; delimiters in the &#039;high order entity&#039; rules actually helped eliminate 99.9% of grammatic ambiguities, which became critical as the grammar grew in complexity).<br /><br />I&#039;m still of two mind as to how much I&#039;ll allow to appear on a single line, but statements that are delimited by something OTHER than a new line, are certainly not out of the question.. however, being able to detect these &#039;new line&#039; tokens in the stream can still be useful as a tool for delimiting entities late in the parsing job (say, after some macro has spewed forth some inline code that our parser has never seen).<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3129" target="_blank">OpCodes.grm.txt</a></li>
      <li><a href="../../attachments/?id=3130" target="_blank">Parser.inc</a></li>
      <li><a href="../../attachments/?id=3131" target="_blank">Interpreter.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-12 02:23:26 by Homer</div>
   </div>
   <div class="post" id="post-211691">
    <div class="subject"><a href="#post-211691">Re: Assembler Engine</a></div>
    <div class="body">Here&#039;s the latest incarnation of the main grammar file.<br />This one contains a &#039;brief&#039; version of the opcodes, as well as some minor improvements to the grammar.<br />This simple grammar already generates over 1000 LALR states, and over 45,000 DFA States.<br />Uncompressed, this grammar compiles to a datatables file of 508kb.<br /><br />I&#039;m implementing the following grammar:<br />#1-Directives must appear on their own line, terminated by &lt;CR&gt;,&lt;LF&gt;, or both.<br />#2-Multiple OpCodes can appear on a single line, if separated by the &#039;;&#039; character, and observing rule #1<br />#3-Complex Expressions can be used as Operands, if they eventually express a numerical value (ie #immediate).<br /><br />This is perfectly legal:<br /><div class="quote"><br />a = 72.3<br />mov eax, a*32/12.4 &nbsp;; push eax<br /></div><br />&quot;a&quot; is a numerical (currently hex, dec, or float) literal representing an immediate numerical value, its not a stack local or a data variable.... we can&#039;t use those in complex expressions, only in complex addressing modes (which can involve complex expressions, heh).<br />In this example, I&#039;m pushing a real4 immediate floating point value calculated at buildtime.<br />It&#039;s not a good or clever example, but it shows the flexibility of the syntax.<br />In fact it should be obvious that we could simply push (complex expression) - and in this case, we could declare the TYPE of the float we are pushing - up to real8, my current choice of internal representation.<br />eg:<br /><div class="quote"><br />push real8 a*32/12.4<br /></div><br /><br /><br /><br />I will implement the &#039;line continuation&#039; symbol at a later time.<br /><br />Right now, I&#039;m playing with a class to represent an output segment, so I can get down to the dirty job of recognizing addressing forms in opcodes, and searching for matching opcode encoding descriptors.<br />The current demo loads the opcode descriptor grammar and then parses the opcode descriptors sourcefile using an embedded derived parser class... then it loads the main grammar file, and then attempts to parse and interpret an input sourcecode file using the main grammar... a start :)<br /><br />The grammars are completely unrelated, thats why I used a separate parser-derived class for the opcode descriptors.<br />Those are purely internal, just my mechanism for getting that data into a form I can readily use in the main engine.<br />I believe that NASM uses a Python script to generate its opcode tables, I don&#039;t know what other people do but I suggest that everyone, at some point, is parsing the data from plaintext descriptions.<br /><br /><br /><br /><br />I still haven&#039;t talked about the issues involved in opcode selection, that will happen soon :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3133" target="_blank">Main.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-14 10:35:15 by Homer</div>
   </div>
   <div class="post" id="post-211698">
    <div class="subject"><a href="#post-211698">Re: Assembler Engine</a></div>
    <div class="body"><br />OK - about opcode encoding selection.<br />There are two key issues: one-to-many mappings, and branch optimization.<br /><br />#1<br />Often, we won&#039;t have a choice - there will only be one suitable opcode encoding.<br />But sometimes, we&#039;ll have to choose between several possible ways to encode the same instruction.<br />Some will be longer in terms of #bytes - but may still execute more quickly.<br />Which do we choose? This heuristic should be something we can set.<br /><br />#2<br />We might think of the bytes being emitted to the Code Segment as being sequence of chunks of linear opcodes, delimited by (Conditional or Unconditional) branching instructions.<br />As an example, let&#039;s assume we have a number of opcodes, followed by a conditional jump (forwards), and the user hasn&#039;t specified what kind of jump.. should we be using 8, 16 or 32-bit offset? We can&#039;t know yet, because we don&#039;t know the &#039;distance&#039; to the target.. There are two solutions in common use.<br />The first is to use the longest encoding, and try to shorten it later.. causing a forwards-ripple effect as we &#039;shrink&#039; the code. Messy.<br />And the second is to defer this problem until we&#039;ve scanned all of the input... known as &#039;multipass assembly&#039;.<br />We don&#039;t actually rescan the input - we rescan our intermediate representation of it.<br />This allows us to resolve all the sizes of the linear codeblocks, and so optimize the size of the branch instructions.<br /><br />I&#039;d love to hear your thoughts on this, guys :)<br /><br /></div>
    <div class="meta">Posted on 2010-05-14 23:06:59 by Homer</div>
   </div>
   <div class="post" id="post-211701">
    <div class="subject"><a href="#post-211701">Re: Assembler Engine</a></div>
    <div class="body">OK, so here is a quite poor implementation of a Segment object which implements &quot;deferred optimization of branch instructions&quot;. It&#039;s not very complete - but the basic ideas are there.<br />Note that it has no base address, no notion of where it exists in memory, or on disk.<br /><br />I make the assumption that all segments are code segments - because data segments are trivially handled by the same code.<br /><br />The segment collects a list of two kinds of elements.<br />The first represents the binary data for a linear chunk of code - ie, a series of completely-resolved opcodes.<br />And the second represents a Branch instruction which we wish to defer.<br />Labels (local to the segment) are optionally, supported, and any element may be tagged with a label which represents the start of that element&#039;s data.<br /><br />The Insert method has been overridden: if the last element in the list is a code element, and the input element we&#039;re appending is also a code element and has no label, then we will merge the data for these two neighbouring code elements.<br /><br />This is in fact the first step to &#039;resolving the list&#039;.<br />Once the list is complete, we&#039;ll deal with the &#039;Unresolved Branch&#039; elements that are delimiting our list from collapsing into a single code element.<br /><br />For each unresolved branch element:<br />If, between this element and its labelled target, there are NO unresolved branch elements, then we can resolve this branch element and merge it into the neighbouring code element.<br />If theres an unresolved branch inbetween, we&#039;ll leave this element and come back to it after we&#039;ve resolved all that we can... I think there will be few,if any, cases which will remain unresolved after this... we should find that we&#039;ve only got one element, its a code element, and it contains all the binary data for this segment, ready to write out to our object file.<br />Actually - we&#039;ll have a list of labeled and unlabeled code elements, and no unresolved branches - at which point we can safely merge the remaining elements... anyway, the goal is to be left with just one element, one block of binary data.<br /><br /><br />I haven&#039;t mentioned object symbols, relocations, etc.<br />Guess thats coming up too :)<br /><br />How am I doing guys? Do you think I&#039;m on the right track with this? :)<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3134" target="_blank">Segment.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-15 00:46:13 by Homer</div>
   </div>
   <div class="post" id="post-211705">
    <div class="subject"><a href="#post-211705">Syntax for switching/selecting current Segment</a></div>
    <div class="body"><br /><br />The main grammar was extended to allow the following directives:<br /><br />.code<br />.data<br />.data?<br />.segment SegmentName ]<br /><br />Where the possible flags are &#039;Writeable&#039;, &#039;Executable&#039;, and &#039;BSS&#039;.<br /><br />If you select a segment that doesn&#039;t exist, it will be created.<br />If you specify no flags, it will be executable, read-only, and initialized (non bss).<br /><br />If you select a &#039;known&#039; segment (such as .Code), or a segment that you created earlier, any flags will be ignored.<br /><br /><br />The assembler now has a toplevel wrapper class to contain its components :)<br />This class embeds a collection of named Segment objects, and keeps a pointer to the current segment.<br /><br />I haven&#039;t yet implemented the &#039;Reduction Handlers&#039; for these new grammars, but I have implemented most if not all of the code that they&#039;ll be driving - so progress is good!<br /><br />And anyway, writing reduction handlers has become a trivial thing, given that I now have a good number of existing handlers to serve as a kind of design template.<br /><br />Here&#039;s a rough idea of what the assembler&#039;s current object hierarchy looks like:<br /><div class="quote"><br />;Assembler &lt;- Evaluator &lt;- Interpreter &lt;- Parser<br />; |&nbsp;  |<br />; |	 OpCodeBank &lt;- OpCodes &lt;- Interpreter &lt;- Parser<br />;Segments&nbsp; &nbsp; &nbsp; &lt;-&nbsp; &nbsp; Collection (of Segment) <br /></div></div>
    <div class="meta">Posted on 2010-05-15 02:20:15 by Homer</div>
   </div>
   <div class="post" id="post-211708">
    <div class="subject"><a href="#post-211708">Re: Assembler Engine</a></div>
    <div class="body"><br />I&#039;ve implemented the handler for &quot;segment selection&quot; (.code, .data, .data?, userdefined).<br />Attached are the assembler toplevel class, and an update of the Segment class.<br />You can see how they work together.<br /><br />Now that I&#039;m able to create/select an output segment, it&#039;s time to take a look at handling opcodes in the main grammar.<br />We&#039;ll want to identify the number and type of operands, and pass that information to an as-yet unwritten function in the OpCode-Encodings Manager which will try to find at least one encoding whose argument count and type(s) is the same (or equivalent).<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3135" target="_blank">XASM.inc</a></li>
      <li><a href="../../attachments/?id=3136" target="_blank">Segment.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-15 06:34:22 by Homer</div>
   </div>
   <div class="post" id="post-211711">
    <div class="subject"><a href="#post-211711">Re: Assembler Engine</a></div>
    <div class="body"><br />This update to the Main Grammar contains some new NonTerminals which help to identify the type of operands appearing in our opcodes. And so, it also defines all the basic datatypes (byte, word, dword, qword, tword, and the reals).<br /><br />I will be implementing a mechanism by which I can attach some useful information and/or payload entities to tokens in the parsetree, before handing them back up the tree.<br />Via this mechanism, I will be able to, at minimum,&nbsp; tag tokens with type information implied by their parent reduction, and so retain information that I deliberately planted in the parsetree according to my grammar rules.<br /><br /><br />The attached image shows the parsetree generated by the input &quot;mov dword ptr,0&quot;<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3137" target="_blank">Main.grm.txt</a></li>
      <li><a href="../../attachments/?id=3138" target="_blank">operand types.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-15 08:18:28 by Homer</div>
   </div>
   <div class="post" id="post-211712">
    <div class="subject"><a href="#post-211712">Re: Assembler Engine</a></div>
    <div class="body">Btw why <br />&quot;szDataSegment&nbsp; db &quot;.&quot;,0,&quot;d&quot;,0,&quot;a&quot;,0,&quot;t&quot;,0,&quot;a&quot;,0,0,0&quot;<br />instead of simply using &quot;dw&quot; ?</div>
    <div class="meta">Posted on 2010-05-15 08:55:34 by Ultrano</div>
   </div>
   <div class="post" id="post-211713">
    <div class="subject"><a href="#post-211713">Re: Assembler Engine</a></div>
    <div class="body">Ultrano - I have formed this habit during the design phase of this project, in order to make it absolutely clear to myself, from a distance, that a given set of strings are Wide, and not American Ascii ... The native format of strings throughout the engine is Wide, however there are a handful of methods and procedures which take an Ascii string - and a couple of times early in the work I managed to confuse them and cause problems.<br />Having resolved those problems, I left those string definitions looking like that as a future warning and reminder to myself.<br />There&#039;s no other reason.<br /><br />Everyone - I&#039;ve extended the Main Grammar to include all the 64-bit registers, and better/more Operand Type support.<br />I have extended the Token structure to allow it to carry 16-bit tags, or 32-bit pointers to user-structs.<br />This allows me to tag Tokens with context-based information, especially type information, but also generally I can now generate internal objects to be associated with tokens and passed back up the parsetree.<br /><br />Token struct<br /> &nbsp; &nbsp;ParentSymbol dd ? &nbsp; &nbsp; 	; -&gt; Symbol<br /> &nbsp; &nbsp;TokenData &nbsp; &nbsp;dd ? &nbsp; &nbsp;	; LPWSTR if Symbol is terminal, otherwise -&gt; Reduction<br /> &nbsp; &nbsp;State dd ? 				; is a LALR state.<br /> &nbsp; &nbsp; union<br /> &nbsp; &nbsp; &nbsp; pPayload dd ?			; User-Defined..<br /> &nbsp; &nbsp; &nbsp; struct<br /> &nbsp; &nbsp; &nbsp; 	_high word ?		; If _high != 0 , Payload field = ptr to MemAlloc&#039;d struct<br /> &nbsp; &nbsp; &nbsp; 	Tag &nbsp; word ?		; If _high == 0 , Tag field = userdefined constant<br /> &nbsp; &nbsp; &nbsp; &nbsp;ends<br /> &nbsp; &nbsp; ends<br />Token ends<br /><br /></div>
    <div class="meta">Posted on 2010-05-15 09:30:03 by Homer</div>
   </div>
   <div class="post" id="post-211714">
    <div class="subject"><a href="#post-211714">Re: Assembler Engine</a></div>
    <div class="body">I&#039;ve added a handler for the &lt;Operand&gt; nonterminal symbol.<br />When I see it, I grab the type of its content, then I resolve its content, then I tag the first of the N resulting tokens with the type id... look below, see the first token of &quot;operand 1&quot; has been tagged as &quot;type 5&quot;, which is &quot;Memory&quot;.<br /><br />In fact, &nbsp;I went ahead and also implemented &#039;tagging handlers&#039; for &lt;reg8&gt; thru &lt;reg64&gt;, and also &lt;Immediate&gt;, &lt;memory&gt; , &lt;regfpu&gt; and &lt;DataType&gt; &nbsp;... I&#039;ll tag all those tokens, so things like &quot;edx&quot; will be tagged as &quot;Reg32&quot; etc... automatically.<br />But the &lt;Operand&gt; handler will overwrite the tag of the first token in each resolved operand, with the overall type of the operand (will become clear, read on).<br /><br />The input statement &quot;mov dword ptr , 0&quot; currently gets processed into this:<br /><br /><div class="quote"><br />#MOV# mov Tag0 &nbsp; #dword# dword Tag5 &nbsp; #ptr# ptr Tag0 &nbsp; #[# [ Tag0 &nbsp; #EAX# eax Tag3 &nbsp; #]# ] Tag0 &nbsp; #,# , Tag0 &nbsp; #IntegerLiteral# 0 Tag6 &nbsp; <br /></div><br /><br />Where the format is &quot;#SymbolName# terminalstring TagID&quot;, and the Tag values are from my Assembler constants:<br />TAG_UNTAGGED		equ 0<br />TAG_REG8				equ 1<br />TAG_REG16			equ 2<br />TAG_REG32			equ 3<br />TAG_REG64			equ 4<br />TAG_MEMORY			equ 5<br />TAG_IMMEDIATE		equ 6<br />TAG_FPUREG			equ 7<br />TAG_DATATYPE			equ 8<br /><br />I think I should have enough information available to start looking for matching opcode encodings - except that I still have not retained my encoding data, because I wasn&#039;t sure how or what I wanted to store.<br />Now I have all the pieces to make that decision.<br /><br />It should be noted that, for OpCode statements at least, these tags are somewhat contextual - we&#039;ve tagged &quot;dword&quot; as being &quot;&lt;Memory&gt;&quot; - but this is only because it&#039;s the first token in the resolved Operand of that Type.<br />Normally, &quot;dword&quot; would be receiving a tag indicating that it is in fact a &lt;DataType&gt;.</div>
    <div class="meta">Posted on 2010-05-15 09:58:24 by Homer</div>
   </div>
   <div class="post" id="post-211715">
    <div class="subject"><a href="#post-211715">Re: Assembler Engine</a></div>
    <div class="body">So .. I&#039;ve started tagging a bunch of Terminal tokens with type information, and I&#039;m also identifying and type-tagging the operands in opcode expressions. All good stuff - some people call this &quot;augmenting the parsetree&quot;, others call it &quot;annotating&quot; - I prefer to call it decorating the tree, because it reminds me of my childhood :)<br /></div>
    <div class="meta">Posted on 2010-05-15 10:57:13 by Homer</div>
   </div>
   <div class="post" id="post-211721">
    <div class="subject"><a href="#post-211721">Re: Assembler Engine</a></div>
    <div class="body"><br />I may not get a lof of coding done today - we&#039;ll see.<br />Here&#039;s what I&#039;m dealing with.<br /><br />My example opcode statement:<br /><div class="quote"><br />mov dword ptr , 0<br /></div><br /><br />How the Assembler is viewing that statement (see previous post for tag info)<br /><div class="quote"><br />#MOV# mov Tag0&nbsp;  #dword# dword Tag5&nbsp;  #ptr# ptr Tag0&nbsp;  #[# [ Tag0&nbsp;  #EAX# eax Tag3&nbsp;  #]# ] Tag0&nbsp;  #,# , Tag0&nbsp;  #IntegerLiteral# 0 Tag6&nbsp;  <br /></div><br /><br />The opcode encoding information which should be the only match for this example:<br /><div class="quote"><br />#Identifier# MOV Tag0&nbsp;  #r/m32# r/m32 Tag0&nbsp;  #,# , Tag0&nbsp;  #imm32# imm32 Tag0&nbsp;  #;# ; Tag0&nbsp;  #o32# o32 Tag0&nbsp;  #Hex# C7 Tag0&nbsp;  #/# / Tag0&nbsp;  #Int# 0 Tag0&nbsp;  #id# id Tag0&nbsp;  #[# [ Tag0&nbsp;  #386# 386 Tag0&nbsp;  #]# ] Tag0&nbsp;  #NewLine# <br /> Tag0 <br /></div><br /><br />I need to write a function that detects that these two are a match, and no other match exists.<br />It might mean playing with the decorations a little.<br /><br /></div>
    <div class="meta">Posted on 2010-05-15 20:33:03 by Homer</div>
   </div>
   <div class="post" id="post-211726">
    <div class="subject"><a href="#post-211726">Re: Assembler Engine</a></div>
    <div class="body">Having added that code to tag Main Grammar tokens with type identifiers, I looked at the output of my OpCode Encodings Grammar, and decided it needed pretty much the same thing - to identify the overall types of each operand in the encodings, and to also identify as many other tokens as possible.<br /><br />So, I&#039;ve just done a crapload of work to support all the Types of the Operands in the OpCode Encodings - there&#039;s a bunch of &#039;compound types&#039;, special register types and other stuff that the Main Grammar currently doesn&#039;t know about - and likely won&#039;t need to.<br /><br />But I still haven&#039;t &#039;quite&#039; got the opcode encodings data in the form that best suits me for searches.<br /></div>
    <div class="meta">Posted on 2010-05-16 04:04:51 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29964&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29964&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29964" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29964&amp;page=2">&gt;</a><a href="../?id=29964&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>