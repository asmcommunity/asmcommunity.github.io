<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Bitmap to region - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24674" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24674">Bitmap to region</a></p>
   <div class="post" id="post-180271">
    <div class="subject"><a href="#post-180271">Bitmap to region</a></div>
    <div class="body">Hi<br />I come here with a well known procedure to create a region based on a bitmap with a colour treated as transparent colour. I some threads I heard about the technique I used to write this code but couldn&#39;t find the source, so I decided to post it for discussion to see if it can be improved.<br /><br />Here the code<br /><pre><code><br />Bmp2Rgn proc uses ebx edi esi hBmp:Handle, dTransparentColor:dword<br />&nbsp; &nbsp; local Bmp:BITMAP, BmpInfoHdr:BITMAPINFOHEADER, hDC:Handle<br />&nbsp; &nbsp; local pBuffer:Pointer, pRectBuffer:Pointer, dRectCount:dword<br />&nbsp; &nbsp; local dCurrScanLine:dword, sdIncrement:sdword<br /><br />&nbsp; &nbsp; invoke GetObject, hBmp, sizeof Bmp, addr Bmp<br />&nbsp; &nbsp; .if eax != 0<br />&nbsp; &nbsp; &nbsp; mov ecx, dTransparentColor&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Transform the RGB to a BGR color as it is found in mem.<br />&nbsp; &nbsp; &nbsp; rol ecx, 8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; RR GG BB AA<br />&nbsp; &nbsp; &nbsp; ror cx, 8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; RR GG AA BB<br />&nbsp; &nbsp; &nbsp; rol ecx, 16&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; AA BB RR GG<br />&nbsp; &nbsp; &nbsp; ror cx, 8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; AA BB GG RR<br />&nbsp; &nbsp; &nbsp; mov dTransparentColor, ecx<br /><br />&nbsp; &nbsp; &nbsp; mov eax, Bmp.bmWidth<br />&nbsp; &nbsp; &nbsp; shl eax, 2<br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biSizeImage, eax<br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biSize, sizeof BmpInfoHdr<br />&nbsp; &nbsp; &nbsp; mov eax, Bmp.bmWidth<br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biWidth, eax<br /><br />&nbsp; &nbsp; &nbsp; mov ecx, Bmp.bmHeight<br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biHeight, ecx<br /><br />&nbsp; &nbsp; &nbsp; .if sdword ptr (ecx) &gt; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Detect top-down or bottom-up bitmaps<br />&nbsp; &nbsp; &nbsp; &nbsp; mov sdIncrement, -1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Bottom-up bitmap<br />&nbsp; &nbsp; &nbsp; &nbsp; mov dCurrScanLine, ecx<br />&nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; mov sdIncrement, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Top-down bitmap<br />&nbsp; &nbsp; &nbsp; &nbsp; mov dCurrScanLine, -1<br />&nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biPlanes, 1<br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biBitCount, 32<br />&nbsp; &nbsp; &nbsp; mov BmpInfoHdr.biCompression, BI_RGB<br /><br />&nbsp; &nbsp; &nbsp; shl eax, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Scanline buffer = Bmp.bmWidth * 4<br />&nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; mul ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Max possible number of rects = width x height / 2<br />&nbsp; &nbsp; &nbsp; shl eax, 1<br />&nbsp; &nbsp; &nbsp; add eax, <br />&nbsp; &nbsp; &nbsp; add eax, sizeof RGNDATAHEADER<br />&nbsp; &nbsp; &nbsp; invoke VirtualAlloc, NULL, eax, MEM_COMMIT, PAGE_READWRITE<br />&nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; .if eax != NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; mov pBuffer, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax, ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov pRectBuffer, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov .RGNDATAHEADER.dwSize, sizeof RGNDATAHEADER<br />&nbsp; &nbsp; &nbsp; &nbsp; mov .RGNDATAHEADER.iType, RDH_RECTANGLES<br />&nbsp; &nbsp; &nbsp; &nbsp; mov .RGNDATAHEADER.nRgnSize, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax, sizeof RGNDATAHEADER - sizeof RECT<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edi, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov hDC, $invoke(GetDC, 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; xor ebx, ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov dRectCount, ebx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .while ebx &lt; Bmp.bmHeight<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov ecx, sdIncrement<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add dCurrScanLine, ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke GetDIBits, hDC, hBmp, dCurrScanLine, 1, pBuffer, addr BmpInfoHdr, DIB_RGB_COLORS<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov esi, pBuffer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor ecx, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;ecx = 0 =&gt; not in region flag<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor edx, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Reset Scanline pixel counter<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .while edx &lt; Bmp.bmWidth<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and eax, 00FFFFFFh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Ignore alpha value<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax == dTransparentColor<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if ecx != 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Terminate the current Rect<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov .RECT.right, edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor ecx, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Reset flag<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif ecx == 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Start a new Rect<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc dRectCount<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add edi, sizeof RECT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Point to next Rect<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax, ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov .RECT.left, edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov .RECT.top, ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov .RECT.bottom, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Set flag<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add esi, 4<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endw<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if ecx != 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Close last Rect<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov .RECT.right, edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; .endw<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, pRectBuffer<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx, dRectCount<br />&nbsp; &nbsp; &nbsp; &nbsp; mov .RGNDATAHEADER.nCount, ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; shl ecx, 4<br />&nbsp; &nbsp; &nbsp; &nbsp; add ecx, sizeof RGNDATAHEADER<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke ExtCreateRegion, NULL, ecx, pRectBuffer<br />&nbsp; &nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke ReleaseDC, 0, hDC<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke VirtualFree, pBuffer, 0, MEM_RELEASE<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br />Bmp2Rgn endp</code></pre><br /><br /><br />Regards,<br /><br />Biterider<br /></div>
    <div class="meta">Posted on 2006-04-30 15:41:11 by Biterider</div>
   </div>
   <div class="post" id="post-180277">
    <div class="subject"><a href="#post-180277">Re: Bitmap to region</a></div>
    <div class="body">There&#39;s a thread called &quot;my new getpixel, 20x faster&quot; or something similar - there&#39;s some source there. The board search engine doesn&#39;t work right now, but the files can be downloaded from http://flork.dk/junk/customshape_20040319.rar . It&#39;s C++ source though, but LEAN_AND_MEAN, and there&#39;s assembly dump of it.<br /><br />I guess we have sortof the same way of doing things, at least I also use ExtCreateRegion... I allocate memory as needed though, instead of one big chunk. As for the rest of the algorithm, I&#39;m too tired to study yours right now :)<br /></div>
    <div class="meta">Posted on 2006-05-01 06:39:59 by f0dder</div>
   </div>
   <div class="post" id="post-180284">
    <div class="subject"><a href="#post-180284">Re: Bitmap to region</a></div>
    <div class="body">Hi,<br />there is an issue with the RGB/BGR memory representation of the transparent color. I corrected it and out it in the first post.<br /><br />Biterider</div>
    <div class="meta">Posted on 2006-05-01 12:27:19 by Biterider</div>
   </div>
  </div>
 </body>
</html>