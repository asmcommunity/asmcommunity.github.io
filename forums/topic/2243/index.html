<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Netmon Source + Terminate Connection - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2243" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=2243">Netmon Source + Terminate Connection</a></p>
   <div class="post" id="post-14145">
    <div class="subject"><a href="#post-14145">Netmon Source + Terminate Connection</a></div>
    <div class="body">Hello<br />I found on Iczelions homepage the Netmon Source (Thanks) and would like to add one function to terminate a selected connection.But how to insert such function i had no exact ideas.<br />Can someone  help me please?</div>
    <div class="meta">Posted on 2001-12-06 10:16:40 by Max</div>
   </div>
   <div class="post" id="post-14378">
    <div class="subject"><a href="#post-14378">Netmon Source + Terminate Connection</a></div>
    <div class="body">Hello<br /><br />it seams no like to help me on this ,i think not that people dont know how to do this.<br />Possible someone like to help me making a port block function or take the time to explain me how the terminate connection works so i dont need to learn tcip.<br />Or if it not works or cant made by a newbie then please tell me this too :-)<br />Is this Page not for People like me too ,people who like to spend Time by asking the Prof. ?<br /><br />Im shure i dont have to learn full ASM or Win Networking to make a simple Portblock or Terminate Connection function so please help me.<br /><br />I found enough Postings about sending ICMP Ping or how to code keyloggers ,on Iczelions Homepage i found a Trojan Source Code.<br />When i browse the archiv i found a lot postings closed because of virus or trojan questions but no help to code security stuff.<br /><br />People please help me to code a simple security tool ,share what you know and dont speak about security only.<br /><br />Thanks<br /><br />Or are at last noone who code ever a security tool for himself in asm ?<br />only Gibson?<br /><br />Cant be !</div>
    <div class="meta">Posted on 2001-12-08 21:59:01 by Max</div>
   </div>
   <div class="post" id="post-14399">
    <div class="subject"><a href="#post-14399">Netmon Source + Terminate Connection</a></div>
    <div class="body">nobody owes you anything, sometimes people know the answer sometimes they don't. Sometimes the question needs to be clearer, sometimes....  it's a messageboard, not a holy grail of answers.<br /><br /><br />Study == the art of finding answers yourself.</div>
    <div class="meta">Posted on 2001-12-09 06:25:48 by Hiroshimator</div>
   </div>
   <div class="post" id="post-14408">
    <div class="subject"><a href="#post-14408">Netmon Source + Terminate Connection</a></div>
    <div class="body">Here's something I found out:<br />There's a function called SetTcpEntry in the IP helper api (see my other post in the networking forum). SetTcpEntry can set the state of one TCP connection.. Currently the only state that a connection can actually be set to is MIB_TCP_STATE_DELETE_TCB. I don't know exactly what this one means but when I tried it killed the connection.<br /><br />Here are some constants you may need <br /><pre><code><br />; only the DELETE_TCB is supported by SetTcpEntry<br />MIB_TCP_STATE_CLOSED       	equ     1<br />MIB_TCP_STATE_LISTEN        equ    2<br />MIB_TCP_STATE_SYN_SENT      equ    3<br />MIB_TCP_STATE_SYN_RCVD      equ    4<br />MIB_TCP_STATE_ESTAB         equ    5<br />MIB_TCP_STATE_FIN_WAIT1     equ    6<br />MIB_TCP_STATE_FIN_WAIT2     equ    7<br />MIB_TCP_STATE_CLOSE_WAIT    equ    8<br />MIB_TCP_STATE_CLOSING       equ    9<br />MIB_TCP_STATE_LAST_ACK      equ   10<br />MIB_TCP_STATE_TIME_WAIT     equ   11<br />MIB_TCP_STATE_DELETE_TCB    equ   12<br /><br /><br />MIB_TCPROW STRUCT<br />  dwState			DWORD	?<br />  dwLocalAddr		DWORD	?<br />  dwLocalPort		DWORD	?<br />  dwRemoteAddr		DWORD	?<br />  dwRemotePort		DWORD	?<br />MIB_TCPROW ENDS<br /></code></pre><br /><br />TcpSetEntry has one parameter: a pointer to a MIB_TCPROW struct. This struct contains the local port &amp; ip and the remote port &amp; ip, as well as the new state (MIB_TCP_STATE_*) to set the connection to. When I tried this by looking at some connection with netstat, using the right values in the struct I was able to kill the connection.<br /><br />I hope this helps, I don't know much about this I just tried it for the first time... <br />Another interesting function is GetTcpTable, it can return a full table of TCP connections like netstat does. Look it up at msdn. Also download the files in my other post about the IP helper api (networking forum).<br /><br />Thomas<br /><br /><strong>edit/P.S.<br />Don't forget that IPs and ports are in network byte order, i.e. big endian, most significant byte first. An IP like 192.168.0.1 is stored in memory as: db 192,168,0,1. A port number is 16-bits (although the dwLocalPort structure member is a dword, I think only the lower word is used). A port number like 6789 (=1A85 in hex) is stored in memory as: db 1A, 85 (which as an intel word would mean 851Ah)<br /></strong></div>
    <div class="meta">Posted on 2001-12-09 09:12:50 by Thomas</div>
   </div>
   <div class="post" id="post-14949">
    <div class="subject"><a href="#post-14949">Netmon Source + Terminate Connection</a></div>
    <div class="body">Hossa<br /><br />hehe i know its a messageboard.<br />but to say it loud and clear :<br /><br />i personal think here is the elite of all asm coders or the best of the best win32 coders *bg*<br /><br />before i post here i read all pages i can get my hands on ,the search function is for members only and im not shure if i should register myself here as a beginner. <br />often there are more then 2 people who can help when one ask a question ,so i think my posting looks like a question for a malicous program.<br /><br />but now to my question :-)<br /><br />thanks alot thomas for taking the time to write some helpfull text !<br /><br />after reading your text i start searching with some words and i found this :<br /><br /> InetChkS.dll documentation<br /><br />This document is a simple reference on using the InetChKs.dll dynamic link libray. Contains some explanations with examples on passing arguments properly to the functions of this DLL.<br />.<br /><br />1 - ip_checksum function<br />2 - tcp_checksum function<br />3 - udp_checksum function<br />4 - icmp_checksum function<br />5 - ppp_checksum function<br />6 - ???<br /><br />1 - ip_checksum function<br /><br />Prototype:<br />ip_checksum  PROTO addr_ip_hdr:DWORD<br /><br />This is one of the simplest functions of InetChkS. Receives just one argument: a pointer to a structure like the the following:<br /><br />;IP Header Structure<br />ip_hdr STRUCT<br />  ip_hlv    BYTE      ?<br />  ip_tos    BYTE      ?<br />  ip_len    WORD      ?<br />  ip_id     WORD      ?<br />  ip_off    WORD      ?<br />  ip_ttl    BYTE      ?<br />  ip_p      BYTE      ?<br />  ip_cksum  WORD      ?	;Must be zero before being computed.<br />  ip_src    DWORD      ?<br />  ip_dest   DWORD      ?<br />ip_hdr ENDS<br /><br />You can find the definition of the ip_hdr structure in the Windows.inc file (for those who use Masm32, the path to Windows.inc is C:\masm32\include). ip_checksum will return the computed checksum value in AX.<br /><br />NOTE: Remember that the Checksum field for most of the protocols (IP, TCP, UDP, ICMP, etc) MUST BE ZERO before being computed.<br /><br /><br />Example <br /><br />Given the following escaped PPP packet:<br /><br />7E FF 03 00 21 45 00 00 2C 00 07 00 00 FF 06 67<br />FE C8 31 83 8F C8 2F 3F D6 04 8F 00 50 5D 72 00<br />00 00 00 00 01 60 02 40 00 A2 0D 00 00 02 04 05<br />B4 AD F4 7E<br /><br />(Escaped PPP packet taken from Trumpet Winsock 5.0)<br /><br />? IP Header<br /><br /> <br />ip_header 	ip_hdr &lt;&gt;	;ip_header variable declaration<br /><br />;ip_hdr fields are assigned their respective values:<br />MOV	ip_header. ip_hlv, 45h<br />MOV	ip_header.ip_tos, 0<br />MOV	ip_header.ip_len, 2Ch<br />MOV	ip_header.ip_id,  07<br />MOV	ip_header.ip_off, 0<br />MOV	ip_header.ip_ttl, 0FFh<br />MOV	ip_header.ip_p, 6<br />MOV	ip_header.ip_cksum, 0		;The Checksum field must be zero before being computed.<br />MOV	ip_header.ip_src, 0C831838Fh<br />MOV	ip_header.ip_dest, 0C82F3FD6h<br /><br />;Then, the ip_checksum function is called<br />INVOKE	ip_checksum, ADDR ip_header<br /><br />After the call, the register AX will store 67FEh (the computed Checksum value). Finally:<br /><br />MOV ip_header.ip_cksum, AX	;The IP datagram is complete now.<br /><br /><br />2 - tcp_checksum function<br /><br />Prototype:<br />tcp_checksum PROTO addr_tcp_hdr:DWORD, addr_tcp_options_data:DWORD, len_options_data:DWORD, addr_ip_hdr:DWORD<br /><br />The TCP checksum calculation is a bit more complex since others structures apart from the TCP header are used. They can be enumerated as follows:<br /><br />1 - TCP Header<br />2 - TCP Options-Data	 	(Opcional)<br />3 - Pseudo Header *<br /><br />* the tcp_checksum function extracts and calculates the Pseudo Header by receiving a pointer to an ip_hdr structure.<br />Therefore, the tcp_checksum function receives the following arguments:<br /><br />1 - Pointer to a tcp_hdr structure. The tcp_hdr structure has the following fields:<br /><br />tcp_hdr STRUCT<br />    tcp_sourc_port WORD ?<br />    tcp_dest_port WORD ?<br />    tcp_seq DWORD ?<br />    tcp_ack DWORD ?<br />    tcp_len BYTE ?<br />    tcp_flag BYTE ?<br />    tcp_win WORD ?<br />    tcp_cksum WORD ?<br />    tcp_urgent WORD ?<br />tcp_hdr ENDS<br /><br />2 - Pointer to the TCP Options-Data. The TCP Options-Data must be store in an array of bytes<br /><br />3 - Length Options-Data. Here, the length of the TCP Option-Data in the array of bytes is specified .<br /><br />4 - Pointer to an ip_hdr structure. The Pseudo Header will be extracted from here.<br /><br />Example<br /><br />Given the following escaped PPP packet:<br /><br />7E FF 03 00 21 45 00 00 2C E8 CC 00 00 3F 06 3F 39 C8 2F<br />3F D6 C8 31 83 8F 00 50 04 8F 15 B9 17 BD 5D 72 00 01 60 <br />12 20 00 94 A3 00 00 02 04 05 98 7C EA 7E<br /><br />(Escaped PPP packet taken from Trumpet Winsock 5.0)<br /><br />? IP Header<br />? TCP Header<br />? TCP Options-Data<br /><br />;Variables declarations:<br />tcp_header 	tcp_hdr &lt;&gt;<br />options_data	100 DUP (0)<br />ip_header 	ip_hdr &lt;&gt;<br /><br />;tcp_hdr fields are assigned their respective values:<br />MOV tcp_header. tcp_sourc_port, 50h<br />MOV tcp_header.tcp_dest_port, 48Fh<br />MOV tcp_header.tcp_seq, 15B917BDh<br />MOV tcp_header.tcp_ack, 5D720001h<br />MOV tcp_header.tcp_len, 60h<br />MOV tcp_header.tcp_flag, 12h<br />MOV tcp_header.tcp_win, 2000h<br />MOV tcp_header.tcp_cksum, 0 	;The Checksum field must be zero before being computed.<br />MOV tcp_header.tcp_urgent, 0<br /><br />;Options-Data fields are assigned their respective values:<br />MOV options_data, 2<br />MOV options_data[1], 4<br />MOV options_data[2], 5<br />MOV options_data[3], 98h<br /><br />;ip_hdr fields are assigned their respective values:<br />MOV	ip_header. ip_hlv, 45h<br />MOV	ip_header.ip_tos, 0<br />MOV	ip_header.ip_len, 2Ch<br />MOV	ip_header.ip_id,  0E8CCh<br />MOV	ip_header.ip_off, 0<br />MOV	ip_header.ip_ttl, 03Fh<br />MOV	ip_header.ip_p, 6<br />MOV	ip_header.ip_cksum, 0	<br />MOV	ip_header.ip_src, 0C82F3FD6h<br />MOV	ip_header.ip_dest, 0C831838Fh<br /><br />;Then, the tcp_checksum function is called <br />INVOKE tcp_checksum, ADDR tcp_header, ADDR options_data, 4, ADDR ip_header<br /><br />After the call, the register AX will store 94A3h (the computed Checksum value). Finally:<br /><br />MOV tcp_header.tcp_cksum, AX	;The TCP segment is complete now.<br /><br />In case the TCP segment does not include Options-Data, a null value must be specified in place of the Pointer to the TCP Options-Data argument. Example:<br /><br />Given the following escaped PPP packet:<br /><br />7E FF 03 00 21 45 00 00 28 EC 5E 00 00 3F 06 3B AB C8 2F<br />3F D6 C8 31 83 8F 00 50 04 8F 15 B9 18 4A 5D 72 00 08 50 <br />11 20 00 AB B0 00 00 C3 F6 7E<br /><br />(Escaped PPP packet taken from Trumpet Winsock 5.0)<br /><br />? IP Header<br />? TCP Header<br /><br />;Varables declarations<br />tcp_header 	tcp_hdr &lt;&gt;<br />ip_header 	ip_hdr &lt;&gt;<br /><br />;tcp_hdr fields are assigned their respective values:<br />MOV tcp_header. tcp_sourc_port, 50h<br />MOV tcp_header.tcp_dest_port, 48Fh<br />MOV tcp_header.tcp_seq, 15B9184Ah<br />MOV tcp_header.tcp_ack, 5D720008h<br />MOV tcp_header.tcp_len, 50h<br />MOV tcp_header.tcp_flag, 11h<br />MOV tcp_header.tcp_win, 2000h<br />MOV tcp_header.tcp_cksum, 0 	;The Checksum field must be zero before being computed.<br />MOV tcp_header.tcp_urgent, 0<br /><br />;ip_hdr fields are assigned their respective values:<br />MOV	ip_header. ip_hlv, 45h<br />MOV	ip_header.ip_tos, 0<br />MOV	ip_header.ip_len, 28h<br />MOV	ip_header.ip_id,  0EC5Eh<br />MOV	ip_header.ip_off, 0<br />MOV	ip_header.ip_ttl, 03Fh<br />MOV	ip_header.ip_p, 6<br />MOV	ip_header.ip_cksum, 0	<br />MOV	ip_header.ip_src, 0C82F3FD6h<br />MOV	ip_header.ip_dest, 0C831838Fh<br /><br />;Then, the tcp_checksum function is called<br />INVOKE tcp_checksum, ADDR tcp_header, NULL, NULL, ADDR ip_header<br /><br />After the call, the register AX will store ABB0h (the computed Checksum value). Finally:<br /><br />MOV tcp_header.tcp_cksum, AX<br /><br />3 - udp_checksum function<br /><br />Prototype:<br />udp_checksum PROTO addr_udp_hdr:DWORD, addr_udp_data:DWORD, len_udp_data:DWORD, addr_ip_hdr:DWORD<br /><br />The way the udp_checksum function calculates the checksum for udp segments is almost the same as the tcp_checksum function does. The only difference lies in the UDP  header structure:<br /><br />udp_hdr STRUCT<br />    udp_sourc_port WORD ?<br />    udp_dest_port WORD ?<br />    udp_len WORD ?<br />    udp_cksum WORD ?<br />udp_hdr ENDS<br /><br />Like TCP, UDP segments may include optional data; if so, the data must be stored in an array of bytes. Also, the UDP checksum calculation requires the Pseudo Header. Therefore, the udp_checksum function receives the same arguments in the same order as tcp_checksum function does. In case the UDP segment does not include Options-Data, a null value must be specified in place of the Pointer to the UDP Options-Data argument.<br /><br />Example<br /><br />Given the following esacped PPP packet:<br /><br />7E FF 03 00 21 45 00 00 1C ED 5A 00 00 0A 11 D0 13 C8 <br />48 29 A1 C8 31 39 48 04 00 1A 04 00 08 EE 76 96 F5 7E<br /><br />(Escaped PPP packet taken from the Net)<br /><br />? Encabezado IP<br />? Encabezado UDP<br /><br /><br />;Variables declarations<br />udp_header 	tcp_hdr &lt;&gt;<br />ip_header 	ip_hdr &lt;&gt;<br /><br />;udp_hdr fields are assigned their respective values:<br />MOV udp_header. udp_sourc_port, 400h<br />MOV udp_header.udp_dest_port, 1A04h<br />MOV udp_header.udp_len, 8<br />MOV udp_header.udp_cksum, 0	;The Checksum field must be zero before being computed.<br /><br />;ip_hdr fields are assigned their respective values:<br />MOV	ip_header. ip_hlv, 45h<br />MOV	ip_header.ip_tos, 0<br />MOV	ip_header.ip_len, 1Ch<br />MOV	ip_header.ip_id,  0ED5Ah<br />MOV	ip_header.ip_off, 0<br />MOV	ip_header.ip_ttl, 0Ah<br />MOV	ip_header.ip_p, 11h<br />MOV	ip_header.ip_cksum, 0	<br />MOV	ip_header.ip_src, 0C84829A1h<br />MOV	ip_header.ip_dest, 0C8313948h<br />	      ...	<br />INVOKE udp_checksum, ADDR udp_header, NULL, NULL, ADDR ip_header<br /><br />After the call, the register AX will store EE76h (the computed Checksum value). Finally:<br />MOV udp_header.udp_cksum, AX	<br /><br /><br />4 - icmp_checksum function<br /><br />Prototype:<br />icmp_checksum PROTO addr_icmp_hdr:DWORD, addr_icmp_data:DWORD, len_icmp_data:DWORD<br /><br />This function calculates the chekcsum for ICMP datagrams. Receives three arguments:<br /><br />1 - Pointer to the ICMP header structure. The ICMP header structure can be found in the Windows.inc file.<br /><br />icmp_hdr STRUCT<br />  icmp_type   BYTE      ?<br />  icmp_code   BYTE      ?<br />  icmp_cksum  WORD      ?<br />  icmp_id     WORD      ?<br />  icmp_seq    WORD      ?<br />  icmp_data   BYTE      ?<br />icmp_hdr ENDS<br /><br />2 - Pointer to the ICMP datagram data. This arguments is a pointer to the optional data the ICMP datagram may included. Like tcp_checksum and udp_checksum functions, if the ICMP datagrams includes data, it must be stored in an array of bytes. <br />In case the UDP segment does not include data, a null value must be specified in place of this argument.<br /><br />3 - Length of the ICMP datagram data. Here the size in bytes of the ICMP datagram data is specified.<br /><br />Ejemplo<br /><br />Given the following PPP escaped  packet:<br /><br />7E FF 03 00 21 45 00 00 38 6F DF 00 00 80 01 B4 12 <br />0A 00 01 0B 0A 00 01 C9 03 03 C2 D2 00 00 00 00 45 <br />00 00 47 07 F0 00 00 80 11 1B E3 0A 00 01 C9 0A 00 <br />01 0B 08 A7 79 19 00 33 B8 36 17 78 7E<br /><br />(PPP escaped packet taken from the Net)<br /><br />? Encabezado ICMP<br />? Datos ICMP<br /><br />;Varables declarations<br />icmp_header 	icmp_hdr &lt;&gt;<br />icmp_data	100 DUP (0)<br /><br />;icmp_header fields are assigned their respective values:<br />MOV	icmp_header. icmp_type, 3<br />MOV	icmp_header.icmp_code, 3<br />MOV	icmp_header.icmp_cksum, 0		;The checksum field must be zero before being computed.<br />MOV	icmp_header.icmp_id,  0<br />MOV	icmp_header.icmp_seq, 0<br />MOV	icmp_header.icmp_data, 45h<br /><br />MOV  icmp_data, 0<br />MOV  icmp_data[1], 0<br />MOV  icmp_data[2], 47h<br />             ...<br />MOV  icmp_data[26], 36h<br /><br />;Then<br />INVOKE icmp_checksum, ADDR icmp_header, ADDR icmp_data, 27<br /><br />After the call, the register AX will store C2D2h (the computed Checksum value). Finally:<br />MOV icmp_header.icmp_cksum, AX	<br /><br /><br />5 - ppp_checksum function<br /><br />Prototipo:<br />ppp_checksum PROTO addr_ppp_data:DWORD, len_ppp_data:DWORD<br /><br />This is another of the simplest function in this DLL. Just receives two arguments:<br /><br />1 - Pointer to PPP data. This is a pointer to an array of bytes with the PPP data.<br />2 - Longitud datos PPP. Here, the length of the PPP Data in the array of bytes is specified .<br /><br />The PPP data in the array of bytes must not include the checksum bytes when calling the ppp_checksum function.<br /><br />Example<br /><br />Given the following PPP escaped packet:<br /><br />7E FF 03 00 21 45 00 00 28 00 0A 00 00 FF 06 67<br />FF C8 31 83 8F C8 2F 3F D6 04 8F 00 50 5D 72 00<br />08 15 B9 18 4A 50 10 3F 74 8C 3D 00 00 40 8E 7E<br /><br />(PPP escaped packet taken from Trumpet Winsock 5.0)<br /><br />? PPP Data<br />? PPP Checksum value (must not be included when calling the ppp_checksum function)<br /><br />;Declarations<br />ppp_data 1000 DUP (0)<br /><br />;The elements of the array of bytes are assigned the respectives values.<br />MOV  ppp_data, 0FFh<br />MOV  ppp_data[1], 3<br />MOV  ppp_data[2], 0<br />             ...		<br />MOV  ppp_data[40], 8Ch<br />MOV  ppp_data[41], 3Dh  <br />MOV  ppp_data[42], 0	<br />MOV  ppp_data[43], 0<br /><br />;Then<br />INVOKE  ppp_checksum, ADDR ppp_data, 44<br /><br />After the call, the register AX will store 408Eh (the computed Checksum value). Finally:<br />MOV  ppp_data[44], AH	;AH = 40h<br />MOV  ppp_data[45], AL	;AL = 8Eh<br /><br /><br />6- Bonus function!!!!: ppp_encapsulate_data<br /><br />Prototype:<br />ppp_encapsulate_data PROTO p_ppp_data:DWORD, len_ppp_data:DWORD<br /><br />This function encapsulates PPP data. Receives two arguments:<br /><br />1 - Pointer to an array of bytes with the PPP data. <br />2 - Length of the PPP data in the array.<br /><br />Important: the array of bytes which stores the PPP data must be large enough so that it can support the enlargement in its size when the data is encapsulated. Normally, the size of the array with the ppp data must be twice as large as the size of the array with the non-escaped PPP data. Otherwise, a run-time error will make Windows send your program off the memory.<br /><br />The new size of the array with the encapsulted ppp data will be returned in EAX.<br /><br />For example, given the following array:<br /><br />ppp_data BYTE 20 DUP (0)<br />len_ppp_data DWORD ?<br />	...<br />MOV ppp_data, 0FFh<br />MOV ppp_data[1], 0C0h<br />MOV ppp_data[2], 21h<br />MOV ppp_data[3], 1<br />MOV ppp_data[4], 0<br />MOV ppp_data[5], 0<br />MOV ppp_data[6], 4<br />MOV ppp_data[7], 0Dh<br />MOV ppp_data[8], 0EFh<br /><br />	...<br />INVOKE  encapsulate_ppp_data, ADDR ppp_data, 9<br />MOV	len_ppp_data, EAX	;EAX = 15<br /><br />After the call, the the ppp_data array will look like:<br /><br />ppp_data[0]   = 7Eh<br />ppp_data[1]   = 0FFh<br />ppp_data[2]   = 0C0h<br />ppp_data[3]   = 21H<br />ppp_data[4]   = 7Dh<br />ppp_data[5]   = 21h<br />ppp_data[6]   = 7Dh<br />ppp_data[7]   = 20h<br />ppp_data[8]   = 7Dh<br />ppp_data[9]   = 20h<br />ppp_data[10] = 7Dh<br />ppp_data[11] = 24h<br />ppp_data[12] = 7Dh<br />ppp_data[13] = 2Dh<br />ppp_data[14] = EFh<br />ppp_data[15] = 7Eh<br /><br />and EAX will store  0FH (15 in decimal) which is the new size of the ppp_data array<br /><br />End of Internet CheksumS Document<br /><br />-- -------------------<br /><br />i upload the zip file with asm sample source and all need stuff and post here the link so you and others can use this too.<br /><br />thanks for help !</div>
    <div class="meta">Posted on 2001-12-14 09:26:07 by Max</div>
   </div>
   <div class="post" id="post-15021">
    <div class="subject"><a href="#post-15021">Netmon Source + Terminate Connection</a></div>
    <div class="body"><div class="quote">im not shure if i should register myself here as a beginner.</div><br />Well, this isn't the apache httpd project. Not like you have to submit a very important part of some project to become relevent.<br /><br />You should read TCP/IP illiustrated printed by Prentice Hall</div>
    <div class="meta">Posted on 2001-12-15 04:58:06 by eet_1024</div>
   </div>
   <div class="post" id="post-15558">
    <div class="subject"><a href="#post-15558">Netmon Source + Terminate Connection</a></div>
    <div class="body">seems to me that one simple way of killing a connection is closing the socket that it's using... and as far as i know you can get that socket... haven't tested this theory but it should work...</div>
    <div class="meta">Posted on 2001-12-20 16:53:39 by NervGaz</div>
   </div>
   <div class="post" id="post-17812">
    <div class="subject"><a href="#post-17812">Netmon Source + Terminate Connection</a></div>
    <div class="body">NervGaz :<br />-----<br />seems to me that one simple way of killing a connection is closing the socket that it's using... and as far as i know you can get that socket... haven't tested this theory but it should work...<br />------<br /><br />lets say i have the ip and the port ,how do i get the socket this connection use ?<br /><br /><br />Thomas:<br />-----<br />When I tried this by looking at some connection with netstat, using the right values in the struct I was able to kill the connection. <br />-----<br /><br />can you please post or send me by email a simple example on how do you close the connection with MIB_TCP_STATE_DELETE_TCB ?<br />   <br />im to stupid to follow what you two try to tell me :-(<br />im reading here <a target="_blank" href="http://msdn.microsoft.com/library/en-us/tcpip/ipover_0nqk.asp?frame=true">http://msdn.microsoft.com/library/en-us/tcpip/ipover_0nqk.asp?frame=true</a> but i dont get it<br /><br />Thanks</div>
    <div class="meta">Posted on 2002-01-06 02:40:24 by Max</div>
   </div>
   <div class="post" id="post-17826">
    <div class="subject"><a href="#post-17826">Netmon Source + Terminate Connection</a></div>
    <div class="body">Here you go.<br />It is really easy. This is the actual code:<br /><br /><pre><code><br />TestRow     MIB_TCPROW &lt;MIB_TCP_STATE_DELETE_TCB,\<br />                        IPADDR&#40;127,0,0,1&#41;,PORTNR&#40;1572&#41;,\ ;local <br />                        IPADDR&#40;127,0,0,1&#41;,PORTNR&#40;9944&#41;&gt;  ;remote <br /><br />.code<br />start&#58;<br />    invoke  SetTcpEntry, addr TestRow<br />    invoke  ExitProcess, NULL<br /></code></pre><br /><br />Just telnet to some server (or a local open port), open &quot;netstat -an&quot;, locate the connection:<br /><pre><code><br />TCP    127.0.0.1&#58;1572         127.0.0.1&#58;9944         ESTABLISHED<br /></code></pre><br /><br />Fill in those IPs and ports in the TestRow structure and build+run the program. The connection will be lost then.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-01-06 04:23:05 by Thomas</div>
   </div>
   <div class="post" id="post-17833">
    <div class="subject"><a href="#post-17833">Netmon Source + Terminate Connection</a></div>
    <div class="body">thomas:<br /><br />unorthodox but cool :)</div>
    <div class="meta">Posted on 2002-01-06 05:12:55 by clip</div>
   </div>
   <div class="post" id="post-17836">
    <div class="subject"><a href="#post-17836">Netmon Source + Terminate Connection</a></div>
    <div class="body">Wow !<br /><br />such easy ???<br />i fall from my chair when i read your post Thomas.<br /><br />Ok all others are more then right when they vote you for Network Section admin :-) <br /><br />and i had much to learn as i see.....<br />bah to stupid to understand msdn :-(<br />hobby coder needs new brain !<br /><br />happy coding and much thanks Thomas</div>
    <div class="meta">Posted on 2002-01-06 05:24:15 by Max</div>
   </div>
  </div>
 </body>
</html>