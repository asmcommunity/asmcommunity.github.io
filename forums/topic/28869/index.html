<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Unused proc params - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28869" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28869">Unused proc params</a></p>
   <div class="post" id="post-204042">
    <div class="subject"><a href="#post-204042">Unused proc params</a></div>
    <div class="body">In my last project there were plenty of callback functions that I had to write.<br /><br />Almost all of them received several parameters that I didn&#039;t process:<br /><br /><pre><code><br />procname proc \<br />		usedparam1,\<br />		usedparam2,\<br />		unusedparam1,\<br />		unusedparam2<br /><br />		mov	eax,<br />		mov	eax,<br />		ret<br /><br />	inc b 	;ugly, but keeps MASM happy<br />	inc b <br />procname endp<br /></code></pre><br /><br />Then I&#039;ve made some macros, so the code looks like this:<br /><br /><pre><code><br />procname proc \<br />		usedparam1,\<br />		usedparam2,\<br />		ignore(unusedparam1),\<br />		ignore(unusedparam2)<br /><br />		mov	eax,<br />		mov	eax,<br />		ret<br />procname endp<br /></code></pre><br /><br />The macro will reference all unused params with the INC followed by ORG $-3 which will remove the instruction from the EXE file. Howewer, only one RET can be placed in the proc.<br /><br />It will also change the names of all unused params, so that you can&#039;t access it by error.<br /><br /><br />Then I&#039;ve made two more macros to let me access params with ESP, rather than EBP:<br /><br /><pre><code><br />procname proc \<br />		useESP(usedparam1),\<br />		useESP(usedparam2),\<br />		ignESP(unusedparam1),\<br />		ignESP(unusedparam2)<br /><br />		mov	eax,<br />		mov	eax,<br />		ret<br />procname endp<br /></code></pre><br /><br />1. If you use useESP/ignESP then you must use it with ALL params passed to proc.<br />2. You can&#039;t (yet) use USES or LOCAL with useESP/ignESP.<br />3. useESP/ignESP require that all params are DWORD in size.<br /><br />&quot;ignore&quot; and &quot;useESP/ignESP&quot; macros can&#039;t be mixed within one proc.<br /><br />If you like it, you can get it from<br />www.beotel.net/~astancic (click on UnusedStack.zip)<br /><br />Bye!<br /></div>
    <div class="meta">Posted on 2007-12-23 13:15:01 by aleksaZR</div>
   </div>
   <div class="post" id="post-204048">
    <div class="subject"><a href="#post-204048">Re: Unused proc params</a></div>
    <div class="body">??????<br /><br />What is the purpose of this ? You still need to have the proper number of parameters in order for the stack to balance and it seems you still have to declare them in the PROC. Seems like a pretty pointless macro that makes things more complicated than just declaring the parameters as they are spelled out at MSDN. Also, multiple RETs and USES are kind of important so the macro removes useful things from MASM to add something that saves no time or typing or does anything at all. Sorry to sound a bit caustic but I have a pet peeve with macros in general, using only two in all the code I write, which is a substantial amount.<br /><br />Donkey</div>
    <div class="meta">Posted on 2007-12-23 17:13:13 by donkey</div>
   </div>
   <div class="post" id="post-204049">
    <div class="subject"><a href="#post-204049">Re: Unused proc params</a></div>
    <div class="body">I mostly agree with donkey.<br /><br />I do use one instruction generating macro.. an x87 RPN expression evaluator.. but its the WYSIWYG mother of all macros.. each item in the RPN expression generates exactly 1 instruction, always from left to right, and its always exactly the instruction you would expect. It is basically a limited horizontal x87 assembler.<br /><br />I do not use any macros that maintain a &#039;state&#039; with other macros, or with itself, and I never use the &quot;simplified&quot; proc directive or stack frames. I prefer to document my code instead, and consider the EBP register a resource that shouldnt be wasted pointing at some arbitrary water mark on the stack. Hell, i&#039;ve even been known to use ESP as a general purpose register.<br /></div>
    <div class="meta">Posted on 2007-12-23 18:16:25 by Rockoon</div>
   </div>
   <div class="post" id="post-204052">
    <div class="subject"><a href="#post-204052">Re: Unused proc params</a></div>
    <div class="body">Hi Rockoon,<br /><br />Can&#039;t say that I go that far, I use frames and invoke since they make my code more readable and I am notorious for lack of comments. The only macros I use are a CoInvoke macro I used for COM and since I use GoAsm and it has no equivalent to the C calling convention I have another that I wrote called CInvoke though I don&#039;t use that too often preferring CALL xxx/ADD ESP, xxx instead. Since FRAME and INVOKE are about the only high level constructs in GoAsm, (there are no equivalents to .IF or .WHILE) I use no others. The thing that bothers me with macros is that some programmers seem to be trying to rewrite assembler to look like C, with SWITCH/CASE and others, if you want to code in assembler then code in assembler, if not then maybe HLA is for you.<br /><br />Donkey</div>
    <div class="meta">Posted on 2007-12-23 19:21:55 by donkey</div>
   </div>
   <div class="post" id="post-204055">
    <div class="subject"><a href="#post-204055">Re: Unused proc params</a></div>
    <div class="body">Hopefuly not derailing this thread, but..<br /><br />I understand why programmers who write large programs in 100% assembler would want lots of high level constructs. I just wonder why they are tackling the complexity problems of large programs with an assembler, when clearly there are lots of tools designed specifically to reduce that complexity (such as C/JAVA/BASIC compilers.) <br /><br />Most of the assembly being written today is in the form of libraries callable from those very tools, and the industry as a whole is rapidly moving to tools that are even better at managing complexity by using scripting languages to glue together higly reusable components written in C/JAVA/BASIC (which themselves glue together the libraries) <br /><br />On the very frontier of development are the folks that go one step further and use a markup language such as DHTML to glue together their scripts which glue together their components which glue together their libraries...<br /><br /></div>
    <div class="meta">Posted on 2007-12-24 00:35:20 by Rockoon</div>
   </div>
   <div class="post" id="post-204061">
    <div class="subject"><a href="#post-204061">Re: Unused proc params</a></div>
    <div class="body">aleksaZR,<br /><br />&nbsp; &nbsp;  Perhaps you would like to peruse the following link, which a method of keeping track of subroutine parameters using STRUCTS.&nbsp; http://www.asmcommunity.net/board/index.php?topic=24957.0&nbsp; see reply #1.<br /><br /><br />To the Ineffable All,<br /><br />&nbsp; &nbsp;  I agree with Donkey in that it is sometimes easy to come up with MACROs that are works of art instead of something practical.&nbsp; After all, you wrote them, and it is hard to say no your babies.&nbsp; Us old timers have seen plenty of attempts to make an assembler into a &quot;poor man&#039;s C language&quot;.&nbsp; But one good thing about high level constructs is that they help eliminate jump label clutter.&nbsp; Ratch</div>
    <div class="meta">Posted on 2007-12-24 12:14:45 by Ratch</div>
   </div>
   <div class="post" id="post-204064">
    <div class="subject"><a href="#post-204064">Re: Unused proc params</a></div>
    <div class="body">I like using PROC directive because it really helps me write a piece of code.<br />(localized code and data labels, regs saving..)<br /><br />And it looks much more readable than the code I used to write when I started x86 asm some 10 years ago.<br />Not to mention Z80 code I started some 20 years ago.<br />In all that time, 99.99% of all my code were written in asm.<br /><br />So, I do have experience and it tells me that 95% of the functions do not have to be optimized, but easily understood later.<br /><br />As I said, the last project (using a windows video driver within another OS) required that I implement a lot<br />of functions whose parameters I simply don&#039;t need.<br /><br />And a &quot;ignore&quot; macro works great in that situations:<br />it informs ME that the param is actually ignored by the function,<br />and it informs MASM that the param is &#039;used&#039; by the proc, so it won&#039;t complain, w/o any code being generated.<br />(&quot;procedure argument or local not referenced&quot; can be disabled, but that is not what I want in ALL of my code)<br /><br />The useESP/ignESP macros came in handy for small functions when you dont have to save the regs and with 2-3 params.<br />(saving the regs could be implemented in the macros, but I didn&#039;t need that)<br /><br />Dont forget that ESP requires 4 bytes and EBP 3 bytes of code, most of the time.<br />Using ESP over EBP produces bigger code, if you have to access the stack several times.<br /><br />Regards,<br />Aleksa</div>
    <div class="meta">Posted on 2007-12-24 18:26:57 by aleksaZR</div>
   </div>
   <div class="post" id="post-204068">
    <div class="subject"><a href="#post-204068">Re: Unused proc params</a></div>
    <div class="body">aleksaZR,<br /><br /><div class="quote">As I said, the last project (using a windows video driver within another OS) required that I implement a lot<br />of functions whose parameters I simply don&#039;t need.<br /><br />And a &quot;ignore&quot; macro works great in that situations:<br />it informs ME that the param is actually ignored by the function,<br />and it informs MASM that the param is &#039;used&#039; by the proc, so it won&#039;t complain, w/o any code being generated.<br />(&quot;procedure argument or local not referenced&quot; can be disabled, but that is not what I want in ALL of my code)</div><br /><br />&nbsp; &nbsp;  When you say you &quot;implement&quot; functions, does that mean that you write them?&nbsp; If so, why write functions that take parameters you don&#039;t need?&nbsp; If implement means you call functions already written, how can you not fill the stack with the correct number of parameters and in the order the function wants, and expect it to run correctly?&nbsp; There is something I am not getting here.<br /><br /><div class="quote">Dont forget that ESP requires 4 bytes and EBP 3 bytes of code, most of the time.<br />Using ESP over EBP produces bigger code, if you have to access the stack several times.</div><br /><br />&nbsp; &nbsp;  True, but an extra byte is usually a great tradeoff for having another register to work with, in a register starved CPU.<br /><br />&nbsp; &nbsp;  One thing I like about PROCless programming is that it is sometimes possible to PUSH parameters onto the stack long before the CALL to the subroutine is made.&nbsp; Instead of having to collect them somewhere so they can be PUSHed all at once as is done the PROC method.&nbsp; Ratch<br /><br /><br /></div>
    <div class="meta">Posted on 2007-12-24 20:19:10 by Ratch</div>
   </div>
   <div class="post" id="post-204071">
    <div class="subject"><a href="#post-204071">Re: Unused proc params</a></div>
    <div class="body">Thats not really an issue with the &quot;simplified&quot; PROC directive, but rather an issue with the INVOKE macro.<br /><br />Invoke does have too many issues to count.<br /><br /></div>
    <div class="meta">Posted on 2007-12-24 22:35:55 by Rockoon</div>
   </div>
   <div class="post" id="post-204076">
    <div class="subject"><a href="#post-204076">Re: Unused proc params</a></div>
    <div class="body"><div class="quote"><br />When you say you &quot;implement&quot; functions, does that mean that you write them?<br /></div><br /><br />&quot;implement&quot; means that I write them.<br /><br /><div class="quote"><br />If so, why write functions that take parameters you don&#039;t need?<br /></div><br /><br />Because the video/miniport driver expects them and will jump somewhere.<br />I had to write all functions that the drivers were linked to.<br /><br />Some of the functions I&#039;ve implemented ignore ALL params and<br />do nothing OR just return a default value OR enter debuger.<br /><br />But some functions ignore some params and use others, thats where &#039;ignore&#039; comes in.<br /><br />The same thing is with &quot;EnumFontFamProc&quot; where you usually don&#039;t need<br />all the params to get the names of all installed fonts.<br /><br /><div class="quote"><br />One thing I like about PROCless programming is that it is sometimes possible<br />to PUSH parameters onto the stack long before the CALL to the subroutine is made.<br />Instead of having to collect them somewhere so they can be PUSHed all at once as is done the PROC method<br /></div><br /><br />That can be avoided with CALL instead of INVOKE.<br /></div>
    <div class="meta">Posted on 2007-12-25 06:33:47 by aleksaZR</div>
   </div>
  </div>
 </body>
</html>