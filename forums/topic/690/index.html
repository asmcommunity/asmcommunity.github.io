<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fractal Image Compression (in C, not ASM) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=690" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=690">Fractal Image Compression (in C, not ASM)</a></p>
   <div class="post" id="post-4134">
    <div class="subject"><a href="#post-4134">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">Someone requested this code from me some time ago. I got it with about 20 compression routines last year from a book I bought. But this is the most interested (IMHO). The book talks about a compression ratio of about 97 - 99% on  images.<br />The bad thing with this code is, that I couldn't compile it :( <br /><br />frac.c<br /><pre><code><br />/************************** Start of FRAC.C *************************<br /> *<br /> * This is the FRAC module, which implements a graphics fractal compression<br /> * program.  It needs to be linked with the standard support routines.<br /> * Copyright 1995 Jean-loup Gailly<br /> */<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;math.h&gt;<br />#include &quot;bitio.h&quot;<br />#include &quot;errhand.h&quot;<br /><br />#ifdef unix<br />#  define float double /* better accuracy but more memory usage */<br />#endif<br /><br />char *CompressionName = &quot;Fractal compression&quot;;<br />char *Usage = <br />&quot;infile outfile &#91;-q quality&#93; &#91;-d density&#93; &#91;-h h_size&#93; &#91;-v v_size&#93;\n\<br />   quality from 1..20, domain density from 0..2\n\<br />Decompression parameters&#58;\n\<br />    infile outfile &#91;-i iterations&#93; &#91;-s scale&#93;\n&quot;;<br /><br />typedef unsigned char image_data;<br />typedef unsigned long uns_long;<br /><br />/*<br /> * Maximum gray level in an image<br /> */<br />#define MAX_GREY 255<br /><br />/*<br /> * Number of classes. Each class corresponds to one specific ordering<br /> * of the image brightness in the four quadrants of a range or domain.<br /> * There are 4*3*2 = 24 classes.<br /> */<br />#define NCLASSES 24<br /><br />/*<br /> * Minimum and maximum number of bits for the side of a range. The actual<br /> * range sizes are between 1&lt;&lt;MIN_BITS and 1&lt;&lt;MAX_BITS. To simplify the<br /> * implementation and avoid ridiculously small ranges, MIN_BITS must be &gt;= 2.<br /> * This implementation also requires MAX_BITS &lt;= 7.<br /> */<br />#define MIN_BITS 2<br />#define MAX_BITS 4<br /><br />/*<br /> * Maximum contrast factor in a range to domain mapping.<br /> */<br />#define MAX_CONTRAST 1.0<br /><br />/*<br /> * Bit sizes for encodings of contrast and brightness in an affine map.<br /> * Using smaller sizes increases compression and degrades image quality.<br /> */<br />#define CONTRAST_BITS    4<br />#define BRIGHTNESS_BITS  6<br /><br />#define MAX_QCONTRAST   &#40;&#40;1&lt;&lt;CONTRAST_BITS&#41;-1&#41;   /* max quantized contrast */<br />#define MAX_QBRIGHTNESS &#40;&#40;1&lt;&lt;BRIGHTNESS_BITS&#41;-1&#41; /* max quantized brightness */<br /><br />/*<br /> * De-quantize an integer value in the range 0 .. imax to the range 0.0 .. max<br /> * while preserving the mapping 0 -&gt; 0.0 and imax -&gt; max.<br /> */<br />#define dequantize&#40;value, max, imax&#41; &#40;&#40;double&#41;&#40;value&#41;*&#40;max&#41;/&#40;double&#41;imax&#41;<br /><br />/*<br /> * Compute the square of a pixel value and return the result as unsigned long<br /> */<br />#define square&#40;pixel&#41; &#40;uns_long&#41;&#40;pixel&#41;*&#40;pixel&#41;<br /><br />/*<br /> * Range data&#58; range&#91;i&#93;&#91;j&#93; is the brightness at row i and column j<br /> */<br />image_data **range;<br /><br />/*<br /> * Domain data, summed over 4 pixels&#58; domain&#91;i&#93;&#91;j&#93; is the sum of the<br /> * pixel values at &#40;2j, 2i&#41;, &#40;2j+1, 2i&#41;, &#40;2j, 2i+1&#41; and &#40;2j+1, 2i+1&#41;<br /> */<br />unsigned **domain;<br /><br />/*<br /> * Cumulative range data, kept only for pixels of even coordinates.<br /> * cum_range&#91;i&#93;&#91;j&#93; is the sum of all pixel values strictly above and to the<br /> * left of pixel &#40;2j, 2i&#41;. In particular, cum_range&#91;y_size/2&#93;&#91;x_size/2&#93; is<br /> * the sum of all pixel values in the image. This table is also used for<br /> * the cumulative domain data.<br /> */<br />uns_long **cum_range;<br /><br />/*<br /> * Cumulative squared range data, kept only for pixels of even coordinates.<br /> * cum_range2&#91;i&#93;&#91;j&#93; is the sum of the squares of all pixel values strictly<br /> * above and to the left of pixel &#40;2j, 2i&#41;. In particular,<br /> * cum_range2&#91;y_size/2&#93;&#91;x_size/2&#93; is the sum of all the squared pixel values<br /> * in the image.<br /> */<br />float **cum_range2;<br /><br />/*<br /> * Cumulative squared domain data. cum_domain2&#91;i&#93;&#91;j&#93; is the sum of the squares<br /> * of all domain values strictly above and to the left of domain &#40;j,i&#41;, which<br /> * corresponds to pixel &#40;2j, 2i&#41;. The values in cum_domain2 are scaled by<br /> * a factor of 16.0 to avoid some multiplications.<br /> */<br />float **cum_domain2;<br /><br />/*<br /> * Domain density&#58; domains of size s*s are located every &#40;s&gt;&gt;dom_density&#41;<br /> * pixels. The density factor can range from 0 to 2 &#40;smallest domains<br /> * have a size of 8 and must start on even pixels boundaries&#41;. Density<br /> * factors 1 and 2 get better image quality but significantly slow<br /> * down compression.<br /> */<br />int dom_density = 0;<br /><br />/*<br /> * Maximum tolerated mean square error between original image and<br /> * reconstructed uncompressed image.<br /> */<br />double max_error2;<br /><br />/*<br /> * The fractal &#40;compressed&#41; file<br /> */<br />BIT_FILE *frac_file;<br /><br />/*<br /> * Information common to all domains of a certain size&#58; info&#91;s&#93; describes<br /> * domains of size 1&lt;&lt;&#40;s+1&#41;, corresponding to ranges of size 1&lt;&lt;s<br /> */<br />struct domain_info &#123;<br />    int pos_bits;   /* Number of bits required to encode a domain position */<br />    int x_domains;  /* Number of domains in x &#40;horizontal&#41; dimension */<br />&#125; dom_info&#91;MAX_BITS+1&#93;;<br /><br /><br />/*<br /> * Each domain is described by a 'domain_data' structure.<br /> * domain_head&#91;c&#93;&#91;s&#93; is the head of the list of domains of class c<br /> * and size 1&lt;&lt;&#40;s+1&#41; &#40;corresponding to ranges of size 1&lt;&lt;s&#41;.<br /> */<br />typedef struct domain_struct &#123;<br />    int x;                      /* horizontal position */<br />    int y;                      /* vertical position */<br />    float d_sum;                /* sum of all values in the domain */<br />    float d_sum2;               /* sum of all squared values in the domain */<br />    struct domain_struct *next; /* next domain in same class */<br />&#125; domain_data;<br /><br />domain_data *domain_head&#91;NCLASSES&#93;&#91;MAX_BITS+1&#93;;<br /><br />/*<br /> * Ranges are described by a 'range_data' structure. This structure<br /> * is computed on the fly for each range as it is compressed.<br /> */<br />typedef struct range_struct &#123;<br />    int x;         /* horizontal position */<br />    int y;         /* vertical position */<br />    int s_log;     /* log base 2 of the range size */<br />    double r_sum;  /* sum of all values in the range */<br />    double r_sum2; /* sum of all squared values in the range */<br />&#125; range_data;<br /><br />/*<br /> * Range to domain mappings are described by an 'affine_map' structure.<br /> */<br />typedef struct map_struct &#123;<br />    int    contrast;   /* quantized best contrast between range and domain */<br />    int    brightness; /* quantized best brightness offset */<br />    double error2;    /* sum of squared differences between range and domain */<br />&#125; affine_map;<br /><br />/*<br /> * Function prototypes for both ANSI and K&amp;R.<br /> */<br />#ifdef __STDC__<br />#  define OF&#40;args&#41;  args<br />#else<br />#  define OF&#40;args&#41;  &#40;&#41;<br />#endif<br /><br />/*<br /> * Functions used for compression<br /> */<br />void CompressFile  OF&#40;&#40;FILE *input, BIT_FILE *output, int argc, char *argv&#91;&#93;&#41;&#41;;<br />void compress_init OF&#40;&#40;int x_size, int y_size, FILE *image_file&#41;&#41;;<br />void compress_cleanup OF&#40;&#40;int y_size&#41;&#41;;<br />void classify_domains OF&#40;&#40;int x_size, int y_size, int s&#41;&#41;;<br />int  find_class       OF&#40;&#40;int x, int y, int size&#41;&#41;;<br />void compress_range   OF&#40;&#40;int x, int y, int s_log&#41;&#41;;<br />void find_map  OF&#40;&#40;range_data *rangep, domain_data *dom, affine_map *map&#41;&#41;;<br /><br />/*<br /> * Functions used for decompression<br /> */<br />void ExpandFile OF&#40;&#40;BIT_FILE *input, FILE *output, int argc, char *argv&#91;&#93;&#41;&#41;;<br />void decompress_range   OF&#40;&#40;int x, int y, int s_log&#41;&#41;;<br />void refine_image       OF&#40;&#40;void&#41;&#41;;<br />void average_boundaries OF&#40;&#40;void&#41;&#41;;<br /><br />/*<br /> * Functions common to compression and decompression<br /> */<br />typedef void &#40;*process_func&#41; OF&#40;&#40;int x, int y, int s_log&#41;&#41;;<br /><br />void traverse_image OF&#40;&#40;int x, int y, int x_size, int y_size,<br />                        process_func process&#41;&#41;;<br />int  quantize       OF&#40;&#40;double value, double max, int imax&#41;&#41;;<br />void dominfo_init   OF&#40;&#40;int x_size, int y_size, int density&#41;&#41;;<br />void *xalloc        OF&#40;&#40;unsigned size&#41;&#41;;<br />void **allocate     OF&#40;&#40;int rows, int columns, int elem_size&#41;&#41;;<br />void free_array     OF&#40;&#40;void **array, int rows&#41;&#41;;<br />int  bitlength      OF&#40;&#40;uns_long val&#41;&#41;;<br /><br />                /**********************************/<br />                /* Functions used for compression */<br />                /**********************************/<br /><br />/* ==========================================================================<br /> * This is the main compression routine.  By the time it gets called,<br /> * the input and output files have been properly opened, so all it has to<br /> * do is the compression.  Note that the compression routine optionally<br /> * accepts additional parameters&#58;<br /> * - the quality value, ranging from 0 to 20. It is used as average tolerated<br /> *   error between the original image and its uncompressed version. &#40;Non<br /> *   integer values are also accepted.&#41;<br /> * - the domain density factor, ranging from 0 &#40;fastest compression&#41; to 2<br /> *   &#40;best but very slow compression&#41;.<br /> * - horizontal and vertical images sizes &#40;default 320 x 200&#41;. Both sizes<br /> *   must be multiple of 4 in this implementation &#40;this restriction could be<br /> *   removed with slightly more complex code&#41;.<br /> */<br />void CompressFile&#40;input, output, argc, argv&#41;<br />    FILE *input;<br />    BIT_FILE *output;<br />    int argc;<br />    char *argv&#91;&#93;;<br />&#123;<br />    int x_size = 320;     /* horizontal image size */<br />    int y_size = 200;     /* vertical image size */<br />    double quality = 2.0; /* quality factor */<br />    int s;                /* size index for domains; their size is 1&lt;&lt;&#40;s+1&#41; */<br /><br />    /* Check the command line parameters&#58; */<br />    for &#40; ; argc != 0; argv++, argc--&#41; &#123;<br />        if &#40;argv&#91;0&#93;&#91;0&#93; != '-' || argc == 1&#41; &#123;<br />            fatal_error&#40;&quot;Incorrect argument&#58; %s\n&quot;, *argv&#41;;<br />        &#125;<br />        switch&#40;argv&#91;0&#93;&#91;1&#93;&#41; &#123;<br />            case 'q'&#58; quality     = atof&#40;*++argv&#41;; argc--; break;<br />            case 'd'&#58; dom_density = atoi&#40;*++argv&#41;; argc--; break;<br />            case 'h'&#58; x_size      = atoi&#40;*++argv&#41;; argc--; break;<br />            case 'v'&#58; y_size      = atoi&#40;*++argv&#41;; argc--; break;<br />            default&#58;  fatal_error&#40;&quot;Incorrect argument&#58; %s\n&quot;, *argv&#41;;<br />        &#125;<br />    &#125;<br />    if &#40;dom_density &lt; 0 || dom_density &gt; 2&#41; &#123;<br />        fatal_error&#40;&quot;Incorrect domain density.\n&quot;&#41;;<br />    &#125;<br />    if &#40;x_size % 4 != 0 || y_size % 4 != 0&#41; &#123;<br />        fatal_error &#40;&quot;Image sizes must be multiple of 4\n&quot;&#41;;<br />    &#125;<br /><br />    /* Allocate and initialize the image data and cumulative image data&#58; */<br />    compress_init&#40;x_size, y_size, input&#41;;<br /><br />    /* Initialize the domain size information as in the decompressor&#58; */<br />    dominfo_init&#40;x_size, y_size, dom_density&#41;;<br /><br />    /* Classify all domains&#58; */<br />    for &#40;s = MIN_BITS; s &lt;= MAX_BITS; s++&#41; &#123;<br />        classify_domains&#40;x_size, y_size, s&#41;;<br />    &#125;<br /><br />    /* Output the header of the compressed file. The first byte &#40;'F' for<br />     * fractal'&#41; is just for a consistency check in the decompressor.<br />     */<br />    frac_file = output;<br />    OutputBits&#40;frac_file, &#40;uns_long&#41;'F',    8&#41;;<br />    OutputBits&#40;frac_file, &#40;uns_long&#41;x_size, 16&#41;;<br />    OutputBits&#40;frac_file, &#40;uns_long&#41;y_size, 16&#41;;<br />    OutputBits&#40;frac_file, &#40;uns_long&#41;dom_density, 2&#41;;<br /><br />    /* Compress the whole image recursively, stopping when the image<br />     * quality is good enough&#58;<br />     */<br />    max_error2 = quality*quality;<br />    traverse_image&#40;0, 0, x_size, y_size, compress_range&#41;;<br /><br />    /* Free all dynamically allocated memory&#58; */<br />    compress_cleanup&#40;y_size&#41;;<br />&#125;<br /><br />/* ==========================================================================<br /> * Allocate and initialize the image data and cumulative image data.<br /> */<br />void compress_init&#40;x_size, y_size, image_file&#41;<br />    int x_size;       /* horizontal image size */<br />    int y_size;       /* vertical image size */<br />    FILE *image_file; /* the input image file */<br />&#123;<br />    int x, y;             /* horizontal and vertical indices */<br />    uns_long r_sum;       /* cumulative range and domain data */<br />    double r_sum2;        /* cumulative squared range data */<br />    double d_sum2;        /* cumulative squared domain data */<br /><br />    range =   &#40;image_data**&#41;allocate&#40;y_size,     x_size,   sizeof&#40;image_data&#41;&#41;;<br />    domain    = &#40;unsigned**&#41;allocate&#40;y_size/2,   x_size/2,   sizeof&#40;unsigned&#41;&#41;;<br />    cum_range = &#40;uns_long**&#41;allocate&#40;y_size/2+1, x_size/2+1, sizeof&#40;uns_long&#41;&#41;;<br />    cum_range2  =  &#40;float**&#41;allocate&#40;y_size/2+1, x_size/2+1, sizeof&#40;float&#41;&#41;;<br />    cum_domain2 =  &#40;float**&#41;allocate&#40;y_size/2+1, x_size/2+1, sizeof&#40;float&#41;&#41;;<br /><br />    /* Read the input image&#58; */<br />    for &#40;y = 0; y &lt; y_size; y++&#41; &#123;<br />       if &#40;fread&#40;range&#91;y&#93;, sizeof&#40;image_data&#41;, x_size, image_file&#41; != x_size&#41; &#123;<br />           fatal_error&#40;&quot;error reading the image data\n&quot;&#41;;<br />       &#125;<br />    &#125;<br /><br />    /* Compute the 'domain' image from the 'range' image. Each pixel in<br />     * the domain image is the sum of 4 pixels in the range image.  We<br />     * don't average &#40;divide by 4&#41; to avoid losing precision.<br />     */<br />    for &#40;y=0; y &lt; y_size/2; y++&#41;<br />    for &#40;x=0; x &lt; x_size/2; x++&#41; &#123;<br />        domain&#91;y&#93;&#91;x&#93; = &#40;unsigned&#41;range&#91;y&lt;&lt;1&#93;&#91;x&lt;&lt;1&#93; + range&#91;y&lt;&lt;1&#93;&#91;&#40;x&lt;&lt;1&#41;+1&#93;<br />                     + range&#91;&#40;y&lt;&lt;1&#41;+1&#93;&#91;x&lt;&lt;1&#93; + range&#91;&#40;y&lt;&lt;1&#41;+1&#93;&#91;&#40;x&lt;&lt;1&#41;+1&#93;;<br />    &#125;<br /><br />    /* Compute the cumulative data, which will avoid repeated computations<br />     * later &#40;see the region_sum&#40;&#41; macro below&#41;.<br />     */<br />    for &#40;x=0; x &lt;= x_size/2; x++&#41; &#123;<br />        cum_range&#91;0&#93;&#91;x&#93; = 0;<br />        cum_range2&#91;0&#93;&#91;x&#93; = cum_domain2&#91;0&#93;&#91;x&#93; = 0.0;<br />    &#125;<br />    for &#40;y=0; y &lt; y_size/2; y++&#41; &#123;<br />        d_sum2 = r_sum2 = 0.0;<br />        r_sum = cum_range&#91;y+1&#93;&#91;0&#93; = 0;<br />        cum_range2&#91;y+1&#93;&#91;0&#93; = cum_domain2&#91;y+1&#93;&#91;0&#93; = 0.0;<br /><br />        for &#40;x=0; x &lt; x_size/2; x++&#41; &#123;<br />            r_sum += domain&#91;y&#93;&#91;x&#93;;<br />            cum_range&#91;y+1&#93;&#91;x+1&#93; = cum_range&#91;y&#93;&#91;x+1&#93; + r_sum;<br /><br />            d_sum2 += &#40;double&#41;square&#40;domain&#91;y&#93;&#91;x&#93;&#41;;<br />            cum_domain2&#91;y+1&#93;&#91;x+1&#93; = cum_domain2&#91;y&#93;&#91;x+1&#93; + d_sum2;<br />                       <br />            r_sum2 += &#40;double&#41; &#40;square&#40;range&#91;y&lt;&lt;1&#93;&#91;x&lt;&lt;1&#93;&#41;<br />                    + square&#40;range&#91;y&lt;&lt;1&#93;&#91;&#40;x&lt;&lt;1&#41;+1&#93;&#41;<br />                    + square&#40;range&#91;&#40;y&lt;&lt;1&#41;+1&#93;&#91;x&lt;&lt;1&#93;&#41;<br />                    + square&#40;range&#91;&#40;y&lt;&lt;1&#41;+1&#93;&#91;&#40;x&lt;&lt;1&#41;+1&#93;&#41;&#41;;<br />            cum_range2&#91;y+1&#93;&#91;x+1&#93; = cum_range2&#91;y&#93;&#91;x+1&#93; + r_sum2;<br />        &#125;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Free all dynamically allocated data structures for compression.<br /> */<br />void compress_cleanup&#40;y_size&#41;<br />    int y_size;              /* vertical image size */<br />&#123;<br />    int s;                   /* size index for domains */<br />    int class;               /* class number */<br />    domain_data *dom, *next; /* domain pointers */<br /><br />    free_array&#40;&#40;void**&#41;range,       y_size&#41;;<br />    free_array&#40;&#40;void**&#41;domain,      y_size/2&#41;;<br />    free_array&#40;&#40;void**&#41;cum_range,   y_size/2 + 1&#41;;<br />    free_array&#40;&#40;void**&#41;cum_range2,  y_size/2 + 1&#41;;<br />    free_array&#40;&#40;void**&#41;cum_domain2, y_size/2 + 1&#41;;<br /><br />    for &#40;s = MIN_BITS; s &lt;= MAX_BITS; s++&#41;<br />    for &#40;class = 0; class &lt; NCLASSES; class++&#41;<br />    for &#40;dom = domain_head&#91;class&#93;&#91;s&#93;; dom != NULL; dom = next&#41; &#123;<br />        next = dom-&gt;next;<br />        free&#40;dom&#41;;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Compute the sum of pixel values or squared pixel values in a range<br /> * or domain from &#40;x,y&#41; to &#40;x+size-1, y+size-1&#41; included.<br /> * For a domain, the returned value is scaled by 4 or 16.0 respectively.<br /> * x, y and size must all be even.<br /> */<br />#define region_sum&#40;cum,x,y,size&#41; \<br />   &#40;cum&#91;&#40;&#40;y&#41;+&#40;size&#41;&#41;&gt;&gt;1&#93;&#91;&#40;&#40;x&#41;+&#40;size&#41;&#41;&gt;&gt;1&#93; - cum&#91;&#40;y&#41;&gt;&gt;1&#93;&#91;&#40;&#40;x&#41;+&#40;size&#41;&#41;&gt;&gt;1&#93; \<br />  - cum&#91;&#40;&#40;y&#41;+&#40;size&#41;&#41;&gt;&gt;1&#93;&#91;&#40;x&#41;&gt;&gt;1&#93;          + cum&#91;&#40;y&#41;&gt;&gt;1&#93;&#91;&#40;x&#41;&gt;&gt;1&#93;&#41;<br /><br /><br />/* ==========================================================================<br /> * Classify all domains of a certain size. This is done only once to save<br /> * computations later. Each domain is inserted in a linked list according<br /> * to its class and size.<br /> */<br />void classify_domains&#40;x_size, y_size, s&#41;<br />    int x_size;  /* horizontal size of the complete image */<br />    int y_size;  /* vertical size   of the complete image */<br />    int s;       /* size index of the domains; their size is 1&lt;&lt;&#40;s+1&#41; */<br />&#123;<br />    domain_data *dom = NULL; /* pointer to new domain */<br />    int x, y;                /* horizontal and vertical domain position */<br />    int class;               /* domain class */<br />    int dom_size = 1&lt;&lt;&#40;s+1&#41;; /* domain size */<br />    int dom_dist = dom_size &gt;&gt; dom_density; /* distance between domains */<br /><br />    /* Initialize all domain lists to be empty&#58; */<br />    for &#40;class = 0; class &lt; NCLASSES; class++&#41; &#123;<br />        domain_head&#91;class&#93;&#91;s&#93; = NULL;<br />    &#125;<br /><br />    /* Classify all domains of this size&#58; */<br />    for &#40;y = 0; y &lt;= y_size - dom_size; y += dom_dist&#41;<br />    for &#40;x = 0; x &lt;= x_size - dom_size; x += dom_dist&#41; &#123;<br /><br />        dom = &#40;domain_data *&#41;xalloc&#40;sizeof&#40;domain_data&#41;&#41;;<br />        dom-&gt;x = x;<br />        dom-&gt;y = y;<br />        dom-&gt;d_sum  = 0.25  *&#40;double&#41;region_sum&#40;cum_range, x, y, dom_size&#41;;<br />        dom-&gt;d_sum2 = 0.0625*&#40;double&#41;region_sum&#40;cum_domain2, x, y, dom_size&#41;;<br /><br />        class = find_class&#40;x, y, dom_size&#41;;<br /><br />        dom-&gt;next = domain_head&#91;class&#93;&#91;s&#93;;<br />        domain_head&#91;class&#93;&#91;s&#93; = dom;<br />    &#125;<br /><br />    /* Check that each domain class contains at least one domain.<br />     * If a class is empty, we do as if it contains the last created<br />     * domain &#40;which is actually of a different class&#41;.<br />     */<br />    for &#40;class = 0; class &lt; NCLASSES; class++&#41; &#123;<br />        if &#40;domain_head&#91;class&#93;&#91;s&#93; == NULL&#41; &#123;<br />            domain_data *dom2 = &#40;domain_data *&#41; xalloc&#40;sizeof&#40;domain_data&#41;&#41;;<br />            *dom2 = *dom;<br />            dom2-&gt;next = NULL;<br />            domain_head&#91;class&#93;&#91;s&#93; = dom2;<br />        &#125;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Classify a range or domain.  The class is determined by the<br /> * ordering of the image brightness in the four quadrants of the range<br /> * or domain. For each quadrant we compute the number of brighter<br /> * quadrants; this is sufficient to uniquely determine the<br /> * class. class 0 has quadrants in order of decreasing brightness;<br /> * class 23 has quadrants in order of increasing brightness.<br /> *<br /> * IN assertion&#58; x, y and size are all multiple of 4.<br /> */<br />int find_class&#40;x, y, size&#41;<br />    int x, y;  /* horizontal and vertical position of the range or domain */<br />    int size;  /* size of the range or domain */<br />&#123;<br />    int class = 0;               /* the result class */<br />    int i,j;                     /* quadrant indices */<br />    uns_long sum&#91;4&#93;;             /* sums for each quadrant */<br />    static delta&#91;3&#93; = &#123;6, 2, 1&#125;; /* table used to compute the class number */<br />    int size1 = size &gt;&gt; 1;<br /><br />    /* Get the cumulative values of each quadrant. By the IN assertion,<br />     * size1, x+size1 and y+size1 are all even.<br />     */<br />    sum&#91;0&#93; = region_sum&#40;cum_range, x,       y,       size1&#41;;<br />    sum&#91;1&#93; = region_sum&#40;cum_range, x,       y+size1, size1&#41;;<br />    sum&#91;2&#93; = region_sum&#40;cum_range, x+size1, y+size1, size1&#41;;<br />    sum&#91;3&#93; = region_sum&#40;cum_range, x+size1, y,       size1&#41;;<br /><br />    /* Compute the class from the ordering of these values */<br />    for &#40;i = 0;   i &lt;= 2; i++&#41;<br />    for &#40;j = i+1; j &lt;= 3; j++&#41; &#123;<br />        if &#40;sum&#91;i&#93; &lt; sum&#91;j&#93;&#41; class += delta&#91;i&#93;;<br />    &#125;<br />    return class;<br />&#125;<br /><br />/* ==========================================================================<br /> * Compress a range by searching a match with all domains of the same class.<br /> * Split the range if the mean square error with the best domain is larger<br /> * than max_error2.<br /> * IN assertion&#58; MIN_BITS &lt;= s_log &lt;= MAX_BITS<br /> */<br />void compress_range&#40;x, y, s_log&#41;<br />    int x, y;    /* horizontal and vertical position of the range */<br />    int s_log;   /* log base 2 of the range size */<br />&#123;<br />    int r_size = 1&lt;&lt;s_log; /* size of the range */<br />    int class;             /* range class */<br />    domain_data *dom;      /* used to iterate over all domains of this class */<br />    domain_data *best_dom = NULL; /* pointer to the best domain */<br />    range_data range;      /* range information for this range */<br />    affine_map map;        /* affine map for current domain  */<br />    affine_map best_map;   /* best map for this range */<br />    uns_long dom_number;   /* domain number */<br /><br />    /* Compute the range class and cumulative sums&#58; */<br />    class = find_class&#40;x, y, r_size&#41;;<br />    range.r_sum =  &#40;double&#41;region_sum&#40;cum_range,  x, y, r_size&#41;;<br />    range.r_sum2 = &#40;double&#41;region_sum&#40;cum_range2, x, y, r_size&#41;;<br />    range.x = x;<br />    range.y = y;<br />    range.s_log = s_log;<br /><br />    /* Searching all classes can improve image quality but significantly slows<br />     * down compression. Compile with -DCOMPLETE_SEARCH if you can wait...<br />     */<br />#ifdef COMPLETE_SEARCH<br />    for &#40;class = 0; class &lt; NCLASSES; class++&#41;<br />#endif<br />    for &#40;dom = domain_head&#91;class&#93;&#91;s_log&#93;;  dom != NULL; dom = dom-&gt;next&#41; &#123;<br /><br />        /* Find the optimal map from the range to the domain&#58;<br />         */<br />        find_map&#40;&amp;range, dom, &amp;map&#41;;<br /><br />        if &#40;best_dom == NULL || map.error2 &lt; best_map.error2&#41; &#123;<br />                best_map = map;<br />                best_dom = dom;<br />        &#125;<br />    &#125;<br /><br />    /* Output the best affine map if the mean square error with the<br />     * best domain is smaller than max_error2, or if it not possible<br />     * to split the range because it is too small&#58;<br />     */<br />    if &#40;s_log == MIN_BITS ||<br />        best_map.error2 &lt;= max_error2*&#40;&#40;long&#41;r_size*r_size&#41;&#41; &#123;<br /><br />        /* If the range is too small to be split, the decompressor knows<br />         * this, otherwise we must indicate that the range has not been split&#58;<br />         */<br />        if &#40;s_log != MIN_BITS&#41; &#123;<br />            OutputBit&#40;frac_file, 1&#41;;  /* affine map follows */<br />        &#125;<br />        OutputBits&#40;frac_file, &#40;uns_long&#41;best_map.contrast, CONTRAST_BITS&#41;;<br />        OutputBits&#40;frac_file, &#40;uns_long&#41;best_map.brightness, BRIGHTNESS_BITS&#41;;<br /><br />        /* When the contrast is null, the decompressor does not need to know<br />         * which domain was selected&#58;<br />         */<br />        if &#40;best_map.contrast == 0&#41; return;<br /><br />        dom_number = &#40;uns_long&#41;best_dom-&gt;y * dom_info&#91;s_log&#93;.x_domains<br />                      + &#40;uns_long&#41;best_dom-&gt;x;<br /><br />        /* The distance between two domains is the domain size 1&lt;&lt;&#40;s_log+1&#41;<br />         * shifted right by the domain_density, so it is a power of two.<br />         * The domain x and y positions have &#40;s_log + 1 - dom_density&#41; zero<br />         * bits each, which we don't have to transmit.<br />         */<br />        OutputBits&#40;frac_file, dom_number &gt;&gt; &#40;s_log + 1 - dom_density&#41;,<br />                   dom_info&#91;s_log&#93;.pos_bits&#41;;<br />    &#125; else &#123;<br />        /* Tell the decompressor that no affine map follows because<br />         * this range has been split&#58;<br />         */<br />        OutputBit&#40;frac_file, 0&#41;;<br /><br />        /* Split the range into 4 squares and process them recursively&#58; */<br />        compress_range&#40;x,          y,          s_log-1&#41;;<br />        compress_range&#40;x+r_size/2, y,          s_log-1&#41;;<br />        compress_range&#40;x,          y+r_size/2, s_log-1&#41;;<br />        compress_range&#40;x+r_size/2, y+r_size/2, s_log-1&#41;;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Find the best affine mapping from a range to a domain. This is done<br /> * by minimizing the sum of squared errors as a function of the contrast<br /> * and brightness&#58;  sum on all range pixels ri and domain pixels di of<br /> *      square&#40;contrast*domain&#91;di&#93; + brightness - range&#91;ri&#93;&#41;<br /> * and solving the resulting equations to get contrast and brightness.<br /> */<br />void find_map&#40;rangep, dom, map&#41;<br />    range_data  *rangep; /* range information &#40;input parameter&#41; */<br />    domain_data *dom;    /* domain information &#40;input parameter&#41; */<br />    affine_map  *map;    /* resulting map &#40;output parameter&#41; */<br />&#123;<br />    int ry;            /* vertical position inside the range */<br />    int dy = dom-&gt;y &gt;&gt; 1; /* vertical position inside the domain */<br />    uns_long rd = 0;   /* sum of range*domain values &#40;scaled by 4&#41; */<br />    double rd_sum;     /* sum of range*domain values &#40;normalized&#41; */<br />    double contrast;   /* optimal contrast between range and domain */<br />    double brightness; /* optimal brightness offset between range and domain */<br />    double qbrightness;/* brightness after quantization */<br />    double max_scaled; /* maximum scaled value = contrast*MAX_GREY */<br />    int r_size = 1 &lt;&lt; rangep-&gt;s_log;                 /* the range size */<br />    double pixels = &#40;double&#41;&#40;&#40;long&#41;r_size*r_size&#41;; /* total number of pixels */<br />        <br />    for &#40;ry = rangep-&gt;y; ry &lt; rangep-&gt;y + r_size; ry++, dy++&#41; &#123;<br /><br />        register image_data *r = &amp;range&#91;ry&#93;&#91;rangep-&gt;x&#93;;<br />        register unsigned   *d = &amp;domain&#91;dy&#93;&#91;dom-&gt;x &gt;&gt; 1&#93;;<br />        int i = r_size &gt;&gt; 2;<br /><br />        /* The following loop is the most time consuming part of the whole<br />         * program, so it is unrolled a little. We rely on r_size being a<br />         * multiple of 4 &#40;ranges smaller than 4 don't make sense because<br />         * of the very bad compression&#41;. rd cannot overflow with unsigned<br />         * 32-bit arithmetic since MAX_BITS &lt;= 7 implies r_size &lt;= 128.<br />         */<br />        do &#123;<br />            rd += &#40;uns_long&#41;&#40;*r++&#41;*&#40;*d++&#41;;<br />            rd += &#40;uns_long&#41;&#40;*r++&#41;*&#40;*d++&#41;;<br />            rd += &#40;uns_long&#41;&#40;*r++&#41;*&#40;*d++&#41;;<br />            rd += &#40;uns_long&#41;&#40;*r++&#41;*&#40;*d++&#41;;<br />        &#125; while &#40;--i != 0&#41;;<br />    &#125;<br />    rd_sum = 0.25*rd;<br /><br />    /* Compute and quantize the contrast&#58; */<br />    contrast = pixels * dom-&gt;d_sum2 - dom-&gt;d_sum * dom-&gt;d_sum;<br />    if &#40;contrast != 0.0&#41; &#123;<br />        contrast = &#40;pixels*rd_sum - rangep-&gt;r_sum*dom-&gt;d_sum&#41;/contrast;<br />    &#125;<br />    map-&gt;contrast = quantize&#40;contrast, MAX_CONTRAST, MAX_QCONTRAST&#41;;<br /><br />    /* Recompute the contrast as in the decompressor&#58; */<br />    contrast = dequantize&#40;map-&gt;contrast, MAX_CONTRAST, MAX_QCONTRAST&#41;;<br /><br />    /* Compute and quantize the brightness. We actually quantize the value<br />     * &#40;brightness + 255*contrast&#41; to get a positive value&#58;<br />     *    -contrast*255 &lt;= brightness &lt;= 255<br />     * so 0 &lt;= brightness + 255*contrast &lt;= 255 + contrast*255<br />     */<br />    brightness = &#40;rangep-&gt;r_sum - contrast*dom-&gt;d_sum&#41;/pixels;<br />    max_scaled = contrast*MAX_GREY;<br />    map-&gt;brightness = quantize&#40;brightness + max_scaled,<br />                               max_scaled + MAX_GREY, MAX_QBRIGHTNESS&#41;;<br /><br />    /* Recompute the quantized brightness as in the decompressor&#58; */<br />    qbrightness = dequantize&#40;map-&gt;brightness, max_scaled + MAX_GREY,<br />                             MAX_QBRIGHTNESS&#41; - max_scaled;<br /><br />    /* Compute the sum of squared errors, which is the quantity we are<br />     * trying to minimize&#58;<br />     */<br />    map-&gt;error2 = contrast*&#40;contrast*dom-&gt;d_sum2 - 2.0*rd_sum&#41; + rangep-&gt;r_sum2<br />                + qbrightness*pixels*&#40;qbrightness - 2.0*brightness&#41;;<br />&#125;<br /><br />                /************************************/<br />                /* Functions used for decompression */<br />                /************************************/<br /><br />/*<br /> * Scale factor for decompression &#40;decompressed size divided by original size&#41;.<br /> * Only integer values are supported to simplify the implementation.<br /> */<br />int image_scale = 1;<br /><br />/*<br /> * An affine map is described by a contrast, a brightness offset, a range<br /> * and a domain. The contrast and brightness are kept as integer values<br /> * to speed up the decompression on machines with slow floating point.<br /> */<br />typedef struct map_info_struct &#123;<br />    int contrast;   /* contrast scaled by 16384 &#40;to maintain precision&#41; */<br />    int brightness; /* brightness offset scaled by 128 */<br />    int x;          /* horizontal position of the range */<br />    int y;          /* vertical position of the range */<br />    int size;       /* range size */<br />    int dom_x;      /* horizontal position of the domain */<br />    int dom_y;      /* vertical position of the domain */<br />    struct map_info_struct *next; /* next map */<br />&#125; map_info;<br /><br />map_info *map_head = NULL; /* head of the linked list of all affine maps */<br /><br />/* ==========================================================================<br /> * This is the main decompression routine.  By the time it gets called,<br /> * the input and output files have been properly opened, so all it has to<br /> * do is the decompression.  Note that the decompression routine optionally<br /> * accepts additional parameters&#58;<br /> * - the number of iterations, ranging from 1 to 15. The image quality<br /> *   does not improve much after 8 to 10 iterations. The default is 8.<br /> * - the scale factor &#40;decompressed size divided by original size&#41;<br /> */<br />void ExpandFile&#40;input, output, argc, argv&#41;<br />    BIT_FILE *input;<br />    FILE *output;<br />    int argc;<br />    char *argv&#91;&#93;;<br />&#123;<br />    int x_size;         /* horizontal image size */<br />    int y_size;         /* vertical image size */<br />    int x_dsize;        /* horizontal size of decompressed image */<br />    int y_dsize;        /* vertical size of decompressed image */<br />    int iterations = 8; /* number of iterations */<br />    int y;              /* current row being written to disk */<br /><br />    /* Check the command line parameters&#58; */<br />    for &#40; ; argc != 0; argv++, argc--&#41; &#123;<br />        if &#40;argv&#91;0&#93;&#91;0&#93; != '-' || argc == 1&#41; &#123;<br />            fatal_error&#40;&quot;Incorrect argument&#58; %s\n&quot;, *argv&#41;;<br />        &#125;<br />        switch&#40;argv&#91;0&#93;&#91;1&#93;&#41; &#123;<br />            case 'i'&#58; iterations  = atoi&#40;*++argv&#41;; argc--; break;<br />            case 's'&#58; image_scale = atoi&#40;*++argv&#41;; argc--; break;<br />            default&#58;  fatal_error&#40;&quot;Incorrect argument&#58; %s\n&quot;, *argv&#41;;<br />        &#125;<br />    &#125;<br />    if &#40;image_scale &lt; 1&#41; &#123;<br />        fatal_error&#40;&quot;Incorrect image scale\n&quot;&#41;;<br />    &#125;<br />    /* Read the header of the fractal file&#58; */<br />    frac_file = input;<br />    if &#40;InputBits&#40;frac_file, 8&#41; != 'F'&#41; &#123;<br />        fatal_error&#40;&quot;Bad fractal file format\n&quot;&#41;;<br />    &#125;<br />    x_size = &#40;int&#41;InputBits&#40;frac_file, 16&#41;;<br />    y_size = &#40;int&#41;InputBits&#40;frac_file, 16&#41;;<br />    dom_density = &#40;int&#41;InputBits&#40;frac_file, 2&#41;;<br /><br />    /* Allocate the scaled image&#58; */<br />    x_dsize = x_size * image_scale;<br />    y_dsize = y_size * image_scale;<br />    range = &#40;image_data**&#41;allocate&#40;y_dsize, x_dsize, sizeof&#40;image_data&#41;&#41;;<br /><br />    /* Initialize the domain information as in the compressor&#58; */<br />    dominfo_init&#40;x_size, y_size, dom_density&#41;;<br /><br />    /* Read all the affine maps, by using the same recursive traversal<br />     * of the image as the compressor&#58;<br />     */<br />    traverse_image&#40;0, 0, x_size, y_size, decompress_range&#41;;<br /><br />    /* Iterate all affine maps over an initially random image. Since the<br />     * affine maps are contractive, this process converges.<br />     */<br />    while &#40;iterations-- &gt; 0&#41; refine_image&#40;&#41;;<br /><br />    /* Smooth the transition between adjacent ranges&#58; */<br />    average_boundaries&#40;&#41;;<br /><br />    /* Write the uncompressed file&#58; */<br />    for &#40;y = 0; y &lt; y_dsize; y++&#41; &#123;<br />        if &#40;fwrite&#40;range&#91;y&#93;, sizeof&#40;image_data&#41;, x_dsize, output&#41; != x_dsize&#41; &#123;<br />            fatal_error&#40;&quot;Error writing uncompressed image\n&quot;&#41;;<br />        &#125;<br />    &#125;<br />    /* Cleanup&#58; */<br />    free_array&#40;&#40;void**&#41;range, y_dsize&#41;;<br />&#125;<br /><br />/* ==========================================================================<br /> * Read the affine map for a range, or split the range if the compressor<br /> * did so in the function compress_range&#40;&#41;.<br /> */<br />void decompress_range&#40;x, y, s_log&#41;<br />    int x, y;    /* horizontal and vertical position of the range */<br />    int s_log;   /* log base 2 of the range size */<br />&#123;<br />    int r_size = 1&lt;&lt;s_log; /* range size */<br />    map_info *map;         /* pointer to affine map information */<br />    double contrast;       /* contrast between range and domain */<br />    double brightness;     /* brightness offset between range and domain */<br />    double max_scaled;     /* maximum scaled value = contrast*MAX_GREY */<br />    uns_long dom_number;   /* domain number */<br /><br />    /* Read an affine map if the compressor has written one at this point&#58; */<br />    if &#40;s_log == MIN_BITS || InputBit&#40;frac_file&#41;&#41; &#123;<br /><br />        map = &#40;map_info *&#41;xalloc&#40;sizeof&#40;map_info&#41;&#41;;<br />        map-&gt;next = map_head;<br />        map_head = map;<br /><br />        map-&gt;x = x;<br />        map-&gt;y = y;<br />        map-&gt;size = r_size;<br />        map-&gt;contrast   = &#40;int&#41;InputBits&#40;frac_file, CONTRAST_BITS&#41;;<br />        map-&gt;brightness = &#40;int&#41;InputBits&#40;frac_file, BRIGHTNESS_BITS&#41;;<br /><br />        contrast = dequantize&#40;map-&gt;contrast, MAX_CONTRAST, MAX_QCONTRAST&#41;;<br />        max_scaled = contrast*MAX_GREY;<br />        brightness = dequantize&#40;map-&gt;brightness, max_scaled + MAX_GREY,<br />                                MAX_QBRIGHTNESS&#41; - max_scaled;<br /><br />        /* Scale the brightness by 128 to maintain precision later, while<br />         * avoiding overflow with 16-bit arithmetic&#58;<br />         *     -255 &lt;= -contrast*255 &lt;= brightness &lt;= 255<br />         * so -32767 &lt; brightness*128 &lt; 32767<br />         */<br />        map-&gt;brightness = &#40;int&#41;&#40;brightness*128.0&#41;;<br /><br />        /* When the contrast is null, the compressor did not encode the<br />         * domain number&#58;<br />         */<br />        if &#40;map-&gt;contrast != 0&#41; &#123;<br /><br />            /* Scale the contrast by 16384 to maintain precision later.<br />             *   0.0 &lt;= contrast &lt;= 1.0 so 0 &lt;= contrast*16384 &lt;= 16384<br />             */<br />            map-&gt;contrast = &#40;int&#41;&#40;contrast*16384.0&#41;;<br /><br />            /* Read the domain number, and add the zero bits that the<br />             * compressor did not transmit&#58;<br />             */<br />            dom_number = InputBits&#40;frac_file, dom_info&#91;s_log&#93;.pos_bits&#41;;<br /><br />            map-&gt;dom_x = &#40;int&#41;&#40;dom_number % dom_info&#91;s_log&#93;.x_domains&#41;<br />                          &lt;&lt; &#40;s_log + 1 - dom_density&#41;;<br />            map-&gt;dom_y = &#40;int&#41;&#40;dom_number / dom_info&#91;s_log&#93;.x_domains&#41;<br />                          &lt;&lt; &#40;s_log + 1 - dom_density&#41;;<br />        &#125; else &#123;<br />            /* For a null contrast, use an arbitrary domain&#58; */<br />            map-&gt;dom_x = map-&gt;dom_y = 0;<br />        &#125;<br /><br />        /* Scale the range and domain if necessary. This implementation<br />         * uses only an integer scale to make sure that the union of all<br />         * ranges is exactly the scaled image, that ranges never overlap,<br />         * and that all range sizes are even.<br />         */<br />        if &#40;image_scale != 1&#41; &#123;<br />            map-&gt;x *= image_scale;<br />            map-&gt;y *= image_scale;<br />            map-&gt;size *= image_scale;<br />            map-&gt;dom_x *= image_scale;<br />            map-&gt;dom_y *= image_scale;<br />        &#125;<br />    &#125; else &#123;<br />        /* Split the range into 4 squares and process them recursively<br />         * as in the compressor&#58;<br />         */<br />        decompress_range&#40;x,          y,          s_log-1&#41;;<br />        decompress_range&#40;x+r_size/2, y,          s_log-1&#41;;<br />        decompress_range&#40;x,          y+r_size/2, s_log-1&#41;;<br />        decompress_range&#40;x+r_size/2, y+r_size/2, s_log-1&#41;;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Refine the image by applying one round of all affine maps on the<br /> * image. The &quot;pure&quot; method would compute a separate new image and then<br /> * copy it to the original image. However the convergence towards the<br /> * final image happens to be quicker if we overwrite the same image<br /> * while applying the affine maps; for the same quality of reconstructed<br /> * image we need fewer iterations. Overwriting the same image also<br /> * reduces the memory requirements.<br /> */<br />void refine_image&#40;&#41;<br />&#123;<br />    map_info *map;   /* pointer to current affine map */<br />    long brightness; /* brightness offset of the map, scaled by 65536 */<br />    long val;        /* new pixel value */<br />    int y;           /* vertical position in range */<br />    int dom_y;       /* vertical position in domain */<br />    int j;<br /><br />    for &#40;map = map_head; map != NULL; map = map-&gt;next&#41; &#123;<br /><br />        /* map-&gt;brightness is scaled by 128, so scale it again by 512 to<br />         * get a total scale factor of 65536&#58;<br />         */<br />        brightness = &#40;long&#41;map-&gt;brightness &lt;&lt; 9;<br /><br />        dom_y = map-&gt;dom_y;<br />        for &#40;y = map-&gt;y; y &lt; map-&gt;y + map-&gt;size; y++&#41; &#123;<br /><br />            /* The following loop is the most time consuming, so we move<br />             * some address calculations outside the loop&#58;<br />             */<br />            image_data *r  = &amp;range&#91;y&#93;&#91;map-&gt;x&#93;;<br />            image_data *d  = &amp;range&#91;dom_y++&#93;&#91;map-&gt;dom_x&#93;;<br />            image_data *d1 = &amp;range&#91;dom_y++&#93;&#91;map-&gt;dom_x&#93;;<br />            j = map-&gt;size;<br />            do &#123;<br />                val  = *d++ + *d1++;<br />                val += *d++ + *d1++;<br />                /* val is now scaled by 4 and map-&gt;contrast is scaled by 16384,<br />                 * so val * map-&gt;contrast will be scaled by 65536.<br />                 */<br />                val = val * map-&gt;contrast + brightness;<br />                if &#40;val &lt; 0&#41; val = 0;<br />                val &gt;&gt;= 16; /* get rid of the 65536 scaling */<br />                if &#40;val &gt;= MAX_GREY&#41; val = MAX_GREY;<br /><br />                *r++ = &#40;image_data&#41;val;<br />            &#125; while &#40;--j != 0&#41;;<br />        &#125;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Go through all ranges to smooth the transition between adjacent<br /> * ranges, except those of minimal size.<br /> */<br />void average_boundaries&#40;&#41;<br />&#123;<br />    map_info *map;   /* pointer to current affine map */<br />    unsigned val;    /* sum of pixel value for current and adjacent ranges */<br />    int x;           /* horizontal position in current range */<br />    int y;           /* vertical position in current range */<br /><br />    for &#40;map = map_head; map != NULL; map = map-&gt;next&#41; &#123;<br /><br />        if &#40;map-&gt;size == &#40;1&lt;&lt;MIN_BITS&#41;&#41; continue; /* range too small */<br /><br />        if &#40;map-&gt;x &gt; 1&#41; &#123;<br />            /* Smooth the left boundary of the range and the right boundary<br />             * of the adjacent range&#40;s&#41; to the left&#58;<br />             */<br />            for &#40;y = map-&gt;y; y &lt; map-&gt;y + map-&gt;size; y++&#41; &#123;<br />                 val  = range&#91;y&#93;&#91;map-&gt;x - 1&#93; + range&#91;y&#93;&#91;map-&gt;x&#93;;<br />                 range&#91;y&#93;&#91;map-&gt;x - 1&#93; =<br />                     &#40;image_data&#41;&#40;&#40;range&#91;y&#93;&#91;map-&gt;x - 2&#93; + val&#41;/3&#41;;<br />                 range&#91;y&#93;&#91;map-&gt;x&#93; =<br />                     &#40;image_data&#41;&#40;&#40;val + range&#91;y&#93;&#91;map-&gt;x + 1&#93;&#41;/3&#41;;<br />            &#125;<br />        &#125;<br />        if &#40;map-&gt;y &gt; 1&#41;  &#123;<br />            /* Smooth the top boundary of the range and the bottom boundary<br />             * of the range&#40;s&#41; above&#58;<br />             */<br />            for &#40;x = map-&gt;x; x &lt; map-&gt;x + map-&gt;size; x++&#41; &#123;<br />                 val  = range&#91;map-&gt;y - 1&#93;&#91;x&#93; + range&#91;map-&gt;y&#93;&#91;x&#93;;<br />                 range&#91;map-&gt;y - 1&#93;&#91;x&#93; =<br />                     &#40;image_data&#41;&#40;&#40;range&#91;map-&gt;y - 2&#93;&#91;x&#93; + val&#41;/3&#41;;<br />                 range&#91;map-&gt;y&#93;&#91;x&#93; =<br />                     &#40;image_data&#41;&#40;&#40;val + range&#91;map-&gt;y + 1&#93;&#91;x&#93;&#41;/3&#41;;<br />            &#125;<br />        &#125;<br />    &#125;<br />&#125;<br /><br />        /*****************************************************/<br />        /* Functions common to compression and decompression */<br />        /*****************************************************/<br /><br />/* ==========================================================================<br /> * Split a rectangle sub-image into a square and potentially two rectangles,<br /> * then split the square and rectangles recursively if necessary.  To simplify<br /> * the algorithm, the size of the square is chosen as a power of two.<br /> * If the square if small enough as a range, call the appropriate compression<br /> * or decompression function for this range.<br /> * IN assertions&#58; x, y, x_size and y_size are multiple of 4.<br /> */<br />void traverse_image&#40;x, y, x_size, y_size, process&#41;<br />    int x, y;             /* sub-image horizontal and vertical position  */<br />    int x_size, y_size;   /* sub-image horizontal and vertical sizes */<br />    process_func process; /* the compression or decompression function */<br />&#123;<br />    int s_size;  /* size of the square; s_size = 1&lt;&lt;s_log */<br />    int s_log;   /* log base 2 of this size */<br /><br />    s_log = bitlength&#40;x_size &lt; y_size ? &#40;uns_long&#41;x_size &#58; &#40;uns_long&#41;y_size&#41;-1;<br />    s_size = 1 &lt;&lt; s_log;<br />    /* Since x_size and y_size are &gt;= 4, s_log &gt;= MIN_BITS */<br /><br />    /* Split the square recursively if it is too large for a range&#58; */<br />    if &#40;s_log &gt; MAX_BITS&#41; &#123;<br />        traverse_image&#40;x,          y,          s_size/2, s_size/2, process&#41;;<br />        traverse_image&#40;x+s_size/2, y,          s_size/2, s_size/2, process&#41;;<br />        traverse_image&#40;x,          y+s_size/2, s_size/2, s_size/2, process&#41;;<br />        traverse_image&#40;x+s_size/2, y+s_size/2, s_size/2, s_size/2, process&#41;;<br />    &#125; else &#123;<br />        /* Compress or decompress the square as a range&#58; */<br />        &#40;*process&#41;&#40;x, y, s_log&#41;;<br />    &#125;<br /><br />    /* Traverse the rectangle on the right of the square&#58; */<br />    if &#40;x_size &gt; s_size&#41; &#123;<br />        traverse_image&#40;x + s_size, y, x_size - s_size, y_size, process&#41;;<br /><br />        /* Since x_size and s_size are multiple of 4, x + s_size and<br />         * x_size - s_size are also multiple of 4.<br />         */<br />    &#125;<br />    /* Traverse the rectangle below the square&#58; */<br />    if &#40;y_size &gt; s_size&#41; &#123;<br />        traverse_image&#40;x, y + s_size, s_size, y_size - s_size, process&#41;;<br />    &#125;<br />&#125;        <br /><br />/* ==========================================================================<br /> * Initialize the domain information dom_info. This must be done in the<br /> * same manner in the compressor and the decompressor.<br /> */<br />void dominfo_init&#40;x_size, y_size, density&#41;<br />    int x_size;       /* horizontal size of original image */<br />    int y_size;       /* vertical size of original image */<br />    int density;      /* domain density &#40;0 to 2&#41; */<br />&#123;<br />    int s;            /* size index for domains; their size is 1&lt;&lt;&#40;s+1&#41; */<br /><br />    for &#40;s = MIN_BITS; s &lt;= MAX_BITS; s++&#41; &#123;<br />        int y_domains;            /* number of domains vertically */<br />        int dom_size = 1&lt;&lt;&#40;s+1&#41;;  /* domain size */<br /><br />        /* The distance between two domains is the domain size 1&lt;&lt;&#40;s+1&#41;<br />         * shifted right by the domain density, so it is a power of two.<br />         */<br />        dom_info&#91;s&#93;.x_domains = &#40;&#40;x_size - dom_size&#41;&gt;&gt;&#40;s + 1 - density&#41;&#41; + 1;<br />        y_domains             = &#40;&#40;y_size - dom_size&#41;&gt;&gt;&#40;s + 1 - density&#41;&#41; + 1;<br /><br />        /* Number of bits required to encode a domain position&#58; */<br />        dom_info&#91;s&#93;.pos_bits =  bitlength<br />            &#40;&#40;uns_long&#41;dom_info&#91;s&#93;.x_domains * y_domains - 1&#41;;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Quantize a value in the range 0.0 .. max to the range 0..imax<br /> * ensuring that 0.0 is encoded as 0 and max as imax.<br /> */<br />int quantize&#40;value, max, imax&#41;<br />    double value, max;<br />    int imax;<br />&#123;<br />    int ival = &#40;int&#41; floor&#40;&#40;value/max&#41;*&#40;double&#41;&#40;imax+1&#41;&#41;;<br /><br />    if &#40;ival &lt; 0&#41; return 0;<br />    if &#40;ival &gt; imax&#41; return imax;<br />    return ival;<br />&#125;<br /><br />/* ==========================================================================<br /> * Allocate memory and check that the allocation was successful.<br /> */<br />void *xalloc&#40;size&#41;<br />    unsigned size;<br />&#123;<br />    void *p = malloc&#40;size&#41;;<br /><br />    if &#40;p == NULL&#41; &#123;<br />        fatal_error&#40;&quot;insufficient memory\n&quot;&#41;;<br />    &#125;<br />    return p;<br />&#125;<br /><br />/* ==========================================================================<br /> * Allocate a two dimensional array. For portability to 16-bit<br /> * architectures with segments limited to 64K, we allocate one<br /> * array per row, so the two dimensional array is allocated<br /> * as an array of arrays.<br /> */<br />void **allocate&#40;rows, columns, elem_size&#41;<br />    int rows;      /* number of rows */<br />    int columns;   /* number of columns */<br />    int elem_size; /* element size */<br />&#123;<br />    int row;<br />    void **array = &#40;void**&#41;xalloc&#40;rows * sizeof&#40;void *&#41;&#41;;<br /><br />    for &#40;row = 0; row &lt; rows; row++&#41; &#123;<br />        array&#91;row&#93; = &#40;void*&#41;xalloc&#40;columns * elem_size&#41;;<br />    &#125;<br />    return array;<br />&#125;<br /><br />/* ==========================================================================<br /> * Free a two dimensional array allocated as a set of rows.<br /> */<br />void free_array&#40;array, rows&#41;<br />    void **array;  /* the two-dimensional array */<br />    int rows;      /* number of rows */<br />&#123;<br />    int row;<br />    for &#40;row = 0; row &lt; rows; row++&#41; &#123;<br />        free&#40;array&#91;row&#93;&#41;;<br />    &#125;<br />&#125;<br /><br />/* ==========================================================================<br /> * Return the number of bits needed to represent an integer&#58;<br /> * 0 to 1 -&gt; 1,<br /> * 2 to 3 -&gt; 2,<br /> * 3 to 7 -&gt; 3, etc...<br /> * This function could be made faster with a lookup table.<br /> */<br />int  bitlength&#40;val&#41;<br />    uns_long val;<br />&#123;<br />    int bits = 1;<br />    <br />    if &#40;val &gt; 0xffff&#41; bits += 16, val &gt;&gt;= 16;<br />    if &#40;val &gt; 0xff&#41;   bits += 8,  val &gt;&gt;= 8;<br />    if &#40;val &gt; 0xf&#41;    bits += 4,  val &gt;&gt;= 4;<br />    if &#40;val &gt; 0x3&#41;    bits += 2,  val &gt;&gt;= 2;<br />    if &#40;val &gt; 0x1&#41;    bits += 1;<br />    return bits;<br />&#125;<br /></code></pre><br /><br />bitio.h<br /><br /><pre><code><br />/************************** Start of BITIO.H *************************/<br /><br />#ifndef _BITIO_H<br />#define _BITIO_H<br /><br />#include &lt;stdio.h&gt;<br /><br />typedef struct bit_file &#123;<br />    FILE *file;<br />    unsigned char mask;<br />    int rack;<br />    int pacifier_counter;<br />&#125; BIT_FILE;<br /><br />#ifdef __STDC__<br /><br />BIT_FILE     *OpenInputBitFile&#40; char *name &#41;;<br />BIT_FILE     *OpenOutputBitFile&#40; char *name &#41;;<br />void          OutputBit&#40; BIT_FILE *bit_file, int bit &#41;;<br />void          OutputBits&#40; BIT_FILE *bit_file,<br />                          unsigned long code, int count &#41;;<br />int           InputBit&#40; BIT_FILE *bit_file &#41;;<br />unsigned long InputBits&#40; BIT_FILE *bit_file, int bit_count &#41;;<br />void          CloseInputBitFile&#40; BIT_FILE *bit_file &#41;;<br />void          CloseOutputBitFile&#40; BIT_FILE *bit_file &#41;;<br />void          FilePrintBinary&#40; FILE *file, unsigned int code, int bits &#41;;<br /><br />#else   /* __STDC__ */<br /><br />BIT_FILE     *OpenInputBitFile&#40;&#41;;<br />BIT_FILE     *OpenOutputBitFile&#40;&#41;;<br />void          OutputBit&#40;&#41;;<br />void          OutputBits&#40;&#41;;<br />int           InputBit&#40;&#41;;<br />unsigned long InputBits&#40;&#41;;<br />void          CloseInputBitFile&#40;&#41;;<br />void          CloseOutputBitFile&#40;&#41;;<br />void          FilePrintBinary&#40;&#41;;<br /><br />#endif  /* __STDC__ */<br /><br />#endif  /* _BITIO_H */<br /><br />/*************************** End of BITIO.H **************************/<br /></code></pre><br /><br />errhand.h<br /><br /><pre><code><br />/************************* Start of ERRHAND.H ************************/<br /><br />#ifndef _ERRHAND_H<br />#define _ERRHAND_H<br /><br />#ifdef __STDC__<br /><br />void fatal_error&#40; char *fmt, ... &#41;;<br /><br />#else   /* __STDC__ */<br /><br />void fatal_error&#40;&#41;;<br /><br />#endif  /* __STDC__ */<br /><br />#endif  /* _ERRHAND_H */<br /><br />/************************** End of ERRHAND.H *************************/<br /></code></pre><br /><br />errhand.c<br /><pre><code><br />/************************* Start of ERRHAND.C ************************<br /> *<br /> * This is a general purpose error handler used with every program in<br /> * the book.<br /> */<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdarg.h&gt;<br />#include &quot;errhand.h&quot;<br /><br />#ifdef __STDC__<br />void fatal_error&#40; char *fmt, ... &#41;<br />#else<br />#ifdef __UNIX__<br />void fatal_error&#40; fmt, va_alist &#41;<br />char *fmt;<br />va_dcl<br />#else<br />void fatal_error&#40; fmt &#41;<br />char *fmt;<br />#endif<br />#endif<br />&#123;<br />    va_list argptr;<br /><br />    va_start&#40; argptr, fmt &#41;;<br />    printf&#40; &quot;Fatal error&#58; &quot; &#41;;<br />    vprintf&#40; fmt, argptr &#41;;<br />    va_end&#40; argptr &#41;;<br />    exit&#40; -1 &#41;;<br />&#125;<br /><br />/************************** End of ERRHAND.C *************************/<br /></code></pre><br /><br />bitio.c<br /><br /><pre><code><br />/************************** Start of BITIO.C *************************<br /> *<br /> * This utility file contains all of the routines needed to impement<br /> * bit oriented routines under either ANSI or K&amp;R C.  It needs to be<br /> * linked with every program used in the entire book.<br /> *<br /> */<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &quot;bitio.h&quot;<br />#include &quot;errhand.h&quot;<br /><br />#define PACIFIER_COUNT 2047<br /><br />BIT_FILE *OpenOutputBitFile&#40; name &#41;<br />char *name;<br />&#123;<br />    BIT_FILE *bit_file;<br /><br />    bit_file = &#40;BIT_FILE *&#41; calloc&#40; 1, sizeof&#40; BIT_FILE &#41; &#41;;<br />    if &#40; bit_file == NULL &#41;<br />        return&#40; bit_file &#41;;<br />    bit_file-&gt;file = fopen&#40; name, &quot;wb&quot; &#41;;<br />    bit_file-&gt;rack = 0;<br />    bit_file-&gt;mask = 0x80;<br />    bit_file-&gt;pacifier_counter = 0;<br />    return&#40; bit_file &#41;;<br />&#125;<br /><br />BIT_FILE *OpenInputBitFile&#40; name &#41;<br />char *name;<br />&#123;<br />    BIT_FILE *bit_file;<br /><br />    bit_file = &#40;BIT_FILE *&#41; calloc&#40; 1, sizeof&#40; BIT_FILE &#41; &#41;;<br />    if &#40; bit_file == NULL &#41;<br />	return&#40; bit_file &#41;;<br />    bit_file-&gt;file = fopen&#40; name, &quot;rb&quot; &#41;;<br />    bit_file-&gt;rack = 0;<br />    bit_file-&gt;mask = 0x80;<br />    bit_file-&gt;pacifier_counter = 0;<br />    return&#40; bit_file &#41;;<br />&#125;<br /><br />void CloseOutputBitFile&#40; bit_file &#41;<br />BIT_FILE *bit_file;<br />&#123;<br />    if &#40; bit_file-&gt;mask != 0x80 &#41;<br />        if &#40; putc&#40; bit_file-&gt;rack, bit_file-&gt;file &#41; != bit_file-&gt;rack &#41;<br />            fatal_error&#40; &quot;Fatal error in CloseBitFile!\n&quot; &#41;;<br />    fclose&#40; bit_file-&gt;file &#41;;<br />    free&#40; &#40;char *&#41; bit_file &#41;;<br />&#125;<br /><br />void CloseInputBitFile&#40; bit_file &#41;<br />BIT_FILE *bit_file;<br />&#123;<br />    fclose&#40; bit_file-&gt;file &#41;;<br />    free&#40; &#40;char *&#41; bit_file &#41;;<br />&#125;<br /><br />void OutputBit&#40; bit_file, bit &#41;<br />BIT_FILE *bit_file;<br />int bit;<br />&#123;<br />    if &#40; bit &#41;<br />        bit_file-&gt;rack |= bit_file-&gt;mask;<br />    bit_file-&gt;mask &gt;&gt;= 1;<br />    if &#40; bit_file-&gt;mask == 0 &#41; &#123;<br />	if &#40; putc&#40; bit_file-&gt;rack, bit_file-&gt;file &#41; != bit_file-&gt;rack &#41;<br />	    fatal_error&#40; &quot;Fatal error in OutputBit!\n&quot; &#41;;<br />	else<br />        if &#40; &#40; bit_file-&gt;pacifier_counter++ &amp; PACIFIER_COUNT &#41; == 0 &#41;<br />		putc&#40; '.', stdout &#41;;<br />	bit_file-&gt;rack = 0;<br />	bit_file-&gt;mask = 0x80;<br />    &#125;<br />&#125;<br /><br />void OutputBits&#40; bit_file, code, count &#41;<br />BIT_FILE *bit_file;<br />unsigned long code;<br />int count;<br />&#123;<br />    unsigned long mask;<br /><br />    mask = 1L &lt;&lt; &#40; count - 1 &#41;;<br />    while &#40; mask != 0&#41; &#123;<br />        if &#40; mask &amp; code &#41;<br />            bit_file-&gt;rack |= bit_file-&gt;mask;<br />        bit_file-&gt;mask &gt;&gt;= 1;<br />        if &#40; bit_file-&gt;mask == 0 &#41; &#123;<br />	    if &#40; putc&#40; bit_file-&gt;rack, bit_file-&gt;file &#41; != bit_file-&gt;rack &#41;<br />		fatal_error&#40; &quot;Fatal error in OutputBit!\n&quot; &#41;;<br />        else if &#40; &#40; bit_file-&gt;pacifier_counter++ &amp; PACIFIER_COUNT &#41; == 0 &#41;<br />		putc&#40; '.', stdout &#41;;<br />	    bit_file-&gt;rack = 0;<br />            bit_file-&gt;mask = 0x80;<br />        &#125;<br />        mask &gt;&gt;= 1;<br />    &#125;<br />&#125;<br /><br />int InputBit&#40; bit_file &#41;<br />BIT_FILE *bit_file;<br />&#123;<br />    int value;<br /><br />    if &#40; bit_file-&gt;mask == 0x80 &#41; &#123;<br />        bit_file-&gt;rack = getc&#40; bit_file-&gt;file &#41;;<br />        if &#40; bit_file-&gt;rack == EOF &#41;<br />            fatal_error&#40; &quot;Fatal error in InputBit!\n&quot; &#41;;<br />    if &#40; &#40; bit_file-&gt;pacifier_counter++ &amp; PACIFIER_COUNT &#41; == 0 &#41;<br />	    putc&#40; '.', stdout &#41;;<br />    &#125;<br />    value = bit_file-&gt;rack &amp; bit_file-&gt;mask;<br />    bit_file-&gt;mask &gt;&gt;= 1;<br />    if &#40; bit_file-&gt;mask == 0 &#41;<br />	bit_file-&gt;mask = 0x80;<br />    return&#40; value ? 1 &#58; 0 &#41;;<br />&#125;<br /><br />unsigned long InputBits&#40; bit_file, bit_count &#41;<br />BIT_FILE *bit_file;<br />int bit_count;<br />&#123;<br />    unsigned long mask;<br />    unsigned long return_value;<br /><br />    mask = 1L &lt;&lt; &#40; bit_count - 1 &#41;;<br />    return_value = 0;<br />    while &#40; mask != 0&#41; &#123;<br />	if &#40; bit_file-&gt;mask == 0x80 &#41; &#123;<br />	    bit_file-&gt;rack = getc&#40; bit_file-&gt;file &#41;;<br />	    if &#40; bit_file-&gt;rack == EOF &#41;<br />		fatal_error&#40; &quot;Fatal error in InputBit!\n&quot; &#41;;<br />        if &#40; &#40; bit_file-&gt;pacifier_counter++ &amp; PACIFIER_COUNT &#41; == 0 &#41;<br />		putc&#40; '.', stdout &#41;;<br />	&#125;<br />	if &#40; bit_file-&gt;rack &amp; bit_file-&gt;mask &#41;<br />            return_value |= mask;<br />        mask &gt;&gt;= 1;<br />        bit_file-&gt;mask &gt;&gt;= 1;<br />        if &#40; bit_file-&gt;mask == 0 &#41;<br />            bit_file-&gt;mask = 0x80;<br />    &#125;<br />    return&#40; return_value &#41;;<br />&#125;<br /><br />void FilePrintBinary&#40; file, code, bits &#41;<br />FILE *file;<br />unsigned int code;<br />int bits;<br />&#123;<br />    unsigned int mask;<br /><br />    mask = 1 &lt;&lt; &#40; bits - 1 &#41;;<br />    while &#40; mask != 0 &#41; &#123;<br />        if &#40; code &amp; mask &#41;<br />            fputc&#40; '1', file &#41;;<br />        else<br />            fputc&#40; '0', file &#41;;<br />        mask &gt;&gt;= 1;<br />    &#125;<br />&#125;<br /><br />/*************************** End of BITIO.C **************************/<br /></code></pre></div>
    <div class="meta">Posted on 2001-08-19 11:23:26 by bazik</div>
   </div>
   <div class="post" id="post-4140">
    <div class="subject"><a href="#post-4140">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">I have that book. :)  I like that you can enlarge the image and you don't get the typical pixelization.  I think a zip file might have been a better choice.  Someone on the hugi size coding compo said they had an assembly version that was very small in size!  What compiler are you using?</div>
    <div class="meta">Posted on 2001-08-19 12:46:27 by bitRAKE</div>
   </div>
   <div class="post" id="post-4141">
    <div class="subject"><a href="#post-4141">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">&gt;I have that book. :)  <br /><br />&quot;The Data Compression Book&quot; by Nelson Gailly? ;)<br /><br />&gt;I think a zip file might have been a better choice.<br /><br />Sure. But it would be interested to see it working.<br /><br />&gt;What compiler are you using?<br /><br />I tried it with VC++, LCC-Win32 and GCC under Linux.</div>
    <div class="meta">Posted on 2001-08-19 12:53:36 by bazik</div>
   </div>
   <div class="post" id="post-4144">
    <div class="subject"><a href="#post-4144">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">Hi<br />bitrake:<br />what do you mean :<br /><div class="quote">I like that you can enlarge the image and you don't get the typical pixelization.</div> <br /><br />can you zoom on the image and it will still keep on the quality?<br /><br />if i understood correctly<br />can you publish or send me  the source for that or the program the that does it ?<br /><br />bye <br />eko</div>
    <div class="meta">Posted on 2001-08-19 13:57:01 by eko</div>
   </div>
   <div class="post" id="post-4147">
    <div class="subject"><a href="#post-4147">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">This is by the vary nature of the algorithm. :)  I don't know if I have the sources, but I'll look.  There is C code <a target="_blank" href="http://inls.ucsd.edu/y/Fractals/book.html">HERE</a>.  If I remember right, all I changed was the decode resolution and it worked.  I've been meaning to do an asm version.  I started it before, but ran up against time constrains of a contest and had to use another compression algo.</div>
    <div class="meta">Posted on 2001-08-19 14:29:13 by bitRAKE</div>
   </div>
   <div class="post" id="post-4150">
    <div class="subject"><a href="#post-4150">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">thanks <br /><br /><br />eko</div>
    <div class="meta">Posted on 2001-08-19 14:59:39 by eko</div>
   </div>
   <div class="post" id="post-4166">
    <div class="subject"><a href="#post-4166">Fractal Image Compression (in C, not ASM)</a></div>
    <div class="body">Try <span style="font-size:18px><a target="_blank" href="ftp://links.uwaterloo.ca/pub/Fractals/Programs/AppWizard/fraccompress.zip">THIS</a></span>.  VC++ project for fractal compression program.</div>
    <div class="meta">Posted on 2001-08-19 18:06:37 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>