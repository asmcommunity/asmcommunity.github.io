<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Linear Search HELP - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29902" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29902">Linear Search HELP</a></p>
   <div class="post" id="post-211200">
    <div class="subject"><a href="#post-211200">Linear Search HELP</a></div>
    <div class="body">;=== Subprogram liner_search ===<br />linear_search:<br /><br />segment .data<br /><br />outof db&nbsp;  &quot;Got out of loop&quot;, 0<br />notf db&nbsp; &nbsp; &quot;Got to not_found&quot;, 0<br /><br />segment .bss<br /><br />segment .text<br />push&nbsp;  ebp						&nbsp; &nbsp; &nbsp; &nbsp; ; push all registers onto stack<br />mov&nbsp; &nbsp; ebp, esp					&nbsp; &nbsp; &nbsp; &nbsp; ; copy esp into ebp to hold place on stack<br />push&nbsp;  ebx<br />push&nbsp;  ecx<br /><br />mov&nbsp; &nbsp; ebx, 					; copy start address of array into ebx<br />mov&nbsp; &nbsp; ecx, 				&nbsp; &nbsp; &nbsp; &nbsp; ; copy size of array into ecx<br />mov&nbsp; &nbsp; eax, 				&nbsp; &nbsp; &nbsp; &nbsp; ; copy dw to be found into eax<br />sub&nbsp; &nbsp; ebx, 4						; setupd array pointer to enter loop<br /><br />search_loop:<br />	add&nbsp; &nbsp; ebx, 4					; increment array pointer to next slot<br />	cmp&nbsp; &nbsp; eax, 				; compare value to be found with value in array<br />	loopne search_loop				; return to beginning of loop if not equal and ecx!=0<br />	cmp&nbsp; &nbsp; eax, 				; compare value to be found with value in array<br />	jne&nbsp; &nbsp; number_not_found			; jump to number_not_found if eax != <br />	mov&nbsp; &nbsp; eax,				; move size of array to eax<br />	sub&nbsp; &nbsp; eax, ecx				&nbsp; &nbsp; &nbsp; &nbsp; ; compute array index of number<br />	mov&nbsp; &nbsp; , eax			&nbsp; &nbsp; &nbsp; &nbsp; ; put index in stack for main<br />	jmp&nbsp; &nbsp; done					; jump to end of subprogram<br />number_not_found:<br />	mov&nbsp; &nbsp; eax, 0					; move 0 into eax to return not found value<br />	mov&nbsp; &nbsp; , eax			&nbsp; &nbsp; &nbsp; &nbsp; ; move 0 into stack for main<br />done:<br />	pop&nbsp; &nbsp; ecx<br />	pop&nbsp; &nbsp; ebx<br />	pop&nbsp; &nbsp; ebp<br />	ret<br />;==== End of subprogram linear_search<br /><br /><br /><br /><br />This is my subprogram linear_search for a main.<br />If i include the element to be found in the array, it return the index of the element fine,<br />However, if the element is not in the array it throws a segmentation fault instead of returning a zero<br /><br />I&#039;ve tried adding comments in after program should end loop and then cmp again to see if loop ended because value was found, or because<br />ecx = 0 and value not found... however, program seems to crash where loopne checks value!=element and ecx=0..<br /><br />PLEASE HELP</div>
    <div class="meta">Posted on 2010-04-02 13:18:49 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211201">
    <div class="subject"><a href="#post-211201">Re: Linear Search HELP</a></div>
    <div class="body">Don&#039;t use so much registers and loopne...<br />You can try something like this:<pre><code><br />SrchDD proto :dword,:dword,:dword<br />...<br />How to call:<br />	invoke	SrchDD, &nbsp;addr addr_array, dwsize, dwsrchpathern<br />	jc	Not_found<br />Found:<br />.....<br />......<br />Not_found:<br />...<br />...<br />SrchDD &nbsp; &nbsp;proc &nbsp;lpsaddr:dword, lpsize:dword, npathern:dword <br />	 &nbsp;pop	ecx 	; return address<br />	 &nbsp;pop	eax	; eax-&gt;start address of array 	<br />	 &nbsp;pop	ecx	; ecx-&gt; size of array into ecx	<br /> 	 &nbsp;pop	edx	; edx-&gt; dw to be found into eax<br />	 &nbsp;add	ecx, eax ; ecx-&gt;last address of array	<br />@@:<br />	 &nbsp;cmp &nbsp; edx,  &nbsp; &nbsp;; compare value to be found with value in array<br />	 &nbsp;je	@f		<br />	 &nbsp;add &nbsp; eax, 4 &nbsp; &nbsp; &nbsp; &nbsp;; increment array pointer to next slot<br />	 &nbsp;cmp	eax, ecx<br />	 &nbsp;jle 	@b<br />	 &nbsp;stc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;; set carry flag=1 -&gt;flag for not_found<br />	 &nbsp;jmp	dword ptr  &nbsp; &nbsp; ; return carry flag=1 and jmp to return address 		 			<br />@@:<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub &nbsp; eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; eax-&gt; index		 &nbsp;<br />	 &nbsp;jmp	dword ptr  &nbsp; &nbsp; ; return the index in EAX and jmp to return address <br />SrchDD &nbsp; &nbsp;endp</code></pre> </div>
    <div class="meta">Posted on 2010-04-02 15:59:15 by lingo12</div>
   </div>
   <div class="post" id="post-211202">
    <div class="subject"><a href="#post-211202">Re: Linear Search HELP</a></div>
    <div class="body">well this is a project for class, and the professor wants us to do it only with what we&#039;ve learned in class thus far...<br /><br />I&#039;ve been messing with my program, and it looks like the problem is that loopne does not exit<br />when it gets to the last element of the array (the size which is stored in ecx)...<br />it just keeps looping and then segmentation fault.... any ideas?</div>
    <div class="meta">Posted on 2010-04-02 16:02:01 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211203">
    <div class="subject"><a href="#post-211203">Re: Linear Search HELP</a></div>
    <div class="body">What are the units of &quot;size of array&quot; that you&#039;re putting in ecx? If that&#039;s in bytes, there&#039;s your problem! ecx should be &quot;number of dwords&quot;. If that isn&#039;t it... keep lookin&#039;...<br /><br />You shouldn&#039;t need to put the index back on the stack, once you&#039;ve calculated it - just return it in eax... that&#039;s the &quot;usual way&quot;... (from the way you&#039;re calculating the index, looks as if &quot;size of array&quot; is in dwords... so the question might be &quot;what are you actually passing it?&quot;)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-04-02 18:00:42 by fbkotler</div>
   </div>
   <div class="post" id="post-211204">
    <div class="subject"><a href="#post-211204">Re: Linear Search HELP</a></div>
    <div class="body">i declared the size variables as:<br />size1 resd 1<br />so they are double words.<br /><br />The problem is just when the element to be found isn&#039;t in the array... the loop keeps going when ecx is 0<br />Works fine when the element is in the array</div>
    <div class="meta">Posted on 2010-04-02 18:03:12 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211205">
    <div class="subject"><a href="#post-211205">Re: Linear Search HELP</a></div>
    <div class="body"><pre><code><div class="quote"><br />...<br />SrchDD&nbsp; &nbsp; proc&nbsp; lpsaddr:dword, lpsize:dword, npathern:dword <br />	&nbsp; pop	ecx 	; return address<br />	&nbsp; pop	eax	; eax-&gt;start address of array 	<br />	&nbsp; pop	ecx	; ecx-&gt; size of array into ecx	<br /> 	&nbsp; pop	edx	; edx-&gt; dw to be found into eax<br />	&nbsp; add	ecx, eax ; ecx-&gt;last address of array	<br />@@:<br />	&nbsp; cmp&nbsp;  edx, &nbsp; &nbsp; ; compare value to be found with value in array<br />	&nbsp; je	@f		<br />	&nbsp; add&nbsp;  eax, 4&nbsp; &nbsp; &nbsp; &nbsp; ; increment array pointer to next slot<br />	&nbsp; cmp	eax, ecx<br />	&nbsp; jle 	@b<br />	&nbsp; xor	eax, eax&nbsp; &nbsp; &nbsp; ; eax=0 -&gt;is a flag for not_found<br />	&nbsp; jmp	dword ptr &nbsp; &nbsp;  ; return zero in EAX and jmp to return address 		 			<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp;  eax,  ; eax-&gt; index		&nbsp; <br />	&nbsp; jmp	dword ptr &nbsp; &nbsp;  ; return the index in EAX and jmp to return address <br />SrchDD&nbsp; &nbsp; endp</code></pre> <br /></div><br /><br />Interesting technique. Did you see that somewhere, or think it up yourself? I don&#039;t think it&#039;s very &quot;robust&quot;, but... interesting...<br /><br />ZosoLzrd,<br /><br />Yes, the &quot;size&quot; of &quot;size of array&quot; is dword, but what are the &quot;units&quot;? I&#039;m not making myself clear... what number is going in ecx? Number of bytes in the array? Or number of dwords in the array? You&#039;re treating it as if it were the latter. I doubt if &quot;loop&quot; is continuing when ecx is zero. But if ecx were number of bytes in the array, it would continue longer than it should (ebx will be past the end of your array - segfault!) If all else fails, post the calling code.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-04-02 18:30:49 by fbkotler</div>
   </div>
   <div class="post" id="post-211206">
    <div class="subject"><a href="#post-211206">Re: Linear Search HELP</a></div>
    <div class="body">Oh sorry.<br />ecx holds the number of dwords in the array.</div>
    <div class="meta">Posted on 2010-04-02 18:32:41 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211207">
    <div class="subject"><a href="#post-211207">Re: Linear Search HELP</a></div>
    <div class="body">i understand what you&#039;re saying about it counting the bytes.<br />But i checked that ecx = the number of integers inputed in the array before entering the loop.<br /></div>
    <div class="meta">Posted on 2010-04-02 18:38:46 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211208">
    <div class="subject"><a href="#post-211208">Re: Linear Search HELP</a></div>
    <div class="body"><strong>&quot;Did you see that somewhere, or think it up yourself? &quot;</strong><br />You can search this and hutch&#039;s forums about my &quot;technique&quot;...<br /><br /><strong>&quot;I don&#039;t think it&#039;s very &quot;robust&quot;, but... interesting...&quot;</strong><br />Don&#039;t think, just measure it for speed...&nbsp;  ;)<br /></div>
    <div class="meta">Posted on 2010-04-02 18:52:12 by lingo12</div>
   </div>
   <div class="post" id="post-211209">
    <div class="subject"><a href="#post-211209">Re: Linear Search HELP</a></div>
    <div class="body">For what shall I search, &quot;lingo12&#039;s technique&quot;?<br /><br />ZosoLzrd,<br /><br />Okay, I&#039;m gonna have to test this, wait a second... okay... Works for me. If the &quot;needle&quot; is the first dword in the array, you&#039;re returning 1, while I&#039;d call that &quot;index 0&quot; (you&#039;re using zero for &quot;not found&quot;), but it works, found or not. What&#039;s different? Got me!<br /><br />A common bug is to put a call to a C function in the middle of a loop - C is allowed to trash ecx - but you haven&#039;t done that. I don&#039;t see the problem. Just to make sure we&#039;re comparing apples with apples, here&#039;s what I tested:<br /><br /><pre><code><br />;=== Subprogram liner_search ===<br /><br />global _start<br />section .text<br />_start:<br />&nbsp; &nbsp; nop<br />&nbsp; &nbsp; push 42<br />&nbsp; &nbsp; push 5<br />&nbsp; &nbsp; push array<br />&nbsp; &nbsp; call linear_search<br />&nbsp; &nbsp; add esp, 4 * 3<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov ebx, eax ; make index the exitcode - view with &quot;echo $?&quot;<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov eax, 1<br />&nbsp; &nbsp; int 80h<br /><br />;&nbsp; I&#039;d really like to see this label moved, but it works like this...<br />linear_search:<br /><br />segment .data<br /><br />array dd 0, 1, 2, 3, 2<br /><br /><br />outof db&nbsp;  &quot;Got out of loop&quot;, 0<br />notf db&nbsp; &nbsp; &quot;Got to not_found&quot;, 0<br /><br />segment .bss<br /><br />segment .text<br /><br />; linear_array:<br />push&nbsp;  ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; push all registers onto stack<br />mov&nbsp; &nbsp; ebp, esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; copy esp into ebp to hold place on stack<br />push&nbsp;  ebx<br />push&nbsp;  ecx<br /><br />mov&nbsp; &nbsp; ebx, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; copy start address of array into ebx<br />mov&nbsp; &nbsp; ecx, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy size of array into ecx<br />mov&nbsp; &nbsp; eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; copy dw to be found into eax<br />sub&nbsp; &nbsp; ebx, 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; setupd array pointer to enter loop<br /><br />search_loop:<br />&nbsp;  add&nbsp; &nbsp; ebx, 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; increment array pointer to next slot<br />&nbsp;  cmp&nbsp; &nbsp; eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compare value to be found with value in array<br />&nbsp;  loopne search_loop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to beginning of loop if not equal and ecx!=0<br />&nbsp;  cmp&nbsp; &nbsp; eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compare value to be found with value in array<br />&nbsp;  jne&nbsp; &nbsp; number_not_found&nbsp; &nbsp; &nbsp; &nbsp;  ; jump to number_not_found if eax != <br />&nbsp;  mov&nbsp; &nbsp; eax,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; move size of array to eax<br />&nbsp;  sub&nbsp; &nbsp; eax, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compute array index of number<br />&nbsp;  mov&nbsp; &nbsp; , eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; put index in stack for main<br />&nbsp;  jmp&nbsp; &nbsp; done&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; jump to end of subprogram<br />number_not_found:<br />&nbsp;  mov&nbsp; &nbsp; eax, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; move 0 into eax to return not found value<br />&nbsp;  mov&nbsp; &nbsp; , eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; move 0 into stack for main<br />done:<br />&nbsp;  pop&nbsp; &nbsp; ecx<br />&nbsp;  pop&nbsp; &nbsp; ebx<br />&nbsp;  pop&nbsp; &nbsp; ebp<br />&nbsp;  ret<br />;==== End of subprogram linear_search<br /></code></pre><br /><br />What am I missing???<br /><br />Best,<br />Frank<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-04-02 19:31:34 by fbkotler</div>
   </div>
   <div class="post" id="post-211210">
    <div class="subject"><a href="#post-211210">Re: Linear Search HELP</a></div>
    <div class="body">Ok so how my program works is, it ask user to input integers for 2 arrays.<br />right now im only using the first array to test my linear search subprogram.<br />I have the program set to look for &#039;5&#039; in the array.<br />So if i enter 5 into the array, it will return and show the index of &#039;5&#039; in the array...<br />Really its the index+1 because the first index would return as 1 as opposed to 0.<br /><br />To test how many times the loop runs i put the following code:<br />call&nbsp; &nbsp; print_int<br />call&nbsp; &nbsp; print_nl<br /><br />to print eax &#039;5&#039; everytime it ran through the loop.<br />It came out to be over 800 times and finally a seg fault...<br /><br />I dont know why it works for you...<br /><br /><br />Here is all my code, maybe it&#039;ll be some help<br /><br /><pre><code>%include &quot;asm_io.inc&quot;<br /><br />segment .data<br /><br />welcome&nbsp; db&nbsp; &nbsp; &quot;Welcome to Assignment 4 by Anthony Gonzalez.&quot;, 0<br /><br />intro&nbsp; &nbsp; db&nbsp; &nbsp; &quot;This program will demonstrate the union and intersection of arrays.&quot;, 0 <br /><br />first&nbsp; &nbsp; db&nbsp; &nbsp; &quot;Please enter double words for first array.&quot;, 0<br /><br />second&nbsp;  db&nbsp; &nbsp; &quot;Please enter double words for second array.&quot;, 0<br /><br />thisis&nbsp;  db&nbsp; &nbsp; &quot;This is the location of the found variable: &quot;, 0<br /><br />afterpush db&nbsp;  &quot;The problem is after push for linear_Search, and before calling it.&quot;,0<br />aftersearch db &quot;The problem is after linear search.&quot;, 0<br /><br />segment .bss<br /><br />array1 resd 50						; first array for input<br />array2 resd 50						; second array for input<br />;union resd 100					array used for union of two arrays<br />;intersection resd 50			&nbsp; &nbsp;  array used for intersection of two arrays<br />size1 resd 1						; size of first array<br />size2 resd 1						; size of second array<br />;unionsize resd 1					size of union array<br />;intersectsize resd 1				size of intersection array<br />location resd 1					; location holder for linear_search<br /><br />segment .text<br />&nbsp; &nbsp; &nbsp;  global&nbsp; asm_main&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />asm_main:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br /><br />enter&nbsp; &nbsp; 0,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  		; setup routine<br />pusha							; push all registers on stack<br /><br />mov&nbsp; &nbsp; eax, welcome					; move welcome message into eax<br />call&nbsp;  print_string					; print welcome message<br />call&nbsp;  print_nl					; print new line<br /><br />mov&nbsp; &nbsp; eax, intro					; move intro message into eax<br />call&nbsp;  print_string					; print intro message<br />call&nbsp;  print_nl					; print new line<br /><br />mov&nbsp; &nbsp; eax, first					; move first prompt into eax for printing<br />call&nbsp;  print_string					; print prompt to screen<br />call&nbsp;  print_nl					; print new line<br /><br />push&nbsp;  array1						; push array1 onto stack for get_array<br />push&nbsp;  size1						; push size1 onto stack to count entries for array1<br /><br />call&nbsp;  get_array					; call subprogram get_array to fill first array<br /><br />pop&nbsp; &nbsp; dword <span style="font-size:1>				; pop counter from stack into size1<br />pop&nbsp; &nbsp; edx						; pop to discard start of array<br /><br />mov&nbsp; &nbsp; eax, second					; move second prompt into eax for printing<br />call&nbsp;  print_string					; print prompt to screen<br />call&nbsp;  print_nl					; print new line<br /><br />push&nbsp;  array2						; push array2 onto stack for get_array<br />push&nbsp;  size2						; push size2 onto stack to count entries for array2<br /><br />call&nbsp;  get_array					; call subprogram get_array to fill second array<br /><br />pop&nbsp; &nbsp; dword <span style="font-size:2>				; pop counter from stack into size2<br />pop&nbsp; &nbsp; edx						; pop to discard start of array<br /><br />mov&nbsp; &nbsp; eax, 5<br /><br />push&nbsp;  eax<br />push&nbsp;  size1<br />push&nbsp;  array1<br /><br />call&nbsp;  linear_search<br /><br />pop&nbsp; &nbsp; edx<br />pop&nbsp; &nbsp; edx<br />pop&nbsp; &nbsp; eax<br /><br />call&nbsp;  print_int<br />call&nbsp;  print_nl<br /><br />mov&nbsp; &nbsp; eax, thisis<br />call&nbsp;  print_nl<br />call&nbsp;  print_string<br /><br /><br /><br />;&nbsp; --- clean up procedure ---<br />dump_regs 97<br />dump_mem&nbsp; 98, array1, 2<br />mov&nbsp; &nbsp; ebp, esp<br />dump_stack 99, 2, 3<br /><br />popa<br />mov&nbsp; &nbsp; eax, 0<br />leave<br />ret<br /><br />;======== End of Main ========<br /><br /><br /><br />;=== Subprogram get_array===<br />get_array:<br /><br />segment .data<br /><br />moreinputs db&nbsp; &nbsp; &quot;Are the more inputs to be entered(Y=1 or N=0)? &quot;, 0<br />enterprompt db&nbsp; &nbsp; &quot;Enter next number: &quot;, 0<br /><br />segment .bss<br /><br />segment .text<br />pusha<br />mov&nbsp; &nbsp; ebp, esp					; copy esp into ebp to hold place on stack<br /><br />mov&nbsp; &nbsp; edx, 				; move array into edx from stack<br />mov&nbsp; &nbsp; ecx, 0						; move size counter for array into ecx from stack<br /><br />mov&nbsp; &nbsp; eax, moreinputs				; move inputs prompt for printing<br />call&nbsp;  print_string					; print inputs prompt<br />call&nbsp;  read_int<br /><br />if:<br />	cmp&nbsp; &nbsp; eax, 1<br />	jne&nbsp; &nbsp; endif<br /><br />	beginloop:					; statement to start while loop<br />	mov&nbsp; &nbsp; eax, enterprompt			; move enterprompt into eax for printing<br />	call&nbsp;  print_string				; print enterprompt<br />	call&nbsp;  read_int				; read integer from keyboard<br />	mov&nbsp; &nbsp; , eax			; place integer incoming integer into array<br />	add&nbsp; &nbsp; ecx, 1					; increment counter for array size<br />	;<br />	mov&nbsp; &nbsp; eax, moreinputs			; move inputs prompt for printing<br />	call&nbsp;  print_string				; print inputs prompt<br />	call&nbsp;  read_int				;<br />	cmp&nbsp; &nbsp; eax, 1					; 8-bit comparison, if equal then zf = 1, otherwise zf =0<br />	je&nbsp; &nbsp;  beginloop				; jump to start of loop if zf = 1<br />	;<br />endif:<br /><br />mov&nbsp; &nbsp; , ecx				; copy counter into stack where size is.<br /><br />popa<br />ret<br />;==== End of Subprogram get_array ====<br /><br /><br />;=== Subprogram liner_search ===<br />linear_search:<br /><br />segment .data<br /><br />outof db&nbsp;  &quot;Got out of loop&quot;, 0<br />notf db&nbsp; &nbsp; &quot;Got to not_found&quot;, 0<br /><br />segment .bss<br /><br />segment .text<br />push&nbsp;  ebp						; push all registers onto stack<br />mov&nbsp; &nbsp; ebp, esp					; copy esp into ebp to hold place on stack<br />push&nbsp;  ebx<br />push&nbsp;  ecx<br /><br />mov&nbsp; &nbsp; ebx, 					; copy start address of array into ebx<br />mov&nbsp; &nbsp; ecx, 				; copy size of array into ecx<br />mov&nbsp; &nbsp; eax, 				; copy dw to be found into edx<br />sub&nbsp; &nbsp; ebx, 4						; setupd array pointer to enter loop<br /><br />search_loop:<br />&nbsp;  add&nbsp; &nbsp; ebx, 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; increment array pointer to next slot<br />&nbsp;  cmp&nbsp; &nbsp; eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compare value to be found with value in array<br />&nbsp;  loopne search_loop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return to beginning of loop if not equal and ecx!=0<br />&nbsp;  cmp&nbsp; &nbsp; eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compare value to be found with value in array<br />&nbsp;  jne&nbsp; &nbsp; number_not_found&nbsp; &nbsp; &nbsp; &nbsp;  ; jump to number_not_found if eax != <br />&nbsp;  mov&nbsp; &nbsp; eax,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; move size of array to eax<br />&nbsp;  sub&nbsp; &nbsp; eax, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; compute array index of number<br />&nbsp;  mov&nbsp; &nbsp; , eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; put index in stack for main<br />&nbsp;  jmp&nbsp; &nbsp; done&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; jump to end of subprogram<br />number_not_found:<br />&nbsp;  mov&nbsp; &nbsp; eax, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; move 0 into eax to return not found value<br />&nbsp;  mov&nbsp; &nbsp; , eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; move 0 into stack for main<br />done:<br />&nbsp; 	pop&nbsp; &nbsp; ecx<br />&nbsp; 	pop&nbsp; &nbsp; ebx<br />&nbsp; 	pop&nbsp; &nbsp; ebp<br />&nbsp; 	ret<br />;==== End of subprogram linear_search</code></pre></div>
    <div class="meta">Posted on 2010-04-02 19:55:18 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211211">
    <div class="subject"><a href="#post-211211">Re: Linear Search HELP</a></div>
    <div class="body">Ah! &quot;push size1&quot; pushes the address of the variable - &quot;push dword <span style="font-size:1>&quot; pushes the contents. Looping the address number of times will segfault, yep!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-04-02 20:41:44 by fbkotler</div>
   </div>
   <div class="post" id="post-211212">
    <div class="subject"><a href="#post-211212">Re: Linear Search HELP</a></div>
    <div class="body">WOW! It works!<br />I can&#039;t believe such a little thing could cause me so much grief!<br /><br />Thanks so much!</div>
    <div class="meta">Posted on 2010-04-02 20:49:30 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211213">
    <div class="subject"><a href="#post-211213">Re: Linear Search HELP</a></div>
    <div class="body"><div class="quote"><br />I can&#039;t believe such a little thing could cause me so much grief!<br /></div><br /><br />Welcome to assembly programming :)</div>
    <div class="meta">Posted on 2010-04-03 07:46:22 by Scali</div>
   </div>
  </div>
 </body>
</html>