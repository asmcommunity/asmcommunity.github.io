<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Premature Design is the root of all evil - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30600" />
    <link rel="next" href="../?id=30600&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=30600">Premature Design is the root of all evil</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30600&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30600&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30600" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30600&amp;page=2">&gt;</a><a href="../?id=30600&amp;page=2">&raquo;</a></form>   <div class="post" id="post-214655">
    <div class="subject"><a href="#post-214655">Premature Design is the root of all evil</a></div>
    <div class="body">As some of you may know, I occasionally blog about various software-related things.<br />This time I&#039;ve written something about how the &#039;new generation&#039; has a tendency to overdesign/overengineer, without bothering to look at the technical details first...<br />Thought I might share it here, some of you may be interested.<br />http://scalibq.wordpress.com/2011/07/20/premature-design-is-the-root-of-all-evil/</div>
    <div class="meta">Posted on 2011-07-20 06:38:43 by Scali</div>
   </div>
   <div class="post" id="post-214656">
    <div class="subject"><a href="#post-214656">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Added to my feeds - will skim through it during lunches :)</div>
    <div class="meta">Posted on 2011-07-20 11:03:43 by JimmyClif</div>
   </div>
   <div class="post" id="post-214657">
    <div class="subject"><a href="#post-214657">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Reminiscent of the idea of an emergent architecture? Nice blog post. </div>
    <div class="meta">Posted on 2011-07-20 11:21:14 by michaelg</div>
   </div>
   <div class="post" id="post-214658">
    <div class="subject"><a href="#post-214658">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Nicely written blog post, Scali.&nbsp; I think a good summation might be: &quot;experience is the best teacher&quot;.</div>
    <div class="meta">Posted on 2011-07-20 11:43:15 by p1ranha</div>
   </div>
   <div class="post" id="post-214659">
    <div class="subject"><a href="#post-214659">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />Nicely written blog post, Scali.&nbsp; I think a good summation might be: &quot;experience is the best teacher&quot;.<br /></div><br /><br />Thanks... personally I&#039;d lean more towards &#039;history&#039; rather than &#039;experience&#039;.<br />I mean, yes I have learnt a lot of things through experience... but then I found out that smart people have learnt these things long before I did, and wrote about it.<br />I quote two articles, one from 1974, and one from 1986. So what I&#039;m saying is not new in any way. It&#039;s just that this knowledge seems to be &#039;in limbo&#039;, so I try to bring it under the attention of the younger generation, so they don&#039;t HAVE to learn the hard way, through many years of experience.<br /><br />I haven&#039;t really put a conclusion/summation at the end of the blog yet... I think I will add one that says something like this.</div>
    <div class="meta">Posted on 2011-07-20 12:10:30 by Scali</div>
   </div>
   <div class="post" id="post-214660">
    <div class="subject"><a href="#post-214660">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />I always build a small prototype application first, which concentrates only on getting such core functionality working, and finding out what’s what.</div><br /><br />Most of my finished programs are &#039;prototypes&#039; which just happen to work&nbsp; :D<br /></div>
    <div class="meta">Posted on 2011-07-20 12:15:01 by JimmyClif</div>
   </div>
   <div class="post" id="post-214661">
    <div class="subject"><a href="#post-214661">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />I haven&#039;t really put a conclusion/summation at the end of the blog yet... I think I will add one that says something like this.<br /></div><br /><br />I&#039;ve added an extra conclusion at the end now, trying to stress that point.</div>
    <div class="meta">Posted on 2011-07-20 15:34:19 by Scali</div>
   </div>
   <div class="post" id="post-214662">
    <div class="subject"><a href="#post-214662">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />I always build a small prototype application first, which concentrates only on getting such core functionality working, and finding out what’s what.</div><br /><br />Most of my finished programs are &#039;prototypes&#039; which just happen to work&nbsp; :D<br /></div><br /><br />Well, that&#039;s good, isn&#039;t it? The program works, and it&#039;s finished :)</div>
    <div class="meta">Posted on 2011-07-20 15:35:20 by Scali</div>
   </div>
   <div class="post" id="post-214663">
    <div class="subject"><a href="#post-214663">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Most of my finished programs are &#039;prototypes&#039; which just happen to work&nbsp; :D<br /></div><br /><br />Well, that&#039;s good, isn&#039;t it? The program works, and it&#039;s finished :)<br /></div><br /><br />Wait just one minute!&nbsp; Are you telling me there are actually finished programs?&nbsp; :shock:</div>
    <div class="meta">Posted on 2011-07-20 16:31:40 by p1ranha</div>
   </div>
   <div class="post" id="post-214664">
    <div class="subject"><a href="#post-214664">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />Wait just one minute!&nbsp; Are you telling me there are actually finished programs?&nbsp; :shock:<br /></div><br /><br />Finished, abandoned... glass is half-full or half-empty... :P</div>
    <div class="meta">Posted on 2011-07-20 17:15:36 by Scali</div>
   </div>
   <div class="post" id="post-214677">
    <div class="subject"><a href="#post-214677">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Tom-eih-toe :: Tom-aah-toe - START: My programs work fine until they crash, then I&#039;ll fix them and GOTO START <br /><br />Thank goodness I&#039;m not paid for programming - for the payee or the payer :)<br /><br />Anyway, just wanted to let you know that I haven&#039;t had such a great time reading a blog in a very long time. The Jed Smith discussion and related posts are pure gold. :thumbsup:</div>
    <div class="meta">Posted on 2011-07-22 07:22:59 by JimmyClif</div>
   </div>
   <div class="post" id="post-214679">
    <div class="subject"><a href="#post-214679">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />Anyway, just wanted to let you know that I haven&#039;t had such a great time reading a blog in a very long time. The Jed Smith discussion and related posts are pure gold. :thumbsup:<br /></div><br /><br />Yea, I think I let him get off easy there... perhaps I should do another blog follow-up on him soon :)<br />The irony is that I don&#039;t exactly consider myself an expert on security, it&#039;s not even a subject I&#039;m interested in at all, I mostly just learnt about security as and when encountered during whatever programming it is that I was doing at the time. For Windows-programmers it&#039;s pretty obvious: SECURITY_ATTRIBUTES are all over the Win32API (so why doesn&#039;t he know about them?).<br /><br />I&#039;m also waiting for AMD to finally release that Bulldozer of theirs, because I still need to do a follow-up on this post:<br />http://scalibq.wordpress.com/2010/08/31/john-fruehe-amd%e2%80%99s-latest-and-greatest-liar/</div>
    <div class="meta">Posted on 2011-07-22 11:11:31 by Scali</div>
   </div>
   <div class="post" id="post-214683">
    <div class="subject"><a href="#post-214683">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />I&#039;m also waiting for AMD to finally release that Bulldozer of theirs, because I still need to do a follow-up on this post:<br />http://scalibq.wordpress.com/2010/08/31/john-fruehe-amd%e2%80%99s-latest-and-greatest-liar/<br /></div><br /><br />Heh, what a coincidence, just saw this: http://www.brightsideofnews.com/news/2011/7/22/amd-lowers-performance-projections-for-bulldozer-opteron.aspx<br />I guess AMD agrees: John Fruehe was talking smack.<br />This site also points to a Fruehe-blog stating these lies. Told you so :)</div>
    <div class="meta">Posted on 2011-07-23 08:08:30 by Scali</div>
   </div>
   <div class="post" id="post-214685">
    <div class="subject"><a href="#post-214685">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Hey Scali, good read!<br /><br />I can&#039;t say I *totally* agree with you though. I think the design methods taught in schools now is really good, but the true evil is that as soon as these students get out of the class room, they &quot;just wing it&quot;.<br /><br />Our school used the Three-Tier programming model. If you&#039;re not familiar with it, the idea is to create reusable solutions to small problems. This is done by breaking the interface with external actors (users, other computers, or even other parts of the program) and the persistent data storage routines (SQL, CVS, Binary Formats, etc.) completely apart using&nbsp; a business tier which provides the actual solution to the interface. <br /><br /><pre><code><br />Presentation Tier &lt;-&gt; Business Tier &lt;-&gt; Persistence Tier<br /></code></pre><br /><br />What&#039;s more, this programming model is complemented by a series of design documents which controls the flow of development. For example, the use-case document provides the step by step instructions for how the interface (Persistence Tier) will be accessed by the external actors. From the use-case an event/function planning document can be created to prototype the &quot;how&quot; of the solution (Business Tier), this document comes in the form of a large table describing how each signal/event and other interface actions are handled -- usually through a final column describing a bit of English psuedo-code for the solution. This document in turn gives way for a requirements document which describes what storage/network services will be needed to solve the problem at hand (for the Persistence Tier).<br /><br />Now, after that very modular design strategy has been taught, what&#039;s the first thing novice programmers do?<br /><br /><div class="quote"><br />I don&#039;t want to have to write a bunch of documents, I just want to code!<br /></div><br /><br />Yep, that&#039;s right. They throw documentation out of the window to &quot;improve productivity&quot;. But what are they really throwing away? The use-case gives you modularity, the event/procedure planning document gives you a great place to simplify and optimize your algorithms before ever writing any code, and the requirements document builds a reusable standard for data access. And to add insult to injury, they stop designing small solutions and try to improve productivity yet again by creating an overall solution which is neither modular or optimal. Then, when the company wants said application to be updated or features added, the novice is stuck with doing some hacked fixes and trying to extend a system rather than plugging in new components through a small, modular design.<br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2011-07-23 09:04:37 by Synfire</div>
   </div>
   <div class="post" id="post-214687">
    <div class="subject"><a href="#post-214687">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />Hey Scali, good read!</div><br /><br />Thanks.<br /><br /><div class="quote"><br />I can&#039;t say I *totally* agree with you though. I think the design methods taught in schools now is really good, but the true evil is that as soon as these students get out of the class room, they &quot;just wing it&quot;.</div><br /><br />I suppose it can go either way, yes. Some will just go the &#039;textbook&#039;-way too much, where others become too &#039;creative&#039; with the design methodologies.<br /><br />My point is mostly about non-trivial code. Thing with textbook-examples is that you already know the solution beforehand. The three-tier model is nice, but when you have to start from scratch, you may not know exactly what goes where, and how the three tiers need to communicate exactly, in all areas.<br />So in such cases, you&#039;ll want to build a prototype to just experiment with the technology a bit, and figure out what makes sense.<br /><br />I mean, if you take my 3d engine for example... some things just HAVE to go someplace, since it will not work otherwise. For example, I *have* to build an input layout object at the moment I compile a vertex shader, since it is not available at any other point in time. That is just a limitation of the shader compilation model in D3D10+. I had to find that out by building a prototype first... I just built a simple app that did nothing much other than rendering a simple cube on screen. But it taught me all I needed to know about the D3D10+ pipeline.<br /><br />From then on, I could take my D3D9 design, and figure out where and how to modify it to incorporate D3D10+ as well. I did something quite similar for OpenGL, with my BHM 3D sample. I started by just building a simple prototype OpenGL app. This taught me enough about OpenGL to figure out how to build a nice object-oriented wrapper for it. It&#039;s quite similar to my D3D-engine, but some things just work differently.<br />If I had just blindly taken my &#039;textbook&#039; D3D9 design and stuck to that, it would have been very hard to incorporate D3D10+ or OpenGL in there, as the APIs just work quite differently in some ways. You&#039;d paint yourself into a corner, but you wouldn&#039;t know until it actually happened, as the D3D9-design looks good on paper... it *is* a good design, for D3D9, just not for other APIs.</div>
    <div class="meta">Posted on 2011-07-23 09:31:25 by Scali</div>
   </div>
   <div class="post" id="post-214688">
    <div class="subject"><a href="#post-214688">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Well, that&#039;s sorta what I&#039;m talking about though. The model they actually taught in school was based around small solutions. You wouldn&#039;t directly implement a solution for &quot;Game Engine&quot;, rather you would start by creating small solutions for various components of a game engine. This means that as you implement each small part, you can rapidly create test apps which make use of the solution. If as you move along you decide to swap to OpenGL from DirectX, it becomes a matter of updating the Business Tier&#039;s for each solution rather than worrying about how they are connected (the Presentation Tier would make sure that they still connected just fine).<br /><br />But like I said, you get these novices that think they can save time by trying to tackle the &quot;Game Engine&quot; directly, or maybe breaking it up into a few simple objects which describe the game engine. That&#039;s not really what most people are taught but it seems that everyone now-a-days does it.<br /><br />It is actually very similar to what you&#039;re talking about with making prototype apps to learn from first. With the 3-tier model, you simply apply a modular design to each part that you are learning so that when you&#039;re finished playing with your prototype, it can immediately go into production as long as you consistently follow the 3-tier design throughout the scope of your project.<br /><br />What <strong>I</strong> like about the 3-tier model is how it&#039;s completely changed the manner in which I design my applications. If I&#039;m going to be working on the Presentation Tier for a module, I&#039;ll work mostly on pen &amp; paper drawing flowcharts and researching possible frameworks which might make my job easier. If I&#039;m working within the Persistence Tier, I&#039;ll spend most of my time working out the data structures or SQL Queries. And when I&#039;m working within the Business Tier, I spend a lot more time on a dry erase board simplifying any algebraic or boolean logic functions. Because of the separation of each tier, I know immediately how I need to approach each part of a small problem. And usually, by the time I actually begin writing my first draft of the module and it&#039;s test app, it&#039;s already fairly close to production quality and rarely needs any additional optimizations.<br /><br />Why wouldn&#039;t it need additional optimizations? Because I&#039;ve taken my time to truly focus and understand what it is I&#039;m doing. I build the full application up in vary small steps and validate those steps as I grow the modular design into an actual application.<br /><br />I&#039;m not really big into game or graphics design, but to explain it in a more relative manner... Say you wanted to create a software based 3D graphics rendering library (let&#039;s just ignore the fact that pretty much every modern graphics card can handle this stuff for us), with the three tier design method, you would implement a modular pixelOut routine. the presentation tier would be the actual procedure call, ie pixelOut(SCREEN scr, int x, int y). The business tier would be taking that x and y and applying it to the scr bitmap. The persistence tier would be defined as the actual scr bitmap, scr might not be a bitmap, you might decide you want it to be a jpg. But that wouldn&#039;t matter to pixelOut&#039;s presentation or business tiers. Then we write a test app to &quot;prove&quot; the pixelOut works. When it works, we have our first solution. Next we tackle calculating 3d points from 2d points.. this may be done by creating a pair of procedures calcX3d(int x, int z) and calcY3d(int y, int z). You&#039;d follow the standard three tier method with those as well. As you work on each small solution, validating them is easy because you work individually with each solution, and solutions work together because the interfaces are pluggable; ie. pixelOut(calcX3d(iX, 10), calcY3d(iY, 10)); Once you get through that, you might think about implementing some kind of rotation method using precomputed cos/sin tables. Each step just fits, each part will work once plugged in because you design the interface to be reusable. Do you know or care if it&#039;s DirectX or OpenGL behind pixelOut? would it make any difference to calcX3d? Of course not! So from there on, if ever need to change from software rendering to hardware rendering, you just create abstract wrappers for the features of your 3d model that is handled by hardware and nothing else needs updating. This gets thrown out the window by those pesky newbs and rather than solving small problems, they try to solve the problem of pixelOut3DandRotate(....); :P</div>
    <div class="meta">Posted on 2011-07-23 10:54:38 by Synfire</div>
   </div>
   <div class="post" id="post-214692">
    <div class="subject"><a href="#post-214692">Re: Premature Design is the root of all evil</a></div>
    <div class="body">Well, the thing about graphics is that you indeed *do* care about what API is behind it, at least to a certain extent. What that extent is exactly, that&#039;s something you can only determine once you have some hands-on experience with the API.<br />The APIs don&#039;t map 1:1. Which means that indeed you have to worry about how they are connected. For example, I used to have the vertex format declaration stored with each mesh. Makes sense, no? A mesh is where you store vertices, so that&#039;s where you store the vertex format as well.<br /><br />Well, no, apparently not. In D3D10+, there&#039;s some extra validation implemented in the API. As a result, you need to create an Input Descriptor (vertex declarations no longer exist, this is the closest object, semantically), from your compiled vertex shader. After all, the vertex shader code contains the vertex format as well.<br />So something that originally &#039;belonged to&#039; meshes, now had to be moved to the vertex shaders.</div>
    <div class="meta">Posted on 2011-07-23 12:10:05 by Scali</div>
   </div>
   <div class="post" id="post-214696">
    <div class="subject"><a href="#post-214696">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />For example, I used to have the vertex format declaration stored with each mesh. Makes sense, no? A mesh is where you store vertices, so that&#039;s where you store the vertex format as well.</div><br /><br />Actually no. Although a mesh is just a matrix of vertices, a mesh (in a 3 tier design) should be implemented in an abstract manner for support of any plotting method. Example being a Vert4f&lt;&gt; where the 4th value is time so you&#039;re not only modeling the location of the mesh but it&#039;s position on the time-line (or maybe wear imposed on the mesh). In 3 tier design; custom data types and structures should become globally visible to any part of the overall project. These data types can be extended if needed, but the basic &quot;layout&quot; as specified by your class or struct definition should be in a header that doesn&#039;t contain any module dependent references.<br /><br />In your scenario, you implemented a vertex as though it &quot;belonged to&quot; a mesh. What I would have done (using the &quot;Solve Small Problems&quot; rule) is create a module called vertex which just defines the vertex and maybe some routines to convert/access various vertex related information. The mesh would then be implemented as a new module which uses the vertex module. Then when your D3D10+ code comes along, you simply implement the vertex shader by extending the vertex module itself.</div>
    <div class="meta">Posted on 2011-07-23 19:06:49 by Synfire</div>
   </div>
   <div class="post" id="post-214698">
    <div class="subject"><a href="#post-214698">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote"><br />Actually no. Although a mesh is just a matrix of vertices, a mesh (in a 3 tier design) should be implemented in an abstract manner for support of any plotting method.</div><br /><br />But you can&#039;t do that, because you need to play by the rules of the API.<br />So you create a class Mesh, which contains the required data for the API to render a mesh. It&#039;s not really a storage class. Storage is done in lower-level classes, such as vertex buffers and index buffers, primitive descriptors etc (A mesh most certainly is NOT a matrix of vertices, at least not literally... it is an abstract representation of that).<br />A Mesh just groups all the storage classes together so you have everything you need in order to draw that mesh on the given API.<br />Technically my Mesh is abstract.. you can just draw a mesh with one call... It&#039;s just that the implementation of this draw call (and partly the mesh itself, let alone the objects it groups together) will be massively different from one API to another.<br /><br /><div class="quote">In your scenario, you implemented a vertex as though it &quot;belonged to&quot; a mesh. What I would have done (using the &quot;Solve Small Problems&quot; rule) is create a module called vertex which just defines the vertex and maybe some routines to convert/access various vertex related information.</div><br /><br />No, I didn&#039;t. A vertex is just a struct.<br />The vertex format descriptor indeed *was* a separate object (one dictated by D3D9). The thing is just that you have to store that vertex format *somewhere*, in order to describe what kind of data is in your mesh.<br />So, you store a reference of the vertex format descriptor in your mesh. After all, the mesh contains the vertex buffers. And in D3D9, the format descriptor was most closely related to the vertex buffers anyway (you could render without shaders, and then it STILL needed a format descriptor, obviously... it also had the legacy FVF flags still, which you used when creating a vertexbuffer).<br />But D3D10+ changes the rules there. Firstly, the vertexbuffer is now more abstract, just a buffer. Secondly, there&#039;s no fixed function anymore, so you HAVE to have shaders at all times. Thirdly, there&#039;s more validation built into the API at initialization time, rather than at runtime.<br /><br />So in D3D9 the API would want a vertex buffer and a vertex descriptor, before a draw call... and if you then optionally used a shader, it would automatically verify if the shader was compatible with the vertex descriptor.<br />In D3D9 you could create this vertex descriptor at any time you wanted, you just had to pass a definition, not dependent on anything.<br /><br />In D3D10+ however, you cannot create a vertex descriptor yourself. When you compile a vertex shader, you need to use the compiled bytecode (but NOT the compiled vertex shader object, not the same thing... after the shader is compiled and the shader object is created, you can discard the compiled bytecode) to create what is called an Input Layout.<br />So in the new API, you can ONLY create the input layout during shader compilation, which means the rules change significantly. It now actually &#039;belongs to&#039; the shader.<br /><br /><div class="quote"> The mesh would then be implemented as a new module which uses the vertex module. Then when your D3D10+ code comes along, you simply implement the vertex shader by extending the vertex module itself.<br /></div><br /><br />Except that D3D9 also had vertex shaders... they just worked differently from the ones in D3D10+.<br /><br />No offense, but I really don&#039;t think you understand the situation here. My point is that when using a complex API such as D3D or OpenGL, the API dictates for a large part how your application should be designed. The API tells you how your data should be formatted, and where, when and how this data should be stored, passed on etc.<br />A wrong design may significantly impact performance or memory overhead, or may even make certain things impossible to implement at all.<br /><br />Before you are able to make an engine design that can abstract away the (sometimes huge) differences between D3D9, D3D10+ and OpenGL, you first need to be quite at home with all of them, so you know WHAT to abstract. Concepts in one API may be entirely absent in another, or they may work in such a different way that it is almost impossible to abstract away the differences.<br /><br />Edit: Perhaps I need to add this, since it doesn&#039;t seem immediately obvious by just looking at the version number...<br />DirectX versions are revolutionary, not evolutionary. Generally a new version introduces new COM interfaces as well. At the very least, by definition it is an entirely new API, since all typenames are different.<br />In some cases, the difference with the previous version is not that big, and a search-and-replace will take care of 90% of the API differences (eg D3D8-&gt;D3D9, D3D10-&gt;D3D11). In other cases, the API is pretty much completely different in every way, and there&#039;s little if any similarity with the previous version (D3D9-&gt;D3D10).<br />D3D10 was completely redesigned from scratch. So you can&#039;t just take a D3D9-codebase and &#039;update&#039; it to D3D10. The two aren&#039;t even remotely similar. The difference is about as large as going from D3D9 to OpenGL.<br /><br />Edit2: The fact that there are such differences between these APIs, which technically all run on the same hardware, already indicates that there is not just one possible design for such a system. Videocards are a moving target, the design for these APIs is partly the result of at what moment in time these APIs were designed. OpenGL was originally designed for SGI&#039;s computer systems, which were still mostly software renderers back then. It has been extended ever since, to account for new hardware acceleration features, but in general it is still the same design (on the outside).<br />Direct3D is updated at every major hardware architecture update. D3D9 dates from the first D3D9-videocards, the Radeon 9700 series. D3D10 is built around the first D3D10-videocards, the GeForce 8800 series. The hardware design is massively different, and the API design reflects that (even though the hardware and API are still designed to perform basically the same rendering operations, at a higher level).</div>
    <div class="meta">Posted on 2011-07-24 05:05:51 by Scali</div>
   </div>
   <div class="post" id="post-214701">
    <div class="subject"><a href="#post-214701">Re: Premature Design is the root of all evil</a></div>
    <div class="body"><div class="quote">A Mesh just groups all the storage classes together so you have everything you need in order to draw that mesh on the given API.<br />Technically my Mesh is abstract.. you can just draw a mesh with one call... It&#039;s just that the implementation of this draw call (and partly the mesh itself, let alone the objects it groups together) will be massively different from one API to another.</div><br /><br />Then in such a case, as I was trying to get across earlier, you implement each of those &quot;massively different&quot; parts as individual business classes which overload a generic that defines the requirements of any interface components and the outputs (if any) of the storage components.<br /><br />Maybe I&#039;m not reading you right, or maybe you&#039;re not reading me right. But that&#039;s kinda the point of the 3-Tier model. From what you just said, the business tier of your mesh varies from version to version, but as long as you use a well defined generic structure for your business tier, porting between the versions should just be a matter of rewriting the business tier and hot-plugging them as needed.<br /><br /><div class="quote">No, I didn&#039;t. A vertex is just a struct.<br />The vertex format descriptor indeed *was* a separate object (one dictated by D3D9). The thing is just that you have to store that vertex format *somewhere*, in order to describe what kind of data is in your mesh.<br />So, you store a reference of the vertex format descriptor in your mesh. After all, the mesh contains the vertex buffers. And in D3D9, the format descriptor was most closely related to the vertex buffers anyway (you could render without shaders, and then it STILL needed a format descriptor, obviously... it also had the legacy FVF flags still, which you used when creating a vertexbuffer).<br />But D3D10+ changes the rules there. Firstly, the vertexbuffer is now more abstract, just a buffer. Secondly, there&#039;s no fixed function anymore, so you HAVE to have shaders at all times. Thirdly, there&#039;s more validation built into the API at initialization time, rather than at runtime.</div><br /><br />When you start talking about &quot;stored (or transmitted) data&quot; that&#039;s a key that you are needing a persistence tier. Say for example you wanted to write a chat server. The chat server would essentially handle the inputs the same way, it would interface with your system logger or stdout in the same way, but say that a change occurs. Say that some of your users have odd firewall configurations and they can&#039;t send certain types of packets. The business tier isn&#039;t just a &quot;storage container&quot; it acts as an abstract translation tier between whatever input/output medium you are using. So you could have you clients chatting over HTTP, SSH, FTP, or even custom protocols but the business tier wouldn&#039;t care because it&#039;s still receiving the same data because the persistence tier would translate as needed.<br /><br />So I guess what I&#039;m not understanding here is why, given that you create the vertex descriptor as a separate model whose presentation tier is connected to the business persistence tier of the mesh model, you can&#039;t just update the persistence tier of the mesh model to accommodate the changes made to the internal format of the vertex descriptor.<br /><br /><div class="quote">So in D3D9 the API would want a vertex buffer and a vertex descriptor, before a draw call... and if you then optionally used a shader, it would automatically verify if the shader was compatible with the vertex descriptor.<br />In D3D9 you could create this vertex descriptor at any time you wanted, you just had to pass a definition, not dependent on anything.<br /><br />In D3D10+ however, you cannot create a vertex descriptor yourself. When you compile a vertex shader, you need to use the compiled bytecode (but NOT the compiled vertex shader object, not the same thing... after the shader is compiled and the shader object is created, you can discard the compiled bytecode) to create what is called an Input Layout.<br />So in the new API, you can ONLY create the input layout during shader compilation, which means the rules change significantly. It now actually &#039;belongs to&#039; the shader.</div><br /><br />Yeah, maybe it&#039;s my lack of game development knowledge, but is there a reason that you can&#039;t just call down to the shader from the vertex model&#039;s business view when the mesh tries to read in the vertex model? This would just be a small change to the vertex model from what I&#039;m reading.<br /><br /><div class="quote">Except that D3D9 also had vertex shaders... they just worked differently from the ones in D3D10+.</div><br /><br />The reusable models themselves change, but the connections between them stay pretty much the same unless you find your overall model to be unoptimized. I don&#039;t really see how this would be significant unless you were breaking design and using the shader model directly from within your business tier.<br /><br /><div class="quote">No offense, but I really don&#039;t think you understand the situation here.</div><br /><br />Nor do I.&nbsp; :shock:<br /><br /><div class="quote">My point is that when using a complex API such as D3D or OpenGL, the API dictates for a large part how your application should be designed. The API tells you how your data should be formatted, and where, when and how this data should be stored, passed on etc.<br />A wrong design may significantly impact performance or memory overhead, or may even make certain things impossible to implement at all.</div><br /><br />I very much understand that, however. The only game I&#039;ve ever done was a very simple FPS when I was working in a group in college. This was done in the 3-tier design using OpenGL, so I know for a fact that OpenGL can be easily adapted into a 3-tier model. Adversely, the largest corporation to be supporting the 3-tier model as a replacement for MVC is, well.. Microsoft. In fact, I&#039;d be hard pressed to believe that they didn&#039;t use their favorite <a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms685068%28v=vs.85%29.aspx">3-Tier model (COM+)</a> in the design of DirectX itself.<br /><br /><div class="quote">Before you are able to make an engine design that can abstract away the (sometimes huge) differences between D3D9, D3D10+ and OpenGL, you first need to be quite at home with all of them, so you know WHAT to abstract. Concepts in one API may be entirely absent in another, or they may work in such a different way that it is almost impossible to abstract away the differences.</div><br /><br />Amen to that. I&#039;m not saying that 3-tier architectures (a collection of interconnected 3-tier models) never has to be redesigned. The idea is that they RARELY have to be changed. Changing one node in the architecture, unless an extreme case occurs, rarely has any affect on the other nodes because the other nodes are designed to use only a specific part of the other nodes and it&#039;s the responsibility of the other node to provide them as such. If you do have to change the architecture itself, it means your overall design was flawed (or poorly implemented) to begin with. That&#039;s why it&#039;s so important to continue doing all those tedious documents that the newbs think are pointless. it prevents architecture redesign.<br /><br /><div class="quote">Edit: Perhaps I need to add this, since it doesn&#039;t seem immediately obvious by just looking at the version number...<br />DirectX versions are revolutionary, not evolutionary. Generally a new version introduces new COM interfaces as well. At the very least, by definition it is an entirely new API, since all typenames are different.<br />In some cases, the difference with the previous version is not that big, and a search-and-replace will take care of 90% of the API differences (eg D3D8-&gt;D3D9, D3D10-&gt;D3D11). In other cases, the API is pretty much completely different in every way, and there&#039;s little if any similarity with the previous version (D3D9-&gt;D3D10).<br />D3D10 was completely redesigned from scratch. So you can&#039;t just take a D3D9-codebase and &#039;update&#039; it to D3D10. The two aren&#039;t even remotely similar. The difference is about as large as going from D3D9 to OpenGL.</div><br /><br />Ah, so it does use Microsoft&#039;s 3-tier model. It might be possible, just a shot in the dark here, that D3D9 wasn&#039;t built using the 3-tier design style which is why Microsoft did a floor up redesign.<br /><br /><div class="quote">Edit2: The fact that there are such differences between these APIs, which technically all run on the same hardware, already indicates that there is not just one possible design for such a system. Videocards are a moving target, the design for these APIs is partly the result of at what moment in time these APIs were designed. OpenGL was originally designed for SGI&#039;s computer systems, which were still mostly software renderers back then. It has been extended ever since, to account for new hardware acceleration features, but in general it is still the same design (on the outside).<br />Direct3D is updated at every major hardware architecture update. D3D9 dates from the first D3D9-videocards, the Radeon 9700 series. D3D10 is built around the first D3D10-videocards, the GeForce 8800 series. The hardware design is massively different, and the API design reflects that (even though the hardware and API are still designed to perform basically the same rendering operations, at a higher level).</div><br /><br />Again, the point of the 3-tier design is to make individual solutions to each of these differences in a way that they interconnect together in a seamless fashion which doesn&#039;t disturb the other models in the architecture.</div>
    <div class="meta">Posted on 2011-07-24 13:26:21 by Synfire</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30600&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30600&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30600" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30600&amp;page=2">&gt;</a><a href="../?id=30600&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>