<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Terrain Revisited - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28760" />
  <link rel="prev" href="../?id=28760&amp;page=2" />  <link rel="next" href="../?id=28760&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28760">Terrain Revisited</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=28760&amp;page=1" style="">&laquo;</a><a href="../?id=28760&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="28760" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=28760&amp;page=4">&gt;</a><a href="../?id=28760&amp;page=4">&raquo;</a></form>   <div class="post" id="post-203540">
    <div class="subject"><a href="#post-203540">Re: Terrain Revisited</a></div>
    <div class="body">Everything is going well so far.<br /><br />I&#039;ve redesigned my TerrainPatch object to recursively construct a full-depth QuadTree (of indexed trifans or whatever other geometry we choose to spew), calculate the error metrics at the leaves, and propagate the error metrics back through the tree as we return from the recursion.<br />By full-depth, I mean that recursion only terminates when the (pixelspace) distance between two heightmap sample points (of a quad) is less than one pixel (on BOTH AXES)... ie, we ran out of sample resolution, if we &#039;zoom in&#039; any further, we will not see any new data, just interpolation of our data as taken at full resolution.<br /><br />Problem with D3DXComputeNormalMap.<br />It generates the Normals yes, and we already know that they are encoded as three Signed Bytes (-127 - +128) but they are defined in TEXTURE SPACE (sometimes called Tangent Space).<br /><br />I need to convert them back into WorldSpace, or else perform all Normal calculations in Tangent Space.<br />One solution requires a transform matrix, the other requires the inverse of that matrix.<br />Until I figure out how to make that matrix, I&#039;m screwed.<br /><br />http://www.gamasutra.com/view/feature/1515/messing_with_tangent_space.php?page=2<br /><br /></div>
    <div class="meta">Posted on 2007-11-09 23:33:32 by Homer</div>
   </div>
   <div class="post" id="post-203541">
    <div class="subject"><a href="#post-203541">Re: Terrain Revisited</a></div>
    <div class="body">It looks prohibitively expensive to convert UVW to XYZ !!!<br />I mean really REALLy expensive.<br />Several times what it would cost to use the old trusted method (calculate surfacenormals then average those face-shared values to find the vertexnormals).<br /><br />Alternatively, I could come up with my own solution.<br />I could, for examle, do this:<br />For each heightmap sample point, calculate the sum of the vectors from that point to four (or eight) neighbour sample points (wrapping as needed).<br />If we can calculate the &#039;unit stepovers&#039; required to step along the resulting vector, then we have our WorldSpace VertexNormal.<br /><br />Or is there an easy and quick way to convert those pesky normalmap values?<br /><br /><br /></div>
    <div class="meta">Posted on 2007-11-10 02:44:09 by Homer</div>
   </div>
   <div class="post" id="post-203542">
    <div class="subject"><a href="#post-203542">Re: Terrain Revisited</a></div>
    <div class="body">I haven&#039;t played with texture matrices, but isn&#039;t it possible to suply the same matrix for boththe world/view tranfsformation (so that vrtices get transformed) and texture transformation (so the normal maps get transformed) ?</div>
    <div class="meta">Posted on 2007-11-10 04:28:36 by ti_mo_n</div>
   </div>
   <div class="post" id="post-203544">
    <div class="subject"><a href="#post-203544">Re: Terrain Revisited</a></div>
    <div class="body">No.<br />Lets be clear.<br />We have many SPACES which are different Coordinate Systems.<br /><br />Texture Space... &quot;face space&quot;.<br />Object Space... obvious<br />View Space... &quot;camera space with depth of view, orientation, and position&quot;<br />Projection Space... &quot;camera space in bindpose, with depth of view&quot;<br />World Space... &quot;absolute space&quot;<br /><br />And theres others I have used, such as Barycentric Space... but back to the point.<br /><br />When we talk about moving stuff from one Space to another, we&#039;re talking about transforming it from one Coordinate System to another... usually using a Matrix.<br /><br />The combined World, Projection and View matrices will get you into Camera space... see the above list.<br />Transformations are non commutative, so we cant just use world*view, or else we have no depth of view.. our camera lens is flat and has no focus.<br />We need to include projection matrix.<br />But anyway, that just gets us to Camera space, when we still need to get into &#039;face space&#039; or &#039;face plane space&#039; if that makes it sound nicer.<br />We are at least two matrices away from our goal, and it gets worse.<br />We need to find one matrix to calculate the face normal, and then split it into separate matrices for each vertex on that face !!!<br />Other solutions to this involve finding the surfacenormal of the face using two edges then doing some other junk... Sigh!<br /><br />Look , Texture Space is great for Pixel Shaders and such, but its not a whole lot of use to us cpu coders unless we move all our other stuff into texture space as well.<br /><br />That requires a matrix.<br /><br />Moving stuff from worldspace to texturespace or back requires a compound matrix which in one MatrixMultiply uses a different matrix per vertex per face.<br /><br />Ouch.<br /><br />This geometry is regular and we can find neighbours easily at any LOD.<br />I think its cheaper just to calculate all the darned facenormals and then find the vertexnormals in the usual way.<br /><br />What we need to do:<br />At the leaves of our tree, discern triangles.<br />Calculate their facenormals.<br />Calculate each vertex normal = the average of the the normals of the faces it shares. For a regular geometry, its not hard.<br /><br />We only need to do it at the leaves because we only want the normals for lowest-level calculation of error metric, to be handed back up the tree.<br />We do NOT need to store Planes inside our Nodes of our Tree at any place.<br />It might be nice, but not needed.<br /><br /></div>
    <div class="meta">Posted on 2007-11-10 06:42:04 by Homer</div>
   </div>
   <div class="post" id="post-203561">
    <div class="subject"><a href="#post-203561">Re: Terrain Revisited</a></div>
    <div class="body">I was almost right about the matrix-per-vertex-per-face claim.<br />It turns out that since all three vertices of a Triangle are coplanar, they can use the same matrix.<br />So for Triangles, we need one matrix per plane.<br />But for more complex geometries, even just quads, we need to calculate one matrix per vertex, since we cant be sure that the vertices are coplanar in worldspace.<br /><br />So without further ado, here&#039;s what it costs us to build one such matrix:<br /><br />2 Additions<br />27 Subtractions<br />51 Multiplications<br />1 Division<br />==<br />81 unavoidable operations <br /><br />Like I said, it costs a whole lot more than finding vertexnormals from facenormals does.<br />Now, thats JUST to calculate a matrix, not to Apply it to transform vertices.<br /><br />The cost to find the Surface Normal of a Triangle is:<br />2 adds<br />9 subs<br />9 muls<br />3 divs<br />1 sqrt<br />=====<br />24 unavoidable operations<br /><br />To find vertex normals, we need to perform another 9 adds and 3 divides per vertex = 36 more operations per triangle..<br />====<br />60 unavoidable operations per triangle, in total.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-11-10 18:51:49 by Homer</div>
   </div>
   <div class="post" id="post-203564">
    <div class="subject"><a href="#post-203564">Re: Terrain Revisited</a></div>
    <div class="body">Now that I am thinking about calculating accurate worldspace normals based on surfacenormals taken at the unit-triangle LOD, my recursive tree builder no longer works for me.<br />It becomes a chore to access the data for geometry for neighbours at the same LOD in different tree branches.<br /><br />It makes sense to rewrite that code once more.<br />This time, we start at the Leaves of the tree, by sampling the heightmap at the unit level, and build the tree in reverse.<br />Now, we can access all of the data at the deepest level within the same iteration of the function :)<br /><br /></div>
    <div class="meta">Posted on 2007-11-10 22:37:46 by Homer</div>
   </div>
   <div class="post" id="post-203565">
    <div class="subject"><a href="#post-203565">Re: Terrain Revisited</a></div>
    <div class="body">I&#039;ve decided to leave my code alone and deal with the calculation of my normalmap separately.<br />My normalmap starts out full of zeroes...<br />As soon as the Heightmap is loaded, I will process heightmap pixels in a loop..<br /><br />At each step, four pixels will be considered.<br />From these, a theoretical Quad of two triangles is imagined.<br />For each triangle, the surfacenormal is calculated, we then add that normal value to whats stored in the same three array positions IN THE NORMALMAP... yes, same normal, stored in all three places.<br />We do the same for the other triangle as well.<br />Now we flip the split line on our imaginary quad, and repeat those steps... doing this we improve our result by a factor of four - its as if we have used all 4 triangles of a trifan :)<br />Now we&#039;re done with this Quad, we increment our pixel-stepping loop, lather, rinse and repeat.<br /><br />Finally, when we&#039;ve run out of fresh pixels, our NormalMap contains vectors which are the Sum of the SurfaceNormals of all Faces sharing each Vertex... they are vector sums, we need to Normalize them.<br />Having done that, we have a vast array of farm fresh terrain vertex normals at maximum resolution - and it doesn&#039;t affect the existing code :)<br /><br />I did look into gpu-accelerated terrain deformation schemes such as parallax occlusion mapping, but I cant see how any of them work with collision detection so I am giving them a miss for now.<br /><br />It would have been nice if Microsoft had included WORLDSPACE in the flags for D3DXComputeNormalMap.<br />Anyhow, time to put my coding hat on and write the new NormalMap generator function.<br /><br /></div>
    <div class="meta">Posted on 2007-11-11 08:44:55 by Homer</div>
   </div>
   <div class="post" id="post-203599">
    <div class="subject"><a href="#post-203599">Re: Terrain Revisited</a></div>
    <div class="body">It&#039;s been a few days since I last posted.<br />I&#039;ve implemented the idea I mentioned last time...<br /><br />Here is my code for calculating a very accurate map of vertex normals for a heightmapped surface.<br />The algorithm I&#039;ve used reduces the potential number of pixel lookups substantially, eliminating much oversampling and resulting in a nice fat speedup... sure, theres more room to optimize this code, my point is that optimizing the ALGO is most often more worthwhile than optimizing the code.<br />The resolution of the heightmap is arbitrary, and defines the bounds of the array of normals produced.... that is to say, a Normal is produced for each Pixel of heightmap information.<br />I have not included a function called SurfaceNormal which returns a surfacenormal for a triangle given as three points in 3D space... however I have posted that in the past.<br /><br />This code is unproven, but I have fed it various test data and looked at the normals it produces, and they seem sane at first glance.<br />Also, I&#039;ve tried with and without the &#039;divide by n&#039;, and as I suspected, it made no difference, since Normalizing a vector-sum is eqiivalent to Averaging those input normals :)<br /><br /><pre><code><br />Allocate and calculate an array of worldspace Normals for the theoretical<br />;vertices resting on the terrain surface based on the heightmap at max. resolution:<br />;Forge theoretical triangles between groups of 4 heightmap texels, and produce<br />;several surface normals, and Sum those normals for each participating heightmap texel.<br />;NOTE:<br />;This proc assumes that your HeightMap is loaded into a DXPixelmap object.<br />;Input Params:<br />;WorldSize is the axial UNSIGNED size of the entire world, as a 32bit float.<br />GenerateNormalMap proc uses esi edi ebx WorldSize:real4<br />LOCAL xEnd,yEnd				;Loop control variables<br />LOCAL xCur,yCur<br />LOCAL vex1:D3DXVECTOR3		;Four theoretical vertex positions on the terrain surface<br />LOCAL vex2:D3DXVECTOR3<br />LOCAL vex3:D3DXVECTOR3<br />LOCAL vex4:D3DXVECTOR3<br />LOCAL vOut1:D3DXVECTOR3		;Four theoretical surface normals from four theoretical triangles<br />LOCAL vOut2:D3DXVECTOR3<br />LOCAL vOut3:D3DXVECTOR3<br />LOCAL vOut4:D3DXVECTOR3<br />LOCAL ptrA,ptrB,ptrC,ptrD	;Four normal-array element pointers associated with &#039;vex&#039;<br /><br />	;Create an Array to hold our Normals<br />	mov g_NormalMap,$New(Array,Init,0,sizeof D3DXVECTOR3)<br />	;The array needs two Dimensions (Width, Height taken from HeightMap)<br />	mov edx,g_HeightMap<br />	OCall g_NormalMap::Array.DimAppend,.DXPixelmap.dWidth,ARR_MEMZERO<br />	mov edx,g_HeightMap<br />	OCall g_NormalMap::Array.DimAppend,.DXPixelmap.dHeight,ARR_MEMZERO	<br />	<br />	mov edi,g_HeightMap<br />	mov eax,.DXPixelmap.dHeight<br />	dec eax			;dont process last line in Y<br />	mov yEnd,eax<br />	mov eax,.DXPixelmap.dWidth<br />	mov xEnd,eax<br />	<br />	xor ecx,ecx<br />	.while ecx&lt;yEnd<br />		push ecx<br />		mov yCur,ecx<br /><br />		xor ecx,ecx<br />		.while ecx&lt;xEnd<br />			push ecx<br />			mov xCur,ecx<br />			<br />			DbgDec xCur<br />			DbgDec yCur<br />			<br />			;Obtain ptrs to array elements at (X,Y) and (X,Y+1)			<br />			mov ptrA,$OCall (g_NormalMap::Array.ItemPtr,xCur,yCur)<br />			mov eax,yCur<br />			inc eax			<br />			mov ptrB,$OCall (g_NormalMap::Array.ItemPtr,xCur,eax)<br />			<br />			;Calculate Vertex at (X,Y)<br />			OCall g_HeightMap::DXPixelmap.GetPixel,xCur,yCur<br />			shr eax,8<br />			and eax,255<br />			fildReg eax<br />			fmul WorldSize<br />			mov edx,255		;Heightmap samples are Bytes (0 to 255)<br />			fildReg edx<br />			fdiv<br />			fstp vex1.y<br />			;<br />			fild xCur		;Vertex XZ coords are Scaled by WorldSize<br />			fmul WorldSize	;and Biased by Half WorldSize<br />			fild xEnd<br />			fld1<br />			fsub<br />			fdiv<br />			fld WorldSize<br />			fmul r4_half<br />			fsub<br />			fstp vex1.x	<br /><br />			;<br />			fild yCur<br />			fmul WorldSize<br />			fidiv yEnd<br />			fld WorldSize<br />			fmul r4_half<br />			fsub<br />			fstp vex1.z			<br />			<br />			;Calculate Vertex at (X,Y+1)<br />			mov eax,yCur<br />			inc eax<br />			OCall g_HeightMap::DXPixelmap.GetPixel,xCur,eax<br />			shr eax,8<br />			and eax,255<br />			fildReg eax<br />			fmul WorldSize<br />			mov edx,255<br />			fildReg edx<br />			fdiv<br />			fstp vex2.y<br />			;<br />			fild xCur<br />			fmul WorldSize<br />			fild xEnd<br />			fld1<br />			fsub<br />			fdiv<br />			fld WorldSize<br />			fmul r4_half<br />			fsub<br />			fstp vex2.x<br /><br /><br />			;<br />			fild yCur<br />			fld1<br />			fadd <br />			fmul WorldSize<br />			fidiv yEnd<br />			fld WorldSize<br />			fmul r4_half<br />			fsub<br />			fstp vex2.z<br />			<br />		<br />			pop ecx<br />			push ecx<br />			.if ecx==0<br />				;dont do anything first iteration<br />				;we need 4 vertices, we only have 2				<br /><br />			.else<br />				DbgVec3 vex1<br />				DbgVec3 vex2<br />				DbgVec3 vex3<br />				DbgVec3 vex4<br />				;subsequent iteration : calculate surfacenormals<br />				;The leftmost (previous) two pixels are stored in vex3 and vex4<br />				;The rightmost (current) two pixels are stored in vex1 and vex2<br />				;3 1<br />				;4 2	<br />				invoke SurfaceNormal,addr vOut1,addr vex3,addr vex4,addr vex2			<br />				invoke SurfaceNormal,addr vOut2,addr vex3,addr vex2,addr vex1	<br />				invoke SurfaceNormal,addr vOut3,addr vex3,addr vex4,addr vex1<br />				invoke SurfaceNormal,addr vOut4,addr vex1,addr vex4,addr vex2<br />			;	DbgVec3 vOut4,,&quot;Surface Normal 4 of 4&quot;<br />								<br />				;We can simply sum the four resulting surfacenormals		<br />				fld&nbsp; vOut1.x<br />				fadd vOut2.x<br />				fadd vOut3.x<br />				fadd vOut4.x<br />				fstp vOut1.x<br />				fld&nbsp; vOut1.y<br />				fadd vOut2.y<br />				fadd vOut3.y<br />				fadd vOut4.y<br />				fstp vOut1.y<br />				fld&nbsp; vOut1.z<br />				fadd vOut2.z<br />				fadd vOut3.z<br />				fadd vOut4.z<br />				fstp vOut1.z<br />				;DbgVec3 vOut1,,&quot;Sum of 4 Surface Normals&quot;<br />				<br />				;and add the resulting vector to the array of vector sums<br />				;at the same places as the four input pixels<br />				mov eax,ptrA<br />				mov ebx,ptrB<br />				mov ecx,ptrC<br />				mov edx,ptrD<br />				fld vOut1.x<br />				fadd .D3DXVECTOR3.x<br />				fstp .D3DXVECTOR3.x<br />				fld vOut1.x<br />				fadd .D3DXVECTOR3.x<br />				fstp .D3DXVECTOR3.x<br />				fld vOut1.x<br />				fadd .D3DXVECTOR3.x<br />				fstp .D3DXVECTOR3.x<br />				fld vOut1.x<br />				fadd .D3DXVECTOR3.x<br />			;	fdiv r4_4<br />				fstp .D3DXVECTOR3.x<br />				<br />				fld vOut1.y<br />				fadd .D3DXVECTOR3.y<br />				fstp .D3DXVECTOR3.y<br />				fld vOut1.y<br />				fadd .D3DXVECTOR3.y<br />				fstp .D3DXVECTOR3.y<br />				fld vOut1.y<br />				fadd .D3DXVECTOR3.y<br />				fstp .D3DXVECTOR3.y<br />				fld vOut1.y<br />				fadd .D3DXVECTOR3.y<br />			;	fdiv r4_4<br />				fstp .D3DXVECTOR3.y<br />				<br />				fld vOut1.z<br />				fadd .D3DXVECTOR3.z<br />				fstp .D3DXVECTOR3.z<br />				fld vOut1.z<br />				fadd .D3DXVECTOR3.z<br />				fstp .D3DXVECTOR3.z<br />				fld vOut1.z<br />				fadd .D3DXVECTOR3.z<br />				fstp .D3DXVECTOR3.z<br />				fld vOut1.z<br />				fadd .D3DXVECTOR3.z<br />			;	fdiv r4_4<br />				fstp .D3DXVECTOR3.z<br /><br />			.endif<br /><br />			;shadow-buffer the last 2 pixel-vertices we fetched<br />			m2m vex3.x,vex1.x<br />			m2m vex3.y,vex1.y<br />			m2m vex3.z,vex1.z<br />			m2m vex4.x,vex2.x<br />			m2m vex4.y,vex2.y<br />			m2m vex4.z,vex2.z<br />			;and pointers to the destination vector-sum array elements<br />			m2m ptrC,ptrA<br />			m2m ptrD,ptrB<br />			<br />			pop ecx<br />			inc ecx<br />		.endw<br />		<br />		pop ecx<br />		inc ecx<br />	.endw<br />	<br />	;Finally, we need to Normalize each and every vector-sum in our Array<br />	xor ecx,ecx<br />	.while ecx&lt;yEnd<br />		push ecx<br />		mov yCur,ecx<br />		xor ecx,ecx<br />		.while ecx&lt;xEnd<br />			push ecx<br />			OCall g_NormalMap::Array.ItemPtr,ecx,yCur<br />			push eax<br />			invoke D3DXVec3Normalize,eax,eax<br />			pop eax<br />			DbgVec3 eax,,&quot;Terrain Normal&quot;<br />			pop ecx<br />			inc ecx<br />		.endw<br />		pop ecx<br />		inc ecx<br />	.endw	<br />	ret<br />GenerateNormalMap endp<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2007-11-15 09:09:04 by Homer</div>
   </div>
   <div class="post" id="post-203600">
    <div class="subject"><a href="#post-203600">Re: Terrain Revisited</a></div>
    <div class="body">I am concerned that you might think that there are &quot;accurate&quot; normals that can be generated from heightmap data .. heightmaps do not contain enough information for this. Generating normals from heightmap data requires an underlying assumption about the surface that the heightmap data approximates. <br /><br />Early in a project this isnt an issue because the programmer just wants normals that provide some level of smoothing for lighting calculations, so that things &quot;look better&quot; <br /><br />..but when you get into more advanced things such as physical interactions with the terrain, those underlying assumptions become very important. The various methods of generating the normals (and thusly which assumption was made) each provide a different illusion of curvature and the physical interactions should idealy coincide with that specific illusion.<br /><br />I would work from the reverse with a plan on using something like cubic interpolation for sampling the heighmap at higher resolutions for the physics, and as such would derive the normals from the gradiant of each vertex under that assumption.<br /><br /></div>
    <div class="meta">Posted on 2007-11-15 09:39:09 by Rockoon</div>
   </div>
   <div class="post" id="post-203604">
    <div class="subject"><a href="#post-203604">Re: Terrain Revisited</a></div>
    <div class="body">Thanks for your comment :)<br /><br />I have to agree with your statements and suggestions in principle.<br />But I will disagree with them for the purposes of this discourse, and in respect to this DLOD implementation.<br /><br />The fundamental premise that I am working on is that the heightmap, at full resolution, provides an array of accurate point representations of the theoretical surface, and that we will generally NOT wish to sample data at &#039;higher than max resolution&#039; ie interpolation (of any kind) between actual heightmap samples is unwarranted.<br />The heightmap in our case contains the finest representation of geometry, and we will typically be rendering with LESS than maximum resolution, effectively skipping some of our heightmap samples, and this is the important part, this is where the Error Metrics come into play.<br /><br />If we say that at maximum resolution that our heightmap data PERFECTLY represents the surface (as it would at INFINITE resolution), then we can use that as a basis to determine the amount of visual error that would be produced at any LOWER resolution. We precalculate these error values at various levels of density (resolution), and then at runtime we scale them with the viewing distance, and thus determine whether a given amount of spatial error at a given viewing distance is acceptable or not.<br />If its not acceptable, we travel further down our tree, where the leaves in our tree represent our finest level of detail (max heightmap resolution), where the error is guaranteed to be zero at ANY viewing distance.<br /><br />Attempting to interpolate further data from the heightmap beyond that point is, in my mind at least, a fundamentally flawed premise because there can be no &#039;new&#039; data, and the triangles produced will tend to become unacceptably small, which will interfere with our physics code, due to numerical accuracy of floating point operations... planar functions REQUIRE an &#039;epsilon&#039; value, ie Tolerance, which predicates the absolute minimum length of an Edge within our tesselation.<br /><br />There are many, many ways to calculate a Normal, and I am not willing to say any of them is right or wrong. The technique I have used is not new , however the algorithm I used is four times as accurate as the conventional technique, while remaining roughly twice as fast, due to A) taking many more normals into account per vertex and B) shadowing 50% of our pixel fetches.<br /><br /></div>
    <div class="meta">Posted on 2007-11-16 00:04:53 by Homer</div>
   </div>
   <div class="post" id="post-203632">
    <div class="subject"><a href="#post-203632">Re: Terrain Revisited</a></div>
    <div class="body">The attached image shows a terrain whose input heightmap was just 2x2 alternating black and white pixels, yielding &quot;two hills and two valleys&quot; .<br />The heightmap image was expanded during loading into a 12 x 12 pixel image via bilinear filtering.<br />I wanted to see how much detail I could extract from minimal input information, and without actually applying any interpolation at runtime.<br />Also, this is the first image which shows the trifan-quadtree technique in action.<br />At the moment, I am generating my tree down to the resolution of the (expanded) heightmap, and I am rendering only the Leaves, and with no culling of any kind... that is to say, the Visibility Error Metric is not yet being applied... but we can see that the tesselation is working.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2494" target="_blank">lumpy.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-11-17 13:32:45 by Homer</div>
   </div>
   <div class="post" id="post-203634">
    <div class="subject"><a href="#post-203634">Re: Terrain Revisited</a></div>
    <div class="body">I&#039;ve added a new Tool dialog to the application&#039;s Tools menu.<br />It allows you to reload the heightmap from any image file and at any resolution.<br />There are also controls for painting the terrain height directly.<br /></div>
    <div class="meta">Posted on 2007-11-17 16:56:24 by Homer</div>
   </div>
   <div class="post" id="post-203639">
    <div class="subject"><a href="#post-203639">Re: Terrain Revisited</a></div>
    <div class="body">Eye candy :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2496" target="_blank">nice.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-11-17 19:25:27 by Homer</div>
   </div>
   <div class="post" id="post-203641">
    <div class="subject"><a href="#post-203641">Re: Terrain Revisited</a></div>
    <div class="body">Looks nice, you just need textures with 10x the resolution now ;)</div>
    <div class="meta">Posted on 2007-11-17 21:46:40 by f0dder</div>
   </div>
   <div class="post" id="post-203648">
    <div class="subject"><a href="#post-203648">Re: Terrain Revisited</a></div>
    <div class="body">I can obtain 10x the resolution by mapping them 10x more.<br />The number of times textures are repeated can be chosen in the new Heightmap editing control,<br />In fact, you can choose any resolution, without changing your texture detail artwork :)<br /><br />Do note that all these renderings are in 640 x 480 mode !!</div>
    <div class="meta">Posted on 2007-11-18 04:58:44 by Homer</div>
   </div>
   <div class="post" id="post-203650">
    <div class="subject"><a href="#post-203650">Re: Terrain Revisited</a></div>
    <div class="body">I completed the render implementation in the Terrain class, so that it renders all Leaves of our quadtree using both FFPL and PixelShader techniques.<br /><br />I tested using a rather large world, not sure what tree depth.<br />For FFPL, the framerate dropped from around 850 fps to just 19 :|<br />On the bright side, that translates to a hard 367 fps in PS mode.<br />This is NOT acceptable, but its OK, because we are currently rendering FAR more triangles than we have to.<br />The further away stuff gets, the less it matters.<br />As the terrain gets further away, we accept less accurate LOD nodes in our quadtree... we draw less accurate geometry.<br /><br />It can work! We&#039;ll worry about the dreaded popping effects later !!<br /><br />Next immediate mission for me is to add a switch to allow toggle of wireframe rendering mode, so we can more clearly see the way the LOD changes with distance.<br /></div>
    <div class="meta">Posted on 2007-11-18 07:27:13 by Homer</div>
   </div>
   <div class="post" id="post-203671">
    <div class="subject"><a href="#post-203671">Re: Terrain Revisited</a></div>
    <div class="body">I have added code to toggle WireFrame rendering via the SpaceBar.<br /><br />In the attached image, you can see why (even with a relatively low heightmap resolution) the framerate has suffered so much.<br />There&#039;s a heck of a lot of triangles !<br />Less obviously, most of them are normally obscured from view, or have very small area in screenspace because they are distant from the camera, and could be replaced with less costly &#039;imposters&#039;.<br />We can consider the geometry at any level higher in the tree than &#039;Leaf&#039; depth to be such an imposter.<br /><br />My immediate goal now is to implement the Error Metrics that will allow us to decide at runtime when to draw an imposter and when we need to travel all the way to the leaves of our quadtree for fine tesselation.<br />When that is done, I will increase the Resolution of the heightmap, which will in turn generate a larger normalmap, a deeper quadtree, and a finer tesselation of the terrain (which we cannot CURRENTLY afford due to the huge cost of the CURRENT rendering code).<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2503" target="_blank">wireframe.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-11-19 00:56:16 by Homer</div>
   </div>
   <div class="post" id="post-203673">
    <div class="subject"><a href="#post-203673">Re: Terrain Revisited</a></div>
    <div class="body">The Error Metrics have been implemented, and Dynamic Level of Density (dynamic tesselation) is working :)<br /><br />Here&#039;s a screen shot that really does no justice, since you cant see whats actually happenening.<br />As you approach stuff, it &#039;breaks up&#039; into a finer mesh, and does so more quickly where required, with the &#039;flatter&#039; areas requiring a closer viewing distance before they&#039;ll &#039;split&#039;.. ie flat areas seem &#039;reluctant&#039; to split.<br /><br />What isn&#039;t obvious in this image is that the World now has some &#039;cracks&#039; that appear and disappear as you move around, which are caused by two neighbours having too great a difference in LOD.<br /><br />This image shows the problem and the fix: http://www.delphi3d.net/articles/qt_crack.gif<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2505" target="_blank">Tesselate3.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-11-19 06:43:38 by Homer</div>
   </div>
   <div class="post" id="post-203680">
    <div class="subject"><a href="#post-203680">Re: Terrain Revisited</a></div>
    <div class="body">Now would be a great time to fix those cracks I mentioned.<br />However before I do that, I&#039;d like to address something far more critical.<br /><br />Up until now I have avoided creating an actual array of vertices representing the terrain.<br />I have been storing several vertices in each node of my QuadTree instead.<br />This is very wasteful.<br />Since we know we&#039;re going to store the full set of vertices for the terrain at their finest granularity, we might as well just build a huge flat array of vertices, and use indices in our tree nodes.<br /><br />As well as being more memory efficient, a flat array means we&#039;re not stuck with recursion for its own sake.<br />It should at least make it easier for us to detect and fix T junctions :)<br /><br /></div>
    <div class="meta">Posted on 2007-11-20 01:28:58 by Homer</div>
   </div>
   <div class="post" id="post-203681">
    <div class="subject"><a href="#post-203681">Re: Terrain Revisited</a></div>
    <div class="body"><br />I&#039;ve modified my GenerateNormals procedure so that it builds a 2D array of Vertices corresponding to the Heightmap image&#039;s Pixels... well, it builds Position and Normal, but doesn&#039;t yet fill in the Texture coords.<br /><br />Anyway, now that I have access to an array of vertex data, I can eliminate a great deal of code from my recursive QuadTree building method... I can build a tree based on 2D heightmap coordinates, vastly simplifying that code.<br /><br />I still need to perform a World-Halving recursion from toplevel down, but I can do it in 2D relative to the Heightmap, and quickly find any Vertex via those 2D coords since those coords match our Vertex Array exactly.<br /><br />For some reason, it just seems unnecessarily complicated to build the Tree in reverse (from the finest level, upwards), especially when the top-down approach was already implemented, tested and proven.<br /><br /><br /></div>
    <div class="meta">Posted on 2007-11-20 02:41:22 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=28760&amp;page=1" style="">&laquo;</a><a href="../?id=28760&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="28760" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=28760&amp;page=4">&gt;</a><a href="../?id=28760&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>