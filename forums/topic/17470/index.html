<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Another FPU Register Stack Problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17470" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=17470">Another FPU Register Stack Problem</a></p>
   <div class="post" id="post-135231">
    <div class="subject"><a href="#post-135231">Another FPU Register Stack Problem</a></div>
    <div class="body">Hi Guys,<br /><br />I was working on a program that uses the FPU Reg. stack when I encountered something else that left me scratching my head.  I pushed 8 values onto the FPU reg. stack, but trying to pop them brought about some strange (to me) results.<br /><br />Please take a look at the ffg. makeshift program that illustrates:<br /><br />//----------------------------------------------------------------------------------------------------<br />Program MyProg;<br />#include(&quot;stdlib.hhf&quot;)<br /><br />procedure DisplayTOSPointer;    // Store the status-word in  and isolate only the TOS Pointer bits for display. <br />begin DisplayTOSPointer;<br />	fstsw(ax);<br />	and(%0011_1000_0000_0000, ax);<br />	shr(11, ax);<br />	stdout.put(nl, &quot;The value in TOS pointer is &quot;, ax);<br />end DisplayTOSPointer;<br /><br />static<br />	m_dFromStack: real32;<br /><br />begin MyProg;<br /><br />                // Load eight real values into each of the FPU Stack Registers.<br />	fld(7.2);<br />	fld(6.2);<br />	fld(5.2);<br />	fld(4.2);<br />	fld(3.2);<br />	fld(2.2);<br />	fld(1.2);<br />	fld(0.2);<br />	<br />                // Okay, now just pop all eight real values off the stack.<br />	stdout.put(nl, nl, &quot;Popped values:-&quot;);<br />	for(mov(0, ecx); ecx &lt; 8; inc(ecx)) do<br />		DisplayTOSPointer();<br />		fstp(m_dFromStack);<br />		stdout.put(&quot;; &quot;, m_dFromStack, &quot; was popped off the stack.&quot;);<br />	endfor;<br /><br />end MyProg;<br />//----------------------------------------------------------------------------------------------------<br /><br /><br /><br /><br /><br />When I compile and run, I get the ffg. output:<br /><br />//----------------------------------------------------------------------------------------------------<br /><br />Popped values:-<br />The value in TOS pointer is 0000;  0.000000000e+0 was popped off the stack.<br />The value in TOS pointer is 0000;  2.000000029e-1 was popped off the stack.<br />The value in TOS pointer is 0001;  1.200000047e+0 was popped off the stack.<br />The value in TOS pointer is 0002;  2.200000047e+0 was popped off the stack.<br />The value in TOS pointer is 0003;  3.200000047e+0 was popped off the stack.<br />The value in TOS pointer is 0004;  4.199999809e+0 was popped off the stack.<br />The value in TOS pointer is 0005;  5.199999809e+0 was popped off the stack.<br />The value in TOS pointer is 0006;  6.199999809e+0 was popped off the stack.<br />//-----------------------------------------------------------------------------------------------------<br /><br /><br /><br /><br />I was expecting the ffg. output:<br /><br />//-----------------------------------------------------------------------------------------------------<br /><br />The value in TOS pointer is 0000;  2.000000000e-1 was popped off the stack.<br />The value in TOS pointer is 0001;  1.200000047e+0 was popped off the stack.<br />...<br />The value in TOS pointer is 0007;  7.199999809e+0 was popped off the stack.<br />//-----------------------------------------------------------------------------------------------------<br /><br /><br />Why is the first  instruction popping off 0 instead of 0.2?<br />Why isn't the value in the TOS pointer incrementing, thereafter, to point to the second register in the stack?<br /><br /><br /><br /><br />Thanks for all your help.</div>
    <div class="meta">Posted on 2004-03-04 08:56:33 by Jaysen</div>
   </div>
   <div class="post" id="post-135242">
    <div class="subject"><a href="#post-135242">Another FPU Register Stack Problem</a></div>
    <div class="body">Whenever you use an instruction such as <strong>fld(7.2)</strong> with your assembler program, you must realize that it is NOT a standard &quot;Intel&quot; instruction. It must be an internal HLL instruction which is most probably replaced by a macro to convert the value in brackets.<br /><br />Such a macro also most probably uses the FPU to perform the conversion from alphanumeric to REAL numbers. And, to prevent any FPU &quot;stack overflow&quot;, it should free any register required (at least 2) to perform that conversion. That would explain the loss of the first value (i.e. 7.2)you loaded to the FPU.<br /><br />I would have to see the make-up of that conversion macro to properly explain the 0 for the first value you popped.<br /><br /><strong><u>You must be very careful with those HLL instructions. They can be full of nasty surprises.</u></strong><br /><br />Another surprise I got recently was to realize that several API functions in WinXP have been rewritten to use MMX/SSE instruction (which use the FPU registers) without any regard to saving/restoring data already on the FPU.<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-03-04 23:35:45 by Raymond</div>
   </div>
   <div class="post" id="post-135251">
    <div class="subject"><a href="#post-135251">Another FPU Register Stack Problem</a></div>
    <div class="body">Wow, so brilliant!<br /><br />Btw, I have briefly browsed your assembly site; a whole lot more information on the FPU as well.  I'll definately make sure I read the FPU section before I move on in AoA.<br /><br />Thanks a lot.</div>
    <div class="meta">Posted on 2004-03-05 05:01:00 by Jaysen</div>
   </div>
   <div class="post" id="post-135262">
    <div class="subject"><a href="#post-135262">Another FPU Register Stack Problem</a></div>
    <div class="body"><div class="quote"><br />Whenever you use an instruction such as <strong>fld(7.2)</strong> with your assembler program, you must realize that it is NOT a standard &quot;Intel&quot; instruction. It must be an internal HLL instruction which is most probably replaced by a macro to convert the value in brackets.<br /></div><br /><br />Actually, it's nothing sinister at all like this.  fld(7.2) gets translated into<br /><pre><code><br />fld&#40; compiler_named_memory_holding_7_2 &#41;;<br /></code></pre><br />and somewhere in the constant section it creates:<br /><pre><code><br />compiler_named_memory_holding_7_2  real80 7.2<br /></code></pre><br /><br /><div class="quote"><br />Such a macro also most probably uses the FPU to perform the conversion from alphanumeric to REAL numbers. And, to prevent any FPU &quot;stack overflow&quot;, it should free any register required (at least 2) to perform that conversion. That would explain the loss of the first value (i.e. 7.2)you loaded to the FPU.<br /></div><br /><br />Well, the compiler *does* use the FPU to do this conversion, but that's at compile-time, not at run-time.  At run time, all the program sees is an FLD instruction specifying some memory address and the IEEE representation for 7.2 contained within that memory address.<br /><br /><div class="quote"><br />I would have to see the make-up of that conversion macro to properly explain the 0 for the first value you popped.<br /></div><br /><br />I believe the above pretty much shows you what was done. <br /><br /><div class="quote"><br /><strong><u>You must be very careful with those HLL instructions. They can be full of nasty surprises.</u></strong><br /></div><br />Nothing nasty about it. It's exactly what *you'd* want to do if you needed to load a literal constant onto the FPU stack.<br /><br /><div class="quote"><br />Another surprise I got recently was to realize that several API functions in WinXP have been rewritten to use MMX/SSE instruction (which use the FPU registers) without any regard to saving/restoring data already on the FPU.<br /></div><br />????!!!!<br />Actually, the SSE instructions do not use the FPU's register set, so I assume you mean MMX only.  This would clearly be a bug in Win32 unless they've documented these effects. What functions were they?<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-03-05 16:26:01 by rhyde</div>
   </div>
   <div class="post" id="post-135263">
    <div class="subject"><a href="#post-135263">Re: Another FPU Register Stack Problem</a></div>
    <div class="body"><div class="quote"><br />Hi Guys,<br /><br /><br />Why is the first  instruction popping off 0 instead of 0.2?<br />Why isn't the value in the TOS pointer incrementing, thereafter, to point to the second register in the stack?<br /><br /><br /><br /><br />Thanks for all your help. </div><br /><br />Don't forget that the standard library routines that convert between FP format and string format need to use a few locations on the FPU stack. So what's happening here is that you push eight items on the stack, call stdout.put (which, ultimately, calls the FP-&gt;string conversion code), and that code uses the FPU for the conversion, causing a stack overflow.  IIRC, it takes two items on the stack to do an FP conversion, so if you push six items, you should be okay (actually, you can push seven, because your code pops one item off before calling stdout.put).<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-03-05 16:29:25 by rhyde</div>
   </div>
   <div class="post" id="post-135276">
    <div class="subject"><a href="#post-135276">Another FPU Register Stack Problem</a></div>
    <div class="body">randall<br /><br />Not being at all familiar with the HLL instructions of HLA, I picked the wrong one to explain the &quot;nasty&quot; :o  surprise. That's why I strongly believe in my signature.<br /><br />Thanks for clearing up which one was at fault in this case. (BTW are users made aware of this potential problem in HLA's Help files?)<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-03-06 00:23:00 by Raymond</div>
   </div>
   <div class="post" id="post-135289">
    <div class="subject"><a href="#post-135289">Another FPU Register Stack Problem</a></div>
    <div class="body"><div class="quote"><br />randall<br /><br />Not being at all familiar with the HLL instructions of HLA, I picked the wrong one to explain the &quot;nasty&quot; :o  surprise. That's why I strongly believe in my signature.<br /><br />Thanks for clearing up which one was at fault in this case. (BTW are users made aware of this potential problem in HLA's Help files?)<br /><br />Raymond </div><br /><br />Of course :-).<br />The extensions to the instruction set are always pointed out as being extensions. And the documentation certainly explains how the extensions are implemented.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-03-06 15:21:12 by rhyde</div>
   </div>
   <div class="post" id="post-135293">
    <div class="subject"><a href="#post-135293">Another FPU Register Stack Problem</a></div>
    <div class="body">Thanks for that clarification. However, IMHO, to assume that users will notice, absorb and apply such information will probably be correct much less than half the time.<br /><br />This acts as a reminder for me to modify (as soon as I can) my library of FPU functions (Fpulib) to simply avoid such nasty surprises by saving and restoring any FPU register which would be required to be emptied to perform the called function. You may want to consider similar action with your HLL instructions using the FPU.<br /><br />With all due respect for your immense contributions,<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-03-06 23:06:22 by Raymond</div>
   </div>
   <div class="post" id="post-135336">
    <div class="subject"><a href="#post-135336">Another FPU Register Stack Problem</a></div>
    <div class="body">Many thanks for clearing that up, Raymond and Randall Hyde.<br /><br />Btw, I have +/- 5 other small questions, but I'll mail them all at once in a single thread, soon.  And if you guys could take the time and trouble to, once, again come to my aid I would be forever in your debt.<br /><br />Dear Mr Hyde,<br /><br />I'm still using the beta version so I don't know if you've already updated AoA. But I also think it would be very helpful (from a student's point of view) if you could also make note/warn about the possible oversight when attempting to  use all 8 registers in HLA.<br /><br />Everything of the best, with the WinXP programming, Raymond!<br /><br />My most grateful and warmest thanks.</div>
    <div class="meta">Posted on 2004-03-08 01:12:08 by Jaysen</div>
   </div>
   <div class="post" id="post-135383">
    <div class="subject"><a href="#post-135383">Another FPU Register Stack Problem</a></div>
    <div class="body"><div class="quote"><br />Dear Mr Hyde,<br /><br />I'm still using the beta version so I don't know if you've already updated AoA. But I also think it would be very helpful (from a student's point of view) if you could also make note/warn about the possible oversight when attempting to  use all 8 registers in HLA.<br /><br />Everything of the best, with the WinXP programming, Raymond!<br /><br />My most grateful and warmest thanks. </div><br /><br />Actually, the &quot;final&quot; edition is the published edition by No Starch Press.  And in Chapter One I explicitly state &quot;The SP/ESP register pair, for example, has a very special purpose that effectively prevents you from using it for any other purpose...&quot;  I don't fully explain the problems at this point in the book (it is Chapter One, after all), but I do mention that ESP is, effectively, unusable.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-03-08 14:24:15 by rhyde</div>
   </div>
   <div class="post" id="post-135519">
    <div class="subject"><a href="#post-135519">Another FPU Register Stack Problem</a></div>
    <div class="body">jaysen, <br /><br />if you are using windows then i highly recommend downloading ollydebug; its free, its pretty and its very useful. <br /><br />debugging is time consuming, confusing, and soul destroying, ollydebug takes the edge off it. <br /><br />if you were using it then i'm sure you would have been able to work out what went wrong with your program.<br /><br />anyway, continued good luck to you sir,<br />fatray.</div>
    <div class="meta">Posted on 2004-03-09 20:42:15 by fatray</div>
   </div>
   <div class="post" id="post-135967">
    <div class="subject"><a href="#post-135967">Another FPU Register Stack Problem</a></div>
    <div class="body">Thanks Fatray,<br /><br />I'm going to download OllyDebug now...<br /><br />Kindest regards.</div>
    <div class="meta">Posted on 2004-03-15 06:22:31 by Jaysen</div>
   </div>
  </div>
 </body>
</html>