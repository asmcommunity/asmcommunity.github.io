<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>adler32 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4463" />
    <link rel="next" href="../?id=4463&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4463">adler32</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4463&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4463&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4463" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4463&amp;page=2">&gt;</a><a href="../?id=4463&amp;page=4">&raquo;</a></form>   <div class="post" id="post-31162">
    <div class="subject"><a href="#post-31162">adler32</a></div>
    <div class="body">Here's a new challenge for all the optimisation gurus here: the adler32 algorithm.<br />This is a CRC like algorithm which is for example used as checksum for a decoded ZLIB stream. The algorithm is much more simple than CRC though. The C version is:<br /><pre><code><br />#define BASE 65521 /* largest prime smaller than 65536 */<br /><br />unsigned long update_adler32&#40;unsigned long adler,unsigned char *buf, int len&#41;<br />&#123;<br />    unsigned long s1 = adler &amp; 0xffff;<br />    unsigned long s2 = &#40;adler &gt;&gt; 16&#41; &amp; 0xffff;<br />    int n;<br />    for &#40;n = 0; n &lt; len; n++&#41; <br />    &#123;<br />        s1 = &#40;s1 + buf&#91;n&#93;&#41; % BASE;<br />        s2 = &#40;s2 + s1&#41; % BASE;<br />    &#125;<br />    return &#40;s2 &lt;&lt; 16&#41; + s1;<br />&#125;<br /><br /></code></pre><br /><br />This is an update function for an adler code, which means you can feed the previous adler code and proceed with it, along with a pointer to the buffer with the data and a len parameter containing the length of the data. Initially, the adler code is 1. Example: if you want to compute the adler value of a 100 byte buffer, call:<br /><pre><code>adler = update_adler32&#40;&#91;b&#93;1&#91;/b&#93;, pointer_buffer,100&#41;;</code></pre><br />you can also do the buffer in pieces:<br /><pre><code><br />adler = update_adler32&#40;&#91;b&#93;1&#91;/b&#93;, pointer_buffer,20&#41;;<br />adler = update_adler32&#40;&#91;b&#93;adler&#91;/b&#93;, pointer_buffer + 20,30&#41;; // next 30 bytes<br />adler = update_adler32&#40;&#91;b&#93;adler&#91;/b&#93;, pointer_buffer + 50,50&#41;; // last 50 bytes<br /></code></pre><br />This code should produce the same value as the first version. Knowing this may be useful for optimizations, for example you can first process as much DWORD units as possible, and do the last bytes (len%4) seperately.<br /><br />Here's the first, not much optimized, straight-forward translation in asm:<br /><pre><code><br /> BASE equ 65521 <br />    mov     ecx, adler<br />    mov     edi, len<br />    mov     esi, buf<br />    mov     edx, ecx<br />    and     ecx, 0ffffh     ; ecx = s1<br />    xor     eax, eax<br />    add     edi, esi<br />    shr     edx, 16         ; edx = s2<br />    @next&#58;<br />        mov     al, &#91;esi&#93;<br />        add     ecx, eax        ;s1=s1+buf&#91;n&#93;<br />        cmp     ecx, BASE<br />        jb      @F<br />        sub     ecx, BASE<br />        @@&#58;<br />        add     edx, ecx<br />        inc     esi<br />        @@&#58;<br />        cmp     edx, BASE<br />        jb      @F<br />        sub     edx, BASE<br />        jmp     @B<br />        @@&#58;<br />    cmp     esi, edi<br />    jb      @next<br />    mov     eax, edx<br />    shl     eax, 16<br />    add     eax, ecx<br />    ret<br /></code></pre><br /><br />One optimisation a C compiler will probably not think of, is replacing the modulus (and thus two slow divisions) by a simple compare and one or two substractions:<br /><pre><code><br />        s1 = &#40;s1 + buf&#91;n&#93;&#41; % BASE;<br />        s2 = &#40;s2 + s1&#41; % BASE;<br /></code></pre><br />Initially, s1 is the lower word of adler, so it can only be 65535 at most. buf can be 255 at most, which gives a total of 65535 +255 = 65790. No need to divide by BASE, as it either does or doesn't fit in (0 or 1).<br />s2 goes analogous, but because s2 and s1 are added, BASE may fit in twice...<br />After these two lines, s1 and s2 will obviously be &lt; BASE so the rules described above will apply to every iteration.<br /><br />This code can probably be much more optimized, any bright ideas are welcome. I'm also wondering if it would be possible to unroll the loop, although it's not easy because the s1 and s2 values depend on their previous values..<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-27 10:49:20 by Thomas</div>
   </div>
   <div class="post" id="post-31165">
    <div class="subject"><a href="#post-31165">adler32</a></div>
    <div class="body">Could you not move the modulo outside the loop?<br /><br /><pre><code><br />&#123;<br />    unsigned long s1 = adler &amp; 0xffff;<br />    unsigned long s2 = &#40;adler &gt;&gt; 16&#41; &amp; 0xffff;<br />    int n;<br />    for &#40;n = 0; n &lt; len; n++&#41; <br />    &#123;<br />        s1 = &#40;s1 + buf&#91;n&#93;&#41;;<br />        s2 = &#40;s2 + s1&#41;;<br />    &#125;<br />    return &#40;&#40;s2 % BASE&#41; &lt;&lt; 16&#41; + &#40;s1 % BASE&#41;;<br />&#125;<br /></code></pre><br /><br />Mirno</div>
    <div class="meta">Posted on 2002-03-27 11:14:04 by Mirno</div>
   </div>
   <div class="post" id="post-31168">
    <div class="subject"><a href="#post-31168">adler32</a></div>
    <div class="body">I thought about that but I don't think it will work as eventually s1 or s2 will become bigger than 2^32-1 and overflow... For small data sets it will probably work.. I'll test it on a big one.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-27 11:45:55 by Thomas</div>
   </div>
   <div class="post" id="post-31175">
    <div class="subject"><a href="#post-31175">adler32</a></div>
    <div class="body">You can unroll the loop though, here's the math that proves the formulas used:<br /><pre><code><br />---------------<br />unroll&#58;<br />    s1 = &#40;s1 + buf&#91;n+0&#93;&#41;<br />    s2 = &#40;s2 + s1&#41;<br />    <br />    s1 = &#40;s1 + buf&#91;n+1&#93;&#41;<br />    s2 = &#40;s2 + s1&#41;<br />    <br />    s1 = &#40;s1 + buf&#91;n+2&#93;&#41;<br />    s2 = &#40;s2 + s1&#41;<br />    <br />    s1 = &#40;s1 + buf&#91;n+3&#93;&#41;<br />    s2 = &#40;s2 + s1&#41;<br />-----------------<br />change names&#58;<br />    A = &#40;s1 + buf&#91;n+0&#93;&#41;<br />    B = &#40;s2 + A&#41;<br />    <br />    C = &#40;A + buf&#91;n+1&#93;&#41;<br />    D = &#40;B + C&#41;<br />    <br />    E = &#40;C + buf&#91;n+2&#93;&#41;<br />    F = &#40;D + E&#41;<br />    <br />    G = &#40;E + buf&#91;n+3&#93;&#41;<br />    H = &#40;F + G&#41;<br /><br />    new s1 = G<br />    new s2 = H<br />------------------<br />substitute&#58;<br />    <br />    <br />    E = <br />    F = <br />    <br />    G = &#40;&#40;&#40;&#40;s1 + buf&#91;n+0&#93;&#41; + buf&#91;n+1&#93;&#41; + buf&#91;n+2&#93;&#41; + buf&#91;n+3&#93;&#41;<br />    H = &#40;&#40;&#40;&#40;s2 + &#40;s1 + buf&#91;n+0&#93;&#41;&#41; + &#40;&#40;s1 + buf&#91;n+0&#93;&#41; + buf&#91;n+1&#93;&#41;&#41; + &#40;&#40;&#40;s1 + buf&#91;n+0&#93;&#41; + buf&#91;n+1&#93;&#41; + buf&#91;n+2&#93;&#41;&#41; + G&#41;<br /><br />    new s1 = G<br />    new s2 = H<br />------------------<br />simplify&#58;<br />&#40;b0=buf&#91;n+0&#93;, b1=buf&#91;n+1&#93;....&#41;<br /><br />    G = s1 + buf&#91;n+0&#93;+ buf&#91;n+1&#93; + buf&#91;n+2&#93; + buf&#91;n+3&#93;<br />      = s1 + &#123;b0+b1+b2+b3&#125;<br />    H = s2 + s1 + buf&#91;n+0&#93; + s1 + buf&#91;n+0&#93; + buf&#91;n+1&#93; + s1 + buf&#91;n+0&#93; + buf&#91;n+1&#93; + buf&#91;n+2&#93; + G<br />      = s2 + 3*s1 + 3*b0 + 2*b1 + b2 + G<br />    <br />    new_s1 = s1 + &#123;b0+b1+b2+b3&#125;<br />    new_s2 = s2 + 3*s1 + 3*b0 + 2*b1 + b2 + new_s1<br /><br /></code></pre><br /><br />This code does work on a test set of 2,5 MB.. size has to be a multiple of 4 but as I said you can use the original proc for the remaining bytes because of the nature of adler32.<br /><pre><code> + buf + buf + buf;<br />        unsigned long new_s2 = s2 + 3*s1 + 3*buf + 2*buf + buf + new_s1;<br />        <br />        s1 = new_s1;<br />        s2 = new_s2;<br /><br />        s1 %= BASE;<br />        s2 %= BASE;<br />        <br />    }<br />    return (s2 &lt;&lt; 16) + s1;<br />}<br /></code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-27 12:11:39 by Thomas</div>
   </div>
   <div class="post" id="post-31188">
    <div class="subject"><a href="#post-31188">adler32</a></div>
    <div class="body">Here's one that is unrolled, not that much faster though..<br /><pre><code><br />    mov     ecx, adler<br />    mov     edi, len<br />    mov     esi, buf<br />    mov     edx, ecx<br />    and     ecx, 0ffffh     ; ecx = s1<br />    xor     eax, eax<br />    add     edi, esi<br />    shr     edx, 16         ; edx = s2<br />    xor     ebx, ebx<br />    <br />    next&#58;<br />        ;s1 = &#40;s1 + buf&#91;n&#93;&#41; % BASE;<br />        ;s2 = &#40;s2 + s1&#41; % BASE ;<br />        <br />        mov     al, &#91;esi+0&#93;<br />        mov     bl, &#91;esi+1&#93;<br />        <br />        <br />        add     ecx, eax<br />        add     edx, ecx<br />        add     ecx, ebx<br />        add     edx, ecx<br /><br />        mov     al, &#91;esi+2&#93;<br />        mov     bl, &#91;esi+3&#93;<br /><br />        add     ecx, eax<br />        add     edx, ecx<br />        add     ecx, ebx<br />        add     edx, ecx<br /><br />@@&#58;<br />        cmp     ecx, BASE<br />        jb      @F<br />        sub     ecx, BASE<br />        jmp     @B<br /><br />@@&#58;<br />        add     esi, 4<br />@@&#58;<br />        cmp     edx, BASE<br />        jb      @F<br />        sub     edx, BASE<br />        jmp     @B<br />@@&#58;<br />    cmp     esi, edi<br />    jb      next<br />    mov     eax, edx<br />    shl     eax, 16<br />    add     eax, ecx<br />    ret<br /></code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-27 12:58:04 by Thomas</div>
   </div>
   <div class="post" id="post-31253">
    <div class="subject"><a href="#post-31253">adler32</a></div>
    <div class="body">I haven't tested this, but the theme should be appearant:<pre><code>update_adler32 PROC uses ebx esi edi, adler&#58;DWORD, buf&#58;DWORD, len&#58;DWORD<br />	mov eax,adler<br />	mov ecx,buf<br />	mov edx,eax<br />	shr eax,16<br />	and edx,0FFFFh<br /><br />;	xor ebx,ebx<br />	sub eax,edx<br />	jmp _x<br />_0&#58;<br />;	mov bl,&#91;ecx&#93;<br />	movzx ebx, BYTE PTR &#91;ecx&#93;<br />	inc ecx<br />	add eax,edx<br />	add edx,ebx<br />	cmp eax,BASE + 1<br />	sbb edi,edi<br />	cmp edx,BASE + 1<br />	sbb esi,esi<br />	and edi,BASE<br />	and esi,BASE<br />	sub eax,edi	; values are restricted to&#58;<br />	sub edx,esi	; &#91;0, BASE&#41;<br /><br />_x&#58;	dec len<br />	jns _0<br /><br />	add eax,edx<br />	cmp eax,BASE + 1<br />	sbb esi,esi<br />	and esi,BASE<br />	sub eax,esi<br /><br />	shl eax,16<br />	mov ax,dx<br />	ret<br />update_adler32 ENDP</code></pre>BASE could be in a register as well, if EDI is replaced with EBX.  There is also a way to eliminate the CMP instructions at the expensive of having to do the modulus at the end - I'll post again later.</div>
    <div class="meta">Posted on 2002-03-27 21:33:40 by bitRAKE</div>
   </div>
   <div class="post" id="post-31276">
    <div class="subject"><a href="#post-31276">adler32</a></div>
    <div class="body">The mathematics makes it look simple. If you could<br />assume that you would not get an overflow, then<br />it is just a matter of adding to the end and then<br />dividing (like Mirno said). However, S2 grow exponentially.<br /><br />I tried to find a relation with BASE and the<br />register base (4294967295) that would allow a <br />simple conversion at the end.<br /><br />Maybe using the mmx registers, assuming that you <br />could get x number of iterations before you needed<br />to divide could help.<br /><br />S2 = (ADL* + n*ADL + n*A[0] + (n-1)*A[1] ...         A)%BASE<br /><br />S1 = (ADL + A[0] + A[1] ... A)%BASE</div>
    <div class="meta">Posted on 2002-03-28 02:10:25 by bdjames</div>
   </div>
   <div class="post" id="post-31289">
    <div class="subject"><a href="#post-31289">adler32</a></div>
    <div class="body">I've tested all versions I have so far, but the differences aren't that big.. Recently someone (Nico) contacted me about my post on huffman codes as he has been working on a PNG decoder as well. He had written it's own adler32 procedure, which was the fastest so far. <br />He also pointed out that I made an error in my first post about adler32. S2 will always be smaller than 2xBASE so the extra jump isn't necessary. <br /><pre><code><br />Nico's version&#58;<br /><br />GetAdler proc lpData&#58;DWORD,DataSize&#58;DWORD<br />    push ebx<br />    push esi<br />    xor eax,eax<br />    inc eax<br />    xor ebx,ebx<br />    mov esi,lpData<br />Loop1&#58;<br />    cmp DataSize,0<br />    jz EndLoop1<br />    cmp DataSize,5552<br />    ja MaxReached<br />    mov edx,DataSize<br />    jmp Cont<br />MaxReached&#58;<br />    mov edx,5552 <br />Cont&#58;<br />    sub DataSize,edx<br />Loop2&#58;<br />    test edx,edx<br />    jz EndLoop2<br />    dec edx<br />    xor ecx,ecx<br />    mov cl,&#91;esi&#93;<br />    add eax,ecx <br />    inc esi<br />    add ebx,eax<br />    jmp Loop2<br />EndLoop2&#58;<br />    mov ecx,65521<br />    xor edx,edx<br />    div ecx<br />    push edx<br />    mov eax,ebx<br />    xor edx,edx<br />    div ecx<br />    mov ebx,edx<br />    pop eax<br />    jmp Loop1<br />EndLoop1&#58;<br />    shl ebx,16<br />    or eax,ebx<br />ExitProc&#58;<br />    pop esi<br />    pop ebx<br />    ret<br />GetAdler endp<br /></code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-28 03:51:36 by Thomas</div>
   </div>
   <div class="post" id="post-31290">
    <div class="subject"><a href="#post-31290">adler32</a></div>
    <div class="body">Here's the timing of the versions so far:<br /><pre><code><br />C-Version&#58;      7C068FF0, time = 1943 ms for 10 loops<br />Nico&#58;           7C068FF0, time = 150 ms for 10 loops<br />Thomas&#58;         7C068FF0, time = 210 ms for 10 loops<br />Thomas2&#58;        7C068FF0, time = 201 ms for 10 loops<br />bitRAKE&#58;        20CF8FFF, time = 210 ms for 10 loops<br />Thomas3&#58;        7C068FF0, time = 120 ms for 10 loops<br /></code></pre><br />Using getTickCount around a loop that calls the adler function 10 times, using a data buffer of 2.83MB (2972436 bytes)..<br /><br /><strong>BitRAKE:</strong> Your version did not produce the right adler code (see hex values above).<br /><br />Thomas3 is this version:<br /><pre><code><br />    mov     ecx, adler<br />    mov     esi, buf<br />    mov     edx, ecx<br />    and     ecx, 0ffffh     ; ecx = s1<br />    xor     eax, eax<br />    shr     edx, 16         ; edx = s2<br />    mov     ebx, BASE<br />    shr     len, 2<br />_l1&#58;<br />    cmp     len, 0<br />    jz      _done<br /><br />    mov     edi, 963<br />    cmp     len, edi<br />    ja      _b2<br />    mov     edi, len<br />_b2&#58;<br />    sub     len, edi<br />    next&#58;<br />        mov     al, &#91;esi+0&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+1&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+2&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+3&#93;<br />        add     ecx, eax<br />        add     esi, 4<br />        add     edx, ecx<br /><br />        dec     edi<br />    jnz     next<br /><br />    mov     eax, edx<br />    xor     edx, edx<br />    div     ebx<br />    mov     edi, edx<br />    mov     eax, ecx<br />    xor     edx, edx<br />    div     ebx<br />    mov     ecx, edx<br />    mov     edx, edi<br /><br />    jmp _l1<br />_done&#58;<br />    <br />    mov     eax, edx<br />    shl     eax, 16<br />    add     eax, ecx<br />    ret<br /></code></pre><br /><br />The inner loop does 963 dwords without MOD, then MODs the results and does the next 963 dwords. Even in the worst case, the inner loop will never overflow ecx and edx.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-28 03:57:00 by Thomas</div>
   </div>
   <div class="post" id="post-31299">
    <div class="subject"><a href="#post-31299">adler32</a></div>
    <div class="body">Thomas, I think you can use mul instead of div, which speeds up<br />things greatly.<br />Magic multiplier to get qu ob reg\base = 80078071h<br />put it in ebx instead of base.<br />To divide value in eax on base do:<br />  mov edx,ebx<br />  mul ebx<br />  shr edx,15 <br />;edx = quantiant of eax/base<br />  to get reminder now<br />  mul result in by base and sub the result from value that<br />  was in eax<br />.data<br />base dd 65521<br />.code<br />	 mov edi,edx ;devident<br />	 mov edx,ebx ;= 80078071h<br />	 mul ebx<br />	 mov eax,edx<br />	 xor edx,edx<br />	 shr eax,15<br />	 mul base<br />	 sub edi,eax<br />	;and so on with second div<br /><br />It may be further optimized - I am just giving main idea</div>
    <div class="meta">Posted on 2002-03-28 05:41:56 by The Svin</div>
   </div>
   <div class="post" id="post-31301">
    <div class="subject"><a href="#post-31301">adler32</a></div>
    <div class="body"><strong>The Svin</strong>: I tried your code, but it doesn't produce the right results... I've walked through the code and that time it divided correctly, but the final adler value isn't correct...<br /><br /><pre><code><br />    mov     ecx, adler<br />    mov     esi, buf<br />    mov     edx, ecx<br />    and     ecx, 0ffffh     ; ecx = s1<br />    xor     eax, eax<br />    shr     edx, 16         ; edx = s2<br />    mov     ebx, 80078071h <br />    shr     len, 2<br />_l1&#58;<br />    cmp     len, 0<br />    jz      _done<br /><br />    mov     edi, 963<br />    cmp     len, edi<br />    ja      _b2<br />    mov     edi, len<br />_b2&#58;<br />    sub     len, edi<br />    next&#58;<br />        mov     al, &#91;esi+0&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+1&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+2&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+3&#93;<br />        add     ecx, eax<br />        add     esi, 4<br />        add     edx, ecx<br /><br />        dec     edi<br />    jnz     next<br />    <br />    mov edi,edx ;devident <br />    mov eax, edx<br />    mov edx,ebx ;= 80078071h <br />    mul ebx <br />    mov eax,edx <br />    xor edx,edx <br />    shr eax,15 <br />    push 65521 <br />    mul dword ptr &#91;esp&#93; <br />    sub edi,eax<br />    mov edx, edi<br />    add esp, 4<br /><br />    push edx<br /><br />    mov edi,ecx ;devident <br />    mov eax, ecx<br />    mov edx,ebx ;= 80078071h <br />    mul ebx <br />    mov eax,edx <br />    xor edx,edx <br />    shr eax,15 <br />    push 65521 <br />    mul dword ptr &#91;esp&#93; <br />    sub edi,eax<br />    mov ecx, edi<br />    add esp, 4<br />    <br />    pop edx<br /><br /><br /><br />    jmp _l1<br />_done&#58;<br />    <br />    mov     eax, edx<br />    shl     eax, 16<br />    add     eax, ecx<br /></code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-28 06:06:12 by Thomas</div>
   </div>
   <div class="post" id="post-31303">
    <div class="subject"><a href="#post-31303">adler32</a></div>
    <div class="body"><pre><code><br />    mov     ecx, adler<br />    mov     esi, buf<br />    mov     edx, ecx<br />    and     ecx, 0ffffh     ; ecx = s1<br />    xor     eax, eax<br />    shr     edx, 16         ; edx = s2<br />    mov     ebx, 80078071h<br />    shr     len, 2<br />_l1&#58;<br />    cmp     len, 0<br />    jz      _done<br /><br />    mov     edi, 963<br />    cmp     len, edi<br />    ja      _b2<br />    mov     edi, len<br />_b2&#58;<br />    sub     len, edi<br />    next&#58;<br />        mov     al, &#91;esi+0&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+1&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+2&#93;<br />        add     ecx, eax<br />        add     edx, ecx<br />    <br />        mov     al, &#91;esi+3&#93;<br />        add     ecx, eax<br />        add     esi, 4<br />        add     edx, ecx<br /><br />        dec     edi<br />    jnz     next<br />.data<br />ALIGN 4<br />base dd 65521<br />.code<br />	 mov edi,edx ;devident<br />	 mov edx,ebx ;= 80078071h<br />	 mul ebx<br />	 mov eax,edx<br />	 xor edx,edx<br />	 shr eax,15<br />	 mul base<br />	 sub edi,eax<br />	 mov eax,ecx<br />	 mov edx,ebx<br />	 mul ebx<br />	 mov eax,edx<br />	 xor edx,edx<br />	 shr eax,15<br />	 mul base<br />	 sub ecx,eax<br />	 mov edx,edi<br /><br />    jmp _l1<br />_done&#58;<br />    <br />    mov     eax, edx<br />    shl     eax, 16<br />    add     eax, ecx<br />    ret<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-28 06:22:59 by The Svin</div>
   </div>
   <div class="post" id="post-31308">
    <div class="subject"><a href="#post-31308">adler32</a></div>
    <div class="body">It still gives the wrong value :(</div>
    <div class="meta">Posted on 2002-03-28 07:14:20 by Thomas</div>
   </div>
   <div class="post" id="post-31311">
    <div class="subject"><a href="#post-31311">adler32</a></div>
    <div class="body">Please, send me testing code with any proc inside it wich produce right values, I'll try write code that catches the moment of difference.</div>
    <div class="meta">Posted on 2002-03-28 07:36:09 by The Svin</div>
   </div>
   <div class="post" id="post-31317">
    <div class="subject"><a href="#post-31317">adler32</a></div>
    <div class="body">I've converted the test code from C to asm so the C version isn't in the test anymore.<br />To test it choose a big file (at least 2MB) from your harddisk, copy it as file.dat in the test dir, run file2obj which will use f0dder's bin2o to create blah.obj. The test will use the first 2MB of the file to test.<br /><strong>edit: updated it to let it use vkim's debug window</strong><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-28 08:17:18 by Thomas</div>
   </div>
   <div class="post" id="post-31331">
    <div class="subject"><a href="#post-31331">adler32</a></div>
    <div class="body">I wrote simple test (run only inside debugger!!!)<br /><pre><code><br />.data<br />base dd 65521<br />.code<br />start&#58;<br />	xor ebx,ebx<br />	mov ecx,80078071h<br />@@&#58;	inc ebx<br />	xor edx,edx<br />	mov eax,ebx<br />	div	base<br />	mov edi,edx<br />	mov edx,ecx<br />	mov esi,ebx<br />	mov eax,ebx<br />	mul edx<br />	mov eax,edx<br />	xor edx,edx<br />	shr eax,15<br />	mul base<br />	sub esi,eax<br />	cmp edi,esi<br />	je @B<br />	mov eax,eax ;!set brakepoint here and press F9<br />                call ExitProcess<br /></code></pre><br />Test showed that reminders got by both div and my method<br />are absolutly identical. I wasn't been able to get to mov eax,eax<br />(Alt x was the only way out ;)<br />Error somewhere out of this part - I let you know later when<br />catch it though your test prog.</div>
    <div class="meta">Posted on 2002-03-28 10:34:30 by The Svin</div>
   </div>
   <div class="post" id="post-31362">
    <div class="subject"><a href="#post-31362">adler32</a></div>
    <div class="body">I used file 1075239 bytes and got this results:<br /><pre><code><br />eax = Nico      &#58; code&#58;7A298223, 451 ms for 10 loops on 2MB of data<br />eax = BitRAKE   &#58; code&#58;7BAC8232, 721 ms for 10 loops on 2MB of data<br />eax = Thomas2   &#58; code&#58;FC4C8223, 310 ms for 10 loops on 2MB of data<br />eax = Thomas3   &#58; code&#58;F3CE8108, 190 ms for 10 loops on 2MB of data<br />eax = Svin2     &#58; code&#58;02D56DB8, 181 ms for 10 loops on 2MB of data<br /></code></pre><br /><br />None of the same code :)</div>
    <div class="meta">Posted on 2002-03-28 12:57:54 by The Svin</div>
   </div>
   <div class="post" id="post-31363">
    <div class="subject"><a href="#post-31363">adler32</a></div>
    <div class="body">I found 1 place now final value (from ecx part) the same:<br />(the thing was that in your code part of eax (ah +) has<br />quontient after last devision and I changed using eax to multiply quontient):<br /><pre><code><br />eax = Nico      &#58; code&#58;C9AD7C71, 431 ms for 10 loops on 2MB of data<br />eax = BitRAKE   &#58; code&#58;C0B67C80, 711 ms for 10 loops on 2MB of data<br />eax = Thomas2   &#58; code&#58;C9AD7C71, 310 ms for 10 loops on 2MB of data<br />eax = Thomas3   &#58; code&#58;C9AD7C71, 190 ms for 10 loops on 2MB of data<br />eax = Svin2     &#58; code&#58;BE827C71, 181 ms for 10 loops on 2MB of data<br /></code></pre><br /><br />Part of work is done.</div>
    <div class="meta">Posted on 2002-03-28 13:33:43 by The Svin</div>
   </div>
   <div class="post" id="post-31364">
    <div class="subject"><a href="#post-31364">adler32</a></div>
    <div class="body">That's not strange if you use only 1 MB of data. You should use a file of at least 2MB..<br />Only bitRAKE's and yours should not produce the right values:<br /><pre><code><br />eax = Nico      &#58; code&#58;9639F0C4, 190 ms for 10 loops on 2MB of data<br />eax = BitRAKE   &#58; code&#58;0B5AF0D3, 151 ms for 10 loops on 2MB of data<br />eax = Thomas2   &#58; code&#58;9639F0C4, 130 ms for 10 loops on 2MB of data<br />eax = Thomas3   &#58; code&#58;9639F0C4, 70 ms for 10 loops on 2MB of data<br />eax = Svin2     &#58; code&#58;8B1CBB09, 80 ms for 10 loops on 2MB of data<br /></code></pre><br /><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-28 13:34:10 by Thomas</div>
   </div>
   <div class="post" id="post-31365">
    <div class="subject"><a href="#post-31365">adler32</a></div>
    <div class="body">Lower word is correct, one word to go :) It seems to be a little faster than my latest version. What processor do you use?<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-28 13:36:14 by Thomas</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4463&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4463&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4463" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4463&amp;page=2">&gt;</a><a href="../?id=4463&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>