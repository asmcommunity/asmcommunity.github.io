<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Using gcc to compile the sqrt function. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29268" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29268">Using gcc to compile the sqrt function.</a></p>
   <div class="post" id="post-206761">
    <div class="subject"><a href="#post-206761">Using gcc to compile the sqrt function.</a></div>
    <div class="body">I am recently trying to learn assembly and am playing around with compiling things in C/C++ and looking at the generated assembly.&nbsp; I am very confused about the asm generated by sqrt(double).&nbsp; I am running gcc under linux fedora core 6.&nbsp; Here is my C code:<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;math.h&gt;<br /><br />int main()<br />{<br />&nbsp; &nbsp; double x, y;<br /><br />&nbsp; &nbsp; printf(&quot;Enter Number: &quot;);<br /><br />&nbsp; &nbsp; scanf(&quot;%lf&quot;, &amp;x);<br /><br />&nbsp; &nbsp; y = sqrt(x);<br /><br />&nbsp; &nbsp; printf(&quot;x = %12.40e\n&quot;, x);<br />&nbsp; &nbsp; printf(&quot;y = %12.40e\n&quot;, y);<br /><br />&nbsp; &nbsp; return (0);<br />}<br /><br /><br />I have generated assembly for this using the command:<br /><br />/usr/libexec/gcc/i386-redhat-linux/4.1.2/cc1 -quiet -v testsqrt.c -quiet -dumpbase testsqrt.c -masm=intel -mtune=generic -auxbase testsqrt -O -version -o /tmp/testsqrt.s<br /><br />The generated asm is:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .file&nbsp;  &quot;testsqrt.c&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; .intel_syntax<br />&nbsp; &nbsp; &nbsp; &nbsp; .section&nbsp; &nbsp; &nbsp; &nbsp; .rodata.str1.1,&quot;aMS&quot;,@progbits,1<br />.LC0:<br />&nbsp; &nbsp; &nbsp; &nbsp; .string &quot;Enter Number: &quot;<br />.LC1:<br />&nbsp; &nbsp; &nbsp; &nbsp; .string &quot;%lf&quot;<br />.LC2:<br />&nbsp; &nbsp; &nbsp; &nbsp; .string &quot;x = %12.40e\n&quot;<br />.LC3:<br />&nbsp; &nbsp; &nbsp; &nbsp; .string &quot;y = %12.40e\n&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; .text<br />.globl main<br />&nbsp; &nbsp; &nbsp; &nbsp; .type&nbsp;  main, @function<br />main:<br />&nbsp; &nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;  %ecx, [%esp+4]<br />&nbsp; &nbsp; &nbsp; &nbsp; and&nbsp; &nbsp;  %esp, -16<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; DWORD PTR [%ecx-4]<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; %ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  %ebp, %esp<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; %ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp;  %esp, 52<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  DWORD PTR [%esp], OFFSET FLAT:.LC0<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; printf<br />&nbsp; &nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;  %eax, [%ebp-16]<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  DWORD PTR [%esp+4], %eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  DWORD PTR [%esp], OFFSET FLAT:.LC1<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; scanf<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; &nbsp;  QWORD PTR [%ebp-16]<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; &nbsp;  %st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp; fsqrt<br />&nbsp; &nbsp; &nbsp; &nbsp; fst&nbsp; &nbsp;  QWORD PTR [%ebp-32]<br />&nbsp; &nbsp; &nbsp; &nbsp; fucomp&nbsp; %st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp; fnstsw&nbsp; %ax<br />&nbsp; &nbsp; &nbsp; &nbsp; sahf<br />&nbsp; &nbsp; &nbsp; &nbsp; jp&nbsp; &nbsp; &nbsp; .L5<br />&nbsp; &nbsp; &nbsp; &nbsp; je&nbsp; &nbsp; &nbsp; .L6<br />.L5:<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp&nbsp; &nbsp; QWORD PTR [%esp]<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; sqrt<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp&nbsp; &nbsp; QWORD PTR [%ebp-32]<br />&nbsp; &nbsp; &nbsp; &nbsp; .p2align 4,,4<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp&nbsp; &nbsp;  .L2<br />.L6:<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp&nbsp; &nbsp; %st(0)<br />.L2:<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; &nbsp;  QWORD PTR [%ebp-16]<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp&nbsp; &nbsp; QWORD PTR [%esp+4]<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  DWORD PTR [%esp], OFFSET FLAT:.LC2<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; printf<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; &nbsp;  QWORD PTR [%ebp-32]<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp&nbsp; &nbsp; QWORD PTR [%esp+4]<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  DWORD PTR [%esp], OFFSET FLAT:.LC3<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; printf<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  %eax, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp;  %esp, 52<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  %ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  %ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;  %esp, [%ecx-4]<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; .size&nbsp;  main, .-main<br />&nbsp; &nbsp; &nbsp; &nbsp; .ident&nbsp; &quot;GCC: (GNU) 4.1.2 20070925 (Red Hat 4.1.2-33)&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; .section&nbsp; &nbsp; &nbsp; &nbsp; .note.GNU-stack,&quot;&quot;,@progbits<br /><br />It seems to me that the fsqrt command should be able to compute this square root.&nbsp; In the assembly code the command fsqrt appears, afterwards there is an fucomp, a jp, and a je.&nbsp; Two lines after .L5 there is a &quot;call sqrt&quot;.&nbsp; I don&#039;t understand this logic&nbsp; at all.&nbsp; Are there cases where fsqrt gives an incorrect or inaccurate result that requires further processing?&nbsp; Any help would be appreciated.&nbsp; Thanks.</div>
    <div class="meta">Posted on 2009-01-30 11:48:15 by mengfanke</div>
   </div>
   <div class="post" id="post-206762">
    <div class="subject"><a href="#post-206762">Re: Using gcc to compile the sqrt function.</a></div>
    <div class="body">Well, the couple of lines that immediately follow the fsqrt are getting the fpu StateFlags onto the cpu, so that we can then use some conditional jumps..<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; fsqrt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;calculate st(0) = square root<br />&nbsp; &nbsp; &nbsp; &nbsp; fst&nbsp; &nbsp; &nbsp;QWORD PTR [%ebp-32]&nbsp; &nbsp; ;store st(0), but dont actually unload it<br />&nbsp; &nbsp; &nbsp; &nbsp; fucomp&nbsp; %st(0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;compare st(0) with ITSELF, and unload it from st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp; fnstsw&nbsp; %ax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;set ax = fpu state flags<br />&nbsp; &nbsp; &nbsp; &nbsp; sahf&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;set fpu state flags = ah<br />&nbsp; &nbsp; &nbsp; &nbsp; jp&nbsp; &nbsp; &nbsp; .L5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;if TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; je&nbsp; &nbsp; &nbsp; .L6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;if FALSE<br /><br /><br />Clearly, this is a test for NaN..<br /><div class="quote">One can therefore test whether a variable has a NaN value by comparing it to itself, thus if x = x gives false then x is a NaN code</div><br /><br />The fpu is designed to operate apon &#039;real&#039; numbers, it&#039;s not suitable for returning the square root of a negative number (other than zero), as these are &#039;imaginary&#039;, or &#039;complex&#039; numbers, which take a different form to our familiar &#039;real&#039; numbers.<br /><br />If we ask for the square root of say, -49, the fpu will return NAN (Not A Number), an error code, we&#039;ll need to calculate the square roots of complex numbers the hard way.<br /><br />Seriously, this is a poorly crafted test, we should have just looked at the high bit of the input term to see if its negative, then switched to fsqrt or call sqrt based on that.<br /><br /></div>
    <div class="meta">Posted on 2009-01-30 18:42:52 by Homer</div>
   </div>
   <div class="post" id="post-206764">
    <div class="subject"><a href="#post-206764">Re: Using gcc to compile the sqrt function.</a></div>
    <div class="body">The more you learn about assembly, the more you will observe how much bloating most of those HLL compilers spit out even for simple functions. Your example is just the tip of the iceberg.<br /></div>
    <div class="meta">Posted on 2009-01-30 22:20:25 by Raymond</div>
   </div>
   <div class="post" id="post-206795">
    <div class="subject"><a href="#post-206795">Re: Using gcc to compile the sqrt function.</a></div>
    <div class="body">Homer and Raymond:<br /><br />Thank you for your responses.&nbsp; I would have thought that fsqrt returning NaN is sufficient, it really is surprinsing how much additional computation is performed after the call to fsqrt.&nbsp; Again, I am fairly new to assembly and appreciate your responses.</div>
    <div class="meta">Posted on 2009-02-02 20:56:24 by mengfanke</div>
   </div>
   <div class="post" id="post-206801">
    <div class="subject"><a href="#post-206801">Re: Using gcc to compile the sqrt function.</a></div>
    <div class="body">Try compiling the code with Visual C++ and &quot;/fp:fast&quot;...<br /><div class="quote">fast - &quot;fast&quot; floating-point model; results are less predictable</div>. Not the smartest stack management code, but it does FSQRT without too much weirdness.</div>
    <div class="meta">Posted on 2009-02-03 00:45:34 by f0dder</div>
   </div>
  </div>
 </body>
</html>