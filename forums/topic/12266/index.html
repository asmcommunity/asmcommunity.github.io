<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Programming here. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12266" />
    <link rel="next" href="../?id=12266&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12266">Programming here.</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12266&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12266&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12266" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12266&amp;page=2">&gt;</a><a href="../?id=12266&amp;page=2">&raquo;</a></form>   <div class="post" id="post-94253">
    <div class="subject"><a href="#post-94253">Programming here.</a></div>
    <div class="body">This Thread discussing about Port Programming.<br />Do you agree ?.<br /><br />I want a Simple example to programming the HD Device. The Example should be like this:<br /><br />1. Set Hardisk to Sec 1, Cyl 0, Head 0. <br />2. Save the first byte.<br />3. Rewrite it.<br />4. Load the saved byte.<br />5. Write it back to normal.<br /><br />If this thread not match in this criteria, just delete it and send me n PM with subject, &quot;You stupid Morron, Its not match&quot;. :grin:</div>
    <div class="meta">Posted on 2003-04-08 08:11:04 by realvampire</div>
   </div>
   <div class="post" id="post-94254">
    <div class="subject"><a href="#post-94254">Programming here.</a></div>
    <div class="body">sounds like wrong forum to me. It's &quot;low level programming&quot;, not &quot;electronics&quot;.</div>
    <div class="meta">Posted on 2003-04-08 08:12:49 by f0dder</div>
   </div>
   <div class="post" id="post-94256">
    <div class="subject"><a href="#post-94256">Well</a></div>
    <div class="body">I dont think so. But its okay. Are we here gonna designing a Hardware device ?</div>
    <div class="meta">Posted on 2003-04-08 08:15:09 by realvampire</div>
   </div>
   <div class="post" id="post-94257">
    <div class="subject"><a href="#post-94257">Programming here.</a></div>
    <div class="body">As far as I can see, this forum is about messing with hardware and programming PICs. Doesn't have much to do with lowlevel access to the harddrive :)</div>
    <div class="meta">Posted on 2003-04-08 08:18:46 by f0dder</div>
   </div>
   <div class="post" id="post-94258">
    <div class="subject"><a href="#post-94258">ummm...</a></div>
    <div class="body">Maybe thats what I mean, PIC programming, but what is it? the use and its definition.:tongue: :stupid:</div>
    <div class="meta">Posted on 2003-04-08 08:21:29 by realvampire</div>
   </div>
   <div class="post" id="post-94455">
    <div class="subject"><a href="#post-94455">Programming here.</a></div>
    <div class="body">I moved this thread to Main, so more people might get the idea of what your interested in.  F0dder is right, your looking for low level access to your harddrive (probably via windows OS).  This is probably a ring0 concern ~ one that im not skilled in.  <br /><br />Perhpas someone else might be tho...<br />:NaN:</div>
    <div class="meta">Posted on 2003-04-08 17:25:35 by NaN</div>
   </div>
   <div class="post" id="post-94477">
    <div class="subject"><a href="#post-94477">Okay.</a></div>
    <div class="body">:o  Ahum..., oke thanks. Ring0 I'll check it. Where is the good Explanation for this ?</div>
    <div class="meta">Posted on 2003-04-08 20:46:49 by realvampire</div>
   </div>
   <div class="post" id="post-94524">
    <div class="subject"><a href="#post-94524">Programming here.</a></div>
    <div class="body">Hello realvampire,<br /><br />Check this funtion in the SDK:  <strong>Int 21h Function 7305h</strong> <br /><br />Maybe it is helpful.<br /><br />best regards,<br /><br /><br />czDrillard</div>
    <div class="meta">Posted on 2003-04-08 22:29:44 by czDrillard</div>
   </div>
   <div class="post" id="post-94586">
    <div class="subject"><a href="#post-94586">Programming here.</a></div>
    <div class="body">realvampir,<br /><br />seems you want to manipulate the mbr...   you can find many example of this on the net. Search on google as &quot;reading mbr&quot;.<br /><br />czDrillard method is good. If you want you can do the same at bios level, check also for int 13h service 02 to read a sector,  service 03 to write.</div>
    <div class="meta">Posted on 2003-04-09 02:51:37 by Bit7</div>
   </div>
   <div class="post" id="post-94598">
    <div class="subject"><a href="#post-94598">Programming here.</a></div>
    <div class="body">reading MBR is very easy, especially on NT. You just use a special syntax to CreateFile.<br /><br />Programming the harddrive via port I/O is somewhat complex - at least you need to know what you're doing. And you will NOT be doing this under windows, not even from ring0.</div>
    <div class="meta">Posted on 2003-04-09 03:25:29 by f0dder</div>
   </div>
   <div class="post" id="post-94900">
    <div class="subject"><a href="#post-94900">Hmmmm....</a></div>
    <div class="body">:grin:  I dont want to use Interupt, I must increase my skill, thats why I didnt like to use WinAPI and Interupt.</div>
    <div class="meta">Posted on 2003-04-09 17:47:06 by realvampire</div>
   </div>
   <div class="post" id="post-94939">
    <div class="subject"><a href="#post-94939">Programming here.</a></div>
    <div class="body">If you *really* want to work with hdd in this low level mode (i.e. with ports in and out) I could give you some advice. I am currently trying to write a hdd driver for SOL OS (see BogdanOntanu about that :) ) and I just finished the first Read_Sector procedure (one that works in LBA mode only, however).<br />Anyways, this works only when you are in some O.S. that allows direct access to ports (i.e. real mode MSDOS or some other O.S. like SOL OS :) )<br /><br />It's written for TASM, but shouldn't make a big difference. Does not use interrupts and is not very nice written also. About interrupts.. You should set the device (HDD) not to assert INTRQ. This is done in the 'main' progam, I will also include the full source as a zip attachement.<br /><br /><br /><pre><code><br /><br />wait_ready	PROC STDCALL<br />	push ecx<br />	push edx<br /><br />; Here we should wait 400ns, but since we don't have a timer yet... &#58;P<br />	mov ecx,512<br />	@@wait1&#58;<br />	dec ecx<br />	jnz @@wait1<br /><br />; Then try to read status.<br />; 3f6h is the alternate status register. According to ATA standards<br />; this is the register one shall read status from<br />; until drive generates an interrupt or the BSY bit is clear.<br />; Reading 1f7h &#40;status register&#41; implies INTACK - drive<br />; clears INTRQ and also clears Status register contents.<br />	mov dx,3f6h<br />	@@wait2&#58;<br />	in al,dx<br />	and al,80h<br />	jnz @@wait2<br />	mov dx,1f7h<br />; After BSY is clear read status register also. That is a<br />; required step in order for the drive to know that we<br />; acknowledged its request and eventually<br />; we are ready to read data.<br />	in al,dx<br />	pop edx<br />	pop ecx<br />	ret<br />ENDP<br /><br />; ************* READ SECTOR ***************<br /><br /><br />LBA_Read_Sector PROC STDCALL<br />	ARG sector_no&#58;DWORD,lp_buff&#58;DWORD<br /><br />	mov edi,&#91;lp_buff&#93;<br />	mov eax,&#91;sector_no&#93;<br />	<br />	mov dx,1f3h		; lba bits 0-7<br />	out dx,al	<br /><br />	mov dx,1f4h<br />	xchg al,ah<br />	out dx,al			; lba bits 8-15<br />	<br />	shr eax,16<br />	<br />	mov dx,1f5h		; lba bits 16-23<br />	out dx,al<br />	<br />	mov	dx,1f6h<br />; and bits 24-27, along with drive/head register<br />; and LBA mode bit &#58;&#41; are here<br />	xchg al,ah<br />	or	al,11100000b<br />	and al,11101111b	; lowest bits are lba 24-27, the 0 bit is the drive no.<br />	out dx,al<br /><br />	mov dx,1f2h		<br />	mov al,1		; no. of sectors to read; one for now<br />	out dx,al<br /><br />	mov dx,01f7h<br />	mov al,20h	; read sectors command<br />	out dx,al<br /><br />	call wait_ready STDCALL<br /><br />	and al,00001000b	; check DRQ - if ON then we have to read data, else... something is wrong.<br />	jz @@err<br />	mov ecx,256<br /><br />	mov dx,01f0h<br />	@@hdloop&#58;<br />	in	ax,dx<br />	mov WORD PTR &#91;edi&#93;,ax<br />	inc edi<br />	inc edi<br />	dec ecx<br />	jnz @@hdloop<br />	xor eax,eax<br />	ret<br />	<br />	@@err&#58;<br />	mov eax,1<br />	ret<br />ENDP<br /></code></pre><br /><br />Hope this will help.. You could check the SOL OS site <a target="_blank" href="http://www.hostileencounter.com/sol_os/index.html">here</a> for more information. Unfortunatelly the version with this HDD app. isn't released yet.<br /><br />Good luck! :alright:</div>
    <div class="meta">Posted on 2003-04-09 19:10:58 by Hawkuletz</div>
   </div>
   <div class="post" id="post-95039">
    <div class="subject"><a href="#post-95039">Programming here.</a></div>
    <div class="body">you shouldn't even program harddrive with port I/O from DOS. Only if you're messing around with os-dev.<br />&quot;Increase your skill&quot; ... there isn't really much skill to programming ATA through port I/O, the only &quot;skill&quot; involved would be googling for specifications and port commands.</div>
    <div class="meta">Posted on 2003-04-10 02:14:02 by f0dder</div>
   </div>
   <div class="post" id="post-95082">
    <div class="subject"><a href="#post-95082">Programming here.</a></div>
    <div class="body"><div class="quote"><br />you shouldn't even program harddrive with port I/O from DOS. Only if you're messing around with os-dev.<br />&quot;Increase your skill&quot; ... there isn't really much skill to programming ATA through port I/O, the only &quot;skill&quot; involved would be googling for specifications and port commands. </div><br /><br />agreed :grin: <br /><br />and if you have an enough time, make a PIC project to connect to ATA HD, so it can read/write it, the easy way is to use avaiable super i/o controller chip. i did once in my thesis, but its not hd, it simpler, its floppy :grin:  that what you want to talk i though, if you place this thread in electronic.</div>
    <div class="meta">Posted on 2003-04-10 06:19:03 by dion</div>
   </div>
   <div class="post" id="post-95090">
    <div class="subject"><a href="#post-95090">Programming here.</a></div>
    <div class="body">Here is small program I did for using io/ports and read master boot record of drive c on win9x.<br /><br /><pre><code><br />; use a dirty hack to get to ring 0 and read mbr with i/o-ports, on win 9x<br /><br />.486<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br /><br />ReadMbr PROTO<br /><br />.data?<br /><br />Idtr df ?<br />hFile dd ?<br />bytesRet dd ?<br />bootSector db 512 dup &#40;?&#41;<br /><br />.data<br /><br />szApp db &quot;bootsector2&quot;,0<br />szOk db &quot;master boot record of drive c&#58;&quot;,13,10<br />db &quot;saved to &quot;<br />szFileName  db &quot;mbr.txt&quot;,0<br />szFileFail db &quot;Error saving file.&quot;,0<br /><br />ioports  dw 1f7h,1f5h,1f4h,1f3h,1f2h,1f6h<br />outbytes db 20h ,00h , 00h, 01h, 01h,0a0h<br /><br />.code<br /><br />    ; read mbr from drive c&#58;<br /><br />ReadMbr PROC<br />    mov ecx, 6<br />    mov esi, OFFSET ioports<br />    mov edi, OFFSET outbytes<br />    <br />@@&#58; mov dx, word ptr &#91;esi-2+ecx*2&#93;<br />    mov al, byte ptr &#91;edi-1+ecx&#93;<br />    out dx, al<br />    dec ecx<br />    jnz SHORT @B<br />    <br />@@&#58; in al, dx<br />    test al, 08h<br />    jz SHORT @B<br />    <br />    mov ecx, 128<br />    mov esi, OFFSET bootSector<br />    mov dx, 1f0h   <br />    rep insd<br />    iretd   <br />ReadMbr ENDP<br /><br />start&#58;<br /><br />        ; Redirect int 3h in Interupt Descriptor Table<br />        <br />	sidt fword ptr Idtr		; get far pointer to Interupt Descriptor Table<br />	mov ebx, dword ptr Idtr+2	; get the offset part of the far pointer<br /> 	push &#91;ebx+24&#93;		      ; save the descriptor for int 3h &#40;3*8=24&#41;<br />	push &#91;ebx+28&#93;<br />	lea eax, ReadMbr	            ; Redirect int 3h to Our ReadMbr-procedure<br />	mov word ptr &#91;ebx+24&#93;, ax<br />	shr eax, 16<br />	mov word ptr &#91;ebx+30&#93;, ax<br />	pushad				; save registers<br />	int 3h				; invoke ReadMbr<br />	popad				      ; restore registers	<br />	pop &#91;ebx+28&#93;     		      ; restore original int 3h-descriptor<br />	pop &#91;ebx+24&#93;<br /><br />            ; save the mbr to disk<br />            <br />      invoke CreateFile, ADDR szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, 0, CREATE_ALWAYS,\<br />                                                                        FILE_ATTRIBUTE_NORMAL, 0<br />      cmp eax, INVALID_HANDLE_VALUE<br />      jnz @F<br />                _fileFail&#58;<br />                    invoke MessageBox, NULL, ADDR szFileFail, ADDR szApp, MB_ICONERROR<br />                    jmp _quit<br />@@&#58;   mov hFile, eax<br />      invoke WriteFile, eax, ADDR bootSector, 512, ADDR bytesRet, 0<br />            test eax, eax<br />            jz _fileFail<br />      invoke MessageBox, NULL, ADDR szOk, ADDR szApp, MB_ICONASTERISK<br />_quit&#58;<br />      invoke CloseHandle, hFile<br />      invoke ExitProcess, 0<br /><br />end start<br /></code></pre><br /><br /><a target="_blank" href="">http://www.nondot.org/sabre/os/articles/DiskandDiscDrives/</a> this site has description of io ports to drives and other low level stuff</div>
    <div class="meta">Posted on 2003-04-10 06:57:45 by david</div>
   </div>
   <div class="post" id="post-95121">
    <div class="subject"><a href="#post-95121">Im understand mom..</a></div>
    <div class="body">Thats why you keep telling me dont subscibe this thread :confused: .<br /><br />Thanks David, int 31h is at Es=0 and DI=31*4, so....<br />es*16+DI*4<br />&lt;==&gt; 0+C4h<br />&lt;==&gt;C4h<br /><br />It's located at C4. I try to call it like this...<br /><pre><code><br /> mov eax,c4 <br /> call eax<br /></code></pre><br /><br />But..., where I should put the Parameter.<br />Note: Please tell me if I done something wrong.:confused:</div>
    <div class="meta">Posted on 2003-04-10 09:39:02 by realvampire</div>
   </div>
   <div class="post" id="post-95128">
    <div class="subject"><a href="#post-95128">Programming here.</a></div>
    <div class="body">For a serious stuff you should code a .vxd for ring0 on win9x, but there is this trick to do it too.<br /><br />The interupt descriptor table is an array of addresses for each of the interupts.<br />(You can't call these addresses directly, only by making an int-opcode, so you see you cannot pass any argument as you ask)<br />So you can choose one interupt that is not likely to be called by the operating system, like int 3h,<br />and substitue the address of that interrupt with the address of YOUR ROUTINE.<br />Then naturally, after doing that, if you call<br />int 3h<br />Your Routine will be called instead, but in ring0.<br />After returning you have to restore the original address of int3h in the IDT of course.<br />It is possible on win9x, because of some weird reason, they didn't protect memory area the interupt descriptor table resides in at all<br />from ring3 when designing the operating system. It works on WinMe too.<br /><br />Most people in this forum will tell to code a vxd I'm sure, but it's a pretty cool little snippet to play with.</div>
    <div class="meta">Posted on 2003-04-10 10:16:05 by david</div>
   </div>
   <div class="post" id="post-95131">
    <div class="subject"><a href="#post-95131">Programming here.</a></div>
    <div class="body">ring0 hacks == bugs. But I guess that since microsoft have retired the 9x product line, they wont be fixed for this ugly abomination of a operating system (&quot;exnteded dos extender&quot; :grin: ).<br /><br />realvampire, before you even consider messing with port I/O, especially harddrive related, you need a more thorough understanding of IA32. Even in realmode, you can NOT call an interrupt like that. A far call &quot;might&quot; work, but you'd have trouble when the interrupt code returns.<br /><br />In protected mode, the IDT isn't located at base address 0 - it can be located anywhere. Windows will typically have it at some fixed address, but of course you shouldn't depend on this, and rather get it with sidt. And you shouldn't even mess with the IDT directly, but use the OS services for this. And on top of that, you can't really call dos interrupts from windows, they need to be executed in vm86 - and are totally unexistant on NT. BIOS interrupts will be available on NT too, since they're BIOS interrupts after all - but here you shouldn't even _think_ of calling them, unless you very much know what you're doing. And, honestly speaking, you don't.</div>
    <div class="meta">Posted on 2003-04-10 10:25:04 by f0dder</div>
   </div>
   <div class="post" id="post-95133">
    <div class="subject"><a href="#post-95133">Yeahh...</a></div>
    <div class="body"><div class="quote"><em>Originally posted by f0dder </em><br />... unless you very much know what you're doing. And, honestly speaking, you don't.</div><br /><br />...And, Honestly speaking. You're Right.  :grin:<br /><br />What is IA32?, Im hoping Dion translate a good resource about this. Now it be a Bit *Lazzy*. :stupid:</div>
    <div class="meta">Posted on 2003-04-10 10:37:30 by realvampire</div>
   </div>
   <div class="post" id="post-95135">
    <div class="subject"><a href="#post-95135">Programming here.</a></div>
    <div class="body">IA32 = Intel Architecture, 32bit processors.<br />You'll want to get yourself a copy of the intel pentium4 processor manuals from <a target="_blank" href="http://developer.intel.com">http://developer.intel.com</a> (if you can't find them, let me know and I'll track down the PDFs for you - it's not like it's hard). Then you'll have to concentrate on volume 3, systems programming.<br /><br />When you understand concepts like privileged instructions, paging, task switching (etc), you need to familiarize yourself with how windows uses that, and what restrictions it puts on you.<br /><br />The conclusion you end up with, should be that direct harddrive programming just isn't done from &quot;user&quot; code - you only do this if you're writing a driver for the hardware. Or messing around with osdev :) (and you really should only do programming of this kind from a clean boot with your own bootsector code, I would recommend against it even from something as &quot;clean&quot; as DOS).</div>
    <div class="meta">Posted on 2003-04-10 10:46:19 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12266&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12266&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12266" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12266&amp;page=2">&gt;</a><a href="../?id=12266&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>