<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>What is XM? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8445" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=8445">What is XM?</a></p>
   <div class="post" id="post-61726">
    <div class="subject"><a href="#post-61726">What is XM?</a></div>
    <div class="body">I post this to game programming because I think that XM is a DirectX Music format...<br /><br />I've seen it used in HUGI magazines and the programmer of HUGI has a small assembly program available that plays XM files.<br /><br />What I have hard time finding out is what exactly is XM?  It is synthesised music like MIDI, is it WAVE, is it a mix of the two?  Is it directX?  How do I create my own XM file?  I haven't seen any sound editors that produce it, I use Cool Edit Pro 2002 (the newly released update)...  Is it mainly for game programming?<br /><br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2002-10-14 11:39:26 by _Shawn</div>
   </div>
   <div class="post" id="post-61730">
    <div class="subject"><a href="#post-61730">What is XM?</a></div>
    <div class="body">Xm is neither a midi nor wav file but it's closer to a midi. It's like the mod and s3m file. The instruments are waves and they are used to play the notes and special effects in tracks. This file type is used mostly in games as it can be looped easily from inside the file. Probably the best of this kind of file type is the .it file format, though there might be some other that came out tha't I'm not aware of. <br /><br />To produce them, I used to use Impulse tracker, but now there are many more.  Googling with s3m mod tracker should come with enough links, though ModPlug Tracker is pretty good.<br /><br />It has nothing to do with directx, you can play them on dos or probably even linux...</div>
    <div class="meta">Posted on 2002-10-14 11:54:32 by Silas</div>
   </div>
   <div class="post" id="post-61758">
    <div class="subject"><a href="#post-61758">What is XM?</a></div>
    <div class="body">XM is an eXtended Module format, born in the DOS, it was introduced by FastTracker 2.0 (previous versions were using MOD format). There was a competitive program, ScreamTracker, which had introduced the S3M format with the 3.0 version (it's ScreamTracker 3 Module), but XM was generally more powerful. And then the ImpulseTracker arrived with the IT format, which was the extension of both S3M and XM format, it's the most powerful module format now.</div>
    <div class="meta">Posted on 2002-10-14 15:25:59 by Tomasz Grysztar</div>
   </div>
   <div class="post" id="post-61794">
    <div class="subject"><a href="#post-61794">What is XM?</a></div>
    <div class="body">Also to add to the very good expplanations above <br />I will say that esp for games XM is good because:<br /><br />1)It can be looped very easy and so it offers many minutes of music and can adapt to game status much easyer than .wav or .mp3 files<br />2) There is a very good source code asm player by Chris Dragan AFAIK<br />3) Size is small . Not as small as midi but it will play the same not depending on music board (while midi depend heavely on sound/music board type) because samples are ecoded as waves...<br />4) It will not require/eat much CPU time (more than wave but much less than mp3)</div>
    <div class="meta">Posted on 2002-10-14 22:25:30 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-62034">
    <div class="subject"><a href="#post-62034">What is XM?</a></div>
    <div class="body">IF you are programming a player, just remember panning/pitch envelopes there are too many players out there that ignore the envelopes. They think I don't notice it but I do, I have sharp ears. I'll post an audio resampling theory you can use:4.1 - Mixer data structure<br />We know that the mixing routine must generate MixLength bytes of audio data into a specified buffer in memory. It must take the raw sample data, and adjust it according to pitch, volume and pan variables while accounting for any loop points in the sample. The data which maintains all this information is best stored in a data structure local to the mixing code. There should a structure for each channel to be mixed and the format should contain: <br /><br /><br />(dword) Mix_CurrentPtr            ;Pointer to current sample<br />(dword) Mix_LoopEnd               ;Pointer to end of sample/loop end<br />(dword) Mix_LoopLen               ;Sample loop length (0 if no loop)<br />(word)  Mix_LowSpeed              ;Scaling rate (fractional part)<br />(word)  Mix_HighSpeed             ;Scaling rate (integer part)<br />(word)  Mix_Count                 ;Scaling fractional counter<br />(byte)  Mix_Volume                ;Volume of sample<br />(byte)  Mix_PanPos                ;Pan position<br />(byte)  Mix_ActiveFlag            ;Is voice active flag? (0 = inactive)<br />(byte)  Mix_SampleType (optional) ;Defines: 8 or 16-bit sample,<br />                                  ;         bi-directional looping, etc.<br /><br />Note: for efficiency reasons these variables may not necessarily be stored exactly as indicated in this structure. A flat-memory model is assumed throughout this description to simplify explanation. <br /><br />Whenever the device dependent code calls the tracking code to update channel variables, it must then interpret the changes to these variables (section 2.3) and set the variables in this mixer data structure accordingly. <br /><br /><br />--------------------------------------------------------------------------------<br /><br />4.2 - Resampling digital audio<br />Resampling of digital audio refers to the procedure used to make a sound sampled at one frequency sound the same when played back at a different mixing rate. If a sample is recorded at 44khz and is to be played back at the same pitch but using an output frequency of 32khz then a certain percentage of the original sample data has to be skipped during playback or the sample won't maintain the original pitch. Likewise, if a 22khz sample is to be played back at the same pitch using a 32khz mixing rate, some of the sample data will have to be scaled to insert more data in the output stream than is in the original sample. <br /><br />The basic resampling algorithm involves determining the ratio of desired frequency against output frequency and then scaling the sample data accordingly. In the mixing code the resampling is done on the run by stepping through the sample data by a scaling factor which involves both integer and fractional components instead of simply incrementing 1 byte at a time. <br /><br />The sample frequency is determined by the tracking code as a combination of the current pitch period and the middle-C frequency for the current sample (C2SPD). The scaling factor is determined from the sample frequency by the ratio: <br /><br /><br />	Sample Freq<br />Scale = -----------<br />	Mixing Freq<br /><br /><br />For efficiency reasons scaling is done using fixed point instead of floating point arithmetic. 32-bit precision (16-bit integer and 16-bit fractional) gives good results for the range of frequencies typically found in this kind of situation, hence the scaling factor is typically broken into two 16-bit variables (Mix_HighSpeed and Mix_LowSpeed). <br /><br />Example pseudo-code: determining sample scaling factor<br /><br /><br /><br />(word)Mix_HighSpeed = (SampleFreq / MixingRate);                      <br /><br />(word)Mix_LowSpeed = (((SampleFreq % MixingRate) &lt;&lt; 16) / MixingRate);<br />			^^^^^^^^^^^^^^^^^^^^^^^                       <br />		     remainder of previous division                   <br /><br />The actual scaling routine is then implemented by using a carry-counter to simulate fractional stepping through the sample. The Mix_Count variable is maintained for this purpose and is only reset to zero when a new sample is started. <br /><br />To step through a sample with the scaling factor, firstly add Mix_LowSpeed to Mix_Count. Then add Mix_HighSpeed AND the overflow carry from the previous operation to Mix_CurrentPtr. Get the byte which Mix_CurrentPtr is pointing to and add it to the output stream. Repeat for all the bytes needed to fill the output buffer. <br /><br />Sample loops are handled by checking if Mix_CurrentPtr has reached or passed Mix_LoopEnd. If so then Mix_LoopLen is subtracted from Mix_CurrentPtr. Note that Mix_Count is NOT reset to zero when a sample loops. If the sample does not loop then the sample stops when Mix_CurrentPtr is greater or equal to Mix_LoopEnd. <br /><br />Example assembly code: scaled sample-stepping (not optimised)<br /><br /><br />For demonstration Mix_CurrentPtr is assumed to be only 16-bits. In a real routine all registers and variables would be 32-bits for speed. <br /><br /><br />StepSample:     mov ax,   ;add Mix_LowSpeed to Mix_Count<br />		add ,ax      ;carry flag is set on add overflow<br />		mov ax, ;add Mix_HighSpeed to Mix_CurrentPtr<br />		adc ax,  ; with carry flag<br />		cmp ax,    ;check if passed loop endpoint, skip<br />		jb dontloop             ; if not passed endpoint else subtract<br />		sub ax,    ; Mix_LoopLen from Mix_CurrentPtr<br />dontloop:       mov ,ax ;store Mix_CurrentPtr for next loop<br /><br /><br /><br />--------------------------------------------------------------------------------<br /><br />4.3 - Mixing samples with volume<br />Once we have a way of scaling the samples correctly we need to combine the samples for each of the channels into one output stream. As mentioned in the first section, mixing audio is achieved simply by adding all of the component samples (assuming the samples are signed). However, to control the sample volume and protect against distortion and clipping if the range exceeds the 8-bit limit on the output data, the data from each sample must be scaled before being summed into the total output. <br /><br />The theoretical approach to applying volume to a sample involves multiplying the sample by a volume scaling factor before being summed into the output. <br /><br />Example assembly code: sample volume scaling (not optimised)<br /><br /><br />This routine would be applied for each channel for each byte in the output stream. For demonstration it assumes a 16-bit sample pointer, 8-bit signed sample data and an 8-bit signed output stream. <br /><br /><br />SumSample:   mov si,    ;get pointer to current sample byte<br />	     mov al,ds:             ;get the current sample byte<br />	     imul byte ptr  ;perform SIGNED multiply by vol. scale<br />	     add ,ah        ;then ADD it to the output byte<br />					;NOTE: add AH register NOT AL<br /><br /><br />By adding the AH register to the output byte, it effectively is performing the C operation: <br /><br /><br />(char)OutputByte = ((char)*(Mix_CurrentPtr) * (char)Mix_Volume) / 256; <br />This makes the Mix_Volume variable equivalent to a fractional multiply which is needed to make the sample quieter to prevent overflow in the output stream. <br /><br />The Mix_Volume variable can be calculated from the total number of channels to be mixed and the volume of the channel, and needs to be updated whenever the tracking code specifies a new volume on the channel. The equation to determine Mix_Volume for 8-bit samples and an 8-bit output stream without allowing any sample clipping is thus: <br /><br /><br />Mix_Volume = ((256/NumberOfChans)*MODVolume) &gt;&gt; 6; <br />Once all the channels have been added to the OutputByte, it can then be converted to an unsigned format (since soundblaster cards have an unsigned data format) and then placed in the output buffer. The easiest way to convert an 8-bit signed value into 8-bit unsigned is to flip bit 7 using exclusive or. ie. OutputData XOR 128. <br /><br />Example pseudo-code: complete mixing routine (very unoptimised but functional)<br /><br /><br />The whole mixing routine is then implemented as a group of nested loops, where MixLength is the number of bytes desired in the output stream. StepSample and SumSample are the algorithms defined previously. <br /><br /><br />void Mix8bitMono( int MixLength, char * buffer )<br />{<br />	static ChannelDataStruc Channels;<br />	int MixCount;<br />	int channel;<br />	char OutputByte;<br /><br />	MixCount = MixLength;<br /><br />	while( MixCount )<br />	{<br />		OutputByte = 0;<br />		for( channel = 0, channel &lt; NumberOfChannels, channel++ )<br />		{<br />			StepSample( *Channels );<br />			SumSample( *Channels );<br />		}<br />		*(buffer++) = OutputByte ^ 128;<br />		MixCount--;<br />	}<br />}<br /><br />I spent alot of time looking for a working algothrim, use this and if you find a better once please share with me and the rest! :D If you need more info to be on your way please let me know</div>
    <div class="meta">Posted on 2002-10-16 19:59:09 by x86asm</div>
   </div>
   <div class="post" id="post-62039">
    <div class="subject"><a href="#post-62039">What is XM?</a></div>
    <div class="body">So XM files are pitch generated (similar to MIDI) but aren't pre-recorded waves (unless wavetables?)<br /><br />I was listening to the opening music on HUGI 24 and it sounds like it's a lot more robust than MIDI for being pitches... chorus, various tracks, reverb, distortion, pitch changes (guitar &gt; bends and slides and vibratos) very good bass and dums on my Creative Audigy with Creative 5.1 speakers and subwoofer... a bit better than any MIDI I've ever heard...<br /><br />Or, does it get mixed with waves in the file?  Where can I find impluse tracker or similar?  Is it legit these days?<br /><br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2002-10-16 20:24:09 by _Shawn</div>
   </div>
   <div class="post" id="post-62046">
    <div class="subject"><a href="#post-62046">What is XM?</a></div>
    <div class="body">Nope XM is not pitch generated, instead it uses a series of wave samples that are mixed and looped in a carefull way, x86asm was trying to make you understand how one can use a sample of a C2 note taken from a very good instrument to scale it a little and generate other notes without loosing too much quality.  When more quality is needed you can always use more samples stored inside XM file. It is a kind of software synthetiser.<br /><br />AFAIK Chriss Dragan has a free written in win32asm source code level XM player ... <br /><br /><a target="_blank" href="http://zp.amsnet.pl/cdragan/assembly.html">http://zp.amsnet.pl/cdragan/assembly.html</a><br /><br /><br />but there are many closed source (sometimes better?) XM players and editors out there... some are free and  some are comercial.<br /><br />As long as you create your own music (aka &quot;track it&quot;) it is sure legal stuff... just do not copy other people's tracks without permission ...</div>
    <div class="meta">Posted on 2002-10-16 21:32:43 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-63196">
    <div class="subject"><a href="#post-63196">What is XM?</a></div>
    <div class="body">I was surprised when I read the FastTracker 2.0 documentation a while ago. It turned out that the guys who invented the XM format lived in the same city as me! Cool guys!</div>
    <div class="meta">Posted on 2002-10-24 01:09:17 by gliptic</div>
   </div>
  </div>
 </body>
</html>