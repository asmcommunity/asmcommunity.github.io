<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ASM's influence in the modern world - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28995" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=28995">ASM's influence in the modern world</a></p>
   <div class="post" id="post-204927">
    <div class="subject"><a href="#post-204927">ASM's influence in the modern world</a></div>
    <div class="body">Clearly ASM does have advantages in many applications that require &quot;to the metal&quot; development and in areas of optimisation.<br />Universities and organisations however seem to have pushed ASM out of the door, given that this is the case, does ASM have a future outside of it&#039;s niche areas?<br />People would classify these tasks as &quot;difficult&quot; if done in pure ASM:<br />* Scripting<br />* Writing medium to large programs<br /><br />How do the people here feel about this?<br />Are there any disadvantages in writing a program fully in ASM compared to C++ or Java? Keep in mind I am not talking about the advantages of Java or C++ over ASM, I realise that you can use the macro system to largely write OOP programs in ASM.<br /><br />My feeling is that ASM is limited in today&#039;s world purely as an optimisation tool, something that high level and even scripting level languages would link to in order to be performant at some operation.</div>
    <div class="meta">Posted on 2008-03-05 02:47:32 by Kruno</div>
   </div>
   <div class="post" id="post-204931">
    <div class="subject"><a href="#post-204931">Re: ASM's influence in the modern world</a></div>
    <div class="body"><div class="quote"><br />People would classify these tasks as &quot;difficult&quot; if done in pure ASM:<br />* Scripting<br />* Writing medium to large programs<br /></div>Scripting can&#039;t be done in assembly because scripting is always done in a scripting language.&nbsp; Writing medium to large programs is slower more than difficult because higher level languages are automatic code generators and the code is somewhat easier to read.&nbsp; But if you are used to coding in assembly, it can be almost as easy to read as any HLL.<br /><div class="quote"><br />My feeling is that ASM is limited in today&#039;s world purely as an optimisation tool, something that high level and even scripting level languages would link to in order to be performant at some operation.<br /></div>This has all been covered too many times in the past.&nbsp; HLLs make coding faster at the expense of larger programs and perhaps sloppier coding and maybe the need for more tools to keep it all together.</div>
    <div class="meta">Posted on 2008-03-05 07:45:38 by drhowarddrfine</div>
   </div>
   <div class="post" id="post-204932">
    <div class="subject"><a href="#post-204932">Re: ASM's influence in the modern world</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />People would classify these tasks as &quot;difficult&quot; if done in pure ASM:<br />* Scripting<br />* Writing medium to large programs<br /></div>Scripting can&#039;t be done in assembly because scripting is always done in a scripting language.&nbsp; Writing medium to large programs is slower more than difficult because higher level languages are automatic code generators and the code is somewhat easier to read.&nbsp; But if you are used to coding in assembly, it can be almost as easy to read as any HLL.]</div><br /><br />nonsense.. scripting can be done in assembly, its just not that common.. and the task rating is purely relative to the skill set of the coder...</div>
    <div class="meta">Posted on 2008-03-05 08:01:16 by evlncrn8</div>
   </div>
   <div class="post" id="post-204940">
    <div class="subject"><a href="#post-204940">Re: ASM's influence in the modern world</a></div>
    <div class="body">How do you script in assembly?</div>
    <div class="meta">Posted on 2008-03-05 20:32:54 by drhowarddrfine</div>
   </div>
   <div class="post" id="post-204944">
    <div class="subject"><a href="#post-204944">Re: ASM's influence in the modern world</a></div>
    <div class="body"><div class="quote"><br />How do you script in assembly?<br /></div><br />Bytecode, calling a proc from a table, or executing script text that looks very much like asm code. <br /><br />Kruno: without asm, you wouldn&#039;t be seeing modern console games that constantly push the limits, or scientific projects like F@H that need to squeeze-out max performance. And everywhere else, ... you&#039;d be constantly seeing projects getting canceled when OOP-brainwashed kids start encapsulating everything instead of doing the right thing; constantly making their own assumptions on how the cpu magically executes their code/script. It&#039;s like running in the dark - rarely a good thing. I&#039;ve seen enough times teams of HLL/script coders being given a task, each coder expressing their assumptions on how code works, each trying to drag everything to circle around their assumptions.  . <br /><br />At least by knowing asm, having experience in optimization with asm, and knowing what your compiler produces - you can code most of your project in a HLL. And then optimize the critical parts in asm. You&#039;ll also be seeing many new ways to design/implement your project (as you know how the cpu works), often leading to even faster and bug-free completion of a project. <br /><br />The 3 disadvantages of making a project completely in asm are:<br />- floating point arithmetic - it&#039;s hard/slow to type and bug-prone when you&#039;re inexperienced. <br />- multidimensional arrays - it&#039;s not a piece of cake, but at least not as hard as the FPU<br />- register preservation has to be taken care of, or you can introduce a bug. Once you decide on a style/standard, it becomes a breeze. <br />Everything else can be handled easily with macros. <br /><br />Once you&#039;re experienced enough, only the FPU code can be a bother. </div>
    <div class="meta">Posted on 2008-03-05 22:00:30 by Ultrano</div>
   </div>
   <div class="post" id="post-204945">
    <div class="subject"><a href="#post-204945">Re: ASM's influence in the modern world</a></div>
    <div class="body"><div class="quote"><br />How do you script in assembly?<br /></div><br /><br />The closest I can conceive of is by using macros.<br /><br />Beyond that, scripting languages and assembly language are on opposite sides of the programming spectrum :|<br /><br />There will always be a need for someone who knows how some piece of code is directly affecting the underlying machine. However, <strong>how many</strong> are needed is a different question altogether.<br /><br />This reminds me of the separation between Analog and Digital electronics, the difficultly between the two and the amount of designers/developers there are.<br /><br /><div class="quote"><br />Are there any disadvantages in writing a program fully in ASM compared to C++ or Java? Keep in mind I am not talking about the advantages of Java or C++ over ASM, I realise that you can use the macro system to largely write OOP programs in ASM.<br /></div><br /><br />Time, price, quality... pick any two ;)</div>
    <div class="meta">Posted on 2008-03-05 22:05:39 by SpooK</div>
   </div>
   <div class="post" id="post-204953">
    <div class="subject"><a href="#post-204953">Re: ASM's influence in the modern world</a></div>
    <div class="body">I&#039;ve written parsers and runtime parsers (interpreters/script engines) in asm before, its just another form of input data. I really don&#039;t see the problem.<br /></div>
    <div class="meta">Posted on 2008-03-07 02:44:27 by Homer</div>
   </div>
   <div class="post" id="post-205433">
    <div class="subject"><a href="#post-205433">Re: ASM's influence in the modern world</a></div>
    <div class="body">Why coding in ASM?<br /><br />Strangely this question is always asked by coders that don&#039;t write programs in ASM.<br />The only advantages they see coding in ASM are speed and size.<br /><br />Here are another ones:<br /><br />Creating Algorithms is easy.<br />You are not required to learn a complicated syntax from a complicated programming language. There are only few commands the CPU can understand. You have to deal with them. If the program doesn&#039;t work the way you like, it&#039;s your fault - see &quot;debugging is easy&quot;.<br /><br />WYWIWYG - What you write is what you get.<br />No High-Level-Compiler alters the written code or adds malicious one because of dubious &quot;optimizations&quot;. Only you are the optimizer.<br /><br />Data structures are easy.<br />Look into disassembled code from a high level language compiler and you will see that sophisticated data structures are often being reduced to a simple form.<br />Use simple data structures to make the algorithm more comprehendable. The versatile addressing modes of the x86-CPU are very comfortable.<br /><br />Debugging is easy.<br />Because you are conform with the assembler syntax, you are also conform with the disassembler syntax from any debugger. Just put an &quot;INT 3&quot; at the desired position in your source code and the debugger will stop there if you run the program.<br /><br />Creating binaries is easy.<br />You don&#039;t have to install a licence restricted multi mega byte super compiler which nestles into your system and buckles all interfaces. A text editor, an Assembler-EXE and a Linker-EXE and are sufficient.<br /></div>
    <div class="meta">Posted on 2008-06-02 22:42:02 by TasmDev</div>
   </div>
   <div class="post" id="post-205443">
    <div class="subject"><a href="#post-205443">Re: ASM's influence in the modern world</a></div>
    <div class="body">There is more.<br /><br />Asm has been evolving for some time now, through the extended functionality of each generation of assemblers.<br /><br />Now asm is evolving though an entirely new(ly-reinvented) programming paradigm that is becoming known as &quot;OOP-asm&quot; (not to be confused with Randy Hyde&#039;s &#039;HLA - HighLevel Assembly&#039; language, which is a standalone preprocessor that emits asm sourcecode).<br /><br />This paradigm has various advantages when compared to various high and/or lowlevel languages - it allows the programmer to take advantage of the benefits of each school of code as it suits them, and in a given context they might choose to lean the code one way or the other. But at the end of the day, its being compiled by an ASSEMBLER - so you have a lot more (full asm) control over register use and choice of operators, where and when you see fit.<br /><br />I repeat - Asm is EVOLVING - it is not a dead NOR a fixed language - it is NOT machinecode - it is as dynamic and symbolic as we WANT it to be - and you HLL purists please note that OOPASM has similar development times, with typically faster and smaller binaries, even without careful optimizing.<br /><br />So much for the new wave :P<br /><br /></div>
    <div class="meta">Posted on 2008-06-03 07:38:01 by Homer</div>
   </div>
  </div>
 </body>
</html>