<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>NumberToString conversion - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29332" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29332">NumberToString conversion</a></p>
   <div class="post" id="post-207160">
    <div class="subject"><a href="#post-207160">NumberToString conversion</a></div>
    <div class="body">I just finished a number to string conversion proc as a learning exercise.&nbsp; My idea was to divide the number by 1 in the largest possible place value and then continue to divide reiteratively, dividing the divisor by 10 each time.&nbsp; After each division I take the quotient and add 48 (the ascii table offset) to it to get that number&#039;s corresponding ascii character.&nbsp; Then at the end taking the last number as is.<br /><br />So that&#039;s my solution and it works like a charm.&nbsp; My question now is:&nbsp; is that the way it&#039;s usually done, or is there a less costly algorithm?&nbsp; There used to be an algorithms section on this board but I couldn&#039;t find it.&nbsp; Cheers!<br /><br />Here&#039;s the code:<br /><br /><pre><code><br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Title: NumberToString<br />;|&nbsp; In: dwNumberIn (Contains the dword value to be converted.)<br />;|&nbsp; &nbsp; &nbsp; dwBufSizeIn (Contains the size, in bytes, of the buffer pointed to.)<br />;|&nbsp; Out: pStringOut (Contains a pointer to the buffer receiving the string.)<br />;|&nbsp; Returns: -2 on buffer to small, -1 on error, 0 if successful<br />;|&nbsp; Notes: Maximum DWORD value is 4,294,967,295 (0xFFFFFFFF)<br />;|&nbsp; Author: R.Daneel&nbsp; &nbsp; &nbsp; <br />;+----------------------------------------------------------------------------+<br />NumberToString&nbsp; &nbsp;proc&nbsp; &nbsp; dwNumberIn:DWORD, pStringOut:DWORD, dwBufSizeIn:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwRemainder:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwQuotient:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwNumber:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;pCharPosition:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwDivCount:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwDivisor:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;boolZeroFlag:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwDigitCount:DWORD<br /><br /><br />&nbsp; &nbsp; ;## Set the zero keeper flag to FALSE<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;boolZeroFlag, FALSE<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Set the initial digit count to zero<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDigitCount, 0<br /><br />&nbsp; &nbsp; ;## Save the original number<br />&nbsp; &nbsp; push&nbsp; &nbsp; dwNumberIn<br />&nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp;dwNumber<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Set the string buffer tracking variable<br />&nbsp; &nbsp; push&nbsp; &nbsp; pStringOut<br />&nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp;pCharPosition<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Set the initial divisor to 1 billion and the div count to 9<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDivisor, 1000000000&nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDivCount, 9<br />&nbsp; &nbsp;<br />&nbsp; &nbsp; ;## Clear the output buffer with zeros<br />&nbsp; &nbsp; pushf<br />&nbsp; &nbsp; cld<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;al, 0<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ecx, dwBufSizeIn<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, pStringOut<br />&nbsp; &nbsp; rep&nbsp; &nbsp; &nbsp;stosb<br />&nbsp; &nbsp; popf<br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Enter the loop to begin dividing down the number by 10&#039;s.&nbsp; The idea is to<br />&nbsp; &nbsp; ;## divide the number again and again by descending 10&#039;s position and use the<br />&nbsp; &nbsp; ;## quotient as the basis for what number goes at that position.&nbsp; Then we add<br />&nbsp; &nbsp; ;## 48 to that number to get to the corresponding ascii character.<br />&nbsp; &nbsp; .WHILE (dwDivCount &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; ;## See if this number is divisible by the divisor<br />&nbsp; &nbsp; &nbsp; &nbsp; nop<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;edx, edx <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumber<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ebx, dwDivisor<br />&nbsp; &nbsp; &nbsp; &nbsp; div&nbsp; &nbsp; &nbsp;ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwRemainder, edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwQuotient, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .IF ((dwQuotient &gt; 0) &amp;&amp; (boolZeroFlag != TRUE))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## Since we&#039;ve hit a number greater than zero, now we need to<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## display the zeros since they&#039;ll have significance.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;boolZeroFlag, TRUE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .IF ((dwQuotient &gt; 0) || (boolZeroFlag == TRUE))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## See if we&#039;ve reached the string size limit<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc&nbsp; &nbsp; &nbsp;dwDigitCount<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwBufSizeIn<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; &nbsp;eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF (dwDigitCount &gt; eax)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## Since there was an error, let&#039;s clear the output buffer <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## with zeros so we don&#039;t give false results.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cld<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;al, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ecx, dwBufSizeIn<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, pStringOut<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep&nbsp; &nbsp; &nbsp;stosb<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popf&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, -2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## This number was larger than the divisor so the quotient<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## should tell us what the first character should be.&nbsp; We need<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## to add 48 to that number to get the equivelant ascii char.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## We then store the character in the first byte of the string.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwQuotient<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp; &nbsp;eax, 48<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, pCharPosition<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stosb<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## Increment to the next byte in the string buffer.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc&nbsp; &nbsp; &nbsp;pCharPosition&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## Now subtract (quotient * divisor) from the original value<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## to begin testing the next position.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WHILE (dwQuotient &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumber<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp;eax, dwDivisor<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwNumber, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; &nbsp;dwQuotient<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ENDW<br />&nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;## Decrement the div count and divide the divisor by 10 to get the<br />&nbsp; &nbsp; &nbsp; &nbsp; ;## next 10&#039;s position to test<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; &nbsp;dwDivCount<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;edx, edx <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwDivisor<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ebx, 10<br />&nbsp; &nbsp; &nbsp; &nbsp; div&nbsp; &nbsp; &nbsp;ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDivisor, eax&nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; .ENDW<br />&nbsp; &nbsp;<br />&nbsp; &nbsp; ;## Put the final remainder in the last string position<br />&nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumber<br />&nbsp; &nbsp; add&nbsp; &nbsp; &nbsp;eax, 48<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, pCharPosition<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; ret<br />NumberToString&nbsp; &nbsp;endp<br /></code></pre></div>
    <div class="meta">Posted on 2009-03-25 16:55:59 by rdaneel</div>
   </div>
   <div class="post" id="post-207165">
    <div class="subject"><a href="#post-207165">Re: NumberToString conversion</a></div>
    <div class="body">Hi,<br />No offence, really, but this is acutally the longest and probably the slowest &quot;dw2ascii&quot; function I&#039;ve ever seen ;) So yeah - there are better ways to do it :P First of all: avoid <strong>any</strong> divisions. Div is generally bad. Then delete this &#039;Clear the output buffer with zeros&#039; because it&#039;s kinda pointless.<br /><br />Look at MASM32&#039;s implementation of &quot;dwtoa&quot;. It should give you some nice ideas :)</div>
    <div class="meta">Posted on 2009-03-26 09:24:41 by ti_mo_n</div>
   </div>
   <div class="post" id="post-207166">
    <div class="subject"><a href="#post-207166">Re: NumberToString conversion</a></div>
    <div class="body">A way to remove one division is to &#039;reverse&#039; your algorithm.<br />You divide out digits from one end, starting with a big divisor, and then cutting down the divisor one digit at a time...<br />The number can be seen as this:<br />number = digit(n) * 10^n + digit(n-1) * 10^(n-1) + ... + digit(1) * 10^1 + digit(0) * 10^0<br /><br />Looking at it another way:<br />digit(0) = number % 10;<br />digit(1) = (number/10) % 10;<br />digit(2) = (number/100) % 10;<br />...<br />digit(n) = number/(10^n) % 10;<br /><br />Basically you can rewrite that as a sequential algorithm:<br />number(n) = number(n-1) / 10;<br />digit(n) = number(n) % 10;<br /><br />This allows you to take advantage of the fact that % 10 and / 10 are a single div operation. Then you just have a single loop... The only difference is that you start filling your buffer from the other side.</div>
    <div class="meta">Posted on 2009-03-26 10:23:44 by Scali</div>
   </div>
   <div class="post" id="post-207167">
    <div class="subject"><a href="#post-207167">Re: NumberToString conversion</a></div>
    <div class="body">ti_mo_n:&nbsp; none taken.&nbsp; i am a terrible asm programmer.&nbsp; this was mostly a mental exercise to see if I could reproduce this function without cheating and looking at the m32lib source.&nbsp; now that I know a way to do it I feel free to cheat. :)&nbsp; i planned on trying to convert those divs to some form of shr+mul after I confirmed that the layout worked.&nbsp; thanks for the info.<br /><br />scali:&nbsp; this seems to be what the m32lib is doing if I read it correctly.&nbsp; now I understand why he reversed the digits in that code.&nbsp; great info.&nbsp; thankyou.<br /><br />- in general, I hate using pre-made code without knowing at least how it accomplishes what it&#039;s doing.&nbsp; once i understand the concept then it doesn&#039;t feel like cheating to use those common functions.&nbsp; maybe i&#039;m just odd.&nbsp; thanks again guys.</div>
    <div class="meta">Posted on 2009-03-26 11:06:48 by rdaneel</div>
   </div>
   <div class="post" id="post-207168">
    <div class="subject"><a href="#post-207168">Re: NumberToString conversion</a></div>
    <div class="body">On a side note (and interesting tidbit) I thought once like that too but unlike you I decided to peek in the m32lib and clearly remember one of my bestest WTF moments ever...&nbsp; :lol:<br /><br /><pre><code>; #########################################################################<br /><br />&nbsp; &nbsp; &nbsp; .386<br />&nbsp; &nbsp; &nbsp; .model flat, stdcall&nbsp; ; 32 bit memory model<br />&nbsp; &nbsp; &nbsp; option casemap :none&nbsp; ; case sensitive<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; wsprintfA PROTO C :DWORD,:VARARG<br />&nbsp; &nbsp; &nbsp; &nbsp; wsprintf equ &lt;wsprintfA&gt;<br /><br />&nbsp; &nbsp; .data<br />&nbsp; &nbsp; &nbsp; fMtStrinG db &quot;%lu&quot;,0<br /><br />&nbsp; &nbsp; .code<br /><br />; #########################################################################<br /><br />dw2a proc dwValue:DWORD, lpBuffer:DWORD<br /><br />&nbsp; &nbsp; ; -------------------------------------------------------------<br />&nbsp; &nbsp; ; convert DWORD to ascii string<br />&nbsp; &nbsp; ; dwValue is passed as a value, direct, indirect or in register<br />&nbsp; &nbsp; ; lpBuffer is the ADDRESS of the receiving buffer<br />&nbsp; &nbsp; ; EXAMPLE:<br />&nbsp; &nbsp; ; invoke dw2a,edx,ADDR buffer<br />&nbsp; &nbsp; ; -------------------------------------------------------------<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke wsprintf,lpBuffer,ADDR fMtStrinG,dwValue<br /><br />&nbsp; &nbsp; ret<br /><br />dw2a endp<br /><br />; #########################################################################<br /><br />end<br /></code></pre></div>
    <div class="meta">Posted on 2009-03-26 11:29:29 by JimmyClif</div>
   </div>
   <div class="post" id="post-207169">
    <div class="subject"><a href="#post-207169">Re: NumberToString conversion</a></div>
    <div class="body">LOL!!!&nbsp; i did the same freakin thing.&nbsp; I saw that call to wsprintf and thought cheater!&nbsp; then i realized i was looking at the wrong file.&nbsp;  :oops:&nbsp; good stuff. lol.</div>
    <div class="meta">Posted on 2009-03-26 12:43:50 by rdaneel</div>
   </div>
   <div class="post" id="post-207170">
    <div class="subject"><a href="#post-207170">Re: NumberToString conversion</a></div>
    <div class="body">You could probably use muls yea.<br />I don&#039;t think I ever tried that... but you could use fixedpoint arithmetic...<br />Namely:<br />1: x / 10 = x * (1/10)<br />Which can be rewritten to (x * (2^32/10)) / (2^32) == (x * (2^32/10)) &gt;&gt; 32<br />And<br />2: x % 10 = x - ((int)(x/10)*10)<br /><br />Substitute x/10 with the first equation, and you have completely removed the divisions from the algorithm.<br />The x*10 operation can also be replaced with some shifts or adds...<br />Eg:<br />y = x + x // x * 2<br />z = x &lt;&lt; 3 // x * 8<br />x = x + y // x * (2 + 8 )<br /><br />Depending on the CPU used, these elaborate substitutions might actually be faster than using a div or mul directly.</div>
    <div class="meta">Posted on 2009-03-26 12:56:41 by Scali</div>
   </div>
   <div class="post" id="post-207171">
    <div class="subject"><a href="#post-207171">Re: NumberToString conversion</a></div>
    <div class="body">I tried my hand at doing it with muls only, no divs...<br />It works, gets a tad inaccurate for numbers close to 2^32, but I&#039;ve put in a correction factor, so it always gives the right result. If you were to optimize it, you could split the algo in two... If you find out where the instability starts, you can just use the quick-and-dirty version for all small numbers, and use the correction only for large numbers.</div>
    <div class="meta">Posted on 2009-03-26 15:42:05 by Scali</div>
   </div>
   <div class="post" id="post-207172">
    <div class="subject"><a href="#post-207172">Re: NumberToString conversion</a></div>
    <div class="body"><div class="quote"><br />I tried my hand at doing it with muls only, no divs...</div><br />What about only one multiplication and no loops :)<br /><a target="_blank" href="http://www.masm32.com/board/index.php?topic=9951.msg73240#msg73240">http://www.masm32.com/board/index.php?topic=9951.msg73240#msg73240</a></div>
    <div class="meta">Posted on 2009-03-26 16:45:01 by drizz</div>
   </div>
   <div class="post" id="post-207173">
    <div class="subject"><a href="#post-207173">Re: NumberToString conversion</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />I tried my hand at doing it with muls only, no divs...</div><br />What about only one multiplication and no loops :)<br /><a target="_blank" href="http://www.masm32.com/board/index.php?topic=9951.msg73240#msg73240">http://www.masm32.com/board/index.php?topic=9951.msg73240#msg73240</a><br /></div><br /><br />I&#039;d rather hear the explanation than see the code.</div>
    <div class="meta">Posted on 2009-03-26 16:58:44 by Scali</div>
   </div>
   <div class="post" id="post-207174">
    <div class="subject"><a href="#post-207174">Re: NumberToString conversion</a></div>
    <div class="body">Sure,<br /><br />maximum unsiged 32bit number is 4294967295, thats 10 digits in base 10<br />im using fixed point arithmetic to get decimal digit in the last 4 bits of a 64bit number<br /><br />only small difference is handling the first digit, it can be max 4<sub>(10)</sub><br />i&#039;m going to multiply the number by 2<sup>(64-A)</sup>/B<br />where A is the number of bits of number 4<br />4<sub>(10)</sub> = 100<sub>(2)</sub>, that is 3 bits, A=3<br />B = 10<sup>Int(Log10(4294967295))</sup><br /><br />2^(64-A)/B = 0x089705F41<br /><br />after handling the first digit, we get subsequent digits by multiplying with 10<br />the digit is in the last nibble of 64bit number (last 4 bits)<br /><br /><pre><code><br />dw2ascii(DWORD val)<br />{<br />	//val=4294967295;<br />	QWORD x,y;<br />	DWORD i,j;<br />	<br />	x=(QWORD)val*0x089705F41; // mul by 2^(64-3)/1000000000<br />	x+=0x70000000; // this is only needed for when val is very big ~~ 4294967295 <br />	i=x&gt;&gt;(64-3); // last 3 bits == either 0,1,2,3 or 4<br />	printf(&quot;%u&quot;,i);<br />	// move the number in position and clear out the last nibble (4 bits)<br />	x&gt;&gt;=1; <br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;// mask out everything but the last nibble<br />	x*=10;// multiply by 10 to get next digit in the last nibble<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br />	<br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br /><br />	x=x&amp;0xFFFFFFFFFFFFFFF;<br />	x*=10;<br />	i=x&gt;&gt;(64-4);<br />	printf(&quot;%u&quot;,i);<br />	<br />}<br /><br /></code></pre><br /><br />Oh, and full 64bits are only needed for first 2 digits, afterwards lower dword can be ignored <br /></div>
    <div class="meta">Posted on 2009-03-26 18:26:47 by drizz</div>
   </div>
   <div class="post" id="post-207177">
    <div class="subject"><a href="#post-207177">Re: NumberToString conversion</a></div>
    <div class="body">Yea, thanks.<br />I half figured out your code... I saw that you were multiplying by 10 all the time, extracting one digit from the most significant part of the register.<br />That made me think that you used a constant to basically scale 1000000000 up to 0x10000000 (so most significant decimal digit becomes most significant hexadecimal digit.. in a way... and that means the top 4 bits).<br /><br />I didn&#039;t really have the time yet to fully analyse your constant, but I did see there was some kind of special case. And right, good observation that the top digit can only be 0-4, so you need less bits than for the rest.<br /><br />One thing though... Why exactly do you do this:<br />x+=0x70000000; // this is only needed for when val is very big ~~ 4294967295<br /><br />I suppose 0x700000000 is the equivalent of 0.5 in the upscaled number? So basically you use it to round to nearest (as a proper div would do), rather than rounding down?<br /><br />At any rate, it&#039;s a very elegant routine... If it&#039;s completely robust for all numbers between 0 and 2^32, that&#039;d be great.<br />I bet if I write out all my multiplications into a formula, this relation will somehow follow from it. I used the &#039;reverse&#039; method like with divisions, starting out with the lowest digit first. But for multiply, using the highest digit first makes a lot more sense.</div>
    <div class="meta">Posted on 2009-03-27 02:50:46 by Scali</div>
   </div>
   <div class="post" id="post-207178">
    <div class="subject"><a href="#post-207178">Re: NumberToString conversion</a></div>
    <div class="body">DIV isn&#039;t too bad on newer cpu&#039;s but using SSEx (if you can) is the way to go.</div>
    <div class="meta">Posted on 2009-03-27 02:59:59 by sinsi</div>
   </div>
   <div class="post" id="post-207179">
    <div class="subject"><a href="#post-207179">Re: NumberToString conversion</a></div>
    <div class="body"><div class="quote"><br />Yea, thanks.<br />I half figured out your code... I saw that you were multiplying by 10 all the time, extracting one digit from the most significant part of the register.<br />That made me think that you used a constant to basically scale 1000000000 up to 0x10000000 (so most significant decimal digit becomes most significant hexadecimal digit.. in a way... and that means the top 4 bits).<br /><br />I didn&#039;t really have the time yet to fully analyse your constant, but I did see there was some kind of special case. And right, good observation that the top digit can only be 0-4, so you need less bits than for the rest.<br /><br />One thing though... Why exactly do you do this:<br />x+=0x70000000; // this is only needed for when val is very big ~~ 4294967295<br /><br />I suppose 0x700000000 is the equivalent of 0.5 in the upscaled number? So basically you use it to round to nearest (as a proper div would do), rather than rounding down?<br /><br />At any rate, it&#039;s a very elegant routine... If it&#039;s completely robust for all numbers between 0 and 2^32, that&#039;d be great.<br />I bet if I write out all my multiplications into a formula, this relation will somehow follow from it. I used the &#039;reverse&#039; method like with divisions, starting out with the lowest digit first. But for multiply, using the highest digit first makes a lot more sense.<br /></div><br /><br />You are correct in your observations, and the function works for all numbers in [0 , 2<sup>32</sup>-1] interval.<br />0x70000000 value is empiricaly chosen and yes its for rounding, sorry for the misleading comment<br /> <br /><pre><code>dw2ascii(DWORD val,BYTE *pbuff)<br />{<br />	//DWORD val=4294967295;<br />	QWORD x;<br />	DWORD i,j;<br />	<br />	x=(QWORD)val*0x089705F41; // mul by 2^(64-3)/1000000000<br />	x+=0x70000000;<br />	i=x&gt;&gt;(64-3); // last 3 bits == either 0,1,2,3 or 4<br />	<br />	pbuff[0]=i+0x30;<br />	<br />	x&gt;&gt;=1; 	// clear out the last nibble (4 bits)<br />	x=x&amp;0xFFFFFFFFFFFFFFF;// mask out everything but the last nibble<br />	x*=10;// multiply by 10 to get next digit in the last nibble<br />	i=x&gt;&gt;(64-4);<br />	<br />	pbuff[1]=i+0x30;<br />	<br />	j=(x&gt;&gt;32)&amp;0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[2]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[3]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[4]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[5]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[6]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[7]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[8]=i+0x30;<br /><br />	j&amp;=0xFFFFFFF;<br />	j*=10;<br />	i=j&gt;&gt;(32-4);<br />	pbuff[9]=i+0x30;<br />	<br />	pbuff[10]=0;<br />}<br /></code></pre><br /></div>
    <div class="meta">Posted on 2009-03-27 07:37:57 by drizz</div>
   </div>
   <div class="post" id="post-207181">
    <div class="subject"><a href="#post-207181">Re: NumberToString conversion</a></div>
    <div class="body">Thanks for the explanation.<br />It was fun trying to dissect your code, and making my own version. I&#039;ll try to complete my version tonight, now that the last few details have been worked out (hopefully)... It sorta worked, but wasn&#039;t accurate enough for all digits.<br /><br />I think it&#039;s fun and very useful to solve problems without using the &#039;obvious&#039; solution, based on simple maths.<br />In the past, I used a Commodore 64, which didn&#039;t even have instructions for mul and div at all. You could only add, sub and shift (one bit at a time).<br />Since I had to write my own mul and div routines, it gave me a nice insight in how various operations relate, and how analysing bit-patterns can be useful in skipping certain operations, or rewriting things for more efficient instructions.</div>
    <div class="meta">Posted on 2009-03-27 09:29:49 by Scali</div>
   </div>
   <div class="post" id="post-207182">
    <div class="subject"><a href="#post-207182">Re: NumberToString conversion</a></div>
    <div class="body">You don&#039;t have to tell me that assembly is fun&nbsp; :P<br /><br />For the brave ones that want to apply this tehnique for 64bit number-to-string <br />2^127/10^19 = 17014118346046923173 (0EC1E4A7DB69561A5H) is a nice constant<br /><br />here is a quick test that shows it works for 64bits too (watch the leftmost nibble)<br />FFFFFFFFFFFFFFFF<sub>(16)</sub> = 18446744073709551615<sub>(10)</sub><br /><span style="font-family:Monospace">EC1E4A7DB69561A5 * FFFFFFFFFFFFFFFF<br /> = EC1E4A7DB69561A413E1B582496A9E5B<br />------------------------------------<br /> = EC1E4A7DB69561A413E1B582496A9E5B .<br /> = 1D83C94FB6D2AC34827C36B0492D53CB .<br /> = 8725DD1D243ABA0D18DA22E2DBC545EE<br /> = 477AA3236A4B448C<br /> = 4ACA5F6226F0AD78<br /> = 6BE7B9D58566C6B0<br /> = 770D42573603C2E0<br /> = 468497681C259CC0<br /> = 412DEA1119781F80<br /> = 0BCB24AAFEB13B00<br /> = 75EF6EADF2EC4E00<br /> = 3B5A52CB7D3B0C00<br /> = 71873BF2E44E7800<br /> = 0F48577CEB10B000<br /> = 98D36AE12EA6E000<br /> = 58422CCBD284C000<br /> = 5295BFF6392F8000<br /> = 19D97F9E3BDB0000<br /> = 627EFC2E568E0000<br /> = 18F5D9CF618C0000<br /> = 599A8219CF780000</span><br />again for first 2 digits we need 128bits and afterwards only 64.</div>
    <div class="meta">Posted on 2009-03-27 10:36:41 by drizz</div>
   </div>
   <div class="post" id="post-207185">
    <div class="subject"><a href="#post-207185">Re: NumberToString conversion</a></div>
    <div class="body">ok, here is a test version of 64bitNumberToString, needs further testing and optimizing.<br /><br /><pre><code>__declspec(naked) __stdcall _U64ToStr (QWORD val, BYTE *pbuff)<br />{<br />	__asm<br />	{<br />		#define __locals 4*4+4*4//4*4=regs + 4*4=128bit temp<br />		#define __saveregs dword ptr <br />		#define __128bittmp dword ptr <br />		#define __val_hi dword ptr <br />		#define __val_lo dword ptr <br />		#define __pbuff dword ptr <br />		#define __cnst_hi 0xEC1E4A7D<br />		#define __cnst_lo 0xB69561A5<br />		#define __correction_lo 0xE30437FB<br />		#define __correction_hi 0xAD7B4F1B<br />		sub esp,__locals<br />		mov __saveregs[0*4],ebp<br />		mov __saveregs[1*4],esi<br />		mov __saveregs[2*4],edi<br />		mov __saveregs[3*4],ebx<br />		//<br />		// 64bit x 64bit = 128bit result<br />		// -------------------------------<br />		mov esi,__val_lo//__x_lo<br />		mov edi,__val_hi//__x_hi<br />		mov eax,__cnst_lo//__y_lo; = b0<br />		mul esi;// get a0*b0 = d1:d0<br />		//mov ebp,__r_lo<br />		mov __128bittmp[0*4],eax;//d0<br />		mov ecx,edx;//d1<br />		mov eax,__cnst_lo//__y_lo; = b0<br />		xor ebx,ebx<br />		mul edi;// get a1*b0 = e1:e0<br />		add ecx,eax;//e0<br />		adc ebx,edx;//e1<br />		mov eax,__cnst_hi//__y_hi; =b1<br />		mul esi;// get a0*b1 = f1:f0<br />		add ecx,eax;//f0<br />		adc ebx,edx;//f1<br />		mov __128bittmp[1*4],ecx<br />		mov ecx,0<br />		mov eax,__cnst_hi//__y_hi; =b1<br />		adc ecx,ecx<br />		//mov ebp,__r_hi<br />		mul edi;// get a1*b1 = g1:g0<br />		add eax,ebx;//g0<br />		adc edx,ecx;//g1<br />		mov __128bittmp[2*4],eax<br />		mov __128bittmp[3*4],edx<br />		// -------------------------------<br />		xor eax,eax<br />		add __128bittmp[0*4],__correction_lo<br />		adc __128bittmp[1*4],__correction_hi<br />		adc __128bittmp[2*4],eax<br />		adc __128bittmp[3*4],eax<br />		// -------------------------------<br />		mov eax,&#039;0&#039;<br />		mov edx,__128bittmp[3*4]<br />		add edx,edx//high dword of high qword<br />		adc eax,0// first digit 0 or 1<br />		mov ebp,__pbuff<br />		mov ,al<br /> 		shr edx,1<br /> 		//mov __128bittmp[3*4],edx<br /> 		//<br />		mov esi,__128bittmp[0*4]<br />		mov edi,__128bittmp[1*4]<br />		mov eax,__128bittmp[2*4]<br />		//mov edx,__128bittmp[3*4]<br />		<br />		// move into position<br />		shrd esi,edi,3<br />		shrd edi,eax,3<br />		shrd eax,edx,3<br />		shr edx,3<br />		<br />		// mul by 10<br />		<br />		mov __128bittmp[0*4],esi<br />		mov __128bittmp[1*4],edi<br />		mov __128bittmp[2*4],eax<br />		mov __128bittmp[3*4],edx<br />		shld edx,eax,2<br />		shld eax,edi,2<br />		shld edi,esi,2<br />		shl esi,2<br />		add esi,__128bittmp[0*4]<br />		adc edi,__128bittmp[1*4]<br />		adc eax,__128bittmp[2*4]<br />		adc edx,__128bittmp[3*4]<br />		add esi,esi<br />		adc edi,edi<br />		adc eax,eax<br />		adc edx,edx<br />		<br />		mov ebx,edx<br />		and edx,0x0FFFFFFF<br />		shr ebx,32-4<br />		add ebx,&#039;0&#039;<br />		mov byte ptr ,bl<br />		<br />		// mul by 10<br />		<br />		mov __128bittmp[0*4],esi<br />		mov __128bittmp[1*4],edi<br />		mov __128bittmp[2*4],eax<br />		mov __128bittmp[3*4],edx<br />		shld edx,eax,2<br />		shld eax,edi,2<br />		shld edi,esi,2<br />		shl esi,2<br />		add esi,__128bittmp[0*4]<br />		adc edi,__128bittmp[1*4]<br />		adc eax,__128bittmp[2*4]<br />		adc edx,__128bittmp[3*4]<br />		add esi,esi<br />		adc edi,edi<br />		adc eax,eax<br />		adc edx,edx<br />		<br />		mov ebx,edx<br />		and edx,0x0FFFFFFF<br />		shr ebx,32-4<br />		add ebx,&#039;0&#039;<br />		mov byte ptr ,bl<br />		<br />		#define shouldbeunrolled 17<br />		mov ecx,-shouldbeunrolled<br />	_L0:<br />		mov esi,eax;<br />		mov edi,edx;<br />		shld edx,eax,2;<br />		shl eax,2;<br />		add eax,esi;<br />		adc edx,edi;<br />		add eax,eax;<br />		adc edx,edx;<br />		mov ebx,edx;<br />		and edx,0x0FFFFFFF;<br />		shr ebx,32-4;<br />		add ebx,&#039;0&#039;;<br />		mov byte ptr ,bl;<br />		inc ecx<br />		jnz _L0<br />		<br /><br />		mov byte ptr ,0<br />		// -------------------------------<br />		mov ebp,__saveregs[0*4]<br />		mov esi,__saveregs[1*4]<br />		mov esi,__saveregs[2*4]<br />		mov ebx,__saveregs[3*4]<br />		add esp,__locals<br />		ret 8+4<br />	}<br />}<br /></code></pre></div>
    <div class="meta">Posted on 2009-03-29 11:54:30 by drizz</div>
   </div>
  </div>
 </body>
</html>