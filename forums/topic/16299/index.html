<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Library: Strings - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16299" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=49">ASM Book Project</a> &raquo; <a href="../?id=16299">Library: Strings</a></p>
   <div class="post" id="post-126608">
    <div class="subject"><a href="#post-126608">Library: Strings</a></div>
    <div class="body">I'm putting all the tested string related code over here.<br /><br />To start with the famous string length function from Agner Fog:<br /><br /><br /><strong>String Length</strong><br /><pre><code><br />;+--------------------------------------------------------<br />;<br />;  _cstrlen<br />; <br />; Description&#58;<br />;     Determines the length of a null-terminated<br />;     string.<br />;<br />; Prototype&#58;<br />;      1. C&#58;<br />;           extern &quot;C&quot; <br />;           DWORD __stdcall <br />;           _cstrlen&#40;<br />;               char *lpszString        // input string<br />;           &#41;;<br />;<br />; Params&#58;<br />;       lpszString<br />;             pointer to string.<br />;<br />; Returns&#58;<br />;     DWORD value in EAX.<br />;<br />; Revision History&#58;<br />;      01-11-2000&#58; Slightly modified by Jeremy <br />;             Collake &#40;lowercase code&#41;<br />;             to force dword alignment.<br />;<br />; Notes&#58;<br />;     The proc is exported with name mangling<br />;     enabled, and another alias for it has been<br />;     created for it in the .def file like this&#58;<br />;     &quot;_cstrlen=__cstrlen@4&quot;<br />;     Both call the same function.<br />;<br />;--------------------------------------------------------------------<br />align 4<br />_cstrlen PROC    export uses ebx edx  lpszString&#58;DWORD<br />        MOV     EAX,lpszString            ; get pointer to string<br />        LEA     EDX,&#91;EAX+3&#93;            ; pointer+3 used in the end<br />        mov	ebx,&#91;eax&#93;<br />	add	eax,4<br />	lea	ecx,&#91;ebx-01010101h&#93;<br />	not	ebx<br />        and	ecx,ebx<br />        and	ecx,80808080h<br />        jnz	j1<br />        shr	eax,2<br />        shl	eax,2        <br />L1&#58;    MOV     EBX,&#91;EAX&#93;              ; read first 4 bytes<br />        ADD     EAX,4                  ; increment pointer<br />        LEA     ECX,&#91;EBX-01010101H&#93;    ; subtract 1 from each byte<br />        NOT     EBX                    ; invert all bytes<br />        AND     ECX,EBX                ; and these two<br />        AND     ECX,80808080H          ; test all sign bits<br />        JZ      L1                     ; no zero bytes, continue loop<br />j1&#58;<br />        TEST    ECX,00008080H          ; test first two bytes<br />        JNZ     SHORT L2<br />        SHR     ECX,16                 ; not in the first 2 bytes<br />        ADD     EAX,2<br />L2&#58;     SHL     CL,1                   ; use carry flag to avoid branch<br />        SBB     EAX,EDX                ; compute length<br />        RET    <br />_cstrlen ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2003-12-04 17:50:45 by Art Sands</div>
   </div>
   <div class="post" id="post-128369">
    <div class="subject"><a href="#post-128369">Library: Strings</a></div>
    <div class="body">Art Sands,<br /><br />I am submitting this version of the string length subroutine.  I tested it and it appears to work OK.  Ratch<br /><br /><pre><code><br />;-------------------------------------------------------------------------------<br />;*******************************************************************************<br />; STRLEN&#58;    Calculates the length of a ASCII string terminated by a zero byte.*<br />;                                                                              *<br />; Called by&#58; PUSH &lt;address of string&gt;                                          *<br />;            CALL STRLEN                                                       *<br />;                                                                              *<br />; Returns&#58;   EAX=String Length--Length does NOT include zero byte terminator.  *<br />;                                                                              *<br />; Notes&#58;     This subroutine conforms with WIN32 conventions regarding         *<br />;            register preservation and stack balancing.                        *<br />;                                                                              *<br />; Coder&#58;     Ratch                                                             *<br />;*******************************************************************************<br />STRLEN&#58;                     ;it all begins here<br />  MOV EAX,&#91;ESP+DWORD&#93;       ;address of string<br /><br />  .REPEAT                   ;searching string ....<br />    MOV EDX,&#91;EAX&#93;           ;next 4 byte gulp &#40;DWORD&#41;<br />    ADD EAX,DWORD           ;EAX=character pointer<br />    LEA ECX,&#91;EDX-01010101H&#93; ;propagate if byte is zero<br />    NOT EDX                 ;set up test pattern<br />    AND EDX,ECX             ;leftmost bit of zero byte should now be set<br />    AND EDX,080808080H      ;sieve out zero bytes<br />  .UNTIL !ZERO?             ;check the next DWORD<br /><br />                            ;we now know the current DWORD contains a zero byte<br />  SUB EAX,DWORD+BYTE        ;compensate for entry additions into loops<br /><br />  .REPEAT                   ;searching current DWORD ...<br />    INC EAX                 ;increase word count if no carry from shift<br />    ROR EDX,8               ;bring leftmost bit of each byte into carry flag<br />  .UNTIL CARRY?             ;if carry flag set, byte is zero<br /> <br />  SUB EAX,&#91;ESP+DWORD&#93;       ;subtract beginning of string to get length<br /><br />  RET DWORD                 ;all done, and string length in EAX<br />                            ;return to sender and balance the stack<br />;-------------------------------------------------------------------------------</code></pre></div>
    <div class="meta">Posted on 2003-12-18 21:25:49 by Ratch</div>
   </div>
   <div class="post" id="post-128376">
    <div class="subject"><a href="#post-128376">here's Microsoft's code</a></div>
    <div class="body"><pre><code><br />        page    ,132<br />        title   strlen - return the length of a null-terminated string<br />;***<br />;strlen.asm - contains strlen&#40;&#41; routine<br />;<br />;       Copyright &#40;c&#41; Microsoft Corporation. All rights reserved.<br />;<br />;Purpose&#58;<br />;       strlen returns the length of a null-terminated string,<br />;       not including the null byte itself.<br />;<br />;*******************************************************************************<br /><br />        .xlist<br />        include cruntime.inc<br />        .list<br /><br />page<br />;***<br />;strlen - return the length of a null-terminated string<br />;<br />;Purpose&#58;<br />;       Finds the length in bytes of the given string, not including<br />;       the final null character.<br />;<br />;       Algorithm&#58;<br />;       int strlen &#40;const char * str&#41;<br />;       &#123;<br />;           int length = 0;<br />;<br />;           while&#40; *str++ &#41;<br />;                   ++length;<br />;<br />;           return&#40; length &#41;;<br />;       &#125;<br />;<br />;Entry&#58;<br />;       const char * str - string whose length is to be computed<br />;<br />;Exit&#58;<br />;       EAX = length of the string &quot;str&quot;, exclusive of the final null byte<br />;<br />;Uses&#58;<br />;       EAX, ECX, EDX<br />;<br />;Exceptions&#58;<br />;<br />;*******************************************************************************<br /><br />        CODESEG<br /><br />        public  strlen<br /><br />strlen  proc<br /><br />        .FPO    &#40; 0, 1, 0, 0, 0, 0 &#41;<br /><br />string  equ     &#91;esp + 4&#93;<br /><br />        mov     ecx,string              ; ecx -&gt; string<br />        test    ecx,3                   ; test if string is aligned on 32 bits<br />        je      short main_loop<br /><br />str_misaligned&#58;<br />        ; simple byte loop until string is aligned<br />        mov     al,byte ptr &#91;ecx&#93;<br />        add     ecx,1<br />        test    al,al<br />        je      short byte_3<br />        test    ecx,3<br />        jne     short str_misaligned<br /><br />        add     eax,dword ptr 0         ; 5 byte nop to align label below<br /><br />        align   16                      ; should be redundant<br /><br />main_loop&#58;<br />        mov     eax,dword ptr &#91;ecx&#93;     ; read 4 bytes<br />        mov     edx,7efefeffh<br />        add     edx,eax<br />        xor     eax,-1<br />        xor     eax,edx<br />        add     ecx,4<br />        test    eax,81010100h<br />        je      short main_loop<br />        ; found zero byte in the loop<br />        mov     eax,&#91;ecx - 4&#93;<br />        test    al,al                   ; is it byte 0<br />        je      short byte_0<br />        test    ah,ah                   ; is it byte 1<br />        je      short byte_1<br />        test    eax,00ff0000h           ; is it byte 2<br />        je      short byte_2<br />        test    eax,0ff000000h          ; is it byte 3<br />        je      short byte_3<br />        jmp     short main_loop         ; taken if bits 24-30 are clear and bit<br />                                        ; 31 is set<br /><br />byte_3&#58;<br />        lea     eax,&#91;ecx - 1&#93;<br />        mov     ecx,string<br />        sub     eax,ecx<br />        ret<br />byte_2&#58;<br />        lea     eax,&#91;ecx - 2&#93;<br />        mov     ecx,string<br />        sub     eax,ecx<br />        ret<br />byte_1&#58;<br />        lea     eax,&#91;ecx - 3&#93;<br />        mov     ecx,string<br />        sub     eax,ecx<br />        ret<br />byte_0&#58;<br />        lea     eax,&#91;ecx - 4&#93;<br />        mov     ecx,string<br />        sub     eax,ecx<br />        ret<br /><br />strlen  endp<br /><br />        end<br /></code></pre></div>
    <div class="meta">Posted on 2003-12-18 22:33:36 by evil__donkey</div>
   </div>
   <div class="post" id="post-128381">
    <div class="subject"><a href="#post-128381">Library: Strings</a></div>
    <div class="body">evil__donkey,<br /><br />Yikes! What qualifications do they require of their programmers?  Are the APIs written that badly too?  Ratch</div>
    <div class="meta">Posted on 2003-12-18 23:03:59 by Ratch</div>
   </div>
   <div class="post" id="post-128382">
    <div class="subject"><a href="#post-128382">Library: Strings</a></div>
    <div class="body">well it's from the c runtime, and you know Microsoft. they write clean but shit code. btw, can you explain why they are aligning the string here.</div>
    <div class="meta">Posted on 2003-12-18 23:19:40 by evil__donkey</div>
   </div>
   <div class="post" id="post-128401">
    <div class="subject"><a href="#post-128401">Library: Strings</a></div>
    <div class="body"><div class="quote"><br />can you explain why they are aligning the string here. </div><br /><br />From Agner Fog's manual: &quot;On P1 and PMMX, misaligned data will take at least 3 clock cycles extra to access if a 4-byte boundary is crossed.&quot; Aligning the string (if required) should speed up their main_loop on older processors.</div>
    <div class="meta">Posted on 2003-12-19 07:20:50 by Frank</div>
   </div>
   <div class="post" id="post-128408">
    <div class="subject"><a href="#post-128408">Library: Strings</a></div>
    <div class="body">Frank,<br />OK, I added string alignment to the program I submitted earlier.  The code to do this can be switched on or off depending on the need.  Also the two small loops can be rolled or unrolled by a switch for speed or space.  The choice is yours.  Ratch</div>
    <div class="meta">Posted on 2003-12-19 10:48:07 by Ratch</div>
   </div>
   <div class="post" id="post-128612">
    <div class="subject"><a href="#post-128612">Library: Strings</a></div>
    <div class="body">Anyway, the strlen posted by evil_donkey does look like the one posted by lingo whom claims that piece of code is the fastest strlen. <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=8330">http://www.asmcommunity.net/board/index.php?topic=8330</a></div>
    <div class="meta">Posted on 2003-12-22 01:29:19 by roticv</div>
   </div>
   <div class="post" id="post-128625">
    <div class="subject"><a href="#post-128625">Library: Strings</a></div>
    <div class="body">Humm, is it legal to re-port the MS CRT sourcecode?</div>
    <div class="meta">Posted on 2003-12-22 07:02:26 by f0dder</div>
   </div>
   <div class="post" id="post-128626">
    <div class="subject"><a href="#post-128626">Library: Strings</a></div>
    <div class="body">ms provides the source code for free with vs .net, and so long as you include the copyright, i think it should be ok.</div>
    <div class="meta">Posted on 2003-12-22 07:09:51 by evil__donkey</div>
   </div>
   <div class="post" id="post-156417">
    <div class="subject"><a href="#post-156417">Library: Strings</a></div>
    <div class="body">Here is a subroutine to find the first instance of multiple characters in a string with only one string scan.<br /><br />INVOKIT MFNDCHR,@ STRADR,'a','A','e','E','i','I','o','O','u','U',0 ;find first instance of a vowel in a string<br /><br />INVOKIT MFNDCHR,@ STRADR,'.','!','?',0 ;parse out a sentence<br /><br />Note the caution about always PUSHing a zero onto the stack first!<br />Notice the nonstandard coding to return from the subroutine.  Ratch<br /><br /><pre><code><br />;-------------------------------------------------------------------------------<br />;*******************************************************************************<br />; MFNDCHR&#58;   Returns the address of the first character found within a string  *<br />;            from a list of characters PUSHed onto the stack.                  *<br />;                                                                              *<br />; Called by&#58; INVOKIT MFNDCHR,@ STRADR,&lt;char&gt;,&lt;char&gt;,&lt;char&gt;,&lt;char&gt;,...,0        *<br />;                                                                              *<br />; Example&#58;   INVOKIT MFNDCHR,@ STRADR,'a','A','e','E','i','I','o','O','u','U',0*<br />;                                                                              *<br />; Returns&#58;   EAX=address, NOT the index of the character within the string. To *<br />;            get the index, subtract the string address from EAX.              *<br />;                                                                              *<br />; Notes&#58;     A parameter of 0 MUST be PUSHed onto the stack FIRST!             * <br />;            This marks the end of the stack and also searches for the string  *<br />;            terminator.  Failure to do this will result in performance error. *<br />;                                                                              *<br />;            This subroutine conforms with WIN32 conventions regarding         *<br />;            register preservation and stack balancing.                        *<br />;                                                                              *<br />; Coder&#58;     Ratch                                                             *<br />;*******************************************************************************<br /><br />MFNDCHR$1 STRUCT<br />  DWORD 4 DUP &#40;?&#41; ;register save area<br />  RETURN DWORD ?<br />  STRADR DWORD ?<br />  FIRSTP DWORD ?<br />; ....   DWORD ?  ;any number of parameter chars can be pushed onto stack<br />MFNDCHR$1 ENDS<br /><br />S$1 EQU ESP.MFNDCHR$1          ;save some typing<br /><br /> .CODE<br /><br />MFNDCHR&#58;                       ;it all begins here<br />  RPUSHIT EBX,EBP,ESI,EDI      ;save those registers<br />  MOV EBP,01010101H            ;replication constant<br />  MOV EDI,&#91;S$1.STRADR&#93;         ;address of string<br /><br />  .REPEAT                      ;searching string ....<br />    LEA ESI,&#91;S$1.FIRSTP&#93;       ;pointer to char list<br />    XOR EBX,EBX                ;clear accumulation mask<br /><br />    .REPEAT                    ;searching DWORD for chars from list<br />      MOV EAX,&#91;ESI&#93;            ;next char to check<br />      MUL EBP                  ;replication operation<br />      MOV ECX,EBP              ;@@@ prepare for propagation operation<br />      MOV EDX,&#91;EDI&#93;            ;next DWORD<br />      NEG ECX                  ;@@@ prepare for propagation operation<br />      XOR EDX,EAX              ;add to accumulation mask<br />      ADD ECX,EDX              ;@@@ propagation operation<br />;      LEA ECX,&#91;EDX-01010101H&#93; ;this instruction replaces the 3 above marked with @@@<br />      NOT EDX                  ;prepare for propagation operation<br />      AND EDX,ECX              ;propagation operation<br />      ADD ESI,DWORD            ;increment pointer for chars to check<br />      OR EBX,EDX               ;update accumulation mask<br />      TEST EAX,EAX             ;check if done with char list<br />    .UNTIL ZERO?<br /><br />    ADD EDI,DWORD              ;increment pointer for DWORD of string<br />    AND EBX,80808080H          ;sieve out zero bytes from accumulation mask<br />  .UNTIL !ZERO?                ;check for successful search<br /><br />  .REPEAT                      ;searching current DWORD ...<br />    INC EDI                    ;increase char count if no carry from shift<br />    ROR EBX,8                  ;bring leftmost bit of each byte into carry flag<br />  .UNTIL CARRY?                ;if carry flag set, at least one byte is zero<br /><br /><br />  LEA EDX,&#91;S$1.STRADR&#93;         ;prepare to compute number of params pushed<br />  LEA EAX,&#91;EDI-DWORD-BYTE&#93;     ;adjust found char address<br />  SUB EDX,ESI                  ;EDX=negative value of number of params pushed<br /><br />  POPIT EBX,EBP,ESI,EDI        ;restore those registers<br />  POP ECX                      ;ECX=return address<br />  SUB ESP,EDX                  ;balance stack<br />  JMP ECX                      ;return to sender<br />;-------------------------------------------------------------------------------<br /></code></pre></div>
    <div class="meta">Posted on 2005-01-29 01:09:27 by Ratch</div>
   </div>
   <div class="post" id="post-157731">
    <div class="subject"><a href="#post-157731">Library: Strings</a></div>
    <div class="body">here is a nice small strlen: <a target="_blank" href="http://modseven.de/pastebin.php?id=25">http://modseven.de/pastebin.php?id=25</a></div>
    <div class="meta">Posted on 2005-03-05 17:57:56 by dila</div>
   </div>
  </div>
 </body>
</html>