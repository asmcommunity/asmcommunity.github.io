<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>D3D Pipeline Order - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14469" />
  <link rel="prev" href="../?id=14469&amp;page=1" />  <link rel="next" href="../?id=14469&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=14469">D3D Pipeline Order</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=14469&amp;page=1" style="">&laquo;</a><a href="../?id=14469&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="14469" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=14469&amp;page=3">&gt;</a><a href="../?id=14469&amp;page=3">&raquo;</a></form>   <div class="post" id="post-216272">
    <div class="subject"><a href="#post-216272">Re: D3D Pipeline Order</a></div>
    <div class="body">The normalization is the equivalent of the clipping operation, forcing vertices into a unit space, but with some clever hardware optimizing we can predict the result of the w divide and reject early, thus the clipping itself is done in hardware - but the transform into unit space is up to us.</div>
    <div class="meta">Posted on 2012-09-21 03:06:12 by Homer</div>
   </div>
   <div class="post" id="post-216274">
    <div class="subject"><a href="#post-216274">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />The normalization is the equivalent of the clipping operation, forcing vertices into a unit space, but with some clever hardware optimizing we can predict the result of the w divide and reject early, thus the clipping itself is done in hardware - but the transform into unit space is up to us.<br /></div><br /><br />You still don&#039;t have a clue, do you?<br />1) There *is* no normalization being done on position data anywhere.<br />2) Normalizing position data has no geometric meaning whatsoever. It would merely corrupt your meshes on screen. For example, take a cube with reasonably tessellated sides, centered around (0,0,0). If you normalize all its vertices, the result is a (unit) sphere (all vertex positions will be normalized to have the same (unit) length from the origin).<br />&#039;Forcing vertices into a unit space&#039; makes no sense. If they don&#039;t fit, they don&#039;t fit.<br />3) The homogeneous division (which you mistakenly equate to normalization) does not perform clipping. Link to a common polygon clipping algorithm was already provided. The algorithm did not even remotely resemble a homogeneous division.<br />4) Not all your geometry will always fit into the unit cube, not even after homogeneous division. See example screenshots of triangles and torus object which fall partly off the screen, hence are partly outside the unit cube.<br />Anyone with a bit of common sense will see that there&#039;s no way the clipped triangles in the screenshot can be the result of merely rejecting vertices from a triangle.<br />In fact, anyone with a bit of common sense will see that rejecting a single vertex from a triangle is equivalent to rejecting the entire triangle.<br />And with a bit more common sense, they would also see that there is no way to clip a triangle like that by merely performing a division.<br />5) Part of transforming into unit space is the homogeneous division, which is automatically performed by the fixed-function rasterization stage on the GPU, and as such is not &#039;up to us&#039;.<br />6) Clipping does not force vertices into a space. It clips off the parts of the geometry that do not fit in the space, and introduces new geometry (new polygon edges) so that the resulting object DOES fit (without any corruption/warping/etc).<br /><br />How long are you going to try to keep this up?<br /><br />In fact, let&#039;s make this interesting.<br />In the second clipped triangle screenshot that I posted earlier, we have a screen of 320x200 resolution.<br />The projected triangle has the following coordinates in screenspace (x,y):<br />(-10,20), (50,240), (380,100)<br /><br />How do we get from these three coordinates (which are all outside the screen area) to the clipped triangle we see on screen?<br />Which of the vertices do we reject? What do we divide?</div>
    <div class="meta">Posted on 2012-09-21 03:27:47 by Scali</div>
   </div>
   <div class="post" id="post-216277">
    <div class="subject"><a href="#post-216277">Re: D3D Pipeline Order</a></div>
    <div class="body">Isn&#039;t it strange that my renderer works at all, given that I am completely wrong :)<br /><br /><pre><code><br />// This shader sourcecode belongs at the start of the shader &#039;main&#039; function,<br />// it transforms the input ModelSpace vertex position, into WorldSpace, ViewSpace and ClipSpace.<br />//<br />const char* szQuaternionShaderMain = <br />						&quot;	//modelspace to worldspace\n&quot;<br />						&quot;	vec3 vPos_WorldSpace = trans_for(myVertex, s_model);						// ModelSpace to WorldSpace, no matrices\n&quot;<br />						&quot;	//worldspace to viewspace\n&quot;<br />						&quot;	vec3 vPos_ViewSpace = trans_inv(vPos_WorldSpace, s_cam);					// WorldSpace to ViewSpace, no matrices\n&quot;		<br />						&quot;	//viewspace to clipspace\n&quot;<br />						&quot;	vec4 vPos_ClipSpace = get_projection(vPos_ViewSpace, myProjectionData);		// ViewSpace to ClipSpace, (and again, no matrices)\n&quot;;<br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2012-09-22 04:46:40 by Homer</div>
   </div>
   <div class="post" id="post-216278">
    <div class="subject"><a href="#post-216278">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />Isn&#039;t it strange that my renderer works at all, given that I am completely wrong :)</div><br /><br />Not at all, since this is taken care of by the GPU. You just don&#039;t understand what it does.<br />As I said, try writing a renderer entirely in software. You&#039;ll figure out soon enough how projection, clipping and rasterizing go together.</div>
    <div class="meta">Posted on 2012-09-22 04:58:21 by Scali</div>
   </div>
   <div class="post" id="post-216279">
    <div class="subject"><a href="#post-216279">Re: D3D Pipeline Order</a></div>
    <div class="body">Since I transform the input ModelSpace vertex into all three Major Spaces, I am easily able to implement things like View Dependent shader algorithms which require the ViewSpace vertex position as input, which is not possible if the transform (matrix) was baked.<br /></div>
    <div class="meta">Posted on 2012-09-22 05:05:26 by Homer</div>
   </div>
   <div class="post" id="post-216280">
    <div class="subject"><a href="#post-216280">Re: D3D Pipeline Order</a></div>
    <div class="body">For UVs, texturespace can be represented as a single quaternion plus a coordinate, instead of a coordinate, normal, tangent and binormal, saving 60% of the memory requirements to send that rotation. The normal(s) can be pulled out in the shader, or sent in addition to the TextureSpace Quaternion.<br /><br /></div>
    <div class="meta">Posted on 2012-09-22 05:09:21 by Homer</div>
   </div>
   <div class="post" id="post-216281">
    <div class="subject"><a href="#post-216281">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />Since I transform the input ModelSpace vertex into all three Major Spaces, I am easily able to implement things like View Dependent shader algorithms which require the ViewSpace vertex position as input, which is not possible if the transform (matrix) was baked.<br /></div><br /><br />Congratulations, you managed to completely change topic yet again, and dump in a bunch of gratuitous buzzwords to cloud the issue at hand.</div>
    <div class="meta">Posted on 2012-09-22 05:11:54 by Scali</div>
   </div>
   <div class="post" id="post-216282">
    <div class="subject"><a href="#post-216282">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />For UVs, texturespace can be represented as a single quaternion plus a coordinate, instead of a coordinate, normal, tangent and binormal, saving 60% of the memory requirements to send that rotation. The normal can be pulled out in the shader, or sent in addition to the TextureSpace Quaternion.<br /></div><br /><br />Newsflash: Since the basis of a space is orthogonal by definition (orthonormal even, in a strict mathematical sense), it follows that you only need to define two axis for a 3d space. The third axis is implied, since it has to be orthogonal to both given axis.<br />Ergo, your calculations are off, yet again.</div>
    <div class="meta">Posted on 2012-09-22 05:14:50 by Scali</div>
   </div>
   <div class="post" id="post-216283">
    <div class="subject"><a href="#post-216283">Re: D3D Pipeline Order</a></div>
    <div class="body">I told you I was moving on. I have already proven my code works, had it peer reviewed, and so on.<br />I&#039;m not talking about just transforms anymore, shaders need other kinds of inputs.<br />My shaders are constructed based upon input specifications.<br />In this new GLES based engine, the built in shaders are now all based on pure Quaternion inputs.<br />But there is still underlying support for Matrix based shaders.<br />They are all, to some degree, based on input specs.<br />There&#039;s 10 of them, and one of them is a general purpose surfaceshader generator, which has the most input specs ( a vertexformat and an advanced material )<br /><br />I will now let this thread die.<br />You can comment on other threads.<br /><br /><br /></div>
    <div class="meta">Posted on 2012-09-22 05:18:54 by Homer</div>
   </div>
   <div class="post" id="post-216284">
    <div class="subject"><a href="#post-216284">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />I told you I was moving on. I have already proven my code works, had it peer reviewed, and so on.</div><br /><br />You&#039;re still posting in a topic that is about clipping though.<br />And you still don&#039;t know how clipping works.</div>
    <div class="meta">Posted on 2012-09-22 05:24:00 by Scali</div>
   </div>
   <div class="post" id="post-216285">
    <div class="subject"><a href="#post-216285">Re: D3D Pipeline Order</a></div>
    <div class="body">My clipping works just fine, its performed on ClipSpace vertices, which are post-projective. I don&#039;t understand why you have a problem with it.<br /><br /></div>
    <div class="meta">Posted on 2012-09-22 06:56:56 by Homer</div>
   </div>
   <div class="post" id="post-216286">
    <div class="subject"><a href="#post-216286">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />My clipping works just fine, its performed on ClipSpace vertices, which are post-projective. I don&#039;t understand why you have a problem with it.<br /></div><br /><br />Clipping works fine because it&#039;s not *your* clipping. It is hardwired in the rasterizer stage of the GPU.<br />The &#039;problem&#039; I have is that the question in the OP was about the clipping in the rasterizer stage, and the statements you have made about projection and clipping in this thread are basically complete nonsense.</div>
    <div class="meta">Posted on 2012-09-22 17:22:00 by Scali</div>
   </div>
   <div class="post" id="post-216287">
    <div class="subject"><a href="#post-216287">Re: D3D Pipeline Order</a></div>
    <div class="body">I have said that all along, we do not perform the actual clipping, but described how we would do it in software.<br />You have confused insight with implementation.<br /></div>
    <div class="meta">Posted on 2012-09-23 06:05:22 by Homer</div>
   </div>
   <div class="post" id="post-216288">
    <div class="subject"><a href="#post-216288">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />I have said that all along, we do not perform the actual clipping, but described how we would do it in software.<br />You have confused insight with implementation.<br /></div><br /><br />Please, drop the hollow rhetoric. I&#039;m not impressed.<br />Also, just because you&#039;re TRYING to confuse everyone to cover up your mistakes, doesn&#039;t mean it&#039;s actually working.<br />I&#039;m not confused at all. I pointed out VERY clearly that there are many mistakes in your &#039;description&#039;:<br /><div class="quote"><br /><div class="quote"><br />The normalization is the equivalent of the clipping operation, forcing vertices into a unit space, but with some clever hardware optimizing we can predict the result of the w divide and reject early, thus the clipping itself is done in hardware - but the transform into unit space is up to us.<br /></div><br /><br />You still don&#039;t have a clue, do you?<br />1) There *is* no normalization being done on position data anywhere.<br />2) Normalizing position data has no geometric meaning whatsoever. It would merely corrupt your meshes on screen. For example, take a cube with reasonably tessellated sides, centered around (0,0,0). If you normalize all its vertices, the result is a (unit) sphere (all vertex positions will be normalized to have the same (unit) length from the origin).<br />&#039;Forcing vertices into a unit space&#039; makes no sense. If they don&#039;t fit, they don&#039;t fit.<br />3) The homogeneous division (which you mistakenly equate to normalization) does not perform clipping. Link to a common polygon clipping algorithm was already provided. The algorithm did not even remotely resemble a homogeneous division.<br />4) Not all your geometry will always fit into the unit cube, not even after homogeneous division. See example screenshots of triangles and torus object which fall partly off the screen, hence are partly outside the unit cube.<br />Anyone with a bit of common sense will see that there&#039;s no way the clipped triangles in the screenshot can be the result of merely rejecting vertices from a triangle.<br />In fact, anyone with a bit of common sense will see that rejecting a single vertex from a triangle is equivalent to rejecting the entire triangle.<br />And with a bit more common sense, they would also see that there is no way to clip a triangle like that by merely performing a division.<br />5) Part of transforming into unit space is the homogeneous division, which is automatically performed by the fixed-function rasterization stage on the GPU, and as such is not &#039;up to us&#039;.<br />6) Clipping does not force vertices into a space. It clips off the parts of the geometry that do not fit in the space, and introduces new geometry (new polygon edges) so that the resulting object DOES fit (without any corruption/warping/etc).<br /><br />How long are you going to try to keep this up?<br /><br />In fact, let&#039;s make this interesting.<br />In the second clipped triangle screenshot that I posted earlier, we have a screen of 320x200 resolution.<br />The projected triangle has the following coordinates in screenspace (x,y):<br />(-10,20), (50,240), (380,100)<br /><br />How do we get from these three coordinates (which are all outside the screen area) to the clipped triangle we see on screen?<br />Which of the vertices do we reject? What do we divide?<br /></div></div>
    <div class="meta">Posted on 2012-09-23 07:21:40 by Scali</div>
   </div>
   <div class="post" id="post-216289">
    <div class="subject"><a href="#post-216289">Re: D3D Pipeline Order</a></div>
    <div class="body">I make lots of mistakes, but I know what I&#039;m talking about.<br />I know what these transforms do and how to apply them , with or without matrices.<br />Yes, clip space is a unit cube, but your clip space vertices might be outside it, then the gpu will clip them - and?<br />I&#039;m sure you have a point to make, but you have no ammunition as everything I&#039;ve said is accurate.<br /></div>
    <div class="meta">Posted on 2012-09-23 08:47:31 by Homer</div>
   </div>
   <div class="post" id="post-216290">
    <div class="subject"><a href="#post-216290">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />I make lots of mistakes, but I know what I&#039;m talking about.</div><br /><br />I beg to differ. You *act* like you know what you talk about.<br />But you don&#039;t. Ever heard of Dunning-Kruger?<br /><br /><div class="quote"><br />Yes, clip space is a unit cube, but your clip space vertices might be outside it, then the gpu will clip them - and?</div><br /><br />Well, this already is in direct contradiction of things you said earlier, such as:<br /><div class="quote">We don&#039;t perform the final operation - clipping - it&#039;s done by the hardware, based strictly on the value of the W field.<br />But if we did want to do it by hand, we would simply have to &#039;Dehomogenize&#039; (kinda Normalize) the 4D vector, to turn it back into a valid 3D vector, which is just to divide everything by W - the result is a vector X,Y,Z(,1) where XYZ are all between -1 and +1</div><br /><br />Or this:<br /><div class="quote">ClipSpace is a volume from (-1,-1,-1) to (+1,+1,+1) , and when we Normalize the Homogenous ViewSpace Coordinate, the result is mapped to that &#039;unit cube&#039; range. The hardware performs this division by w, and rejects vertices that are outside the unit cube after division by w.<br />We are responsible for everything, including foreshortening, with the exceptions ONLY, of division by W, and rejection (and in fact it&#039;s faster to do the rejection ourselves in a Geometry Shader, but that&#039;s another story).</div><br /><br />Or this:<br /><div class="quote">The normalization is the equivalent of the clipping operation, forcing vertices into a unit space</div><br /><br /><div class="quote"><br />I&#039;m sure you have a point to make, but you have no ammunition as everything I&#039;ve said is accurate.<br /></div><br /><br />Not at all. Pretty much everything you&#039;ve said was inaccurate, and a lot of that was downright wrong. I&#039;ve already listed your mistakes multiple times, you just keep ignoring them.<br />The point I&#039;m making is:<br />1) Your knowledge of 3d is very limited.<br />2) The limits of your knowledge are so narrow that you don&#039;t even manage to see the bigger picture to understand what your limitations are.<br />3) Even when your limits are pointed out to you, you are too arrogant to admit your mistakes, and just ignore and deny everything.<br />4) You&#039;ve been pushing and insulting me for years, on your pathetic ego-trip. Usually I just ignored you, or merely stuck to the technical side of a discussion, trying to correct your misinformation for those who may be reading these threads to get answers to their questions.<br />But I&#039;ve grown tired of your insults and your arrogance.<br />I could name plenty of examples of your personal digs...<br />Take this for example, where you claim I&#039;ve only copied code from examples:<br />http://www.asmcommunity.net/board/index.php?topic=29358.msg210020#msg210020<br /><br />Or here, where you keep nagging about my vertex skinning code: http://www.asmcommunity.net/board/index.php?topic=29617.msg210437#msg210437<br />I stated clearly that I was porting old (working) code to my new codebase, so saying I &#039;only just got it working&#039; is a bit weird...? Then you keep on nagging about the Microsoft DXMesh stuff, while I&#039;ve clearly stated that I use my own code (DXMesh does not even exist in DX10/11 or OpenGL in the first place, besides, the OpenGL code is open source. More weirdness). Then you start nagging about the fact that I use 5 &#039;texcoords&#039; (actually just interpolated vertex data), again while the code is right in front of you.<br /><br />You have a serious attitude problem. You and I are not on the same level, and I am no longer going to protect you against yourself.<br />Seems like you need to be taught a lesson. You keep pushing me for some kind of &#039;pissing match&#039; to see who the hottest 3d programmer is. I think everone but you already knows that you&#039;re not it. Usually I&#039;ve just ignored your nudges, but well... Pointing out just how little you actually know (such as in this thread) may be just the lesson you need.<br />I just underestimated your pigheaded-ness. Even with clear evidence in plain sight, you remain in denial. Seems like a common trait in Australians.<br /><br />Want to show everyone how hot you really are? You can start by answering the question I posed earlier, on how the triangle would actually be clipped to fit screen space.<br />Then you could write a complete software renderer for 286 with EGA to prove that you know all about rasterizing and clipping, and that you can do better than me.<br />Because anyone can use D3D and OpenGL and modify some example code and get something halfway working on screen. Writing your own software renderer (especially one that only uses a 16-bit integer CPU) takes actual understanding and skill.</div>
    <div class="meta">Posted on 2012-09-23 10:25:57 by Scali</div>
   </div>
   <div class="post" id="post-216298">
    <div class="subject"><a href="#post-216298">Re: D3D Pipeline Order</a></div>
    <div class="body">I&#039;ll see ur demo and raise u a game engine!<br />Your fixed ideas are based on a jaded understanding of the transform pipe.<br />If you want to clip in software, you *WILL* need to do the w divide yourself, and reject vertices outside of the unit space. Nothing I have said there is inaccurate.<br />I absolutely am not interested in a pissing match, this is what I do for a living, it&#039;s been a few years since I treated it as a hobby. I think you should definitely buy GPU Pro 3 and check out the chapter by Juraj Vanek regarding the transform pipe. He&#039;s one of the guys I correspond with lately.<br />Have a nice day :)<br /></div>
    <div class="meta">Posted on 2012-09-27 00:49:09 by Homer</div>
   </div>
   <div class="post" id="post-216300">
    <div class="subject"><a href="#post-216300">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />Your fixed ideas are based on a jaded understanding of the transform pipe.<br />If you want to clip in software, you *WILL* need to do the w divide yourself, and reject vertices outside of the unit space. Nothing I have said there is inaccurate.</div><br /><br />You really are a broken record.<br />Still that arrogance, still thinking you know better. Well, you don&#039;t, and you&#039;re still wrong.<br />Anyone who has read this thread can tell you that what you&#039;re saying is nonsense.<br />They may not know exactly how the pipeline works, but common sense will tell them that if you take these three vertices:<br />(-10,20), (50,240), (380,100)<br />There is NO value of W that results in a polygon with 6 edges such as this:<br /><img src="http://www.asmcommunity.net/board/index.php?action=dlattach;topic=14469.0;attach=3363;image" /><br /><br />It&#039;s basic common knowledge that will tell them that dividing a vertex can&#039;t add new edges, let alone rejecting vertices.<br />I asked you specifically how it would be done. You couldn&#039;t answer that either.<br />So I hereby appeal to the common sense of people reading this thread: please chime in and say you don&#039;t buy Homer&#039;s nonsense.</div>
    <div class="meta">Posted on 2012-09-27 02:55:39 by Scali</div>
   </div>
   <div class="post" id="post-216301">
    <div class="subject"><a href="#post-216301">Re: D3D Pipeline Order</a></div>
    <div class="body">All I can say is that you are indeed a moron, and you do not understand homogenous 4-vectors.<br />It&#039;s not my job to show you, so screw you, have a nice life doing demos, and try not to make people more stupid because of your shortcomings.<br /></div>
    <div class="meta">Posted on 2012-09-27 06:59:39 by Homer</div>
   </div>
   <div class="post" id="post-216302">
    <div class="subject"><a href="#post-216302">Re: D3D Pipeline Order</a></div>
    <div class="body"><div class="quote"><br />All I can say is that you are indeed a moron, and you do not understand homogenous 4-vectors.</div><br /><br />I&#039;m not sure what any of this has to do with my understanding of homogeneous 4d-vectors.<br />You don&#039;t necessarily NEED homogeneous 4d-vectors to do this sort of clipping. The screenshot here was taken from my 286-renderer, which as I stated, does not use 4d vectors. Since it does not need a per-pixel z-value, you can re-use the z in the same way as the w in a 4d-homogeneous vector. So in this case I basically use 3d-homogeneous vectors.<br /><br />However, I am no stranger to 4d-homogeneous vectors either, obviously. My Java engine uses a conventional zbuffer approach, and as such the pipeline is modeled after the D3D8 pipeline. However, the clipping itself is still very similar to what the 286 code does.<br />And obviously I&#039;ve used the D3D and OpenGL pipelines as well.<br />Also, here I derive the projection matrices in left-handed and right-handed notation for D3D and OGL: http://www.asmcommunity.net/board/index.php?topic=30124.msg212786#msg212786<br />To which you responded:<br /><div class="quote"><br />That&#039;s a great post, Scali :)<br />At some point, I know I&#039;m going to search here for that info (my brain is more like a sieve each year), and I certainly haven&#039;t ever posted that before, I figure this will be the top result :)<br /></div><br /><br />So you see, in the ~20 years I&#039;ve been doing graphics, I have written a number of 3d pipelines (early 3d accelerated stuff also required custom software pipelines for better performance/more visual trickery), including clippers and everything. If you want to see one of the pipelines, you can just look at the OpenGL renderer at http://sourceforge.net/projects/bhmfileformat/<br />It runs entirely on my own matrix code and shaders.<br />If you really want, I can also show you the pipelines and clippers I wrote in Java, for Amiga, GP2X, 486, 286 etc... But I don&#039;t think anyone doubts that they work, because people have been able to download and run the binaries.<br /><br />So really, I&#039;m not the one who has anything to prove here. You are, however. You cannot even answer a simple question of how a triangle is clipped. Let alone that you would be able to implement a proper clipper in an actual pipeline. So I&#039;m not sure why you keep pretending that you know how it works, and just downright insult me for no reason.<br />Reality bites, doesn&#039;t it?<br /><br />Also, dila responded to this thread earlier.<br />He is the guy who wrote PolySynth: http://www.movss.com/~rich/Code/PolySynth?action=print<br />Another software renderer. Where he had to implement the whole pipeline, and clipping. And he doesn&#039;t agree with you either:<br /><div class="quote"><br />What Scali is saying is correct.<br /><br />Clipping is not just about rejection - removing entire polygons from the pipeline, but also about cutting the polygons so they fit within the view frustum. Sometimes clipping a single polygon will result in multiple polygons being generated.<br /><br />The frustum clipping region is hardcoded in hardware - hence the projection matrix - to scale the scene to fit inside. In this way the programmer moves the geometry in the scene, instead of moving the clipping planes around the geometry.<br /><br />The clipping is performed after the projection matrix is applied (for the reason described above), but before the perspective divide (division by W) that Scali talked about.<br /><br />The reason the programmer does not perform the perspective divide himself is because the 4D vertices that are produced from the perspective matrix multiplication are passed onto the clipper. The clipper then operates on these vertices in 4D space, without the so-called &quot;normalization&quot; that&nbsp; Homer spoke of.<br /></div><br /><br />So that is two people, who have actually proven that they are capable of implementing a full pipeline with clipping, against one person who has not...</div>
    <div class="meta">Posted on 2012-09-27 08:46:21 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=14469&amp;page=1" style="">&laquo;</a><a href="../?id=14469&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="14469" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=14469&amp;page=3">&gt;</a><a href="../?id=14469&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>