<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Using and loading DLLs - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28814" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=113">Low Level Concepts</a> &raquo; <a href="../?id=28814">Using and loading DLLs</a></p>
   <div class="post" id="post-203595">
    <div class="subject"><a href="#post-203595">Using and loading DLLs</a></div>
    <div class="body">Helloes again.<br /><br />I&#039;m currently undergoing a game modding process, and for anyone familiar with Cave Story and its tribute site, I&#039;m making my own Legacy mod <a target="_blank" href="http://www.miraigamer.net/forums/showthread.php?t=886&amp;page=1&amp;pp=10">here</a>.<br /><br />Yes, in all actuality this can be considered h@cking or reverse-engineering... The difference is, I have Pixel&#039;s permission! If you want proof, you can see his bbc <a target="_blank" href="http://hpcgi2.nifty.com/rochet/cgi/bbsMain01.cgi">here</a>.<br />You&#039;ll have to scroll down a bit, but it&#039;s there. Yes, I know most of it&#039;s in Japanese, but I ask Pixel in English and he replies in English. I went by my username here when I asked him.<br /><br />At any rate, I&#039;m trying to get the executable to use PxTone.dll to play music files that I&#039;ve created. I&#039;m using the PEBrowse Professional Interactive debugger to look at its dissassembly, if that&#039;s any use to anyone. I&#039;m using a disassembler because Pixel&#039;s reluctant to release the source code. <br /><br />I&#039;m assuming that once the DLL is loaded, you simply call the hex address of whichever function you want to use, with all the variables and stuff in the stack and registers. <br /><br />This may be a relatively simple question to answer, but I tried searching and I didn&#039;t find anything specific to what I&#039;m trying to do. Once I figure out what to do, I plan on assembling my code pieces in FASM and using XVI32 to insert them into the executable, though I&#039;m not sure how well that will work... I&#039;m pretty sure that if I did that I would have to adjust all the jump offsets and stuff, which might take me a few years, if not decades or centuries...<br /><br />But you&#039;re the experts, you tell me!<br /><br /> - keantoken</div>
    <div class="meta">Posted on 2007-11-15 00:19:14 by keantoken</div>
   </div>
   <div class="post" id="post-203597">
    <div class="subject"><a href="#post-203597">Re: Using and loading DLLs</a></div>
    <div class="body">LoadLibrary -&gt; GetProcAddress (to get the api&#039;s you need)<br />before exiting do a FreeLibrary on the libraries / library loaded<br />(not really needed tho)...</div>
    <div class="meta">Posted on 2007-11-15 01:44:31 by evlncrn8</div>
   </div>
   <div class="post" id="post-203607">
    <div class="subject"><a href="#post-203607">Re: Using and loading DLLs</a></div>
    <div class="body">Hm, not really sure what to do about this topic - seems you have permission and you&#039;re not doing malicious stuff, but it is still somewhat touchy. I&#039;ll start by moving it to &quot;Low Level Concepts&quot;.<br /><br />Anyway, instead of adding your code to the executable etc., you should consider taking &quot;the easy route&quot;. Put the code you want to add in a DLL, and make a loader that injects this DLL. You can do code fixups from the DLL, etc. It&#039;s the approach I used for <a target="_blank" href="http://f0dder.reteam.org/essay02.htm">fixing UFO/XCOM</a>, and it works pretty well.<br /></div>
    <div class="meta">Posted on 2007-11-16 07:29:04 by f0dder</div>
   </div>
   <div class="post" id="post-203615">
    <div class="subject"><a href="#post-203615">Re: Using and loading DLLs</a></div>
    <div class="body"><div class="quote">Hm, not really sure what to do about this topic - seems you have permission and you&#039;re not doing malicious stuff, but it is still somewhat touchy. I&#039;ll start by moving it to &quot;Low Level Concepts&quot;.</div><br /><br />Don&#039;t worry, you can trust me. I respect Pixel enough not to just start h@cking his stuff -&nbsp; he was able to create such a great game by himself in a matter of five years. I would think that that takes determintion at the very least. That said, I would not even think about doing anything illegal with his code.<br /><br />At any rate, thanks for the advice. <br /><br />Do you think I could use your XCOM source as a base for my own project? If so, what assembler did you use? <br /><br /> - keantoken</div>
    <div class="meta">Posted on 2007-11-16 17:45:27 by keantoken</div>
   </div>
   <div class="post" id="post-203616">
    <div class="subject"><a href="#post-203616">Re: Using and loading DLLs</a></div>
    <div class="body">Sure, knock yourself out. Can&#039;t remember which assembler I used, probably MASM back then. With the DLL approach, you can write code in whatever language you want :)</div>
    <div class="meta">Posted on 2007-11-16 18:04:34 by f0dder</div>
   </div>
   <div class="post" id="post-203619">
    <div class="subject"><a href="#post-203619">Re: Using and loading DLLs</a></div>
    <div class="body">Thanks!<br /><br />Okay, I pretty much just messed around a bit in FASM, compiling and fixing any errors it found (I haven&#039;t completely memorized all the formatting and stuff, and it was faster than searching through the manual) and managed to get it to compile. Of course, that doesn&#039;t always mean it compiled RIGHT. At any rate, here&#039;s the converted file:<br /><br /><pre><code>include &quot;WIN32A.INC&quot;<br /><br />;<br />; Patch code for 9x,nt,2k,xp.<br />;<br />;XCOM: UFO defense (aka&nbsp;  UFO: Enemy Unknown) windows version loader, by f0dder.<br />;That&#039;s f0dder@druk.nu , http://f0dder.has it , http://f0dder.cjb.net<br />;All rights desrever ;), 2003/04/30.<br />;<br />; This code will be written at the program entrypoint. It&#039;s job is to load the<br />; patch DLL file, GetProcAddress, and signal to the patcher that it&#039;s done.<br />; Loader is responsible for register preservation etc.<br />;<br /><br /><br /><br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; code<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />__entry:<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  short&nbsp;  skipdata<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; imports fixed by loader<br />&nbsp; &nbsp; &nbsp; &nbsp; hEvent&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; &nbsp; 0<br />&nbsp; &nbsp; &nbsp; &nbsp; _LoadLibraryA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; &nbsp; 0<br />&nbsp; &nbsp; &nbsp; &nbsp; _GetProcAddressA&nbsp; &nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; &nbsp; 0<br />&nbsp; &nbsp; &nbsp; &nbsp; _SetEvent&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; &nbsp; 0<br /><br />skipdata:<br />&nbsp; &nbsp; &nbsp; &nbsp; ; get delta<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .getdelta<br />.getdelta:<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ebp, .getdelta<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; load the DLL<br />&nbsp; &nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  eax, <br />&nbsp; &nbsp; &nbsp; &nbsp; stdcall&nbsp; &nbsp; &nbsp; &nbsp;  , eax<br />&nbsp; &nbsp; &nbsp; &nbsp; ; get address of the doPatch routine<br />&nbsp; &nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  edx, <br />&nbsp; &nbsp; &nbsp; &nbsp; stdcall&nbsp; &nbsp; &nbsp; &nbsp;  , eax, edx<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; signal we&#039;re done to the loader<br />&nbsp; &nbsp; &nbsp; &nbsp; stdcall&nbsp; &nbsp; &nbsp; &nbsp;  , dword <br /><br />.infiniteloop:<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  $&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; we&#039;re done.<br /><br />szDllName&nbsp; &nbsp; &nbsp;  db &quot;patch.dll&quot;, 0<br />szProcName&nbsp; &nbsp; &nbsp; db &quot;DoPatch&quot;, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code></pre><br /><br />First of all, this may not be the last time I mod a file this way, so I would like to add some flexibility to it. I want it to it&#039;s own filename so that it will load the DLLs into an executable in the same folder with the same name. I imagine that this would be done with a syscall like &#039;GetFileName&#039;. Looking into it...<br /><br />EDIT: I found GetFileTitle pretty quickly in VisAsm...<br /><br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; push {cbBuf}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; length of buffe<br />&nbsp; &nbsp; &nbsp; &nbsp; push {lpszTitle}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; address of buffer that receives filenam<br />&nbsp; &nbsp; &nbsp; &nbsp; push {lpszFile}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; address of full path and filename for fil<br />&nbsp; &nbsp; &nbsp; &nbsp; call GetFileTitle</code></pre><br /><br />Don&#039;t ask me why the comments are cut off. Probably a bug with VisAsm. My question is... Ah, I think I just found the answer! It&#039;s really nice how you can just type in the syscall on google and it&#039;ll give you the NSDN documentation on it. If I&#039;m not mistaken, the buffers it&#039;s talking about are the exact same type as the &#039;szDllName&nbsp; &nbsp; &nbsp;  db &quot;patch.dll&quot;, 0&#039; in the previous code snippet. Well, that clears some stuff up. <br /><br />At any rate, this doesn&#039;t seem to be what I want... <br /><br /> - keantoken</div>
    <div class="meta">Posted on 2007-11-16 18:51:26 by keantoken</div>
   </div>
   <div class="post" id="post-204320">
    <div class="subject"><a href="#post-204320">Re: Using and loading DLLs</a></div>
    <div class="body">if you can explain in more detail what you require i can probably help you...</div>
    <div class="meta">Posted on 2008-01-01 20:35:27 by evlncrn8</div>
   </div>
   <div class="post" id="post-204631">
    <div class="subject"><a href="#post-204631">Re: Using and loading DLLs</a></div>
    <div class="body">Best way to do this will be with an injector as stated in a previous post.<br /><br />You will want to make your injector start the game and then inject your dll, then quit. Here is a general template broken into 3 files that you will be able to modify, originally for Starcraft:Broodwar.<br /><br /><pre><code>.Data<br />BWFXN_PrintText			dd 0048CE70h<br /><br />.Data?<br />lgJmp 					db 5 dup(?)<br /><br />.Code<br /><br />BWTextDisplay proc	uses ecx edx	text:DWORD<br /><br />	xor edx, edx<br />	mov ecx, text<br />	call dword ptr <br />	ret<br /><br />BWTextDisplay endp<br /><br />WriteMem proc	MemOffset:DWORD, DataPtr:DWORD, dataLen:DWORD<br /><br />	LOCAL OldProt:DWORD<br /><br />	invoke VirtualProtect, MemOffset, dataLen, PAGE_EXECUTE_READWRITE, addr OldProt<br />	invoke RtlMoveMemory, MemOffset, DataPtr, dataLen<br />	invoke VirtualProtect, MemOffset, dataLen, OldProt, addr OldProt<br />	ret<br /><br />WriteMem endp<br /><br />JmpPatch proc	uses ecx ebx	from:DWORD, to:DWORD<br /><br />	mov	ebx, to<br />	mov	ecx, from<br />	add	ecx, 05h<br />	sub	ebx, ecx<br />	lea	ecx, lgJmp<br />	mov	byte ptr , 0E9h<br />	mov	dword ptr , ebx<br />	invoke WriteMem, from, addr lgJmp, 5<br />	ret<br /><br />JmpPatch endp</code></pre><br /><pre><code>ResourceHack PROTO :DWORD<br /><br />.Data<br /><br />.Data?<br /><br />HndHook			dd ?<br /><br />.Code<br /><br />HotKeys proc nCode:DWORD, wParam:DWORD, lParam:DWORD	<br />	.if nCode != HC_ACTION						jmp HotKeys_End<br />	.endif<br /><br />	mov ebx, lParam<br />	or ebx, 00FFFFFFh<br />	.if ebx == 0C0FFFFFFh				; WM_KEYUP<br />		jmp HotKeys_End<br />	.endif<br /><br />	.if wParam == VK_F11				; what i want displayed<br />		invoke ResourceHack, 0057F0D8h<br />		invoke BWTextDisplay, CTEXT (&quot;Offline Mineral hack&quot;)<br /><br />	.elseif wParam == VK_F12<br />		invoke ResourceHack,&nbsp; 0057F108h<br />		invoke BWTextDisplay, CTEXT (&quot;Offline Gas hack&quot;)<br /><br />	.endif<br /><br />HotKeys_End:<br />	invoke CallNextHookEx, HndHook, nCode, wParam, lParam	; Call next hook in chain<br />	ret<br /><br />HotKeys endp<br /><br />DLLProc proc<br /><br />	invoke FindWindow, CTEXT (&quot;SWarClass&quot;), 0			; Get Starcraft window handle<br />	invoke GetWindowThreadProcessId, eax, 0				; Get Starcraft&#039;s Thread ID<br />	invoke SetWindowsHookEx, WH_KEYBOARD, addr HotKeys, NULL, eax	; Hook our hotkey function<br />	mov HndHook, eax						<br />; Save the handle to our hook Events:		<br />; Events - Here we keep our thread in a loop.<br />xor eax, eax		<br />jmp Events<br />					<br />DLLProc endp<br /><br />ResourceHack proc uses eax ebx ecx Resource:DWORD	<br /><br />	mov ebx, 0512684h						xor eax, eax							mov al, byte ptr 						mov ebx, Resource						mov ecx, dword ptr 				add ecx, 000f4240h					mov dword ptr , ecx				ret<br /><br />ResourceHack endp<br /><br />StartupMsg proc<br />	<br />	pushad							; Preserve all registers<br />	invoke BWTextDisplay, CTEXT (&quot;Eradicated beta1&quot;)	; Print text<br />	popad							; Restore all registers<br />	ret<br />StartupMsg endp</code></pre><br /><br /><pre><code>.386<br />.Model Flat, StdCall<br />OPTION CASEMAP :NONE<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\debug.inc<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\debug.lib<br /><br />include Basic.inc<br />include Events.inc<br /><br />.Data<br /><br />JmpByte		db 0EBh<br /><br />.Data?<br /><br />ThreadID	dd ?<br />hThread		dd ?<br /><br />.code<br /><br />DllEntryPoint proc hInstDLL:DWORD, reason:DWORD, unused:DWORD<br /><br />	mov eax,reason<br />	.if eax == DLL_PROCESS_ATTACH											<br />		call DLLStartup														patches<br />		invoke CreateThread, NULL, 0, addr DLLProc, 0, 0, addr ThreadID				mov hThread, eax														.endif<br />	ret<br /><br />DllEntryPoint endp<br /><br />DLLStartup proc<br /><br /><br />	<br />	invoke WriteMem, 005122C8h, addr JmpByte, 1		; change version number<br /><br />	invoke JmpPatch, 0048CD70h, addr StartupMsg		; Game startup message<br /><br />	ret<br /><br />DLLStartup endp</code></pre><br /><br /><br />This explains how to use the prebuilt functions. After hijacking the main thread on startup, it runs LoadLibrary which calls DLLStartup adds in your callback functions and turns around and lets your game continue. for your callbacks, you need to find part of the code that you want your code to run at. pick the start of a line and JmpPatch to your function. This overwrites 5 bytes, so you must execute(in your function) whatever code you overwrote with the JmpPatch, then you must jmp back to the next line of code that you didn&#039;t perform in your function. Now you can address memory directly without ReadProcessMemory/WriteProcessMemory This should get you going. You will still need to write the injector program to load the dll into the game.</div>
    <div class="meta">Posted on 2008-01-25 23:21:31 by jakor</div>
   </div>
  </div>
 </body>
</html>