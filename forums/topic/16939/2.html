<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>nasm, user/supervisor, ... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16939" />
  <link rel="prev" href="../?id=16939&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16939">nasm, user/supervisor, ...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16939&amp;page=1" style="">&laquo;</a><a href="../?id=16939&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16939" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-131606">
    <div class="subject"><a href="#post-131606">nasm, user/supervisor, ...</a></div>
    <div class="body"><div class="quote">And when doing direct binary output, I still prefer fasm/nasm - since there's no &quot;ripcode&quot; additional step.</div><br /><br />Well I rarely need raw binary code anyway... And when I do, I can't be arsed to work with broken syntaxes such as nasm/fasm. I prefer to just use the good ole MASM or C/C++ power.<br />But sure, there are areas where one tool is better than another. Which is why we have multiple tools :)</div>
    <div class="meta">Posted on 2004-01-25 06:47:48 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131607">
    <div class="subject"><a href="#post-131607">nasm, user/supervisor, ...</a></div>
    <div class="body">hehe... I don't think nasm/fasm are broken syntaxes (while I do think masm allowing memory indirection without brackets are a bad thing). Especially nasm can be annoying if you need &quot;high-level&quot; kind of stuff though - but I generally don't need that for assembly code (high-level code in a low-level language? Gimme the real deal, thank you :))<br /><br />If I needed to inject enough code that self-relocating code is annoying and C/C++ would be nice, I'll just put it in a DLL instead... works like a charm, that's how I did it for the XCOM bugfixes.</div>
    <div class="meta">Posted on 2004-01-25 06:54:14 by f0dder</div>
   </div>
   <div class="post" id="post-131612">
    <div class="subject"><a href="#post-131612">nasm, user/supervisor, ...</a></div>
    <div class="body"><div class="quote">I don't think nasm/fasm are broken syntaxes (while I do think masm allowing memory indirection without brackets are a bad thing).</div><br /><br />Well, MASM simply follows the syntax that Intel defined. That's the point... The syntax is well-defined. I have never seen a decent definition of nasm's syntax. All I know is that it's not Intel's syntax.<br /><br /><div class="quote">but I generally don't need that for assembly code (high-level code in a low-level language? Gimme the real deal, thank you )</div><br /><br />Well the way I see it, if I *have* to use asm anyway (as in, high-level languages don't cut it), I want to make it as comfortable, easy and fast as possible. MASM does this for me. Most of the time I just use inline asm though.<br />I suppose it depends on what you're doing, and how you want to do it. I spend most of my time writing the code, so to me it's important that this part is the easiest. That I might need an extra 'rip'-step, is not important, I don't do that very often anyway, most of the time I'm coding ;)</div>
    <div class="meta">Posted on 2004-01-25 07:12:16 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131623">
    <div class="subject"><a href="#post-131623">nasm, user/supervisor, ...</a></div>
    <div class="body">I learned from here <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=16755">http://www.asmcommunity.net/board/index.php?topic=16755</a> that masm hll features  that they was only macros, folowed by a parser that let you extract interesting expression, byt the way... nasm not have suchs hll constructs, but there exist macros to.. for do the work for you. Also Like I say in the other post, you eventually take a format for do things or a standar in code selections, jumps, etc,.<br /><br />Also people say that nasm dont have the features that others have... here is a feature that masm dont have (they dont take care o such a simple format?, but is the way that the computer start... or take for first.. in this way, I think they ignore the priciple), maybe they have such a feature but is not public... ??.. or maybe simply they dont have.<br /><br /><br />Yes... the correct tool for a specific work.<br /><br />I what to share with you some.... I read time a go books on logic, and express a thing like &quot;the mathematic people dont care if the correctness of what they write, because is a standar follow the expressions that they use&quot;, what is refered is that there exist errors for example in geometry.... not only in the proof of theorems but un the theorems inself!!!!, also if I remember correctly Djikstra express some like that, there exist diference in how you use the words and order, but standar comes more strong that a correct expression.<br /><br />That is all that I say, dunno if nasm sintaxis is the correct, but for me make sense, maybe is not a good software... maybe.. you see dont have the implementation of exitmacro (that in some way... can be easy to implement.. because there exist a anterior &quot;bug&quot; that at less exit the rep-blocks), but can output the raw bin format, also output other formats, the nasm sources are a &quot;spagetti... or cant be readed&quot;, O share with you some in the past, I do a modification that whas not aproved, and the degree in C, the more high that I have in that time was the basics  of pointers, not more, what I say, is if a person with that degree can read that spagetti codes, why others more skilled people say that they can not read it?.<br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-01-25 09:37:33 by rea</div>
   </div>
   <div class="post" id="post-131631">
    <div class="subject"><a href="#post-131631">nasm, user/supervisor, ...</a></div>
    <div class="body">&gt; The syntax is well-defined. I have never seen a decent<br />&gt; definition of nasm's syntax.<br /><br />Can you explain what is a decent definition of a syntax?<br /><br />Anyway you can read the nasm documentation:<br /><a target="_blank" href="http://nasm.sourceforge.net/doc/html/nasmdoc0.html">http://nasm.sourceforge.net/doc/html/nasmdoc0.html</a><br /><br />&gt; All I know is that it's not  Intel's syntax<br /><br />I have the impression that you have never used NASM.<br />NASM use 100% intel syntax.<br /><br />What you call intel syntax: invoke, proc, if, while, offset, addr<br />byte or dword ptr, assume?</div>
    <div class="meta">Posted on 2004-01-25 11:09:46 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-131637">
    <div class="subject"><a href="#post-131637">nasm, user/supervisor, ...</a></div>
    <div class="body"><div class="quote">Can you explain what is a decent definition of a syntax?</div><br /><br />A formal specification of such.<br /><br /><div class="quote">I have the impression that you have never used NASM.</div><br /><br />How is that, because I don't like it? NASM is not the holy grail of assemblers, it is quite possible for someone to use it, and not like it.<br /><br /><div class="quote">NASM use 100% intel syntax.</div><br /><br />Wrong. I have the impression that you do not know what Intel Syntax is.<br /><br /><div class="quote">What you call intel syntax: invoke, proc, if, while, offset, addr<br />byte or dword ptr, assume?</div><br /><br />What I call Intel Syntax, is the syntax that Intel uses in their documents, and the syntax that assemblers such as MASM and TASM (when not in ideal mode) understand.<br />proc, offset, byte/dword ptr are part of those, for example. Whether or not assume is part of it, can be argued, I guess.<br />The others that you mention are MASM-specific macros (although IF is partly supported by TASM aswell).<br /><br />Anyway, let's take this rule of thumb: If I can copy a listing from an Intel manual, and assemble it as-is with an assembler, then it most probably supports Intel Syntax.<br />NASM does not, it has different rules for many things, and I find these rules ill-defined, that is, not even in the page that you linked to, is it explained afaik.</div>
    <div class="meta">Posted on 2004-01-25 12:38:01 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131644">
    <div class="subject"><a href="#post-131644">nasm, user/supervisor, ...</a></div>
    <div class="body">FASM cannot return value from macro either</div>
    <div class="meta">Posted on 2004-01-25 13:16:50 by comrade</div>
   </div>
   <div class="post" id="post-131650">
    <div class="subject"><a href="#post-131650">nasm, user/supervisor, ...</a></div>
    <div class="body">I think there is explained ;)<br /><br />Is simple like this:<br /><br />All in your sourcefile is data, this data have a address specific in the file (In reallity in the final format), you mark a specific address with a label (append ':' or dont use ':'), for use the address you only use name, for get the content at the address you use [].<br /><br />That is all that you need know for handle nasm :)<br /><br />let see if you undertand how easy was:<br /><br />hereAMark<br />mov eax, <br />jmp hereAMark<br /><br />You already know nasm syntaxis!!!!...<br /><br /><br />Yes there are some miss in the documentation.. there are some features that not much know (little they are, but are there...)<br /><br /><br />Maybe you are thinking that is good have the byte ptr, for my not, why type more in a instruction like this?<br /><br /><strong>mov byte ptr , 255</strong> when you already know that if you put [] are referencing the content at, the modifier byte is necesary for the ambiguity, see the note1.<br /><br /><strong>mov al, byte ptr </strong> also in nasm, you use: <strong>mov al,</strong>, here you see is superflows put byte ptr... because you already know the size for get (note1)... also you already know that is a ptr.... because if not... for what you will use [] that reference the content of memory?  hehehehehe, I supose that masm is so good for see the error if you use a instruction like this: <strong>mov al, word ptr</strong>, here you see, if masm give you a error here... masm already know how the instruction will be assembled (mov a byte), but having options that let you be 'superflous' I think that is the correct word. Like you see, more tipying, more tyip?ng is good and have options is good, but I think only when they are good options.<br /><br />note1: when you get/write or compare a memory, you have two things, the size of the address, and what address I need know the content, in nasm you only use [] for reference the content, then you already know that is what masm call <strong>ptr</strong>, the first thing to get, is what address, and this is inside the [], like this , and the second thing is the size of the operation, how many I whant get/write use/like_compare, if you give a register to the instruction for destine or source, the size modifier not have any sense!... because you cant  move a dword from a 1 byte register, and if you whant to move the content of a 1 byte register to a memory, how this content will be expanded to fit in 32 bit memory?, the only case when you need a modifier for nasm size operand of memory is when there o exist a register.<br /><br />cmp , byte 0<br />cmp byte, 0<br /><br />Here you see, a option that nasm give you, you can specify the size to the constant or the memory, but this is not ambihous, because like I say before if you know the size of the operand that is a byte, you can not get a size of a word of a operand that the size is one byte, equaly that if you know the destination can be filled with a byte, then the operand need feet in this size.<br /><br />note2: The only place that you will see [] other that for reference addresss, is with lea and friends, lea eax, <br /><br />note3: If you take that standar of intel docs, I am glad that nasm dont suport the intel sintaxis!!!!, this is more easy to understand and to type, the only that suport nasm from the intel sintaxis is the order of operands, the name of the registers, the ways of direction sometimg.. without use the superflows modifer of size where they are not neesary and the format of [] for address, also see that [] is like a box, is more graphic representation of content of memory, the isntruction set, also I think suport some things that are only from AMD.<br /><br />note3: you use masm because it give you de hability of write more fast code, because is structured programmin constructs...please dont miss what is a hll and what is structured programming!!!, if you use because give you this hability of structured programming... then see that insert in your typing and expression of solution some superflows instructions... that they are not really necesary.<br /><br /><br /><br />At the end we make solutions, but we express with the language of our choice, I think masm is  powerfull, but I dont feel confortable with, for me nasm make more sense.<br /><br />Also like you say, maybe nasm is not the holy grail (I dont know what is grail... but i reuse your words), for me masm is not too, but is more confortable, simple and sintetised for me nasm.<br /><br />Yes I am not saying that nasm dont have bugs... and other things, I am only saying that is more easy express a solution here, but like all, you need practice.<br /><br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-01-25 13:58:49 by rea</div>
   </div>
   <div class="post" id="post-131652">
    <div class="subject"><a href="#post-131652">nasm, user/supervisor, ...</a></div>
    <div class="body">&gt;&gt; Can you explain what is a decent definition of a syntax?<br /><br />&gt; A formal specification of such.<br /><br />In what formal language do you want it? First Order Logic?<br /><br />I think that this is job of the cpu designers, they decide<br />the instructions and mnemonics to use, no the assemblers<br />designers.<br /><br />Any way, what is the formal specification of the MASM syntax?<br /><br />&gt; NASM is not the holy grail of assemblers, it is quite possible<br />&gt; for someone to use it, and not like it.<br /><br />Yes, but neither MASM. <br /><br />I'm not saying what you must use. I only ask how can <br />you speak about something that you neither use nor know?<br />by pure imagination? <br /><br />&gt; I have the impression that you do not know what Intel<br />&gt; Syntax is<br /><br />No, I wrote a ix86 dissasembler without read the intel manuals!<br />Great miracle!<br /><br />Intel syntax:<br />mov eax, <br />or<br />lea eax, <br /><br />and<br />call function<br /><br />is different of:<br />call <br /><br />and NASM uses it so. All this is Intel.<br /><br />NASM uses it.<br /><br />&gt; proc, offset, byte/dword ptr<br /><br />I believed that those  MASM/TASM reserved words were <br />not CPU instructions. What does the proc instruction? <br />what is its opcode?<br /><br />I believed that 'offset' was a operator, not a CPU instruction.<br /><br />&gt; If I can copy a listing from an Intel manual, and assemble it <br />&gt; as-is with an assembler, then it most probably supports<br />&gt; Intel Syntax.<br /><br />Sorry, but there are so many listings in the Intel manual that I don't know what choice.<br /><br />&gt; NASM [...] has different rules for many things, and I find these<br />&gt; rules ill-defined, that is, not even in the page that you linked to,<br />&gt; is it explained afaik.<br /><br />What! Give me a example.</div>
    <div class="meta">Posted on 2004-01-25 14:10:46 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-131654">
    <div class="subject"><a href="#post-131654">nasm, user/supervisor, ...</a></div>
    <div class="body">A yess... I miss that one about the offset, like I say in the past, all in your sourcefile is data, and you mark specific locations with a label (only for not need to see where this realaddress is)<br /><br />I am not profitable in what is offset, even you see that I miss that one!!!, but what I know is that is only used for get  the address in the code of a label, where in nasm, you only use:<br /><br />mov eax, aLabel<br />in masm, you use some like:<br />mov eax, offset aLabel<br /><br /><br />I see two posibilities here, for what the masm developers choice (yes, even this guy need to choice), this format, I think that in masm you can not use:<br /><br />mov eax, aLabel<br /><br />returning to a brief analisys, you like a programmer, already know that you whant move the address of the label to the register eax, is that what you express in that line (for any later porpouses that you whant....) ... if not... you where not using  offset, you know that you need use offset, but for what masm can not get the address directly??, whitout saying that I whant the offset? explicitely?<br /><br />because I thing in some cause, (the first cause), some others masm sintaxis make mov eax, aLabel superflous or whas a collition of sintaxis..... inside masm, and getready for more extra typying (and they insert offset)... or because simple (the second cause)... masm can not diferentiate between a definition or a symbol defined by a equate and a label!!!!!<br /><br />If this is, I im impresed, because some of the things that I listen much times, is that masm parser is a lot so good, and I think it was... only when I analise now the posibilities for what masm need offset is that I see that the parser havesome faults too... masm can not diferentiate between a label and a equate?...and you need access directly the table of symbols? with the operator offset?<br /><br />Or I am going to far??, and is only simply a bad sintaxis design.<br /><br /><br />The last that I say..... this is more extra typing... when you do mov eax, aLabel, in nasm you already know that you whant move the address, and the &quot;simple assembler&quot; like nasm, know that you whant the address of this symbol, but with masm you not only know that you whant to move the address, but explicitely say to your assembler what you whant.<br /><br />Maybe you are thinking that in nasm you need too explicetely say to your assembler what to do, in fact, this is not true (only with the undefined operand read/write/manipulations), and if you whant other features, you can still read the nasm documentation.....<br /><br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-01-25 14:35:22 by rea</div>
   </div>
   <div class="post" id="post-131656">
    <div class="subject"><a href="#post-131656">nasm, user/supervisor, ...</a></div>
    <div class="body">Intel Syntax is the name for the assembly language syntax that you can write x86 programs in, as defined by Intel.<br />It is MORE than just the x86 mnemonics.<br />MASM and TASM obey Intel Syntax (and add some extra macros, directives and such), NASM does not.<br />NASM does use x86 mnemonics, but that's rather obvious, even AT&amp;T syntax uses those, and it is about as far from Intel Syntax as you can get.<br /><br />In short:<br />mov eax, dword ptr [0] is Intel Syntax<br />movl (0),%eax is AT&amp;T Syntax<br />mov eax, dword [0] is... something else.<br /><br />That is all I have to say about it, for the rest: use google.</div>
    <div class="meta">Posted on 2004-01-25 14:51:19 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131661">
    <div class="subject"><a href="#post-131661">nasm, user/supervisor, ...</a></div>
    <div class="body">is only mov eax, [0] (I think you not read the anterior post ;) )<br /><br />Also I think that maybe I not explain well the thing about the mathematics and logics... but hey... if you can have a more clean sintaxis... even if the standar use other, but if you can get a clean sintaxis...why not use it?<br /><br /><br />I am not saying that you need use nasm, but you need take care that you can have a more clean sintaxis, and yes, like you say, that is intel sitaxis, why(<strong>replace why with we</strong>) programm for the processor... the one that you call 'something else' is more near to what a mnemonic is... like you state here, and you give a point to to AT&amp;T sintaxis...., because you say that he uses mnemonics equal than nasm.<br /><br /><br />I think here you explain well the point, masm is Intel sitaxis, and nasm is mnemonic sintaxis.<br /><br />Also the mnemonic sintaxis is more clear than Intel one, I think can be good recognogize that is a more clean sintaxis, and without ambiguities... even if you dont use....<br /><br /><br />have a nice day or night.</div>
    <div class="meta">Posted on 2004-01-25 14:59:47 by rea</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16939&amp;page=1" style="">&laquo;</a><a href="../?id=16939&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16939" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>