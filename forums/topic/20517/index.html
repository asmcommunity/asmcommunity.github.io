<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Is NASM a backend to any HLL's? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20517" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=20517">Is NASM a backend to any HLL's?</a></p>
   <div class="post" id="post-156752">
    <div class="subject"><a href="#post-156752">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Hi,<br />I was just wondering if any compilers use NASM as a backend? Do you think it would be a good choice, in terms of speed, syntax etc.?</div>
    <div class="meta">Posted on 2005-02-07 00:44:58 by StefanD</div>
   </div>
   <div class="post" id="post-156755">
    <div class="subject"><a href="#post-156755">Re: Is NASM a backend to any HLL's?</a></div>
    <div class="body"><div class="quote">Hi,<br />I was just wondering if any compilers use NASM as a backend? Do you think it would be a good choice, in terms of speed, syntax etc.?</div><br /><br />Not an up-to-date information, so take it with a grain of salt.<br /><br />There were several attempts to use nasm with gcc.  One was for 32-bit and one was for x86-64.  The 32-bit version did not work out very well, and quickly died - or so I heard.  x86-64 version was initiated by AMD, and used for initial development of OS on x86-64.  But, not sure it is still available.<br /><br />lcc from Princeton can be configured to run nasm.  This is not applicable to native win-32 port of lcc maintained by someone else - it has its own assembler, which looks much more like djasm from djgpp.  I don't know about Peles C, which, BTW, seems to be a rip-off of lcc. (The original lcc license does not permit that kind of distribution.)<br /><br />And, maybe you want to check out nasm specific forum for more up-to-date info.</div>
    <div class="meta">Posted on 2005-02-07 02:17:06 by Starless</div>
   </div>
   <div class="post" id="post-156757">
    <div class="subject"><a href="#post-156757">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Perhaps you should try reading the <a target="_blank" href="http://www.cs.princeton.edu/software/lcc/pkg/CPYRIGHT">lcc license</a> one more time.</div>
    <div class="meta">Posted on 2005-02-07 02:35:08 by Jibz</div>
   </div>
   <div class="post" id="post-156762">
    <div class="subject"><a href="#post-156762">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Wow, I'm surprised more people haven't taken it on. I think its a pretty well designed piece of software, so I don't know why it isn't more popular. Most people are using MASM for windows programming aren't they?</div>
    <div class="meta">Posted on 2005-02-07 05:53:36 by StefanD</div>
   </div>
   <div class="post" id="post-156914">
    <div class="subject"><a href="#post-156914">Is NASM a backend to any HLL's?</a></div>
    <div class="body">&gt; I was just wondering if any compilers use NASM as a backend?<br /><br />I've used a win32 c compiler that uses NASM as a backend: CC386.<br />In http://www.members.tripod.com/~ladsoft/cc386.htm<br /><br />For C compilers programmers:<br />http://www.geocities.com/nilzone/<br /><br />For Linux:<br />http://retro.tunes.org/simplec/</div>
    <div class="meta">Posted on 2005-02-10 10:08:14 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-156922">
    <div class="subject"><a href="#post-156922">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Jibz is correct here, Pelle's C last I knew uses part of the LCC code properly in complaince with the licence and if fully legal software. Noting that Pelle wrote the vast majority of his system himself to produce a very good freeware C compiler, IDE and supporting system, in no sense could you call his work a rip off, just a very good project that is worth supporting.<br /><br />To address the original question, NASM is a very good multiport / multiplatform assembler but it is probably not fast enough to use as a dedicated back end for a C compiler. Something more bare bones like GAS is the right tool here if you need to take that approach.</div>
    <div class="meta">Posted on 2005-02-10 18:15:46 by hutch--</div>
   </div>
   <div class="post" id="post-156923">
    <div class="subject"><a href="#post-156923">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Hrm, GAS more barebone than NASM? GAS supports multiple architectures and both intel and AT&amp;T syntax... I haven't done any direct speed comparisons, but GAS feels heavier. Might just be me, though :)<br /><br />Anyway, I'd suggest using FASM for compiler backends - it's very fast, and Privalov has put a pride in making it faster whenever it's not &quot;fast enough&quot;.<br /><br />And, well, ideally a compiler shouldn't use an assembler as a backend anyway - it should generate &quot;pcode&quot; in memory and then directly output x86 code from that. Going from pcode-&gt;asm-&gt;x86 code is a silly additional step of parsing, and a relic of old tool design.</div>
    <div class="meta">Posted on 2005-02-10 18:28:10 by f0dder</div>
   </div>
   <div class="post" id="post-156924">
    <div class="subject"><a href="#post-156924">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Yes,<br /><br />FASM is a good choice for a compiler back end as it is genuinely fast enough and certainly a lot easier to construct the front end output for.<br /><br />An interesting comment on pcode production, I know that almost all compilers use an internal image of the source loaded into a variety of complex data structures but I miss the value of the pcode generation first. It sounds like a redundant step.</div>
    <div class="meta">Posted on 2005-02-10 18:57:26 by hutch--</div>
   </div>
   <div class="post" id="post-156925">
    <div class="subject"><a href="#post-156925">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Disclaimer: I haven't done compiler theory, so this is a bit sketchy, but I'll try anyway.<br /><br />As I understand it, a compiler parses (tokenizes, lexes, whatever) it's source into an abstract syntax tree. This is done to verify correct input, and because the AST is a handy way of representing the source; you have it pre-parsed in a binary format, so you don't need to constantly call strlen etc. This AST is also easier to manipulate than text source.<br /><br />Thus, once you have the AST (or &quot;pcode&quot;), you can start doing optimizations, constant folding, expression reduction, ... - so it is <strong>not</strong> a redundant step at all, it's actually required :)<br /><br />From the pcode, you can directly generate native output for whatever CPUs you choose to support. Hell, you can consider .asm output as a specific CPU and fileformat combination. You need a pcode-&gt;whatever backend no matter what you do, and I guess choosing .asm output is &quot;the easy way&quot; to get multiple file format support for a given CPU, without having to add a file-format layer too.<br /><br />And again, the above is mostly guesswork, so I could be terribly wrong - it makes sense to me, though :)<br /><br />Btw, an interesting thing about using pcode representation. If your format is flexible enough, you can have multiple languages using the same pcode format... and thus the same optimizer. Iirc Microsoft did this for VC6 and VB6. Of course VB doesn't go all that fast, because of it's runtime and the language itself. But it's interesting nevertheless.</div>
    <div class="meta">Posted on 2005-02-10 19:19:35 by f0dder</div>
   </div>
   <div class="post" id="post-156929">
    <div class="subject"><a href="#post-156929">Is NASM a backend to any HLL's?</a></div>
    <div class="body">They essentially do that for .NET; compiling all languages to an &quot;intermediate language&quot; then to native code.</div>
    <div class="meta">Posted on 2005-02-10 21:18:20 by drhowarddrfine</div>
   </div>
   <div class="post" id="post-156930">
    <div class="subject"><a href="#post-156930">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Before .NET is used as a case against pcode in compiler technology, keep in mind that .NET is usually JITed (and that the JITer could still use a lot of work), that the .NET framework is &quot;pretty big&quot;, and that there may be better pcode formats than MSIL (is it stack or register based, btw?)</div>
    <div class="meta">Posted on 2005-02-10 21:25:11 by f0dder</div>
   </div>
   <div class="post" id="post-156933">
    <div class="subject"><a href="#post-156933">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Ok, I get the word usage, I usually don't associate pcode with data abstraction in a data structure. I remember pcode as the crap that old VB used to save as a file and it was not very nice stuff.<br /><br />The use of assembler output, (for whatever processor) is a useful step in that the data once it is ordered in the data structures can then be passed through an optimisation stage which generally produces a lot better code if the optimiser design is up to scratch.<br /><br />I tend to see .NET as a big VB runtime wired into later OS versions and I doubt the code quality is all that good but then for its target market, it most probably does not matter. The idea of retaining &quot;unmanaged code&quot; solves the problem where .NET is simply not fast enough or powerful enough to perform a specialised task.</div>
    <div class="meta">Posted on 2005-02-10 22:26:57 by hutch--</div>
   </div>
   <div class="post" id="post-156938">
    <div class="subject"><a href="#post-156938">Is NASM a backend to any HLL's?</a></div>
    <div class="body"><div class="quote"><br />The use of assembler output, (for whatever processor) is a useful step in that the data once it is ordered in the data structures can then be passed through an optimisation stage which generally produces a lot better code if the optimiser design is up to scratch. <br /></div><br />Optimization is being done <strong>before</strong> assembly output, on the program while it is in pcode form. A lot of internal information is lost once assembly output is generated, making it a lot harder to optimize (optimizing assembly output is roughly equivalent to optimizing an existing .exe, although you do have a bit more information available.)<br /><br />Unfortunately I've lost the link, but there was an interesting article on the architecture of Visual C++ - basically how it first does generic (platform-independent) optimizations on the pcode (like simplyfying expressions), then the backend (itanium, x86, x86-64) does CPU-specific optimizations, and then finally code is generated.</div>
    <div class="meta">Posted on 2005-02-11 01:51:16 by f0dder</div>
   </div>
   <div class="post" id="post-156939">
    <div class="subject"><a href="#post-156939">Is NASM a backend to any HLL's?</a></div>
    <div class="body">NASM used to be the assembler used by PureBasic, but it switched to FASM a year ago or so.<br /><br />Regards,</div>
    <div class="meta">Posted on 2005-02-11 02:05:37 by El_Choni</div>
   </div>
   <div class="post" id="post-156942">
    <div class="subject"><a href="#post-156942">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Yes,<br /><br />The 2 stage methods makes sense. Expression simplification tends to cover up bad programming practice where the backend optimisation is capable of delivering good performance if it is well designed. One of the problem that shows even in very recent compilers is the RISC based register theory where you see far more redundant loads and stores to memory under x86 because of the limited number of registers.<br /><br />The real problem is that different hardware has different assumptions and optimising for a processor with many more registers than x86 is a very different matter to dealing with a processor that has 8 general purpose registers.<br /><br />I am inclined to think that a heuristic approach based on the known chaacteristics of a processor family yield better results than more generalised  RISC based compiler theory. I am of the view that the gap between well written assembler code and compiler output could be closed a lot by the heuristic approach.<br /><br />Regards,<br /><br />hutch at movsd dot com</div>
    <div class="meta">Posted on 2005-02-11 03:45:51 by hutch--</div>
   </div>
   <div class="post" id="post-156943">
    <div class="subject"><a href="#post-156943">Is NASM a backend to any HLL's?</a></div>
    <div class="body"><div class="quote"><br />Expression simplification tends to cover up bad programming practice<br /></div><br />Leaving expressions in a &quot;non-optimal&quot; (mathematically wise) form isn't always because of bad programming practice - it can improve code readability (although, of course, code itself should not be the only form of documentation). This kind of optimization also has other purposes - you might need the same subexpression multiple times. Instead of calculating it and putting it in a temporary variable, you can use the subexpression multiple times and have the compiler doing the tedious job - again improving code readability. I remember how some code looked in the old days when compilers where a lot more stupid, and I certainly don't want to go back ;)<br /><br /><div class="quote"><br />The real problem is that different hardware has different assumptions and optimising for a processor with many more registers than x86 is a very different matter to dealing with a processor that has 8 general purpose registers. <br /></div><br />Which is why you split the optimization in two parts - first the generic &quot;logical&quot; optimizations, dead code elimination, expression folding (like inlining function calls, or replacing them by constants when you can (which happens more often than you might think, when using link-time code generation)), et cetera. And then the architecture specific optimization stage, which does register allocation and such.<br /><br /><div class="quote"><br />I am of the view that the gap between well written assembler code and compiler output could be closed a lot by the heuristic approach.<br /></div><br />Using profiler-based based compilation also helps - it lets the compiler see which code is run most often, which branches are usually taken, et cetera. I'm sure how much this gains you in percent speedwise, but every little bit helps :)</div>
    <div class="meta">Posted on 2005-02-11 03:56:06 by f0dder</div>
   </div>
   <div class="post" id="post-156967">
    <div class="subject"><a href="#post-156967">Is NASM a backend to any HLL's?</a></div>
    <div class="body">Here is where I see the problem, writing lousy code and hoping the compiler will fix it up has a very bad track record and while modern compilers will fix up a lot of mistakes or inefficient code, you will never get good code that way. Many modern compilers are capable of producing code at the binary output and that is within range of well written assembler code but it will come from programmers who understand the machine and write their code accordingly.<br /><br />To this extent I fully agree with Randy Hyde in his new book about writing GREAT CODE. Without a grasp of what a compiler is doing under the hood, you end up with rubbish which many produce with even very good compilers.<br /><br />I see the real action in compiler design as producing high quality binary output and for what is a little extra programmer effort, not making obvious mistakes in terms of code efficiency and writing decent code to start with will deliver code that is good enough.<br /><br />The alternative is the bloated garbage that many produce because they either know no better or could not care less. It used to be viable to assume that the next generation of computer hardware would fix the problems of slow lousy code but the advance of computer hardware has slowed a lot in the last couple of years and software will have to get better to keep up with demand.<br /><br />Regards,<br /><br />hutch at movsd dot com</div>
    <div class="meta">Posted on 2005-02-12 00:08:42 by hutch--</div>
   </div>
   <div class="post" id="post-156980">
    <div class="subject"><a href="#post-156980">Is NASM a backend to any HLL's?</a></div>
    <div class="body"><div class="quote"><br />hoping the compiler will fix it up has a very bad track record<br /></div><br />Indeed.<br /><br /><div class="quote"><br />Without a grasp of what a compiler is doing under the hood, you end up with rubbish<br /></div><br />Indeed.<br /><br />However, with a HLL, the programmer should be freed from certain tasks. Of course it's still your own responsibility to use your brain and math skills, select optimal algorithms, choose good data structures, order data in an efficient way (like array of structures vs. structure of arrays) and so on.<br /><br />But you should be free of &quot;micro-management&quot; tasks - otherwise there isn't much benefit from using a HLL. Fortunately, compilers of today tend to handle this well.</div>
    <div class="meta">Posted on 2005-02-12 07:34:57 by f0dder</div>
   </div>
  </div>
 </body>
</html>