<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>TUTORIAL: Win32 OpenGL Demos for ObjAsm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29863" />
  <link rel="prev" href="../?id=29863&amp;page=1" />  <link rel="next" href="../?id=29863&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29863">TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29863&amp;page=1" style="">&laquo;</a><a href="../?id=29863&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29863" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29863&amp;page=3">&gt;</a><a href="../?id=29863&amp;page=3">&raquo;</a></form>   <div class="post" id="post-211063">
    <div class="subject"><a href="#post-211063">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">First i want to say big thanks for the work you put down writing these tutorials, i really appreciate it.<br />Its a big shame tho that its so few that visits this forum.<br /><br /><br />now to my question, in demo #7, something goes wrong for me<br />line 48<br /><pre><code>.if $inv(glGenTextures,1, addr texid)==0</code></pre><br />glGenTextures returns 1 for me, and triggers the msgbox saying error<br /><br />this is my first time ever i deal with opengl, or any graphics library for that part, but i tried to see if i could solve this on my own.<br />checking the documentation on opengl.com (http://www.opengl.org/sdk/docs/man/xhtml/glGenTextures.xml) it says the return value of glGenTextures is void.<br />so i figured since you set texid to 0 before the call, that maybe everything is as it should if we instead check texid so it contains a pointer after the call<br /><pre><code>invoke glGenTextures,1, addr texid<br />.if texid!=0 </code></pre><br />like that, but it just draws the shapes without any texture at all<br /><br />so what do i do wrong? ^^<br /><br />also, when checking out the opengl apis, is it http://www.opengl.org/sdk/docs/man/ thats recommended to use?</div>
    <div class="meta">Posted on 2010-03-19 08:16:30 by Azura</div>
   </div>
   <div class="post" id="post-211064">
    <div class="subject"><a href="#post-211064">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Hi, Azura :)<br />This can happen if you tried to load a texture, but have not yet set a Render Context.. make sure the window is created and the render context is set before trying to load a texture.<br />In fact, you will find that there are two possible error codes that can be returned by glGenTextures - but I am not sure that this behavior (when we dont have a RC yet) is defined, or this error code is defined - but I did fall for this trap originally, and a little detective work showed me that I was not alone.<br />Just know that we do expect zero, and in this case, we will have a nonzero texture id returned to the array we specified (in our case, an array of just one element).<br /><br />Complete documentation of the specification can be found at http://www.opengl.org/documentation/<br /><br />Attached is demo 8.<br />This time, I have modified the texture loader to use OA32&#039;s Pixelmap class.<br />Although this is one seriously powerful and cool class, I&#039;m only using it here to help load various image file formats.<br />Pixelmap uses IPicture to load image files to a device-independant bitmap (internally) - we have access to the bitmap information, including the raw pixel data. It supports BMP, JPEG, TGA and others.<br />This example comes with a JPEG (1024x1024) which is being used to texture our tetrahedron.<br />You&#039;ll notice that textures are now loaded and released by a pair of new bookend functions, and that we now unload and reload textures during screen mode switches.<br /><br />In the next example, we&#039;ll learn about mipmaps and texture filtering, which can improve the way a texture appears when it is scaled up or down outside of its usual size (say, if we are very close or very far from something)...ie, what opengl will do if it needs to &#039;invent&#039; more texture data than exists in the image, or needs to &#039;drop&#039; some texture data.<br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3091" target="_blank">OpenGL_Demo8.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-19 09:10:37 by Homer</div>
   </div>
   <div class="post" id="post-211069">
    <div class="subject"><a href="#post-211069">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">In the OpenGL_Demo8.rar you included a binary and no source.<br /><br /><br /><br />I tried to look deeper into my problem but still cant find out whats wrong.<br />When running your OpenGL_Demo7 code unmodified, or when running the binary you included as OpenGL_Demo8, thats when i get the error &quot;Failed glGenTextures&quot;.<br /><br />If I do the following, checking every of the functions so they do their job:<br /><pre><code><br />RegisterClass<br />CreateWindowEx<br />GetDC<br /><br />ChoosePixelFormat<br />SetPixelFormat<br /><br />wglCreateContext<br />wglMakeCurrent<br /><br />glGenTextures</code></pre><br />then glGenTextures still fails like before<br /><br />edit: calling glGetError after glGenTextures returns 0<br /><br />edit 2: i think the opengl version that is being used is 1.4<br />if that is to any help</div>
    <div class="meta">Posted on 2010-03-19 16:12:45 by Azura</div>
   </div>
   <div class="post" id="post-211070">
    <div class="subject"><a href="#post-211070">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Whoops!<br />Attached is source for demo8, did not bother reattaching the jpeg.<br /><br />Your glGenTextures problem sounds like it could be driver-specific... even though the return value is declared as void in older documentation, that same documentation clearly mentions two possible error codes - so it can&#039;t be void, can it? :P<br /><br />Instead of checking the return value of the api, check whether the texid changed from zero.<br />If it did, consider it successful.<br />Try that, and let me know what happens.<br />If that fails we&#039;ll investigate this further, as that api function should never fail, and is absolutely required for texturing.<br /><br />You&#039;ll see in demo8 that WinMain now calls &#039;ReloadTextures&#039; - just after checking the returnvalue from calling &#039;CreateGLWindow&#039;... but essentially the same idea, so won&#039;t immediately solve your problem.<br />Did the demo8 binary actually run ok for you?<br /><br />PS I added a line to find out the opengl version at runtime and throw a string to debug.<br />Like glGenTextures, it requires a valid Render Context.<br />Apparently I&#039;m using OpenGL v3.2.0<br />This probably explains whats going on with the differences in return values / documentation of the api.<br />Chances are good that your code is actually working fine - but I would still suggest to upgrade your opengl driver at your videocard&#039;s vendor site - and I am seriously considering throwing an error for early versions of OpenGL drivers and telling the user to go update their stuff... 1.4 is quite out of date now, version 4 is in beta.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3093" target="_blank">OpenGL_Demo8.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-19 19:40:51 by Homer</div>
   </div>
   <div class="post" id="post-211071">
    <div class="subject"><a href="#post-211071">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Demo 9 : Texture Filtering<br /><br />If you look closely at the Texture Loader, you will notice these two lines:<br /><pre><code><br />invoke glTexParameteri,GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR;	// Linear Min Filter<br />invoke glTexParameteri,GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR;	// Linear Mag Filter<br /></code></pre><br /><br />Here, we are selecting the &#039;minify and magnify filters&#039;.<br />These tell OpenGL what to do if there is too much texture data, or not enough, to cover a surface on the screen.<br />This is especially obvious when objects are very close, or very far away.<br />Of the six possible filter options, the last four all require something called &#039;mipmaps&#039;.<br />Let&#039;s describe quickly what mipmaps are, and then look at the possible filtering options.<br /><br />Mipmaps are copies of a texture with different levels of quality.<br />OpenGL can choose which &#039;level of density&#039; (mipmap texture) to use based on the pixel/texel ratio, which can drastically improve the visual quality of the rendered scene (by eliminating artefacts such as moire patterns, and providing antialiasing of edges).<br />We can tell OpenGL to generate mipmaps for a given texture by adding one more api call to our texture loader, as can be seen in the attached sourcecode.<br /><br /><br />MinFilter can use any of the six possible options, whereas MagFilter can only use the first two of these.<br />Note that the remaining four options all require &#039;mipmaps&#039;. <br /><br /><div class="quote"><br />GL_NEAREST<br /> &nbsp; &nbsp;Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured. <br />GL_LINEAR<br /> &nbsp; &nbsp;Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include border texture elements, depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping. <br />GL_NEAREST_MIPMAP_NEAREST<br /> &nbsp; &nbsp;Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. <br />GL_LINEAR_MIPMAP_NEAREST<br /> &nbsp; &nbsp;Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value. <br />GL_NEAREST_MIPMAP_LINEAR<br /> &nbsp; &nbsp;Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values. <br />GL_LINEAR_MIPMAP_LINEAR<br /> &nbsp; &nbsp;Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values. <br /><br /></div><br /><br />The attached demo allows you to switch between three sets of min/mag filters by pressing and releasing the F key.<br />I suggest you run this in a large window, or fullscreen, or you may not notice the difference, as there is still no way to move closer to our tetrahedron.<br /><br />Now some notes about the implementation.<br />Since changing the filter is a texture function, it only affects the texture to which we are currently bound.<br />In a demo with multiple textures, our rendering function would be binding to each texture before using it.<br />If we&#039;re going to change the filter in that scenario, it has to happen after each glBindTexture call, so we should not be doing this from some random thread like WndProc, and we should only be doing it if the filter actually changed, not just calling it naively (though to be honest I don&#039;t think theres a big penalty if we do that).<br />In this demo, I only call the BindTexture once, so I can actually safely set the filters any time I like.<br />However I have given example code for how to use a Global variable as a flag to communicate a filter change, which should be monitored from the render function. Of course, we don&#039;t normally go changing filters arbitrarily.<br />Most sourcecode for this topic actually generates three textures, and sets up the filters for each, then just switches textures at runtime - I wanted to show that we don&#039;t need three copies of the same texture to achieve three filter effects.<br /><br />Next, we will begin looking at Lighting, Normals and Materials :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3094" target="_blank">OpenGL_Demo9.asm</a></li>
      <li><a href="../../attachments/?id=3097" target="_blank">screenshot.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-19 21:38:03 by Homer</div>
   </div>
   <div class="post" id="post-211072">
    <div class="subject"><a href="#post-211072">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Demo10 - Basic Lighting and Surface Normals<br /><br />Once we introduce Lighting, our 3D scene really comes alive. It makes a massive difference.<br /><br />Lights have several attributes:<br />Ambient - this is &nbsp;the color which a light contributes to the entire scene. You typically only want one ambient light in your scene, as it dictates how things look in the ABSENCE of light, if that makes sense.<br />Diffuse - this is the color which a light casts apon objects in the scene, ie the color of REFLECTED light, more on this later.<br />Specular - this is the color of the light reflected in the specular highlight we see apon shiny surfaces.<br />Cone Radius - This is used to make &#039;spotlights&#039; with a cone of given angle (r15 = a 30 degree cone).<br />Cone Direction - For Spotlights, the direction the Cone is facing (ie which way is the spotlight facing)<br />Linear Attenuation - How light diminishes over distance<br />Angular Attenuation - For Spotlights only, how light diminishes from the center of the cone to the outer radius.<br /><br />We won&#039;t use all of these at first, we&#039;ll introduce them in stages.<br /><br />The other thing which affects the way objects look under lighting is called Material.<br />Materials describe the way light is reflected off them, which in the real world, would depend what they are &#039;made of&#039;.<br />We can for example describe how &#039;shiny&#039; something is.<br />We&#039;ll look at point lights, then spotlights, then we&#039;ll play with Materials.<br /><br />My next post will contain a very simple Lighting demo, with &#039;Surface Normals&#039; and a single Point light.<br />Although Surface Normals look ok for objects with big flat surfaces, they are not very good for &#039;rounded/smooth&#039; surfaces, so I&#039;ll follow that up with an example that uses &#039;Vertex Normals&#039; (lighting is smoothed across surfaces).<br />We&#039;ll learn how to calculate Surface Normals using crossproducts, and subsequently we&#039;ll learn how to convert SurfaceNormals into Vertex Normals. <br />In fact, for any convex polygon like our tetrahedron and cube which are centered on their Origin, we can actually cheat and calculate all this stuff far more quickly, but lets learn how to do it for ANY shape ;)<br /><br />When we finally look at vertex and &#039;fragment&#039; (pixel) shaders, we&#039;ll have the opportunity to take full control of lighting, and much of these early examples will seem redundant.<br />But one step at a time, yes?<br /><br /></div>
    <div class="meta">Posted on 2010-03-19 23:15:04 by Homer</div>
   </div>
   <div class="post" id="post-211073">
    <div class="subject"><a href="#post-211073">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><div class="quote"><br />Mipmaps are copies of a texture with different levels of quality.</div><br /><br />I&#039;d like to add that mipmaps are scaled-down versions of the original texture. Usually they are a sequence where you cut the resolution in half at each step.<br />Eg, if you have a 512x512 texture, you will get the following set of mipmaps:<br />512x512 (the original)<br />256x256<br />128x128<br />64x64<br />32x32<br />16x16<br />8x8<br />4x4<br />2x2<br />1x1<br /><br />The key to these scaled-down textures is that a filter is applied during the downscaling process. So they are pre-filtered textures. This allows for efficient filtering in realtime.</div>
    <div class="meta">Posted on 2010-03-20 04:18:34 by Scali</div>
   </div>
   <div class="post" id="post-211074">
    <div class="subject"><a href="#post-211074">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><br />So.. Steps to creating our first light:<br /><br /><pre><code><br />&nbsp; &nbsp; .data<br />Color4 struct<br />	r real4 ?<br />	g real4 ?<br />	b real4 ?<br />	a real4 ?<br />Color4 ends<br /><br />AmbientLight Color4 &lt;0.5f,0.5f,0.5f,1.0f&gt;			;Ambient white light, of mid strength<br />DiffuseLight Color4 &lt;1.0f,1.0f,1.0f,1.0f&gt;			;Full intensity white light<br />SpecularLight Color4 &lt;1.0f,1.0f,1.0f,0.0f&gt;&nbsp; 		;Specular highlight<br />PositionLight Color4&nbsp; &lt;0.0f,0.0f,-2.0f,1.0f&gt;		;Position light just behind the camera, facing outwards<br /><br />.code<br />	;Initialize Lighting<br />&nbsp; &nbsp; invoke glLightfv,GL_LIGHT1, GL_AMBIENT, addr AmbientLight<br />&nbsp; &nbsp; invoke glLightfv,GL_LIGHT1, GL_DIFFUSE, addr DiffuseLight<br />&nbsp; &nbsp; invoke glLightfv,GL_LIGHT1, GL_SPECULAR,addr SpecularLight<br />&nbsp; &nbsp; invoke glLightfv,GL_LIGHT1, GL_POSITION, addr PositionLight<br />&nbsp; &nbsp; invoke glEnable,GL_LIGHT1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; invoke glEnable,GL_LIGHTING<br /></code></pre><br /><br />OpenGL supports a fixed number of lights - we are setting properties for Light #1.<br />We then ENABLE Light #1.<br />Finally, we ENABLE LIGHTING (there is NO lighting without this final step).<br /><br />That&#039;s enough to get lighting to work, but it won&#039;t look at all right unless we add some Normals to our geometry (in our render function).<br /><br />So - what is a Normal? Well, its a vector which tells us which Direction something is facing.<br />In Demo10, we will look now at what Surface Normals are all about.<br />And in Demo11, we will learn about &#039;per-vertex&#039; Normals.<br /><br />A surface normal is an imaginary arrow which points outwards from a surface.<br />For a triangle, or any convex polygon (of a given winding order), we can calculate the surface normal from any two consecutive Edges using a CrossProduct.<br /><br />In 3D vector math, aside from vector addition and subtraction, the most common operations are called DotProduct and CrossProduct. I won&#039;t elaborate here on these math operations too much, I&#039;ll just point out that if we take the CrossProduct of two Vectors, we get a third Vector which is orthogonal to both the others - which in fact is the definition of a Surface Normal - literally, it will tell us which way the 3D surface is facing. And our Lighting needs that.<br /><br />Depending on our &#039;prior knowledge&#039; of the geometry, there are certainly alternative ways to determine a SurfaceNormal, but this way is a good general solution.<br /><br />The DotProduct can be calculated as follows:<br />Given two input vectors v1 and v2,<br />find&nbsp; v = v1 x v2<br />		vx = v1y * v2z - v1z * v2y<br />		vy = v1z * v2x - v1x * v2z<br />		vz = v1x * v2y - v1y * v2x<br /><br />We can write a small macro or function to perform that task quickly.<br />Now all we need to do is calculate the SurfaceNormal for each Face of our tetrahedron, and apply them in our render function.<br />Code to follow.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-03-20 06:10:55 by Homer</div>
   </div>
   <div class="post" id="post-211075">
    <div class="subject"><a href="#post-211075">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><div class="quote"><br />Your glGenTextures problem sounds like it could be driver-specific... even though the return value is declared as void in older documentation, that same documentation clearly mentions two possible error codes - so it can&#039;t be void, can it? :P<br /><br />Instead of checking the return value of the api, check whether the texid changed from zero.<br />If it did, consider it successful.</div><br />It does change. <br />After looking into it more, it seems it is like you say it is, successful since texid changes (glGetError also reports no error). Everytime i call glGenTextures it return the amount of textures generated, which i guess is just specific to my system (which actually gives it a kinda bad behavior imo, calling it with for example n=some known error code, will make it return that error no matter if its succesfull or not)<br /><br /><div class="quote"><br />Try that, and let me know what happens.<br />If that fails we&#039;ll investigate this further, as that api function should never fail, and is absolutely required for texturing.<br /><br />You&#039;ll see in demo8 that WinMain now calls &#039;ReloadTextures&#039; - just after checking the returnvalue from calling &#039;CreateGLWindow&#039;... but essentially the same idea, so won&#039;t immediately solve your problem.<br />Did the demo8 binary actually run ok for you?</div><br />I have a couple of different results:<br /><br />The demo8 binary you attached, when running it it first says &quot;failed glGenTextures&quot; then after pressing ok, it continues and draws the shape but completely white (understandable since after it says failed it doesnt finish the rest of LoadTexture)<br /><br />Modifying the demo7 code to allow glGenTextures if texid is changed, results in white shapes, which it shouldnt<br /><br />Modifying the demo8 code to allow glGenTextures if texid is changed, results in success<br /><br />After modifying I cant see why demo7 wont work when demo8 does, but it works atleast and i dont know if its worth the time to try track down whats actually failing in demo7 for me<br /><br /><div class="quote"><br />PS I added a line to find out the opengl version at runtime and throw a string to debug.<br />Like glGenTextures, it requires a valid Render Context.<br />Apparently I&#039;m using OpenGL v3.2.0<br />This probably explains whats going on with the differences in return values / documentation of the api.<br />Chances are good that your code is actually working fine - but I would still suggest to upgrade your opengl driver at your videocard&#039;s vendor site - and I am seriously considering throwing an error for early versions of OpenGL drivers and telling the user to go update their stuff... 1.4 is quite out of date now, version 4 is in beta.</div><br />Not much i can do about it :(<br />The driver i have is the latest one, dating feb 2008<br />and after running the demo8 code i can confirm its version 1.4.0<br /><br />I have only tested the things up to demo8 so far but since my opengl version is kinda old, i guess there will be parts later on which i cant do. Is there anything to do about it except getting new hardware?<br /><br /><br /><br />edit: source for demo10 is missing?</div>
    <div class="meta">Posted on 2010-03-20 07:29:02 by Azura</div>
   </div>
   <div class="post" id="post-211076">
    <div class="subject"><a href="#post-211076">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><div class="quote">Everytime i call glGenTextures it return the amount of textures generated</div><br /><br />Actually, it returns the first unused TextureName - these are simply indices, starting at 1 (0 is reserved).<br />If you loaded a few textures, the number would increment.<br />There is no guarantee the numbers will be always in order, as you might (?) release them out of order, leaving unused TextureNames. I refer to OpenGL TextureNames as TextureIDs, since thats what they really are.<br /><br /><div class="quote"><br /><br />After modifying I cant see why demo7 wont work when demo8 does, but it works atleast and i dont know if its worth the time to try track down whats actually failing in demo7 for me<br /></div><br /><br />There was a small bug in the TextureLoader logic which was fixed by me silently.<br />One of the error cases, I can&#039;t remember, but I fixed it.<br /><br /><div class="quote"><br />since my opengl version is kinda old, i guess there will be parts later on which i cant do. <br />Is there anything to do about it except getting new hardware?<br /></div><br />Well, it&#039;s not going to matter for quite a while, but it&#039;s still not the end of the world.. it is generally possible to emulate most advanced stuff on low-end hardware via different (slower) techniques - we can make our programs scale to the hardware they are running on, by choosing (at runtime from several possible techniques) the best one that will run on this hardware. And we can also give the user the ability to bias this decision-making (turn down features) in order to improve performance on slower machines.<br /><br />It should not be expected that everyone has the latest, greatest hardware and drivers - we should be able to code around this fact of life.<br /><br />I will at some time soon repost all the demos with some corrections and so on.<br />But I do want to press on with the series.<br />Anyway, I&#039;m glad demo8 worked ok for you :)<br />And I will change the TextureLoader logic to work on both new and older OpenGL drivers, thanks to your informative response :)<br /><br />edit: Oh - Source for Demo10 will be posted as soon as I&#039;ve finished describing what makes it tick.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-03-20 08:06:41 by Homer</div>
   </div>
   <div class="post" id="post-211077">
    <div class="subject"><a href="#post-211077">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">OK, I&#039;m gonna let the code speak for itself.<br />If anyone wants to ask me what a SurfaceNormal is, then I will explain it.<br />The source contains some new macros for performing operations with Vectors of arbitrary precision.<br />It also contains a small function for calculating the SurfaceNormal from three consecutive Points of a Face - to Vec3 precision, which is what we need for Normals in OpenGL.<br /><br />The next demo will show how to calculate a Normal for each and every Vertex in our tetrahedron, so we can have nicer lighting.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3099" target="_blank">OpenGL_Demo10.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-20 08:36:51 by Homer</div>
   </div>
   <div class="post" id="post-211078">
    <div class="subject"><a href="#post-211078">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Demo11: Simple Lighting with Vertex Normals<br /><br />We have the SurfaceNormals.<br />Now we want to find a Normal for each VERTEX instead.<br />How do we do that?<br /><br />For each Vertex in our shape, we will find the Average of the Sum of all the Faces which share that Vertex.<br /><br />But this time I&#039;m going to cheat, based on my prior knowledge of the shape.<br />Since the shape is a regular Convex Solid which is centered apon its Origin, the vertex normals are simply the vertices themselves - that is to say, if we want to know the direction of the arrow from the origin to each vertex, it is quite simply the value of each vertex point.<br /><br /></div>
    <div class="meta">Posted on 2010-03-20 08:59:57 by Homer</div>
   </div>
   <div class="post" id="post-211079">
    <div class="subject"><a href="#post-211079">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><div class="quote"><br />It should not be expected that everyone has the latest, greatest hardware and drivers - we should be able to code around this fact of life.</div><br /><br />Especially with OpenGL there can be quite a few problems in this area.<br /><br />Firstly, do not expect the latest drivers for given hardware to also support the latest OpenGL specifications. For example, on Mac OS X, you still only get OpenGL 2.1, which dates from 2006. On Windows, Intel only supports OpenGL 2.0 (from 2004), even on their latest DX10 hardware.<br /><br />Secondly, each driver has its own shader compiler built in, which may have slightly different behaviour (also note that GLSL syntax is not always fully backwards compatible with older versions). So having shaders that compile on one vendor&#039;s drivers is no guarantee that they work on another vendor&#039;s drivers aswell, even when they both support the same OpenGL/GLSL version.<br /><br />Lastly, the behaviour of OpenGL itself is not fully backwards compatible... Some functionality is scrapped altogether in newer versions... in other cases, new extensions may alter the behaviour of existing APIs. A good example of that is the use of vertex arrays. When you use vertex buffer objects, you no longer pass pointers, but rather element offsets to gl*Pointer() functions. With older versions of OpenGL, binding a VBO with name 0 will disable vertexbuffers, and restore the legacy functionality. With newer versions, binding VBO with name 0 is an invalid operation.<br /><br />Things can get pretty hairy if you try to write OpenGL code that actually works on machines other than your own.</div>
    <div class="meta">Posted on 2010-03-20 09:54:30 by Scali</div>
   </div>
   <div class="post" id="post-211087">
    <div class="subject"><a href="#post-211087">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><br />Here is the sourcecode for Demo11.<br />It&#039;s a simple modification of Demo10.<br />All I&#039;ve done is change the render function to use a Normal for each vertex - and as mentioned, in my special case of a tetrahedron centered on its origin, I was able to &#039;know&#039; the VertexNormal for each vertex in advance.<br /><br />Just a few quick words about Directions and stuff.<br /><br />In openGL, you have a coordinate system where you are looking in to the XY Plane, along the MINUS Z axis.<br />You&#039;ll note that to see our tetrahedron, we are translating it to MINUS 6 in the Z axis.<br />So Negative-Z means &#039;into the screen&#039;.<br />When we set the Position of our Light, you&#039;ll notice that we put it at PLUS 4 in the Z axis.<br />This implies that the Light is somewhere just behind the viewer, thus lighting the Scene in front of it.<br />We could have just left it at the Origin (where our camera is), but it would be a little close to the subject, and we wouldn&#039;t be able to see the light &#039;fall off&#039; over distance.<br />This is called &#039;attenuation&#039;.<br />OpenGL performs attentuation automatically, however it is possible to manipulate the attenuation in a few ways.<br />At the moment, our light is actually Directional, and just happens to be pointing in -Z by default.<br />We can make a spotlight by setting a cone radius, and we can set the Direction.<br />It is good to imagine a default light as being a cone light of 180 degrees spread!!<br /><br />In the next demo, we&#039;ll turn our Light into a spotlight.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3100" target="_blank">OpenGL_Demo11.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-20 19:27:48 by Homer</div>
   </div>
   <div class="post" id="post-211123">
    <div class="subject"><a href="#post-211123">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">My Demo10 and Demo11 is showing different lightnings (atleast different strength of light, the directions is hard to tell), shouldnt they be more or less the same?<br /><br />Also since its normals, shouldnt they be normalized (dont know if thats the word used in english, but have length of 1)?<br />I mean thats how a normal is in math, in opengl or graphics i have no idea but i guess it should be the same?</div>
    <div class="meta">Posted on 2010-03-26 08:34:14 by Azura</div>
   </div>
   <div class="post" id="post-211124">
    <div class="subject"><a href="#post-211124">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Not sure how i should explain this but ill give it a try.<br /><br />Before i saw the results of the demos that have lightning included (specially demo11), i thought the result would look like before but the parts which had light on them would be lighter.<br />Now looking on how the result really become i also notice that parts which doesnt have much light on them becomes darker then before, so adding lightning also adds some kind of &quot;darkness&quot;, is there any way to change how light/dark this darkness should be?</div>
    <div class="meta">Posted on 2010-03-26 08:39:56 by Azura</div>
   </div>
   <div class="post" id="post-211145">
    <div class="subject"><a href="#post-211145">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">#1 - OpenGL automatically normalizes its Normals, it just needs a Direction :)<br />#2 - We can modify the &#039;attenuation&#039; of a Spotlight - how fast the light fades and how big the cone of the spotlight is etc.<br /><br />I didn&#039;t pick a very good example shape to show lighting effects, because the angle between any two faces is quite severe in our example - this tends to exaggerate lighting effects just as it does in real life.<br /></div>
    <div class="meta">Posted on 2010-03-28 07:01:21 by Homer</div>
   </div>
   <div class="post" id="post-212601">
    <div class="subject"><a href="#post-212601">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">This is an amazing set of tutorials even though texturing does not work on my nvidia :( I&#039;m sure I can sort that out if you continue</div>
    <div class="meta">Posted on 2010-08-10 14:26:17 by danielrhodea</div>
   </div>
   <div class="post" id="post-212617">
    <div class="subject"><a href="#post-212617">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><br />How about some requests?<br /></div>
    <div class="meta">Posted on 2010-08-11 00:28:20 by Homer</div>
   </div>
   <div class="post" id="post-212726">
    <div class="subject"><a href="#post-212726">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Well, one request that I&#039;d like to put in:<br />Could you include a working binary with every sample you release?<br />That way it takes some uncertainty out of the equation. You know that the binary is built correctly, so that&#039;s what it SHOULD be doing.<br />If you set up the build environment yourself, it may not build exactly as intended.<br /><br />In fact, I&#039;m lazy myself, and can&#039;t really be bothered to build the samples from source code, because I&#039;d have to set up a build environment for it specifically. I&#039;d just like to read through the sourcecode and run the binary to see what it does.<br /><br />I&#039;d like to say the same for your physics stuff. It&#039;s interesting to read through the various posts, but it would be nice to have some &#039;hands on&#039; stuff as well. Some simple binary to play with, and to see how it works in practical situations. It might make things &#039;come alive&#039; to people more.</div>
    <div class="meta">Posted on 2010-08-16 04:39:08 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29863&amp;page=1" style="">&laquo;</a><a href="../?id=29863&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29863" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29863&amp;page=3">&gt;</a><a href="../?id=29863&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>