<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>TUTORIAL: Win32 OpenGL Demos for ObjAsm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29863" />
    <link rel="next" href="../?id=29863&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29863">TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29863&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29863&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29863" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29863&amp;page=2">&gt;</a><a href="../?id=29863&amp;page=3">&raquo;</a></form>   <div class="post" id="post-210986">
    <div class="subject"><a href="#post-210986">TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Hey folks!<br />Ever wanted to get into 3D programming but didn&#039;t know where to start?<br />This tutorial will contain a series of examples which will help you to learn OpenGL programming using the ObjAsm32 rapid application development environment (OOPASM). <br />You will need MASM or JWASM installed, and you will also need to install ObjAsm32.<br /><br />Our first mission will be to create a simple demo which creates an application window, initializes opengl, and uses opengl to render black nothingness. We will implement code to toggle between windowed and fullscreen mode, and we&#039;ll watch the ESCAPE key for quitting the application.<br /><br />Attached is the democode, in the next post I&#039;ll explain what&#039;s going on in that sourcecode, in detail.<br />All future demos in this thread will be based apon this simple application framework.<br /><br /><br />ObjAsm users, be aware of the magical ONLINE UPDATER tool (see Projects folder). You can use this to keep up to date with the latest OA32 updates, without having to reinstall the entire package.<br /><br />Biterider, feel free to go ahead and add these to ObjAsm32&#039;s examples folder as I roll them out.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3076" target="_blank">OpenGL_Demo1.asm</a></li>
      <li><a href="../../attachments/?id=3077" target="_blank">OpenGL_Demo1.inc</a></li>
      <li><a href="../../attachments/?id=3078" target="_blank">opengl32.inc</a></li>
      <li><a href="../../attachments/?id=3079" target="_blank">glu32.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-12 22:08:15 by Homer</div>
   </div>
   <div class="post" id="post-210994">
    <div class="subject"><a href="#post-210994">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Ooh, I missed one file - uploaded.<br />I have only bothered to correct the prototypes of functions I actually used so far.<br /><br />So, let&#039;s have a look whats happening in this sourcecode, starting at the Program Entrypoint:<br /><br /><pre><code>;Program EntryPoint<br />start:<br />	SysInit<br />	mov &nbsp; &nbsp;CommandLine,$inv(GetCommandLine)	<br />	invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT<br />	SysDone<br />	invoke ExitProcess,eax</code></pre><br /><br /><br />At the program entrypoint, the first line we see says &quot;SysInit&quot;.<br />This is typically the first line in any ObjAsm sourcecode, it initializes the OOP environment, I won&#039;t elaborate since this is not a tutorial on the internals of ObjAsm !! Suffice to say, it is partnered with a line &#039;SysDone&#039;, which is typically immediately followed by a call to ExitProcess.... what interests us must occur between these bookends.<br /><br />So, ignoring those, our first &#039;real&#039; line is a call to GetCommandLine.<br />I&#039;m not using commandline stuff in this program, but you never know, its nice to have.<br />Then we see a call to WinMain, ahhh here we go !!<br />We can see that when this call returns, the program will terminate, so all the goodness must be inside WinMain :)<br /><br /><pre><code><br /><br />;Our main program loop.. windows message pump !!<br />;Create our App Window for OpenGL Rendering..<br />;Then start pumping WM&#039;s until its time to die.<br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />LOCAL msg:MSG<br /><br /><br />	<br />	; Ask The User Which Screen Mode They Prefer<br />	@invoke MessageBox,NULL,&quot;Would You Like To Run In Fullscreen Mode?&quot;, &quot;Start FullScreen?&quot;,MB_YESNOCANCEL or MB_ICONQUESTION<br />	.if eax==IDNO<br />		mov fullscreen,FALSE<br />	.elseif eax==IDCANCEL<br />		return FALSE<br />	.endif<br /></code></pre><br /><br />First thing WinMain does is ask the user what screenmode to start with.<br />The user can change it by pressing F1, so its not too important, but its nice to ask.<br /><br /><pre><code><br />	; Create Our OpenGL Window<br />	@invoke CreateGLWindow,&quot;OpenGL Demo #1&quot;,640,480,16,fullscreen<br />	.if !eax<br />		DbgWarning &quot;Window Create failed&quot;<br />		return FALSE<br />	.endif<br /></code></pre><br />We see a call to a function named &#039;CreateGLWindow&#039; - its parameters are: Window Width, Window Height, ColorBitsPerPixel, Boolean WantFullScreen?<br />This function returns TRUE or FALSE to indicate success or failure.<br />We look at the returned value, and if we failed we&#039;ll quit now.<br />Assuming we did not fail, the next code is:<br /><br /><pre><code>	<br />	.repeat<br />		.if $invoke(PeekMessage,addr msg,NULL,0,0,PM_REMOVE)		<br />			.if msg.message==WM_QUIT			<br />				.break<br />			.else<br />				invoke TranslateMessage,addr msg<br />				invoke DispatchMessage,addr msg<br />			.endif<br />		.else		<br />			; Draw The Scene. &nbsp;Watch For ESC Key And Quit Messages From DrawGLScene()<br />			.if (active &amp;&amp; !$invoke(DrawGLScene)) || keys<br />				.break<br />			.else<br />				invoke SwapBuffers,hDC<br />			.endif<br /><br />			.if keys			<br />				mov keys,FALSE<br />				;Destroy the Window<br />				invoke KillGLWindow<br />				;Toggle fullscreen mode flag<br />				xor fullscreen,TRUE<br />				;Recreate the Window with new screen mode<br />				@invoke CreateGLWindow,&quot;OpenGL Demo #1&quot;,640,480,16,fullscreen<br />				.if !eax<br />					DbgWarning &quot;CreateGLWindow failed&quot;<br />					.break<br />				.endif<br />			.endif<br />		.endif<br />	.until 0<br /></code></pre><br />Note that this code is bookended by &#039;.repeat .... .until 0&#039;<br />This is an INFINITE LOOP - we&#039;ll have to break out of this loop if we want to quit now.<br />What we are looking at is called the &#039;Window MessagePump&#039; - its the main program loop.<br />I assume you&#039;re familiar with this thing.<br />Pseudocode for my loop is:<br /><br />-if theres a Window Message (WM) available<br />-- dispatch it<br />-else<br />--if the escape key isnt pressed<br />---call DrawGLScene<br />--else<br />---break the main loop<br />--endif<br />--if F1 key is pressed<br />---call KillGLWindow<br />---toggle screen mode<br />---call CreateGLWindow<br />--endif<br />-endif<br /><br /><pre><code><br />	; Shutdown<br />	invoke KillGLWindow<br />	return msg.wParam<br />WinMain endp<br /></code></pre><br /><br />Should we break from the infinite loop, we&#039;ll kill the window and return from WinMain and terminate the program.<br /><br />So, we just discovered two new functions we&#039;ll wanna look at - CreateGLWindow and KillGLWindow.<br />But there&#039;s one more that should interest us - WndProc. Let&#039;s continue with CreateGLWindow, where WndProc is first mentioned...<br /><br />Everyone keeping up so far? This is all pretty simple stuff for people who have already written Windows apps, but it might benefit someone, who knows.<br /><br />Next post will document at least the three functions mentioned, and I might even manage to squeeze in the whole remaining program description, maybe.<br /><br />Let me know if any of you have problems building the demo!<br /><br /></div>
    <div class="meta">Posted on 2010-03-13 18:57:27 by Homer</div>
   </div>
   <div class="post" id="post-210995">
    <div class="subject"><a href="#post-210995">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><pre><code><br />CreateGLWindow proc psztitle, dwidth, dheight,&nbsp; dbits,&nbsp; fullscreenflag<br />LOCAL PixelFormat<br />local wc:WNDCLASS<br />local dwStyle,dwExStyle<br />LOCAL rc:RECT<br />LOCAL dmScreenSettings:DEVMODE<br />LOCAL pfd:PIXELFORMATDESCRIPTOR<br />	mov rc.left,0<br />	m2m rc.right,dwidth<br />	mov rc.top,0<br />	m2m rc.bottom,dheight<br />	m2m fullscreen,fullscreenflag<br /><br />	invoke RtlZeroMemory,addr wc,sizeof wc<br />	mov wc.style, CS_HREDRAW or CS_VREDRAW or CS_OWNDC;		// Redraw On Size, And Own DC For Window.<br />	mov wc.lpfnWndProc	,offset WndProc<br />	mov wc.cbClsExtra	,0<br />	mov wc.cbWndExtra	,0<br />	m2m wc.hInstance	,hInstance<br />	mov wc.hIcon		,$inv(LoadIcon,NULL, IDI_WINLOGO);			// Load The Default Icon<br />	mov wc.hCursor		,$inv(LoadCursor,NULL, IDC_ARROW);			// Load The Arrow Pointer<br />	mov wc.hbrBackground,0<br />	mov wc.lpszMenuName	,0<br />	mov wc.lpszClassName,$OfsCStr(&quot;OpenGL&quot;)<br /><br />	.if !$inv(RegisterClass,addr wc)<br />		@invoke MessageBox,NULL,&quot;Failed To Register The Window Class.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE;												// Return FALSE<br />	.endif<br /></code></pre><br />We are setting up a RECT to contain our desired window dimensions, and then registering a Window Class whose messagehandler is called &#039;WndProc&#039; - we&#039;ll look at that function shortly.<br /><br /><pre><code><br />		<br />	.if fullscreen	<br />		DbgText &quot;yes&quot;<br />		invoke RtlZeroMemory,addr dmScreenSettings,sizeof dmScreenSettings<br />		mov dmScreenSettings.dmSize,sizeof dmScreenSettings<br />		m2m dmScreenSettings.dmPelsWidth,dwidth<br />		m2m dmScreenSettings.dmPelsHeight,dheight<br />		m2m dmScreenSettings.dmBitsPerPel,dbits<br />		mov dmScreenSettings.dmFields,(DM_BITSPERPEL or DM_PELSWIDTH or DM_PELSHEIGHT)<br />		; Try To Set Selected Mode And Get Results.&nbsp; NOTE: CDS_FULLSCREEN Gets Rid Of Start Bar.<br />		.if $inv(ChangeDisplaySettings,addr dmScreenSettings,CDS_FULLSCREEN)!=DISP_CHANGE_SUCCESSFUL		<br />			; If The Mode Fails, Offer Two Options.&nbsp; Quit Or Use Windowed Mode.<br />			@invoke MessageBox,NULL,&quot;The Requested Fullscreen Mode Is Not Supported By\nYour Video Card. Use Windowed Mode Instead?&quot;,&quot;NeHe GL&quot;,MB_YESNO or MB_ICONEXCLAMATION<br />			.if eax==IDYES<br />				mov fullscreen,FALSE<br />			.else<br />				; Pop Up A Message Box Letting User Know The Program Is Closing.<br />				@invoke MessageBox,NULL,&quot;Program Will Now Close.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONSTOP<br />				return FALSE<br />			.endif<br />		.endif<br />	.endif<br /></code></pre><br />If the caller has requested fullscreen mode, we&#039;ll fill out a description of our desired fullscreen settings, and call a function named &#039;ChangeDisplaySettings&#039; - if that failed, we can fall back on windowed mode, but ask the user first.<br /><br /><br /><pre><code>	<br />	.if (fullscreen)		; Are We Still In Fullscreen Mode?<br />		mov dwExStyle,WS_EX_APPWINDOW;									// Window Extended Style<br />		mov dwStyle,WS_POPUP;											// Windows Style<br />		invoke ShowCursor,FALSE;		 Hide Mouse Pointer<br />	.else<br />		mov dwExStyle,WS_EX_APPWINDOW or WS_EX_WINDOWEDGE;				// Window Extended Style<br />		mov dwStyle,WS_OVERLAPPEDWINDOW;								// Windows Style<br />	.endif<br /><br />	invoke AdjustWindowRectEx,addr rc, dwStyle, FALSE, dwExStyle;		// Adjust Window To True Requested Size<br /><br />	; Create The Window<br />	<br />	mov edx,dwStyle<br />	or edx,WS_CLIPSIBLINGS or WS_CLIPSIBLINGS<br />	invoke CreateWindowEx,	dwExStyle,$OfsCStr(&quot;OpenGL&quot;),psztitle,edx,<br />								0, 0,<br />								dwidth,;rc.right-rc.left,	;// Calculate Window Width<br />								dheight,;rc.bottom-rc.top,	;// Calculate Window Height<br />								0,0,hInstance,0<br />	mov hWnd,eax							<br />	.if !eax<br />		invoke KillGLWindow<br />		@invoke MessageBox,NULL,&quot;Window Creation Error.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /></code></pre><br />Now we&#039;ll create the application window, using the Window Class we registered earlier.<br />If fullscreen, we&#039;ll use a POPUP window style, which has no buttons or titlebar at the top.<br />Otherwise it&#039;ll be a normal overlapped window style.<br /><br /><pre><code><br />	<br />	invoke RtlZeroMemory,addr pfd,sizeof pfd<br />	mov pfd.nSize,sizeof pfd<br />	mov pfd.nVersion,1<br />	mov pfd.dwFlags,PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER<br />	mov pfd.iPixelType,PFD_TYPE_RGBA<br />	mov edx,dbits<br />	mov pfd.cColorBits,dl<br />	mov pfd.cDepthBits,16&nbsp; &nbsp;  ;should be dbits<br />	mov pfd.iLayerType,PFD_MAIN_PLANE<br />	<br />	mov hDC,$inv(GetDC,hWnd)<br />	.if !eax<br />		invoke KillGLWindow<br />		int 3<br />		@invoke MessageBox,NULL,&quot;Can&#039;t Create A GL Device Context.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /><br />	mov PixelFormat,$inv(ChoosePixelFormat,hDC,addr pfd)<br />	.if !eax<br />		invoke KillGLWindow<br />		@invoke MessageBox,NULL,&quot;Can&#039;t Find A Suitable PixelFormat.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /></code></pre><br />We&#039;ll ask OpenGL to choose a pixel format that is compatible with our window.<br /><br /><pre><code><br />	.if !$inv(SetPixelFormat,hDC,PixelFormat,addr pfd)<br />		invoke KillGLWindow<br />		@invoke MessageBox,NULL,&quot;Can&#039;t Set The PixelFormat.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /></code></pre><br />We&#039;ll tell OpenGL to use the pixelformat it suggested.<br /><br /><pre><code><br />	mov hRC,$inv(wglCreateContext,hDC)<br />	.if eax==0<br />		invoke KillGLWindow<br />		@invoke MessageBox,NULL,&quot;Can&#039;t Create A GL Rendering Context.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /></code></pre><br />Try to create an OpenGL Rendering Context.<br /><br /><pre><code><br />	.if $inv(wglMakeCurrent,hDC,hRC)==0<br />		invoke KillGLWindow<br />		@invoke MessageBox,NULL,&quot;Can&#039;t Activate The GL Rendering Context.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /></code></pre><br />Tell OpenGL to use this Render Context<br /><br /><pre><code><br />	invoke ShowWindow,hWnd,SW_SHOW<br />	invoke SetForegroundWindow,hWnd<br />	invoke SetFocus,hWnd<br />	invoke ReSizeGLScene,dwidth, dheight<br /></code></pre><br />Make our window topmost, give it keyboard focus, and call a function named &#039;ResizeGLScene&#039; ... we&#039;ll need to call this anytime the size of the window changed.<br /><br /><pre><code><br />	.if !$inv(InitGL)<br />		invoke KillGLWindow<br />		@invoke MessageBox,NULL,&quot;Initialization Failed.&quot;,&quot;ERROR&quot;,MB_OK or MB_ICONEXCLAMATION<br />		return FALSE<br />	.endif<br /><br />	return TRUE<br />CreateGLWindow endp<br /></code></pre><br /><br />Call a function named &#039;InitGL&#039; - it simply selects some minimal rendering settings.<br />Then we return to the caller TRUE (yay) or FALSE (noooo)<br />That&#039;s it for CreateGLWindow.<br />Now we can look quickly at KillGLWindow, then start to look at the new functions whose names we have discovered.<br /><br /></div>
    <div class="meta">Posted on 2010-03-13 19:24:36 by Homer</div>
   </div>
   <div class="post" id="post-210996">
    <div class="subject"><a href="#post-210996">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><pre><code>;Release our RenderDC, WindowDC, Window and Class<br />KillGLWindow proc<br />	.if fullscreen<br />		invoke ChangeDisplaySettings,NULL,0<br />		invoke ShowCursor,TRUE	<br />	.endif<br /></code></pre><br />If we&#039;re in fullscreen mode, switch back to windowed mode, and unhide the mouse cursor<br /><br /><pre><code><br />	.if hRC	<br />		.if !$invoke (wglMakeCurrent,NULL,NULL)		<br />			@invoke MessageBox,NULL,&quot;Release Of DC And RC Failed.&quot;,&quot;SHUTDOWN ERROR&quot;,MB_OK or MB_ICONINFORMATION<br />		.endif<br /></code></pre><br />Unselect the Render Context<br /><br /><pre><code><br />		.if !$invoke(wglDeleteContext,hRC)		<br />			@invoke MessageBox,NULL,&quot;Release Rendering Context Failed.&quot;,&quot;SHUTDOWN ERROR&quot;,MB_OK or MB_ICONINFORMATION<br />		.endif<br />		mov hRC,NULL<br />	.endif<br /></code></pre><br />Destroy our Render Context<br /><br /><pre><code><br />	.if hDC &amp;&amp; ($invoke(ReleaseDC,hWnd,hDC)==0)<br />		@invoke MessageBox,NULL,&quot;Release Device Context Failed.&quot;,&quot;SHUTDOWN ERROR&quot;,MB_OK or MB_ICONINFORMATION<br />		mov hDC,0<br />	.endif<br /></code></pre><br />Release our Device Context<br /><br /><pre><code><br />	.if hWnd &amp;&amp; ($invoke(DestroyWindow,hWnd)==0)<br />		@invoke MessageBox,NULL,&quot;Could Not Release hWnd.&quot;,&quot;SHUTDOWN ERROR&quot;,MB_OK or MB_ICONINFORMATION<br />		mov hWnd,0<br />	.else<br />		DbgWarning &quot;Window Closed&quot;<br />	.endif<br /></code></pre><br />Destroy application window<br /><br /><pre><code><br />	@invoke UnregisterClass,&quot;OpenGL&quot;,hInstance<br />	.if !eax	<br />		@invoke MessageBox,NULL,&quot;Could Not Unregister Class.&quot;,&quot;SHUTDOWN ERROR&quot;,MB_OK or MB_ICONINFORMATION<br />		mov hInstance,0<br />	.endif<br />	ret<br />KillGLWindow endp<br /></code></pre><br />Unregister our Window Class and return to caller.<br /><br />Well that covers the window create and destroy functions, now we&#039;ll look at WndProc, and then the last couple of remaining functions :) <br />Almost there !!</div>
    <div class="meta">Posted on 2010-03-13 19:34:42 by Homer</div>
   </div>
   <div class="post" id="post-210997">
    <div class="subject"><a href="#post-210997">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><pre><code><br />;Application Window&#039;s Message Handler<br />;No suprises here, we watch for some keypresses and make sure nothing turns the screen off<br />WndProc proc hWin:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />	.switch uMsg<br />		.case WM_ACTIVATE<br />			mov eax,wParam<br />			shr eax,16<br />			.if !ax<br />				mov active,TRUE			<br />			.else			<br />				mov active,FALSE<br />			.endif<br />			return 0<br /></code></pre><br />If the application becomes inactive or is reactivated, we&#039;ll take note.		<br /><br /><pre><code><br />		.case WM_SYSCOMMAND<br />			mov eax,wParam<br />			.if eax==SC_SCREENSAVE || eax==SC_MONITORPOWER<br />				return 0;Prevent From Happening<br />			.endif<br /></code></pre><br />If a screensaver or powersaving feature tries to turn the screen off, we&#039;ll force it to stay awake<br /><br /><pre><code><br />		.case WM_CLOSE		<br />			invoke PostQuitMessage,0<br />			return 0<br /></code></pre><br />If the user closes the application, we&#039;ll post a message to quit.<br /><br /><pre><code><br />		.case WM_KEYDOWN			<br />			mov edx,wParam<br />			mov keys  , TRUE<br />			return 0<br />		<br />		.case WM_KEYUP<br />			mov edx,wParam<br />			mov keys,FALSE<br />			return 0<br /></code></pre><br />We will keep an array of 256 bytes, representing all possible keypresses.<br />If a key is pressed or released, we will set a byte representing that key to true or false.<br /><br /><pre><code><br />		.case WM_SIZE<br />			mov eax,lParam<br />			mov edx,eax<br />			shr edx,16<br />			and eax,0FFFFh<br />			invoke ReSizeGLScene,eax,edx<br />			return 0<br />	.endsw<br /></code></pre><br />If the user stretches the window, we will call ResuzeGLScene with the new window dimensions.<br />	<br /><pre><code><br />	; Pass All Unhandled Messages To DefWindowProc<br />	invoke DefWindowProc,hWin,uMsg,wParam,lParam<br />	ret<br />WndProc endp<br /></code></pre><br />Just what it says - any WM&#039;s we did not handle ourselves are passed to the default handler.<br /><br />OK, That&#039;s it for WndProc.<br />We just have a handful of functions left to look at :)<br /></div>
    <div class="meta">Posted on 2010-03-13 19:47:02 by Homer</div>
   </div>
   <div class="post" id="post-210998">
    <div class="subject"><a href="#post-210998">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><pre><code><br />;Initialize our most basic render settings<br />InitGL proc<br />	invoke glEnable,GL_TEXTURE_2D;									 Enable Texture Mapping<br />	invoke glShadeModel,GL_SMOOTH;									 Enable Smooth Shading<br />	@invoke glClearColor,0,0,0, r4_half;							 Black Background<br />	invoke glClearDepth,r8_1;										 Depth Buffer Setup<br />	invoke glEnable,GL_DEPTH_TEST;									 Enables Depth Testing<br />	invoke glDepthFunc,GL_LEQUAL;									 The Type Of Depth Testing To Do<br />	invoke glHint,GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST;		 Really Nice Perspective Calculations<br />	return TRUE;													 Initialization Went OK<br />InitGL endp<br /></code></pre><br /><br />This just sets up a bunch of typical render settings - we can change these any time.<br /><br /><pre><code><br />;Render the Scene (one frame)<br />DrawGLScene proc<br />	invoke glClear,GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT<br />	return TRUE<br />DrawGLScene endp<br /></code></pre><br />Our render function just clears the screen to blackness, and clears the &#039;depth buffer&#039; (more on that later).<br />If our app is working, we will see a black window :)<br /><br />This is the end of Tutorial #1.<br />If you have questions, please feel free to ask them here !!</div>
    <div class="meta">Posted on 2010-03-13 19:52:36 by Homer</div>
   </div>
   <div class="post" id="post-210999">
    <div class="subject"><a href="#post-210999">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">For those who managed to build the first tutorial sourcecode, congratulations, you made your first OpenGL app :)<br />But gee Homer, its a bit boring.<br />It would be nice to be able to see something other than just blackness!!<br />Today we&#039;re going to draw a Triangle, and a Square.<br />Not super exciting, but hey, we&#039;re just getting started :)<br />Anyway it will be nice to be able to see &#039;something&#039;, right?<br /><br /><pre><code><br />;Render the Scene (one frame)<br />;We are going to draw a Triangle, and a Rectangle (&#039;quad&#039;).<br />DrawGLScene proc<br />.data<br /> &nbsp;;Let&#039;s define a 3D Vector as a set of three floats:<br /> &nbsp;Vec3 struct<br /> &nbsp;	x real4 ?<br /> &nbsp;	y real4 ?<br /> &nbsp;	z real4 ?<br /> &nbsp;Vec3 ends<br /> &nbsp;;Data for our Triangle and Quad &nbsp;<br /> &nbsp;Translate1 Vec3 &lt;-1.5f,0.0f,-6.0f&gt; &nbsp; ;Translation from (0,0,0) to origin of Triangle<br /> &nbsp;Translate2 Vec3 &lt;3.0f,0.0f,0.0f&gt; &nbsp; &nbsp; ;Translation from origin of Triangle to origin of Square<br /> &nbsp;TriPoint1 &nbsp;Vec3 &lt;0.0f, 1.0f, 0.0f&gt;	;Three points make a Triangle<br /> &nbsp;TriPoint2 &nbsp;Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;TriPoint3 &nbsp;Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint1 Vec3 &lt;-1.0f, 1.0f, 0.0f&gt; &nbsp; ;Four points make a Quad<br /> &nbsp;QuadPoint2 Vec3 &lt;1.0f, 1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint3 Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint4 Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;.code<br /></code></pre><br />Define some data we&#039;ll use to draw a triangle and a square.<br /><br /><pre><code><br />	invoke glClear,GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT<br /></code></pre><br />Clear the window to blackness, also clear the z buffer<br /><br /><pre><code><br />	invoke glLoadIdentity										; Reset the current modelview matrix<br /></code></pre><br />Set our magical 3D pen to the world origin (0,0,0)<br /><br /><pre><code><br />	invoke glTranslatef,Translate1.x,Translate1.y,Translate1.z	; Move left 1.5 units and into the screen 6.0<br /></code></pre><br />Move our magical 3D pen to where we want our triangle to be drawn<br /><br /><pre><code><br />	invoke glBegin,GL_TRIANGLES									; Drawing using triangles<br /></code></pre><br />Tell OpenGL that we want to draw triangles<br /><br /><pre><code><br />		invoke glVertex3f,TriPoint1.x,TriPoint1.y,TriPoint1.z	; Top<br />		invoke glVertex3f,TriPoint2.x,TriPoint2.y,TriPoint2.z	; Bottom left<br />		invoke glVertex3f,TriPoint3.x,TriPoint3.y,TriPoint3.z	; Bottom right<br /></code></pre><br />Draw the triangle by declaring its three points<br /><br /><pre><code><br />	invoke glEnd												; Finished Drawing The Triangle<br /></code></pre><br />Tell OpenGL that we&#039;re finished drawing (triangles)<br /><br /><pre><code><br />	invoke glTranslatef,Translate2.x,Translate2.y,Translate2.z	; Move right 3 units<br /></code></pre><br />Move our magical 3D pen over to the right - notice this is relative to the previous position, since we have not called &#039;glLoadIdentity&#039; to reset the magical 3D pen to the world origin again.<br /><br /><pre><code><br />	invoke glBegin,GL_QUADS &nbsp; &nbsp;									; Draw a quad<br /></code></pre><br />Tell OpenGL we want to draw using &#039;quads&#039; (rectangles)<br /><br /><pre><code><br />		invoke glVertex3f,QuadPoint1.x,QuadPoint1.y,QuadPoint1.z; Top left<br />		invoke glVertex3f,QuadPoint2.x,QuadPoint2.y,QuadPoint2.z; Top right<br />		invoke glVertex3f,QuadPoint3.x,QuadPoint3.y,QuadPoint3.z; Bottom right<br />		invoke glVertex3f,QuadPoint4.x,QuadPoint4.y,QuadPoint4.z; Bottom left<br /></code></pre><br />Draw a square, that means 4 points are needed.<br /><br /><pre><code><br />	invoke glEnd												; Finished Drawing The Quad<br /></code></pre><br />Tell OpenGL we&#039;re done drawing (quads)<br /><br /><pre><code><br />	return TRUE<br />DrawGLScene endp<br /></code></pre><br />Return to caller...<br /><br />You can copy/paste that replacement function, or if you&#039;re lazy like me, download the attached update :)<br />Of course, feel free to ask questions or just comment - this is not a formal classroom, this is a friendly learning environment :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3080" target="_blank">OpenGL_Demo2.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-13 21:18:50 by Homer</div>
   </div>
   <div class="post" id="post-211000">
    <div class="subject"><a href="#post-211000">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Well, white shapes on a black background isnt much more exciting, is it?<br />Lets add some color :)<br /><br /><pre><code><br />;Render the Scene (one frame)<br />;We are going to draw a Triangle, and a Rectangle (&#039;quad&#039;).<br />DrawGLScene proc<br />.data<br /> &nbsp;;Let&#039;s define a 3D Vector as a set of three floats:<br /> &nbsp;Vec3 struct<br /> &nbsp;	x real4 ?<br /> &nbsp;	y real4 ?<br /> &nbsp;	z real4 ?<br /> &nbsp;Vec3 ends<br /> &nbsp;;Lets define a Color with 3 components (RGB)<br /> &nbsp;RGB struct<br /> &nbsp;	red &nbsp; real4 ?<br /> &nbsp;	green real4 ?<br /> &nbsp;	blue &nbsp;real4 ?<br /> &nbsp;RGB ends<br /> &nbsp;;Data for our Triangle and Quad &nbsp;<br /> &nbsp;Translate1 Vec3 &lt;-1.5f,0.0f,-6.0f&gt; &nbsp; ;Translation from (0,0,0) to origin of Triangle<br /> &nbsp;Translate2 Vec3 &lt;3.0f,0.0f,0.0f&gt; &nbsp; &nbsp; ;Translation from origin of Triangle to origin of Square<br /> &nbsp;TriPoint1 &nbsp;Vec3 &lt;0.0f, 1.0f, 0.0f&gt;	;Three points make a Triangle<br /> &nbsp;TriPoint2 &nbsp;Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;TriPoint3 &nbsp;Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint1 Vec3 &lt;-1.0f, 1.0f, 0.0f&gt; &nbsp; ;Four points make a Quad<br /> &nbsp;QuadPoint2 Vec3 &lt;1.0f, 1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint3 Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint4 Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;;Some colors<br /> &nbsp;Color1 RGB &lt;1.0f,0.0f,0.0f&gt;<br /> &nbsp;Color2 RGB &lt;0.0f,1.0f,0.0f&gt;<br /> &nbsp;Color3 RGB &lt;0.0f,0.0f,1.0f&gt;<br /> &nbsp;.code<br />	invoke glClear,GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT<br />	invoke glLoadIdentity										; Reset the current modelview matrix<br />	invoke glTranslatef,Translate1.x,Translate1.y,Translate1.z	; Move left 1.5 units and into the screen 6.0<br />	invoke glBegin,GL_TRIANGLES									; Drawing using triangles<br />		invoke glColor3f,Color1.red,Color1.green,Color1.blue<br />		invoke glVertex3f,TriPoint1.x,TriPoint1.y,TriPoint1.z	; Top<br />		invoke glColor3f,Color2.red,Color2.green,Color2.blue<br />		invoke glVertex3f,TriPoint2.x,TriPoint2.y,TriPoint2.z	; Bottom left<br />		invoke glColor3f,Color3.red,Color3.green,Color3.blue<br />		invoke glVertex3f,TriPoint3.x,TriPoint3.y,TriPoint3.z	; Bottom right<br />	invoke glEnd												; Finished Drawing The Triangle<br />	invoke glTranslatef,Translate2.x,Translate2.y,Translate2.z	; Move right 3 units<br />	invoke glBegin,GL_QUADS &nbsp; &nbsp;									; Draw a quad<br />		invoke glColor3f,Color1.red,Color2.green,Color3.blue<br />		invoke glVertex3f,QuadPoint1.x,QuadPoint1.y,QuadPoint1.z; Top left<br />		invoke glColor3f,Color2.red,Color2.green,Color3.blue<br />		invoke glVertex3f,QuadPoint2.x,QuadPoint2.y,QuadPoint2.z; Top right<br />		invoke glColor3f,Color1.red,Color1.green,Color3.blue<br />		invoke glVertex3f,QuadPoint3.x,QuadPoint3.y,QuadPoint3.z; Bottom right<br />		invoke glColor3f,Color1.red,Color2.green,Color2.blue<br />		invoke glVertex3f,QuadPoint4.x,QuadPoint4.y,QuadPoint4.z; Bottom left<br />	invoke glEnd												; Finished Drawing The Quad<br />	return TRUE<br />DrawGLScene endp<br /></code></pre><br />Just before we declare each Point in our geometry (triangle and square), we will specify a COLOR for that point, using the function &#039;glColor3f&#039; (the 3f indicates that theres 3x real4 floating point parameters).<br /><br />Colors can be any mixture of the three components Red, Green and Blue, which are each represented as a floating-point value in the range 0.0 to 1.0 &nbsp;... so you can invent your own colors very easily :)<br /> <br />In fact, we don&#039;t have to set the color for EVERY point - if we wanted several points to have the same color, we could set the color once, then emit several points.<br />In OpenGL, most settings will remain active unless you change them.<br /><br />Lazy people can download the update :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3081" target="_blank">OpenGL_Demo3.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-13 21:54:18 by Homer</div>
   </div>
   <div class="post" id="post-211001">
    <div class="subject"><a href="#post-211001">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><br />Tutorial #4 :)<br />So far, we have been using &#039;relative translation&#039; to move our imaginary 3D pen from one place to the next.<br />It&#039;s ok if we know all the positions of our different &#039;entities&#039; (triangle and square).<br />But what if their positions are changing? Would we like to deal with them completely separately?<br /><br />This time, we&#039;re going to see how to use &#039;absolute translation&#039;.<br />Before we draw each entity, we will call glLoadIdentity	to reset the imaginary 3D pen to the world origin (0,0,0).<br />Our translation values for positioning each entity will now ALL be relative to the world origin.<br />Thus we can specify exactly the 3D worldspace position of each entity.<br /><br /><pre><code><br />;Render the Scene (one frame)<br />;We are going to draw a Triangle, and a Rectangle (&#039;quad&#039;).<br />DrawGLScene proc<br />.data<br />&nbsp; ;Let&#039;s define a 3D Vector as a set of three floats:<br />&nbsp; Vec3 struct<br />&nbsp; 	x real4 ?<br />&nbsp; 	y real4 ?<br />&nbsp; 	z real4 ?<br />&nbsp; Vec3 ends<br />&nbsp; ;Lets define a Color with 3 components (RGB)<br />&nbsp; RGB struct<br />&nbsp; 	red&nbsp;  real4 ?<br />&nbsp; 	green real4 ?<br />&nbsp; 	blue&nbsp; real4 ?<br />&nbsp; RGB ends<br />&nbsp; ;Data for our Triangle and Quad&nbsp; <br />&nbsp; Translate1 Vec3 &lt;-1.5f,0.0f,-6.0f&gt;&nbsp;  ;Translation from (0,0,0) to origin of Triangle<br />&nbsp; Translate2 Vec3 &lt;+1.5f,0.0f,-6.0f&gt;&nbsp;  ;Translation from (0,0,0) to origin of Square<br />&nbsp; TriPoint1&nbsp; Vec3 &lt;0.0f, 1.0f, 0.0f&gt;	;Three points make a Triangle<br />&nbsp; TriPoint2&nbsp; Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br />&nbsp; TriPoint3&nbsp; Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br />&nbsp; QuadPoint1 Vec3 &lt;-1.0f, 1.0f, 0.0f&gt;&nbsp;  ;Four points make a Quad<br />&nbsp; QuadPoint2 Vec3 &lt;1.0f, 1.0f, 0.0f&gt;<br />&nbsp; QuadPoint3 Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br />&nbsp; QuadPoint4 Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br />&nbsp; ;Some colors<br />&nbsp; Color1 RGB &lt;1.0f,0.0f,0.0f&gt;<br />&nbsp; Color2 RGB &lt;0.0f,1.0f,0.0f&gt;<br />&nbsp; Color3 RGB &lt;0.0f,0.0f,1.0f&gt;<br />&nbsp; .code<br />	invoke glClear,GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT<br /><br />	invoke glLoadIdentity										; Reset the current modelview matrix<br />	invoke glTranslatef,Translate1.x,Translate1.y,Translate1.z	; Move left 1.5 units and into the screen 6.0<br />	invoke glBegin,GL_TRIANGLES									; Drawing using triangles<br />		invoke glColor3f,Color1.red,Color1.green,Color1.blue<br />		invoke glVertex3f,TriPoint1.x,TriPoint1.y,TriPoint1.z	; Top<br />		invoke glColor3f,Color2.red,Color2.green,Color2.blue<br />		invoke glVertex3f,TriPoint2.x,TriPoint2.y,TriPoint2.z	; Bottom left<br />		invoke glColor3f,Color3.red,Color3.green,Color3.blue<br />		invoke glVertex3f,TriPoint3.x,TriPoint3.y,TriPoint3.z	; Bottom right<br />	invoke glEnd												; Finished Drawing The Triangle<br /><br />	invoke glLoadIdentity	<br />	invoke glTranslatef,Translate2.x,Translate2.y,Translate2.z	; Move right 3 units<br />	invoke glBegin,GL_QUADS&nbsp; &nbsp; 									; Draw a quad<br />		invoke glColor3f,Color1.red,Color2.green,Color3.blue<br />		invoke glVertex3f,QuadPoint1.x,QuadPoint1.y,QuadPoint1.z; Top left<br />		invoke glColor3f,Color2.red,Color2.green,Color3.blue<br />		invoke glVertex3f,QuadPoint2.x,QuadPoint2.y,QuadPoint2.z; Top right<br />		invoke glColor3f,Color1.red,Color1.green,Color3.blue<br />		invoke glVertex3f,QuadPoint3.x,QuadPoint3.y,QuadPoint3.z; Bottom right<br />		invoke glColor3f,Color1.red,Color2.green,Color2.blue<br />		invoke glVertex3f,QuadPoint4.x,QuadPoint4.y,QuadPoint4.z; Bottom left<br />	invoke glEnd												; Finished Drawing The Quad<br /><br />	return TRUE	<br />DrawGLScene endp<br /></code></pre><br /><br />You won&#039;t see any visible difference if you run this program.<br />But take a close look at the translation values, and notice the extra &#039;glLoadIdentity&#039; call ;)<br />As you can see, the triangle and the square now have unique worldspace positions, and can be manipulated individually without knowledge of the other&#039;s position.<br />That&#039;s important - we now understand how to control individual entities in 3D.<br /><br />But so far, we can&#039;t actually TELL that we are looking at a 3D scene !!!<br />In the next update, we&#039;ll look at how to play with the 3D orientation of our entities :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3082" target="_blank">OpenGL_Demo4.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-13 22:23:52 by Homer</div>
   </div>
   <div class="post" id="post-211002">
    <div class="subject"><a href="#post-211002">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">Tutorial #5 :)<br /><br />In this example, we&#039;ll learn how to rotate our entities about an arbitrary 3D axis.<br />We&#039;ll rotate the Triangle around the Y axis, and we&#039;ll rotate the Square around a COMPOUND axis.<br />And we&#039;ll make them both spin at different speeds.<br /><br /><pre><code><br />DrawGLScene proc<br />.data<br /> &nbsp;;Let&#039;s define a 3D Vector as a set of three floats:<br /> &nbsp;Vec3 struct<br /> &nbsp;	x real4 ?<br /> &nbsp;	y real4 ?<br /> &nbsp;	z real4 ?<br /> &nbsp;Vec3 ends<br /> &nbsp;;Lets define a Color with 3 components (RGB)<br /> &nbsp;RGB struct<br /> &nbsp;	red &nbsp; real4 ?<br /> &nbsp;	green real4 ?<br /> &nbsp;	blue &nbsp;real4 ?<br /> &nbsp;RGB ends<br /> &nbsp;;Data for our Triangle and Quad &nbsp;<br /> &nbsp;Translate1 Vec3 &lt;-1.5f,0.0f,-6.0f&gt; &nbsp; ;Translation from (0,0,0) to origin of Triangle<br /> &nbsp;Translate2 Vec3 &lt;+1.5f,0.0f,-6.0f&gt; &nbsp; ;Translation from (0,0,0) to origin of Square<br /> &nbsp;TriPoint1 &nbsp;Vec3 &lt;0.0f, 1.0f, 0.0f&gt;	;Three points make a Triangle<br /> &nbsp;TriPoint2 &nbsp;Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;TriPoint3 &nbsp;Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint1 Vec3 &lt;-1.0f, 1.0f, 0.0f&gt; &nbsp; ;Four points make a Quad<br /> &nbsp;QuadPoint2 Vec3 &lt;1.0f, 1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint3 Vec3 &lt;1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;QuadPoint4 Vec3 &lt;-1.0f,-1.0f, 0.0f&gt;<br /> &nbsp;;Some colors<br /> &nbsp;Color1 RGB &lt;1.0f,0.0f,0.0f&gt;<br /> &nbsp;Color2 RGB &lt;0.0f,1.0f,0.0f&gt;<br /> &nbsp;Color3 RGB &lt;0.0f,0.0f,1.0f&gt;<br /> &nbsp;;Rotation<br /> &nbsp;fRotation_Triangle real4 0.0f					;Angle to rotate, in degrees<br /> &nbsp;vAxis_Triangle &nbsp; &nbsp; Vec3 &lt;0.0f,1.0f,0.0f&gt;		;Axis of Rotation<br /> &nbsp;fRotation_Square &nbsp; real4 0.0f<br /> &nbsp;vAxis_Square &nbsp; &nbsp; &nbsp; Vec3 &lt;1.0f,0.0f,1.0f&gt;<br /> &nbsp;fRotSpeed_Triangle real4 1.2f					;Amount to increment rotation angle per frame<br /> &nbsp;fRotSpeed_Square &nbsp; real4 20.0f<br /> &nbsp;.code<br />	invoke glClear,GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT<br /><br />	invoke glLoadIdentity										; Reset the current modelview matrix<br />	invoke glTranslatef,Translate1.x,Translate1.y,Translate1.z	; Move left 1.5 units and into the screen 6.0<br />	invoke glRotatef,fRotation_Triangle,vAxis_Triangle.x,vAxis_Triangle.y,vAxis_Triangle.z<br />	invoke glBegin,GL_TRIANGLES									; Drawing using triangles<br />		invoke glColor3f,Color1.red,Color1.green,Color1.blue<br />		invoke glVertex3f,TriPoint1.x,TriPoint1.y,TriPoint1.z	; Top<br />		invoke glColor3f,Color2.red,Color2.green,Color2.blue<br />		invoke glVertex3f,TriPoint2.x,TriPoint2.y,TriPoint2.z	; Bottom left<br />		invoke glColor3f,Color3.red,Color3.green,Color3.blue<br />		invoke glVertex3f,TriPoint3.x,TriPoint3.y,TriPoint3.z	; Bottom right<br />	invoke glEnd												; Finished Drawing The Triangle<br /><br />	invoke glLoadIdentity	<br />	invoke glTranslatef,Translate2.x,Translate2.y,Translate2.z	; Move right 3 units<br />	invoke glRotatef,fRotation_Triangle, vAxis_Square.x,vAxis_Square.y,vAxis_Square.z<br />	invoke glBegin,GL_QUADS &nbsp; &nbsp;									; Draw a quad<br />		invoke glColor3f,Color1.red,Color2.green,Color3.blue<br />		invoke glVertex3f,QuadPoint1.x,QuadPoint1.y,QuadPoint1.z; Top left<br />		invoke glColor3f,Color2.red,Color2.green,Color3.blue<br />		invoke glVertex3f,QuadPoint2.x,QuadPoint2.y,QuadPoint2.z; Top right<br />		invoke glColor3f,Color1.red,Color1.green,Color3.blue<br />		invoke glVertex3f,QuadPoint3.x,QuadPoint3.y,QuadPoint3.z; Bottom right<br />		invoke glColor3f,Color1.red,Color2.green,Color2.blue<br />		invoke glVertex3f,QuadPoint4.x,QuadPoint4.y,QuadPoint4.z; Bottom left<br />	invoke glEnd												; Finished Drawing The Quad<br /><br />	fld fRotSpeed_Triangle<br />	fadd fRotation_Triangle<br />	fstp fRotation_Triangle<br />	<br />	fld fRotSpeed_Square<br />	fadd fRotation_Square<br />	fstp fRotation_Square<br /><br />	return TRUE	<br />DrawGLScene endp<br /></code></pre><br /><br />As you can see, we use the &#039;glRotatef&#039; function to rotate our imaginary 3D pen.<br />Note we do this after translating, and before drawing each entity.<br /><br />First we reset the pen to the world origin, no rotation.<br />Then we translate to the position of the triangle.<br />Then we rotate our pen.<br />Then we draw the triangle.<br /><br />Then we reset the pen to the world origin, no rotation.<br />Then we translate to the position of the square.<br />Then we rotate our pen.<br />Then we draw the square.<br /><br />Finally, we increment our rotation angle counters.<br /><br />See how it works?<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3083" target="_blank">OpenGL_Demo5.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-13 22:47:50 by Homer</div>
   </div>
   <div class="post" id="post-211003">
    <div class="subject"><a href="#post-211003">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><br />The next tutorial will be one of two things, I will let the readers decide.<br /><br />Option A) Textures And TextureMapping<br />Option B) Simple 3D Polytopes (Tetrahedron and Cube)<br /><br />Say which order you would like them :)<br /></div>
    <div class="meta">Posted on 2010-03-13 23:05:25 by Homer</div>
   </div>
   <div class="post" id="post-211004">
    <div class="subject"><a href="#post-211004">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">I keep mentioning a &#039;magical 3D pen&#039; to describe 3D rotation and translation prior to rendering an entity.<br />It doesn&#039;t actually exist, its just one way to describe and understand what&#039;s happening.<br />It&#039;s a useful tool for the purpose of communicating the concepts.<br />You could also say that we are rotating and translating the entire universe space around the thing that we&#039;re about to draw, but that would be less intuitive, agreed?<br /></div>
    <div class="meta">Posted on 2010-03-14 03:45:21 by Homer</div>
   </div>
   <div class="post" id="post-211023">
    <div class="subject"><a href="#post-211023">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">As an aside... with OpenGL 3.3 and 4.0 announced, the way forward in OpenGL is to remove the &#039;naive&#039; legacy functionality (drawing geometry with glBegin()/glEnd() etc, using fixed function transform/lighting/texturing), and instead doing everything with vertex buffer objects and GLSL shaders. (This legacy functionality had already been marked &#039;deprecated&#039; in OpenGL 3.0, and some of it was already removed in 3.1).<br /><br />So when you get into texturing and lighting, perhaps you should focus only on using GLSL, and ignore the legacy fixedfunction stuff?<br />Likewise, perhaps you shouldn&#039;t linger with glBegin()/glEnd()-based geometry too long, and show people how to use VBOs at an early stage?</div>
    <div class="meta">Posted on 2010-03-16 05:28:38 by Scali</div>
   </div>
   <div class="post" id="post-211029">
    <div class="subject"><a href="#post-211029">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">I second that!<br />I understand that these first posts were addressed to beginners but I would like to see more of the &quot;modern&quot; approach instead of the &quot;legacy&quot; approach. There are many &quot;legacy&quot; OpenGL tutorials and only few &quot;modern&quot; ones. So, Homer, please go for the modern stuff as soon you&#039;re done with the basics, pretty please ^^<br /><br />And thanks for another tutorial - they are always a good read :)</div>
    <div class="meta">Posted on 2010-03-16 11:31:35 by ti_mo_n</div>
   </div>
   <div class="post" id="post-211034">
    <div class="subject"><a href="#post-211034">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">I will indeed be talking about vertexbuffer objects and GLSL at my first convenience.<br />However I will cover the basics first, from nothin to guru, as I see them.<br />So, NOONE has an opinion on whether to cover (basic) 3d geometry, or (5 kinds of) texturemapping first?<br />I will choose the geom.<br />I&#039;ve just spent an hour calculating the vertices for an equilateral tetrahedron with a central origin ;)<br /></div>
    <div class="meta">Posted on 2010-03-17 01:03:26 by Homer</div>
   </div>
   <div class="post" id="post-211040">
    <div class="subject"><a href="#post-211040">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><div class="quote"><br />I will indeed be talking about vertexbuffer objects and GLSL at my first convenience.<br />However I will cover the basics first, from nothin to guru, as I see them.</div><br /><br />The situation is quite similar to Direct3D 9 vs Direct3D 10/11...<br />You could start teaching with D3D9, but when you go to D3D10/11, you&#039;ll basically have to say &quot;Okay, forget everything you learnt with D3D9, because none of that is available in D3D10/11 anyway&quot;.<br />The &#039;basics&#039; just don&#039;t exist in the modern D3D and OpenGL APIs anymore (and a lot of &#039;optimizations&#039; via display lists and such are no longer valid in OpenGL either, so it completely throws everything around. Things that older tutorials told people were &#039;the right thing&#039;).<br />In my opinion, you shouldn&#039;t even mention the existence of the legacy functionality. In fact, an interesting tutorial might be to implement your own glBegin()/glEnd()-style of rendering, using a VBO internally.<br />Then you can both explain the concepts of modern rendering AND offer a simple way of getting basic triangles on screen (you could supply the helper functions first, and explain their internal workings at a later stage).</div>
    <div class="meta">Posted on 2010-03-17 05:57:18 by Scali</div>
   </div>
   <div class="post" id="post-211057">
    <div class="subject"><a href="#post-211057">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><div class="quote"><br />In fact, an interesting tutorial might be to implement your own glBegin()/glEnd()-style of rendering, using a VBO internally.<br />Then you can both explain the concepts of modern rendering AND offer a simple way of getting basic triangles on screen (you could supply the helper functions first, and explain their internal workings at a later stage).<br /></div><br /><br />That sounds like a very sensible suggestion, Scali.<br />I will do that!<br />But bear with me while I emit a couple more jaded examples to lay out the basic concepts for absolute beginners.<br />I&#039;m just trying to introduce the concepts first, however I totally agree with your comments :)<br /><br />The attached example is the first to contain &#039;true 3d objects&#039;.<br />This time I have made the triangle into a tetrahedron (4 triangles), and the square into a cube (6 quads).<br /><br />The next example will introduce texturemapping, and then we&#039;ll add normals and lighting.<br />After that we&#039;ll look at display lists, vertex arrays, and then vertex buffer objects.<br />We&#039;ll even write a VBO class that helps us to &#039;contruct&#039; 3D shapes from arbitrary input data.<br />This will make a good solid base for file import/export demos.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3088" target="_blank">OpenGL_Demo6.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-18 06:29:23 by Homer</div>
   </div>
   <div class="post" id="post-211058">
    <div class="subject"><a href="#post-211058">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">My comments in the posted examples have not been well maintained.<br />But they still make sense.<br />Deal with it, noones paying me to teach this.<br />I recommend the application WinMerge to help identify changes from one example to the next!<br />But I&#039;m pretty sure you readers are able to keep up so far.<br />It&#039;s nice to see this thread is receiving some attention.<br />Honk if you love free stuff!<br /><br />Oh, we are so gonna have to cover matrices soon.<br />Matrix transformations, yaknow.<br />That will be a major milestone.<br /><br />Scali mentioned math issues in another thread.<br />I will provide a full set of functions for math with real4 and real8 floats, 3D vectors, 4D planes, 3x3 matrices and 4x4 matrices of both real4 and real8 precision.<br />And much of it is written as macros, rather than procedures, which makes for even faster execution, at the cost of (if you&#039;re crap) replicating code (aka bloat).<br /></div>
    <div class="meta">Posted on 2010-03-18 07:39:37 by Homer</div>
   </div>
   <div class="post" id="post-211061">
    <div class="subject"><a href="#post-211061">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body"><br />Our next demo will be an example of simple texture-mapping.<br />In order to cover our surfaces with texture, we need to be able to load a texture from an image file.<br /><br />Here is a very simple function to load a texture from a BMP file.<br />We won&#039;t worry about &#039;mipmaps&#039; just yet.<br />Consider this a place to start.<br /><br /><pre><code><br />; ---------------------------------------------------------------------------<br />;Helper function to create OpenGL Texture from a BMP File<br />;szFileName = ptr to namestring<br />;ptexid = ptr to dword to receive ID of tex resource<br />;Returns eax = 0(FALSE), or a positive integer (texture id)<br />LoadBMP proc szFileName<br />LOCAL hBMP<br />LOCAL bmp:BITMAP<br />local texid<br /><br /><br />	;Make sure path exists<br />	.if $inv(GetFileAttributes,szFileName) !=-1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Generate a new, empty texture container.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If all goes well, we will be returned EAX=0 and texid=ID of new texture<br />		mov texid,0<br />		.if $inv(glGenTextures,1, addr texid)==0 <br />			;Bind to (ie &#039;select&#039;) the newly-generated Texture immediately<br />			;All subsequent texture operations apply to the currently bound texture<br />			invoke glBindTexture,GL_TEXTURE_2D, texid	<br />			<br />			;Load the BMP image - WE SHOULD USE PIXELMAP AS A LOADER !!!<br />			mov hBMP,$invoke (LoadImage,hInstance, szFileName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION or LR_LOADFROMFILE)<br />			.if eax==0<br />				DbgWarning &quot;LoadImage failed&quot;<br />				DbgStr szFileName<br />				return FALSE<br />			.endif<br />			;Get access to the BMP&#039;s pixel data<br />			invoke GetObject,hBMP, sizeof bmp, addr bmp<br /><br />			;Set up texture parameters<br />			invoke glPixelStorei,GL_UNPACK_ALIGNMENT, 4; Pixel Storage Mode (Word Alignment / 4 Bytes)<br />			invoke glTexParameteri,GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR;	// Linear Min Filter<br />			invoke glTexParameteri,GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR;	// Linear Mag Filter<br />			;Upload the texture to video card<br />			invoke glTexImage2D,GL_TEXTURE_2D, 0, 3, bmp.bmWidth, bmp.bmHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, bmp.bmBits<br />			invoke DeleteObject,hBMP<br />			mov eax,texid<br />		.else<br />			@invoke MessageBox,0,&quot;Failed glGenTextures&quot;,&quot;Error&quot;,MB_OK+MB_ICONERROR<br />			mov eax, FALSE<br />		.endif<br />	<br />	.endif<br />	ret<br />LoadBMP endp<br /></code></pre><br /><br />We create a new texture id, we &#039;bind&#039; to it, we gain access to the raw pixel data of the imagefile, we set up a few texture parameters and we call &#039;glTexImage2D&#039; to upload our pixels to the videocard (ie copy them into our texture). Then we clean up the imagefile stuff since we&#039;re done.<br />We will return NULL for failure, or we will return the TextureID (which is never NULL).<br /><br />In the near future, we&#039;ll improve this function to handle more image file formats etc</div>
    <div class="meta">Posted on 2010-03-19 01:50:10 by Homer</div>
   </div>
   <div class="post" id="post-211062">
    <div class="subject"><a href="#post-211062">Re: TUTORIAL: Win32 OpenGL Demos for ObjAsm</a></div>
    <div class="body">As mentioned in the comments, when we &#039;bind&#039; to a texture, we are infact &#039;selecting&#039; it.<br />We will need to do this in our rendering function too.<br />We must bind to a texture BEFORE we call glBegin - we can&#039;t change textures inside a glBegin/glEnd block.<br />But soon we&#039;ll learn some new ways to draw stuff that don&#039;t require glBegin/glEnd, and it won&#039;t matter so much.<br />I like that this design forces the programmer to make as few texture changes as possible, which is a good thing.<br />It will become more apparent soon, when we start to meddle with 3D meshes, we will need to render &#039;per-texture&#039; groups of faces. But before that, we have to learn a bit more about the basics - textures, lighting/normals, materials, in that order will form the foundation of everything to follow.<br /><br />Attached is Demo #7, and a bitmap (bmp) file.<br />We will use the skeleton from demo #5, but we will replace Color with Texture at each vertex.<br />You will notice a problem with this demo: if we switch screen modes, we lose our texture!<br />In the next post, I will address this problem, and we&#039;ll also make some improvements to our image loader.<br />The next demo will be based on Demo #6 - we will see textured 3D objects :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3089" target="_blank">Demo7.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-19 04:05:46 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29863&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29863&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29863" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29863&amp;page=2">&gt;</a><a href="../?id=29863&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>