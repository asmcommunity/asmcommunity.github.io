<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>getting pointer to C++ method, calling C++ methods - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19067" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19067">getting pointer to C++ method, calling C++ methods</a></p>
   <div class="post" id="post-147439">
    <div class="subject"><a href="#post-147439">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">does anybody know how to get a FUNCTION pointer to nonstatic C++ method ( in C style) and then be able to call it..<br />i know that C++ methods have a secret 1st parameter reference to the class instance..<br />i also know how to get a method pointer (which is typed to that particular class)<br /><br />what i want to do (in ASM and/or C) is get a pointer to the nonstatic method<br />and then be able to call it myself, maybe with a typedef where i pass in the instance as the first parameter..<br /><br />i know many different compilers implmenet the virtual method table and offset and method pointer details differently, if so i'm just interested in MSVC++</div>
    <div class="meta">Posted on 2004-08-05 02:58:53 by klumsy</div>
   </div>
   <div class="post" id="post-147440">
    <div class="subject"><a href="#post-147440">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">if i understand your problem correctly i think that some directx win32asm snippets accomplish the same task by calling dx COM functions, don't they?</div>
    <div class="meta">Posted on 2004-08-05 03:22:36 by Mbee</div>
   </div>
   <div class="post" id="post-147442">
    <div class="subject"><a href="#post-147442">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">i'm not talking about calling methods of COM objects, but rather if i have a C++ method pointer, calling the method (or casting it as a function).</div>
    <div class="meta">Posted on 2004-08-05 03:33:02 by klumsy</div>
   </div>
   <div class="post" id="post-147448">
    <div class="subject"><a href="#post-147448">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body"><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=17987">http://www.asmcommunity.net/board/index.php?topic=17987</a><br />I use this to successfully control C++ objects with my asm code.</div>
    <div class="meta">Posted on 2004-08-05 05:18:36 by Ultrano</div>
   </div>
   <div class="post" id="post-147460">
    <div class="subject"><a href="#post-147460">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">hmm those look really interesting..<br />but i am not using masm<br />but rather just inline assembler inside msvc++7<br />i basically just want to be able to get a C style function pointer from a method pointer and<br />then call it.<br />i don't need such an elebrate system of being able to derive from C++ classes in assembler and such.</div>
    <div class="meta">Posted on 2004-08-05 06:53:27 by klumsy</div>
   </div>
   <div class="post" id="post-147461">
    <div class="subject"><a href="#post-147461">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">class Test{<br />virtual ~Test();<br />virtual long DoIt(long x);<br />virtual long DoIt2();<br />long z;<br />};<br /><br />//Test* obj1 = new Test;<br />obj1-&gt;DoIt(10);<br />obj1-&gt;DoIt2();<br />delete obj1<br /><pre><code><br /><br />mov ecx,obj1<br />push 10<br />push ecx<br />mov eax,&#91;ecx&#93;<br />mov eax,&#91;eax+4&#93;<br />call eax<br /><br /><br />mov ecx,obj1<br />push ecx<br />mov eax,&#91;ecx&#93;<br />mov eax,&#91;eax+8&#93;<br />call eax<br /><br /><br />mov ecx,obj1<br />push 1<br />push ecx<br />mov eax,&#91;ecx&#93;<br />mov eax,&#91;eax&#93;<br />call eax<br /><br /><br /></code></pre><br />~Test()  is  at offset 0 of the vt<br />DoIt(x) is at offset 4 of the vt<br />DoIt2() is at offset 8 of the vt<br /><br />when deleting, the destructor has 1 hidden parameter - usually you need to  &quot;push 1&quot;. <br />If the object has at least 1 virtual function (including the destructor), then it has a vt (virtual table), and the first 4 bytes of the class instance point to it. Each such C++ object of same class has exactly the same 4 first bytes - can be used to identify what type the class is.</div>
    <div class="meta">Posted on 2004-08-05 07:08:53 by Ultrano</div>
   </div>
   <div class="post" id="post-147498">
    <div class="subject"><a href="#post-147498">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">very imformative stuff. from your leads i've come up with this (messy) test code..<br /><br />using inline assembler i test calling a function from assembler, and also convert a method pointer to a function pointer.. however C++ methods use thiscall calling convention, and there is no thiscall keyword to get the C function to work right.. with no parameters it 'pretends' to work right, however the this isn't passed in ECX as it should... anyway here is the test code..its just some simple stuff using MFC for quick ease of making a test app with messagebox<br /><br />test class definition.<br /><br />class Test{<br />public:<br />	virtual ~Test();<br />virtual long DoIt(long x);<br />virtual long DoIt2();<br />virtual long BigTest(int a,int b,int c, int d, int e,CString ratdog);<br />long DoIt3();<br />long z;<br />};<br /><br />Test::~Test()<br />{<br />};<br />long Test::DoIt(long x)<br />{<br />	CString tmpstr;<br />	tmpstr.Format(&quot;do it with one parameter %d&quot;,x);<br />	MessageBox(0,tmpstr,&quot;&quot;,0);<br />	return 1;<br />};<br />long Test::DoIt2()<br />{<br />	MessageBox(0,&quot;hello2&quot;,&quot;&quot;,0);<br />	return 2;<br />};<br />long Test::DoIt3()<br />{<br />	MessageBox(0,&quot;hello3&quot;,&quot;&quot;,0);<br />	return 3;<br />};<br /><br />long Test::BigTest(int a,int b,int c, int d, int e,CString ratdog)<br />{<br />	CString tmpstr;<br />	tmpstr.Format(&quot;%d %d %d %d %d YEAH %s &quot;,a,b,c,d,e,ratdog);<br />	MessageBox(0,tmpstr,&quot;&quot;,0);<br />	return 5;<br />	//tmpstr<br />}<br /><br /><br />..and the test code<br /><br />long (Test::*pfn)();  //method pointer<br />long (Test::*pfn2)(long x);  //method pointer<br />long (Test::*pfnBigTest)(int a,int b,int c, int d, int e,CString ratdog);<br />typedef long cfuncptr(Test * tstptr); //typedef of equiv function pointer<br />typedef long cfuncptr2(Test * tstptr,long x); //typedef of equiv function pointer<br />typedef long cfuncptrBigTest(Test * tstptr,int a,int b,int c, int d, int e,CString ratdog);<br />//_thiscall<br />cfuncptr * funcptr;<br />cfuncptr2 * funcptr2;<br />cfuncptrBigTest * BigTestptr;<br />PVOID myvoid;<br />Test* obj1 = new Test;<br />	pfn = &amp;Test::DoIt2;<br />	(obj1-&gt;*pfn)();<br />	pfn = &amp;Test::DoIt3;<br />	pfnBigTest = &amp;Test::BigTest;<br />	pfn2 = &amp;Test::DoIt;<br />	(obj1-&gt;*pfn2)(4);<br />	(obj1-&gt;*pfnBigTest) (1,2,3,4,5,&quot;first bigtest&quot;);<br />	(obj1-&gt;*pfn)();<br />	obj1-&gt;DoIt(10);<br />	obj1-&gt;DoIt2();<br />	obj1-&gt;DoIt3();<br />	obj1-&gt;BigTest(10,2,40,5,5,&quot;work please&quot;);<br />	MessageBox(&quot;before manual&quot;);<br />	//call the method pointer from assembler.<br />	_asm {<br />	  mov esi,esp<br />	  mov ecx,DWORD PTR obj1;<br />	  call	DWORD PTR pfn;<br />	  }<br /><br />	//use assembler to cast the method pointer to PVOID - since C++ compiler won't let you do this<br />	_asm {<br />	 mov eax,DWORD PTR pfn;	  <br />	  mov myvoid,eax	 <br />	}<br />	//cast PVOID to our equiv C function pointer that passes in the instance of the class as the first parameter<br />	<br />	funcptr = (cfuncptr *) myvoid;<br />	MessageBox(&quot;before C call&quot;);<br />	//run method through function pointer<br />	//this one pretends to work.. except inside the call it wouldn't have a valid reference<br />	//to the class (if the method had tried to access properties etc)<br />	long ab = funcptr(obj1);<br />	CString tmpstr2;<br />	tmpstr2.Format(&quot;return value %d&quot;,ab);<br />	//verify it is returning the return value correctly<br />	MessageBox(tmpstr2);<br />	<br />	_asm {<br />	 mov eax,DWORD PTR pfn2;	  <br />	  mov myvoid,eax	 <br />	}<br />	//cast PVOID to our equiv C function pointer that passes in the instance of the class as the first parameter<br />	funcptr2 = (cfuncptr2 *) myvoid;<br />	MessageBox(&quot;before 2nd C call&quot;);<br />	//run method through function pointer<br />	//this one gives access violation because difference in calliung conventions<br />	long ab2 = funcptr2(obj1,5);<br />	CString tmpstr3;<br />	tmpstr3.Format(&quot;2nd return value %d&quot;,ab2);<br />	//verify it is returning the return value correctly<br />	MessageBox(tmpstr3);<br /><br /><br />.. <br />the question is how can i emulate thiscall..<br />current ideas is use naked functions and use inline assembler to do the same as thiscall, making a C wrapper for each function..<br />or alternatively, just make a dummy class with the same method parameters,<br />and inside it cast the 'this' pointer as Test.<br /><br />anybody else have any ideas?<br />at least now i can get the pointer to the actual function.</div>
    <div class="meta">Posted on 2004-08-05 21:23:45 by klumsy</div>
   </div>
   <div class="post" id="post-147501">
    <div class="subject"><a href="#post-147501">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">MSVC++ passes the <em>this</em> pointer in ECX, usually.<br />But I'm not sure that you can rely on this behavior.</div>
    <div class="meta">Posted on 2004-08-05 22:40:59 by iblis</div>
   </div>
   <div class="post" id="post-147502">
    <div class="subject"><a href="#post-147502">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">i only care about MSVC++ anyhow.. and it seems its THISCALL convention is consistent enough ..<br /><br />i tried this (changing my function pointers to NOT have the &quot;this&quot; as the first param so<br /><br />typedef long _stdcall cfuncptr3(long x); //typedef of equiv function pointer<br />typedef long _stdcall cfuncptrBigTest(int a,int b,int c, int d, int e,CString ratdog);<br /><br />and calling like this<br /><br />	_asm {<br />	 mov eax,DWORD PTR pfn2;	  <br />	  mov myvoid,eax	 <br />	}<br />	funcptr3 = (cfuncptr3 *) myvoid;<br />                _asm {<br />		mov ecx,obj1;<br />	}<br />	long ab = funcptr3(10);<br /><br />which worked PERFECT in most scenarios..<br /><br />but what you can't gaurantee is that the line of code calling the function pointer isn't going to mess up ECX <br />like in this example<br /><br />CString ratstring = &quot;hello&quot;;<br />	_asm {<br />	mov ecx,obj1;<br />	}	<br />	BigTestptr(1,2,3,4,5,ratstring);<br /><br />ratstring CString ratstring = &quot;hello&quot;;<br />	_asm {<br />	mov ecx,obj1;<br />	}	<br />	BigTestptr(1,2,3,4,5,ratstring);<br /><br />functions to prepare ratstring for passing are called which mess up the ecx<br />(here is the assembler output from MSVC++)<br /><br />; 266  : 	_asm {<br />; 267  : 	mov ecx,obj1;<br /><br />	mov	ecx, DWORD PTR _obj1$<br /><br />; 268  : 	}<br />; 269  : 	//BigTestptr(1,2,3,4,5,&quot;hello&quot;);<br /><br />	push	ecx<br />	mov	ecx, esp<br />	mov	DWORD PTR $T83158, esp<br />	mov	esi, esp<br />	lea	eax, DWORD PTR _ratstring$<br />	push	eax<br />	call	DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z<br />	cmp	esi, esp<br />	call	__RTC_CheckEsp<br />	mov	DWORD PTR tv205, eax<br />	push	5<br />	push	4<br />	push	3<br />	push	2<br />	push	1<br />	call	DWORD PTR _BigTestptr$<br /><br />so i think the only reliable method would be to have the complete dispatching code in assembler..<br />thinking of different ways to make a flexible framework (with inline assembler, and probably &quot;naked&quot; functions to do this..<br /><br />any ideas?</div>
    <div class="meta">Posted on 2004-08-05 23:22:58 by klumsy</div>
   </div>
   <div class="post" id="post-147531">
    <div class="subject"><a href="#post-147531">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">I don't mean to crush your dreams here, but realize that MSVC++ was named as such because it's a C++ compiler.  And it's for that very reason why it is not called MSASMVC++.  Yes it may support 'inline assembly' but it is far from being an assembler.  I think you might benefit from ceasing your attempts to turn it into one.<br /><br />The inline assembler's interaction with the class system is shaky and this was intentional, as a lot of things are going on behind the scenes that could be compromised with the interference of rogue assembly code.  If you can get it to work well, you might land a minimal performance boost, but the disadvantages far outweight the benefits, as what you're left with is confusing and unmanageable C++/ASM hybrid code.<br /><br />However, I can understand if you're doing this just to play around and learn.  That's fine.  Keep on experimenting.<br />But if you're trying to come up with a serious application framework then this kind of thing is hackish and just plain bad programming.  (I'm not trying to say that you're a bad programmer, don't worry.)  It's okay, you're not the first to attempt this sort of thing, and I'm sure you won't be the last.  At the very least you will walk away with more intimate knowledge of the internal workings of MS's VC++ compiler.  So it won't all be in vain.<br /><br />If you're looking for an OOP framework using assembly then look around on these forums, as people like NaN have worked diligently to bring this kind of thing to the community.<br /><br />Oh and for future reference the &quot;{CODE} {/CODE}&quot; VBulletin tags (replace the curly braces with brackets) will make your source a lot easier for others to read.<br /><br />Have a good one.  ;)</div>
    <div class="meta">Posted on 2004-08-06 11:52:25 by iblis</div>
   </div>
   <div class="post" id="post-147561">
    <div class="subject"><a href="#post-147561">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body"><div class="quote">I don't mean to crush your dreams here, but realize that MSVC++ was named as such because it's a C++ compiler. And it's for that very reason why it is not called MSASMVC++. Yes it may support 'inline assembly' but it is far from being an assembler. I think you might benefit from ceasing your attempts to turn it into one.</div> <br /><br />maybe i should have explained my context. i do write alot of inline assembler for inner loops MMX/SSE, but this is a bit different. i am not trying turn C++ into an assembler, or planing to write ALOT of code in assembler. actually for this i wish i didn't have to use assembler, but pure C++, but it seems to be impossible.. all i am trying to do is get into the internals of how thiscall calling convection works (which annoyingly doesn't have a keyword), and come to grips with interfacing to virtual call tables at a low level, the same way as i have done previously and successfully with delphi. in my research what i wish to do has been said to be impossible to do. however a little bit of research shows that others have doen similiar things to what i want (Though slightly different)<br /><br />here are a few articles that got me on my way<br /><br /><a target="_blank" href="http://www.google.co.nz/search?q=cache:X9dOYg50emgJ:www.gdconf.com/archives/2001/bilas.doc+naked+thiscall&amp;hl=en">http://www.google.co.nz/search?q=cache:X9dOYg50emgJ:www.gdconf.com/archives/2001/bilas.doc+naked+thiscall&amp;hl=en</a><br /><br /><a target="_blank" href="http://weblogs.asp.net/oldnewthing/archive/2004/02/09/70002.aspx">http://weblogs.asp.net/oldnewthing/archive/2004/02/09/70002.aspx</a><br /><br />two things i am trying to do<br />1)make a dynamic dispatching of nonstatic method calls , where a pointer to a method (which i have to get from assembler) is passed in, as well as an array of parameters.. i often use LUA as a script language, and are totally annoyed at only being able to link callback functions to nonstatic methods or C functions. also i have alot of uses for such dynamic dispatching techniques<br /><br />2)hooking methods, (and i finally sucessfully got to do this yesterday).. i wish to hook any method (a specific one rather than the whole virtual chain (i no my terminology of such thing does isn't the same as the official terminoloy)<br />so at execution time when say the non static Test::doIt is called, it actually gets redirected to HookClass::doItReplacement which will have the same parameters etc<br />and hookclass::doitReplacement with do<br />Test * testptr = (Test *) this; to get typecast this as Test so it can treat it as such.. (working nice)<br />then after hookclass::DoItReplacement does its stuff, its most likely to want to call the original method, and it will use the 'dynamic dispatching of nonstatic method in point 1 to do so.<br /><br />as for bad programming techniques, there are so many situations that we've tried to do things the right way, but have had to come up with a hack to achieve something due to the limitation of an API, language etc, that wasn't designed to do what we want, or need to do with it. However i wouldn't blame you if you thought i was a bad programmer based on the experimental hack i posted earlier, but it was a quick experimental hack :)<br /><br />ok here is all i have to do now to implement the hooking system <br /><br /><pre><code><br />PVOID doitptr;<br />PVOID hookdoitptr;<br />PVOID NextHook;<br />...<br />//declaration of method function that will be hooked<br />long Test&#58;&#58;DoIt&#40;long x&#41;<br />&#123;<br />...<br />&#125;<br /><br />//code to get pointers needed for hooking<br />_asm &#123;<br />           mov eax,DWORD PTR Test&#58;&#58;DoIt;<br />           mov doitptr,eax	 <br />          &#125;<br />_asm &#123;<br />           mov eax,DWORD PTR TestHook&#58;&#58;HookDoIt;<br />           mov hookdoitptr,eax	 <br />          &#125;<br />//install the hook<br />if &#40;!HookCode&#40;doitptr, hookdoitptr, &#40;PVOID*&#41; &amp;NextHook&#41;&#41;<br />		MessageBox&#40;&quot;did not hook right&quot;&#41;;<br />//until it is unhooked whenever Test&#58;&#58;Doit is called, TestHook&#58;&#58;HookDoIt will be called<br />instead.<br /><br />..<br />//and actually what does TestHook&#58;&#58;HookDoIt contains?<br /><br />long TestHook&#58;&#58;HookDoIt&#40;long x&#41;<br />&#123;<br />	long retvalue;<br />	Test * testptr = &#40;Test *&#41; this;<br />	//now do whatever we want here<br />	CString tmpstr;<br />	tmpstr.Format&#40;&quot;inside the hook x&#58; %d this.z &#58; %d&quot;,x,testptr-&gt;z&#41;;<br />	MessageBox&#40;0,tmpstr,&quot;&quot;,0&#41;;<br />	//now we are done, call the original simulating thiscall calling technique<br />	_asm &#123;<br />		push x<br />		mov ecx,this<br />		call NextHook;<br />		mov retvalue,eax		 <br />	&#125;<br />   return retvalue;<br />&#125;;<br />...<br />//and we might want to uninstall the hook sometime<br />UnhookCode&#40;&#40;PVOID*&#41; &amp;NextHook&#41;;<br /></code></pre><br /><br />does my madness make any more sense yet?<br /><br />Karl</div>
    <div class="meta">Posted on 2004-08-06 18:00:35 by klumsy</div>
   </div>
   <div class="post" id="post-147563">
    <div class="subject"><a href="#post-147563">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">I only looked _very_ briefly at your last post, but perhaps a C++ &quot;pointer to member function/method&quot; thingy would work? If not, sorry for my ignorance.<br /><br /><a target="_blank" href="http://www.parashift.com/c++-faq-lite/pointers-to-members.html">http://www.parashift.com/c++-faq-lite/pointers-to-members.html</a></div>
    <div class="meta">Posted on 2004-08-06 18:32:11 by f0dder</div>
   </div>
   <div class="post" id="post-147565">
    <div class="subject"><a href="#post-147565">getting pointer to C++ method, calling C++ methods</a></div>
    <div class="body">earlier (as can be seen in the first post ) i had been using pointer to methods, however pointer to methods are linked ot the specific class, and also they aren't a pointer as such, but rather an offset , and can contain a whole bunch of information depending on the base classes etc.. the reason i need to use the assembly is you can't get a pointer to function, to a nonstatic method in C++, a method pointer isn't a 4 byte 32 bit address.. but rather can be 8 or even 12 bytes because of what it contains.. i'm using inline assembler to get the actual 32 bit pointer to the actual method's code<br /><br />and you can't call a nonstatic method from C, outside of the normal objects method dispatch.<br /><a target="_blank" href="http://www.parashift.com/c++-faq-lite/pointers-to-members.html#faq-33.7">http://www.parashift.com/c++-faq-lite/pointers-to-members.html#faq-33.7</a><br /><br />but my solution above is working quite nice now. i can hook any function of any class whether static, non static, or virtual..<br />i haven't yet experimental how the hooking works with decentant classes, base classes, multiple inheritence yet though.<br /><br />hmm i didn't realise we had posted to the same site until after i had posted :)</div>
    <div class="meta">Posted on 2004-08-06 18:51:02 by klumsy</div>
   </div>
  </div>
 </body>
</html>