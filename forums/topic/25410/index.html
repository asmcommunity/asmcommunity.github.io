<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OASML 1.0 (Open-source Assembly Library) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25410" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25410">OASML 1.0 (Open-source Assembly Library)</a></p>
   <div class="post" id="post-185807">
    <div class="subject"><a href="#post-185807">OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">I am finally done coding the first version of OASML, short form of<br />Open-source Assembly Library, which is the library of different routines dealing<br />with variety of subjects including memory, strings, I/O, keyboard, Files and etc.<br />OASML 1.0 targets real-mode architecture. The majority of the instruction-set is<br />compatible with 8086 except for a few SHR and/or SHL cases in which 80186<br />instruction-set is used.<br /><br />Below is the list of some important features of OASML 1.0:<br /><br />1) The library uses 8086 instruction set throughout the code except for<br />&nbsp;  a few cases of shifts that 80186 instructions are used.<br /><br />2) Each and every procedure in the library can be used independent from<br />&nbsp;  the other procedures by simply copying and pasting the code in your own program.<br /><br />3) None of the units use the DOS trap &quot;INT 21h&quot; except for the<br />&nbsp;  &quot;DOS&quot; and the &quot;Files&quot; unit.<br /><br />4) The OASML 1.0 library supports inline parameter calling convention for<br />&nbsp;  some procedures and function in which the programmer is allowed to include<br />&nbsp;  the parameter in the code segment and the procedure/function would access<br />&nbsp;  and skip over it after it is done executing. For example, you can write<br />&nbsp;  a null-terminated string in your code segment right after the invocation<br />&nbsp;  of the &quot;WriteInlineStr&quot; procedure. The procedure would then read the string<br />&nbsp;  and write it to the console window and then skip over the string and moves<br />&nbsp;  to the next instruction in the code segment.<br /><br />5) Every single line of the code is commented and given full description.<br /><br />6) Each and all of the procedures in the library are given separate description,<br />&nbsp;  the details of the calling convention used, examples and notes.<br /><br />7) All of the procedures in OASML 1.0 are given an example of usage<br />&nbsp;  and sometimes even two.<br /><br />8) The PASCAL calling convention is used throughout the library, pushing<br />&nbsp;  the parameters from left to right. An exception is made to this convention<br />&nbsp;  in which procedures in this library do not remove the parameters from<br />&nbsp;  the stack for convenient.<br /><br />9) The state of the general purpose registers is saved throughout the code,<br />&nbsp;  leaving them unmodified after the execution of each of the procedures.<br />&nbsp;  An exception to this is stated by a few procedures.<br /><br />10) The AL register is used for 8 bit return values of function.<br />&nbsp; &nbsp; The AX register for 16bit functions, DX:AX for 32bit functions and<br />&nbsp; &nbsp; DX:CX:BX:AX for 64bit functions.<br /><br />11) Each procedure in the library has a series of notes written as comments<br />&nbsp; &nbsp; which point out the important behavior of that specific procedure.<br /><br />12)&nbsp; OASML 1.0 does not use string instructions at all for them being rather<br />&nbsp; &nbsp;  sluggish compared to simple instructions such as &quot;MOV&quot;.<br /><br />13) OASML 1.0, although a 16bit library, has full support for 32bit values<br />&nbsp; &nbsp; including simulated instructions such as &quot;XCHG&quot;, &quot;MOV&quot;, &quot;INC&quot; and etc.<br />&nbsp; &nbsp; I/O routines in the library also support the input and output of<br />&nbsp; &nbsp; DWORD values. The Conversion unit can be used to convert DWORD values<br />&nbsp; &nbsp; to Hex/Octal/Binary and etc.<br /><br />14) The policy of OASML 1.0 is toward using null-terminated strings<br />&nbsp; &nbsp; throughout the code for convenience.<br /><br />15) The functionality of the library is extended through the implementation<br />&nbsp; &nbsp; of a few macros that simplify the usage of a group of frequently-used<br />&nbsp; &nbsp; instructions.<br /><br />16) Throughout the library, offsets from which parameters are retrieved assume<br />&nbsp; &nbsp; the &quot;NEAR&quot; call invocation. If you wish to use &quot;FAR&quot; calls, you could add<br />&nbsp; &nbsp; the value &quot;2&quot; to each of the offsets in the stack frame<br />&nbsp; &nbsp; created for some procedures.<br /><br />17) Each procedure features a commented header which gives a full description<br />&nbsp; &nbsp; about the purpose of the procedure and also exact details of the parameters<br />&nbsp; &nbsp; and their size and description, additional notes on the procedure,<br />&nbsp; &nbsp; example(s) and etc.<br /><br />18) The library fully supports signed and unsigned integral values including<br />&nbsp; &nbsp; input, output and conversion.<br /><br />19) The Memory-Management unit does not include &quot;Malloc&quot; and/or &quot;Free&quot;<br />&nbsp; &nbsp; procedures for now. I hope I will be able to implement these procedures<br />&nbsp; &nbsp; in the next release.<br /><br />20) The &quot;String&quot; unit features procedures and functions to work with null-terminated<br />&nbsp; &nbsp; strings including the string comparison, copying of strings, finding strings,<br />&nbsp; &nbsp; string tokenizer and etc.<br /><br /><br />You can download OASML 1.0 from my Http://www.ASMTrauma.com. Let me know what you think of OASML.</div>
    <div class="meta">Posted on 2006-10-09 07:08:29 by XCHG</div>
   </div>
   <div class="post" id="post-185809">
    <div class="subject"><a href="#post-185809">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">hi, i am making multilatform 32bit library. i will have first version soon.<br /><br />to yours, it has few very common (TOO common) critical problems:<br />1. lacks any error handling<br />2. lacks any design<br /><br />without this you cannot make solid library. i spent more time with error handling and testing in extreme cases than with rest of things together</div>
    <div class="meta">Posted on 2006-10-09 08:56:56 by vid</div>
   </div>
   <div class="post" id="post-185816">
    <div class="subject"><a href="#post-185816">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">I believe that I have already averted common pitfalls but i also believe that this is the Assembly programming language and not a HLL; therefore, the programmershould be responsible for handling errors not the library. The library can do its job given the correct input as already stated in the Notes section of OASML but if you are giving it an offset instead of a segment address for example, then it&#39;s *your* fault and not the library&#39;s. Anyway, it&#39;d be nice if you could tell me specifically which of the procedures in this library do not handle common errors as it should be.<br /><br />Thanks for your concern.</div>
    <div class="meta">Posted on 2006-10-10 02:25:25 by XCHG</div>
   </div>
   <div class="post" id="post-185817">
    <div class="subject"><a href="#post-185817">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">GetParamBlock - how do you set size of buffer, to prevent overflow? same for GetAppPath, and all string functions.&nbsp; This was common problems in standard C library for many many years, until they realized they have to allways pass size of buffer to function, too. Other way it&#39;s very hard to prevent buffer overflows<br /><br />Anyway, sorry, i found out you do have error handling there. What you miss is error catching. I believe purpose of library is to ease programmer&#39;s job. catching errors for programmer (where it is possible) is very helpful - why not to do it?<br /><br />by the way, why do you use &quot;dw 10CDh&quot; instead of &quot;int 10h&quot; ?</div>
    <div class="meta">Posted on 2006-10-10 03:07:37 by vid</div>
   </div>
   <div class="post" id="post-185819">
    <div class="subject"><a href="#post-185819">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">The first Note of the  procedure says (quote) &quot;The string is recommended to be 255 bytes long, at least.&quot; although I seem to have forgotten to mention the same thing for the  procedure. And for passing the length of the string to every procedure I think it&#39;d be merely overkill once you are told how many bytes your buffer is recommended to have. Case in point, The &quot;SendMessage&quot; Win32 API can be provided the length of the string to be copied from a window with the WM_GETTEXT message but the &quot;wParam&quot; would *not* indicate the length of the buffer pointed by &quot;lParam&quot;, it is simply the amount of bytes you wish to copy from the source window&#39;s text. The same story must be with the C libraries, allowing the number of bytes to be copied to the buffer to be specified not the length of the buffer.<br /><br />Now would it be rational if I wanted to retrieve like only 5 bytes from ARGV while the procedure is clearly saying &quot;GetParamBlock&quot; which returns the *whole* block which could be of a variable length?<br /><br />Once again, I appreciate your concern.<br /><br />P.S: I added the same note to the  procedure. Thanks to you.</div>
    <div class="meta">Posted on 2006-10-10 04:39:42 by XCHG</div>
   </div>
   <div class="post" id="post-185820">
    <div class="subject"><a href="#post-185820">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">now think about case, when you need to work with data from external source, like file or internet. there is an 30byte array for name, null terminated string. you need to copy this name into your buffer. <br /><br />it comes natural to everyone using string copy, forgetting about case when string is NOT null terminated. In this case you copy more than 30 bytes, your destination buffer will likely overflow and overwrite other data behind it. this is how most exploits work, and it is caused because programmers got used to working with strings in limited buffers, without passing buffer size.</div>
    <div class="meta">Posted on 2006-10-10 04:46:13 by vid</div>
   </div>
   <div class="post" id="post-185821">
    <div class="subject"><a href="#post-185821">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body"><strong>XCHG:</strong> what you need is MAX_PATH+1, where MAX_PATH is defined as 260. But, surprise surprise, you can have longer file/whatever names than this on NT.<br /><br />For just about everything that has to do with writing into buffers, you need to pass a destination-buffer-size, except for very low-level &quot;working horse&quot; routines. Anything else is a recipe for disaster. Just look at m32lib&#39;s vulnerable command line routines, where the proposed &quot;fix&quot; is to bail out if command line is too long...<br /></div>
    <div class="meta">Posted on 2006-10-10 05:10:25 by f0dder</div>
   </div>
   <div class="post" id="post-185822">
    <div class="subject"><a href="#post-185822">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">i am having argument right not with some OpenBSD strlcpy() developer whether source buffer is needed too.<br /><br />i say yes, it can help catching even more errors.</div>
    <div class="meta">Posted on 2006-10-10 10:03:46 by vid</div>
   </div>
   <div class="post" id="post-185823">
    <div class="subject"><a href="#post-185823">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">Source buffer length checking isn&#39;t nearly as necessary as destination buffer, though. Of course in some extreme situations you can get a pagefault by reading too far, but... well :)<br /></div>
    <div class="meta">Posted on 2006-10-10 10:14:30 by f0dder</div>
   </div>
   <div class="post" id="post-185824">
    <div class="subject"><a href="#post-185824">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">Btw, often it&#39;s more time-consuming to wonder whether to implement (and provide) feature#1 or feature#2, than implementing (and providing) them both :) . <br /><br />For file-paths, it&#39;s a must to provide destination buffer size. <br />But for procs like strcpy, you can provide both versions (one with, and one without known buffer-size). </div>
    <div class="meta">Posted on 2006-10-10 10:27:43 by Ultrano</div>
   </div>
   <div class="post" id="post-185825">
    <div class="subject"><a href="#post-185825">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">i don&#39;t agree about providing both. most people are lazy and will use worser one, and after error happens they will blame you for providing it.<br /><br />also i think that it is also purpose of library to &quot;teach&quot; people write proper code, but this is subjective.</div>
    <div class="meta">Posted on 2006-10-10 11:33:15 by vid</div>
   </div>
   <div class="post" id="post-185833">
    <div class="subject"><a href="#post-185833">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">I really don&#39;t know why I had to assume that non null-terminated string were going to be used while the intention obviously here was to work with null-terminated strings as the 14th statement in the details of the library states &quot;The policy of OASML 1.0 is toward using null-terminated strings throughout the code for convenience. &quot;.<br /><br />If you would like to copy for example 30 bytes from the source to the destination whether or not the source is null-terminated, you could use the  in the  unit which allows the maximum length to be specified. However, I will implement a set of new procedures and functions to accept the length for the destination and/or the source.</div>
    <div class="meta">Posted on 2006-10-11 03:51:42 by XCHG</div>
   </div>
   <div class="post" id="post-185837">
    <div class="subject"><a href="#post-185837">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">good decision. and now the hard part - how to beheave if dest / source string is not zero terminated inside the buffer ;)</div>
    <div class="meta">Posted on 2006-10-11 07:40:31 by vid</div>
   </div>
   <div class="post" id="post-185839">
    <div class="subject"><a href="#post-185839">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">Well let?s say the accumulator holds the requested maximum length and data register is used to read from source and copy to the destination. The accumulator needs to get DECremented and be checked if it reaches zero. The procedure should exit as soon as AX is zero or as soon as a null byte is detected in the source string. The destination should then get terminated by a null-byte anyway. ummm!</div>
    <div class="meta">Posted on 2006-10-11 07:49:12 by XCHG</div>
   </div>
   <div class="post" id="post-185840">
    <div class="subject"><a href="#post-185840">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">and what if ax=0?<br /><br />and what about strcat? what about strcat when dest string isn&#39;t zero terminated already? zero terminate it or leave it as is?<br /><br />what about StrInsert? how to beheave if strlen(dest)+strlen(source) &gt; dest_buffer?<br /><br />there are MANY funny cases, i fortunately already have this part behind me, in my library</div>
    <div class="meta">Posted on 2006-10-11 07:56:01 by vid</div>
   </div>
   <div class="post" id="post-185841">
    <div class="subject"><a href="#post-185841">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">Well the first case is really easy. just a TEST on accumulator. The second is already done in OASML too if you look at the notes where it says &quot;The destination string will be terminated by null by the procedure&quot;. Every procedure in OASML which somehow copies some string from somewhere to another string, terminates the string by null.<br /><br />The third one is just ridiculous because you need not worry about it. You should just go until you find the null-terminator or to the extent indicated by the length parameter.</div>
    <div class="meta">Posted on 2006-10-11 09:07:14 by XCHG</div>
   </div>
   <div class="post" id="post-185842">
    <div class="subject"><a href="#post-185842">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">okay, you will find out ;) :P<br /></div>
    <div class="meta">Posted on 2006-10-11 10:18:42 by vid</div>
   </div>
   <div class="post" id="post-185956">
    <div class="subject"><a href="#post-185956">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">Okay, so I&#39;ve already started coding the length-dependent string algorithms and I was wondering what kinds of string routines could possibly be of more use to the users than the others so that I will be focusing on those more. A list of procedures or a very short tip will do. Thank you guys.</div>
    <div class="meta">Posted on 2006-10-15 08:34:35 by XCHG</div>
   </div>
   <div class="post" id="post-185962">
    <div class="subject"><a href="#post-185962">Re: OASML 1.0 (Open-source Assembly Library)</a></div>
    <div class="body">here is mine:</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2120" target="_blank">str.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-10-15 16:38:26 by vid</div>
   </div>
  </div>
 </body>
</html>