<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>url monikers. help!!! - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20101" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=20101">url monikers. help!!!</a></p>
   <div class="post" id="post-154017">
    <div class="subject"><a href="#post-154017">url monikers. help!!!</a></div>
    <div class="body">...Now I see why this section described as 'not for the faint of heart.'. For a week already I am trying to implement a simple namespace handler, but only getting fault after fault.. :evil: <br />Anyway, I wanted to ask if anyone here ever worked with urlmon object? <br />I especially interested in examples of IInternetSession and other interfaces that are used in creation of asynchronous pluggable protocols.</div>
    <div class="meta">Posted on 2004-12-11 14:29:28 by arafel</div>
   </div>
   <div class="post" id="post-154767">
    <div class="subject"><a href="#post-154767">url monikers. help!!!</a></div>
    <div class="body">Could someone do me a favor and look at the code i have linked below. I have tried to remove all the unnecessary parts. But the size is still not so small. sorry.<br /><br />Supplied dll is a name-space handler for http protocol. The system should on every url access ('http:') pass the execution to IInternetProtocol::Start. But for some reason my implementation of Start method never receives the call.<br /><br /><a target="_blank" href="http://coronis.berlios.de/iip.zip">http://coronis.berlios.de/iip.zip</a></div>
    <div class="meta">Posted on 2004-12-25 16:22:11 by arafel</div>
   </div>
   <div class="post" id="post-154790">
    <div class="subject"><a href="#post-154790">url monikers. help!!!</a></div>
    <div class="body">there were some bugs in your code.<br />I made some minor changes and start is now executed (only if you use IE, of course)<br /><br />but since uploading is deactivated in this forum, code follows here:<br />(you will have to delete the OutputDebugString lines, since macro<br />CStr isn't defined):<br /><br /><pre><code><br />.486<br />.model flat, stdcall<br />option casemap&#58;none<br /><br /><br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\advapi32.inc<br />include \masm32\include\ole32.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\shlwapi.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\advapi32.lib<br />includelib \masm32\lib\ole32.lib<br />includelib \masm32\lib\shlwapi.lib<br />includelib \masm32\lib\uuid.lib<br />		<br />        include macros.inc<br /><br /><br /><br />INET_E_USE_DEFAULT_PROTOCOLHANDLER	equ 800C0011h<br /><br /><br />DllRegisterServer       PROTO<br />DllCanUnloadNow         PROTO<br />DllGetClassObject       PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />DllUnregisterServer     PROTO<br />QueryInterface		PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />AddRef			PROTO &#58;DWORD<br />Release			PROTO &#58;DWORD<br />CreateInstance		PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_QueryInterface	PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_AddRef		PROTO &#58;DWORD<br />iecm_Release		PROTO &#58;DWORD<br />iecm_Start    		PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_Continue    	PROTO &#58;DWORD<br />iecm_Abort		PROTO &#58;DWORD, &#58;DWORD<br />iecm_Terminate    	PROTO &#58;DWORD<br />iecm_Suspend    	PROTO<br />iecm_Resume		PROTO<br />iecm_Read		PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_Seek		PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_LockRequest	PROTO &#58;DWORD<br />iecm_UnlockRequest	PROTO<br /><br />externdef IID_IInternetProtocolRoot&#58;IID<br />externdef IID_IInternetProtocol&#58;IID<br /><br />CFObject STRUCT<br />	lpVtbl		DWORD ?<br />	nRefCount	DWORD ?<br />CFObject ENDS<br /><br />IECMObjectStruc STRUCT<br />	lpVtbl		DWORD ?<br />	nRefCount	DWORD ?<br />	nValue          DWORD ?  <br />IECMObjectStruc ENDS<br /><br /><br />QueryInterfaceProto	TYPEDEF PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />AddRefProto		TYPEDEF PROTO &#58;DWORD<br />ReleaseProto		TYPEDEF PROTO &#58;DWORD<br />CreateInstanceProto	TYPEDEF PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br />LockServerProto		TYPEDEF PROTO &#58;DWORD, &#58;DWORD<br /><br />c_QueryInterface	TYPEDEF ptr QueryInterfaceProto<br />c_AddRef		TYPEDEF ptr AddRefProto<br />c_Release		TYPEDEF ptr ReleaseProto<br />c_CreateInstance	TYPEDEF ptr CreateInstanceProto<br />c_LockServer		TYPEDEF ptr LockServerProto<br /><br />IClassFactory STRUCT<br />	QueryInterface		c_QueryInterface ?<br />	AddRef 			c_AddRef ?<br />	Release 		c_Release ?<br />	CreateInstance 		c_CreateInstance ?<br />	LockServer 		c_LockServer ?<br />IClassFactory ENDS<br /><br /><br />iecm_QueryInterfaceProto	TYPEDEF PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_AddRefProto		TYPEDEF PROTO &#58;DWORD<br />iecm_ReleaseProto		TYPEDEF PROTO &#58;DWORD<br />iecm_StartProto			TYPEDEF PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_ContinueProto		TYPEDEF PROTO &#58;DWORD<br />iecm_AbortProto			TYPEDEF PROTO &#58;DWORD, &#58;DWORD<br />iecm_TerminateProto		TYPEDEF PROTO &#58;DWORD<br />iecm_SuspendProto		TYPEDEF PROTO<br />iecm_ResumeProto		TYPEDEF PROTO<br />iecm_ReadProto			TYPEDEF PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_SeekProto			TYPEDEF PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />iecm_LockRequestProto		TYPEDEF PROTO &#58;DWORD<br />iecm_UnlockRequestProto		TYPEDEF PROTO<br /><br />i_QueryInterface	TYPEDEF ptr iecm_QueryInterfaceProto<br />i_AddRef		TYPEDEF ptr iecm_AddRefProto<br />i_Release		TYPEDEF ptr iecm_ReleaseProto<br />i_Start			TYPEDEF ptr iecm_StartProto<br />i_Continue		TYPEDEF ptr iecm_ContinueProto<br />i_Abort			TYPEDEF ptr iecm_AbortProto<br />i_Terminate		TYPEDEF ptr iecm_TerminateProto<br />i_Suspend		TYPEDEF ptr iecm_SuspendProto<br />i_Resume		TYPEDEF ptr iecm_ResumeProto<br />i_Read			TYPEDEF ptr iecm_ReadProto<br />i_Seek			TYPEDEF ptr iecm_SeekProto<br />i_LockRequest		TYPEDEF ptr iecm_LockRequestProto<br />i_UnlockRequest		TYPEDEF ptr iecm_UnlockRequestProto<br /><br />IIECM STRUCT<br />	iecm_QueryInterface	i_QueryInterface ?	; IUnknown members<br />	iecm_AddRef		i_AddRef ?<br />	iecm_Release		i_Release ?<br />	iecm_Abort		i_Abort ?		; IInternetProtocolRoot members<br />	iecm_Continue		i_Continue ?<br />	iecm_Resume		i_Resume ?<br />	iecm_Start		i_Start ?<br />	iecm_Suspend		i_Suspend ?<br />	iecm_Terminate    	i_Terminate ?<br />	iecm_LockRequest	i_LockRequest ?		; IInternetProtocol members<br />	iecm_Read		i_Read ?<br />	iecm_Seek		i_Seek ?<br />	iecm_UnlockRequest	i_UnlockRequest ?<br />IIECM ENDS<br /><br /><br /><br />ShowProgress MACRO strng<br />local	@l<br /><br />.data<br />@l      db strng<br />	db 8 dup&#40;0&#41;<br /><br />.code<br />	pushad<br />	mov	edi, offset @l<br />	xor	eax, eax<br />@@&#58;	scasb<br />	jne	@b<br />	dec	edi<br />	cmp	eax, S_OK<br />	jne	notok<br />	mov	&#91;edi&#93;, dword ptr &quot;KO_S&quot;<br />	mov	&#91;edi+4&#93;, byte ptr 0<br />	jmp	@f<br />notok&#58;	mov	&#91;edi&#93;, dword ptr &quot;LIAF&quot;<br />	mov	&#91;edi+4&#93;, word ptr &quot;DE&quot;<br />	mov	&#91;edi+6&#93;, byte ptr 0<br />@@&#58;	invoke	MessageBox, 0, ADDR @l, 0, MB_OK<br />	popad<br />ENDM<br /><br /><br /><br /><br />.data<br /><br /><br />IECMObject	CFObject &lt;OFFSET vtIClassFactory,0&gt;<br /><br />vtIClassFactory	IClassFactory	&lt;QueryInterface,AddRef,Release,CreateInstance,LockServer&gt;<br />vtIMyCom	IIECM &lt;iecm_QueryInterface,iecm_AddRef,iecm_Release,iecm_Start,iecm_Continue,iecm_Abort,iecm_Terminate,\<br />			iecm_Suspend,iecm_Resume,iecm_Read, iecm_Seek,iecm_LockRequest,iecm_UnlockRequest&gt;<br /><br />IID_IUnknown		GUID &#123;000000000h, 00000h, 00000h,&#123;0C0h, 000h, 000h, 000h, 000h, 000h, 000h, 046h&#125;&#125;<br />IID_IClassFactory	GUID &#123;000000001h, 00000h, 00000h,&#123;0C0h, 000h, 000h, 000h, 000h, 000h, 000h, 046h&#125;&#125;<br />CLSID_IECM		GUID &#123;07FC322AEh, 00971h, 04142h,&#123;09Ch, 00Ch, 0FFh, 07Eh, 054h, 0C7h, 001h, 0A2h&#125;&#125;<br /><br />obj_desc		db &quot;IECM service for mFIDS&quot;,0<br />obj_name		db &quot;IECM&quot;,0<br />clsid_txt		db &quot;CLSID&quot;,0<br />obj_GUID_txt		db &quot;&#123;7FC322AE-0971-4142-9C0C-FF7E54C701A2&#125;&quot;,0<br />InprocServer32_txt	db &quot;InprocServer32&quot;,0<br />ThreadingModel_txt	db &quot;ThreadingModel&quot;,0<br />apartment_txt		db &quot;Apartment&quot;,0<br />nsh_txt			db &quot;PROTOCOLS\Name-Space Handler\http\iecm&quot;,0<br /><br /><br /><br />.data?<br /><br />hInstance	dd ?<br />curpath		db MAX_PATH dup&#40;?&#41;<br /><br /><br /><br />.code<br /><br /><br />;============================================================================================================<br />; dll entry procedure<br />; <br />; returns&#58;	EAX = TRUE/FALSE<br />;<br />;============================================================================================================<br />;															- OK<br />DllMain PROC _hInstance&#58;HANDLE, ulReason&#58;DWORD, _Reserved&#58;DWORD<br /><br />	.if ulReason == DLL_PROCESS_ATTACH<br /><br />		invoke OutputDebugString, CStr&#40;&lt;&quot;DllMain process attach&quot;,13,10&gt;&#41;<br />        mov	eax, _hInstance<br />        mov	&#91;hInstance&#93;, eax<br />        mov	eax, TRUE<br /><br />	.elseif ulReason == DLL_PROCESS_DETACH<br /><br />		invoke OutputDebugString, CStr&#40;&lt;&quot;DllMain thread attach&quot;,13,10&gt;&#41;<br />		mov	eax, FALSE<br /><br />	.elseif ulReason == DLL_THREAD_ATTACH<br /><br />		mov	eax, FALSE<br /><br />	.elseif	ulReason == DLL_THREAD_DETACH<br /><br />	mov	eax, FALSE<br /><br />	.else<br /><br />	mov	eax, FALSE<br /><br />	.endif<br /><br />	ret<br /><br />DllMain ENDP<br /><br /><br /><br />;============================================================================================================<br />; check if service is ready for unload<br />; <br />; returns&#58;	EAX = S_OK/S_FALSE<br />;<br />;============================================================================================================<br /><br />DllCanUnloadNow PROC<br /><br />	cmp	&#91;IECMObject.nRefCount&#93;, 0<br />	je	@f<br />	mov	eax, S_FALSE<br />	ret<br />@@&#58;	mov	eax, S_OK<br />	ret<br /><br />DllCanUnloadNow ENDP<br /><br /><br /><br />;============================================================================================================<br />; gets class object from dll object handler<br />; <br />; returns&#58;	EAX = CLASS_E_CLASSNOTAVAILABLE/S_OK/E_NOINTERFACE<br />;<br />;============================================================================================================<br /><br />DllGetClassObject PROC rclsid&#58;DWORD, piid&#58;DWORD, ppv&#58;DWORD<br /><br /><br />	invoke OutputDebugString, CStr&#40;&lt;&quot;DllGetClassObject&quot;,13,10&gt;&#41;<br />	invoke	IsEqualGUID, rclsid, ADDR CLSID_IECM<br /><br />	.if eax == TRUE<br /><br />		invoke OutputDebugString, CStr&#40;&lt;&quot;DllGetClassObject, CLSID ok&quot;,13,10&gt;&#41;<br />        invoke	QueryInterface, ADDR IECMObject, piid, ppv<br />    	push	eax<br />        .if &#40;eax == S_OK&#41;<br />			invoke OutputDebugString, CStr&#40;&lt;&quot;DllGetClassObject, IID ok&quot;,13,10&gt;&#41;<br />        .else<br />			invoke OutputDebugString, CStr&#40;&lt;&quot;DllGetClassObject, IID not ok&quot;,13,10&gt;&#41;<br />        .endif<br /><br />        invoke	Release, offset IECMObject<br />		pop	eax<br /><br /><br />	.else<br /><br />        mov	eax, CLASS_E_CLASSNOTAVAILABLE<br /><br />	.endif<br /><br />	ret<br /><br /><br />DllGetClassObject ENDP<br /><br /><br /><br />;============================================================================================================<br />; registers the COM object<br />; <br />; returns&#58;	EAX = 0 on success. API function return value otherwise.<br />;<br />;============================================================================================================<br /><br />DllRegisterServer PROC<br /><br />	Local	hKey&#58;DWORD<br />	Local	hKey2&#58;DWORD<br />	Local	hKey3&#58;DWORD<br /><br />    									<br />	invoke	RegCreateKey, HKEY_CLASSES_ROOT, ADDR obj_name, ADDR hKey	; &#91;HKEY_CLASSES_ROOT\CMyCom&#93;<br />	cmp	eax, ERROR_SUCCESS						; @=&quot;IECM service for mFIDS&quot;<br />	jne	@ret<br />	invoke	RegSetValue, hKey, 0, REG_SZ, ADDR obj_desc, sizeof obj_desc<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	RegCreateKey, hKey, ADDR clsid_txt, ADDR hKey2			; &#91;HKEY_CLASSES_ROOT\CMyCom\CLSID&#93;<br />	cmp	eax, ERROR_SUCCESS						; @=&quot;&#123;A21A8C42-1266-11D4-A324-0040F6D487D9&#125;&quot;<br />	jne	@ret<br /><br />    	invoke	RegSetValue, hKey2, 0, REG_SZ, ADDR obj_GUID_txt, sizeof obj_GUID_txt<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	RegCloseKey, hKey<br />	invoke	RegCloseKey, hKey2<br /><br /><br />    	invoke	RegCreateKey, HKEY_CLASSES_ROOT, ADDR clsid_txt, ADDR hKey	; &#91;HKEY_CLASSES_ROOT\CLSID\'GUID'&#93;<br />	cmp	eax, ERROR_SUCCESS						; @=&quot;IECM service for mFIDS&quot;<br />	jne	@ret<br /><br />    	invoke	RegCreateKey, hKey, ADDR obj_GUID_txt, ADDR hKey2<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />   	invoke	RegSetValue, hKey2, 0, REG_SZ, ADDR obj_desc, sizeof obj_desc<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br /><br />	invoke	RegCreateKey, hKey2, ADDR obj_name, ADDR hKey3			; &#91;HKEY_CLASSES_ROOT\CLSID\'GUID'\CMyCom&#93;<br />	cmp	eax, ERROR_SUCCESS						; @=&quot;CMyCom&quot;<br />	jne	@ret<br /><br />	invoke	RegSetValue, hKey3, 0, REG_SZ, ADDR obj_name, sizeof obj_name<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	RegCloseKey, hKey3<br /><br /><br />    	invoke	GetModuleFileName, hInstance, ADDR curpath, MAX_PATH<br />	cmp	eax, 4<br />	jbe	@ret<br /><br />    	invoke	RegCreateKey, hKey2, ADDR InprocServer32_txt, ADDR hKey3     ;&#91;HKEY_CLASSES_ROOT\CLSID\'GUID'\InprocServer32&#93;<br />	cmp	eax, ERROR_SUCCESS						; @=&quot;fullpathto\iecm.dll&quot;<br />	jne	@ret								; &quot;ThreadingModel&quot;=&quot;Both&quot;<br /><br />	invoke	RegSetValue, hKey3, 0, REG_SZ, ADDR curpath, MAX_PATH<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	RegSetValueEx, hKey3, ADDR ThreadingModel_txt, 0, REG_SZ, ADDR apartment_txt, sizeof apartment_txt<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	RegCloseKey, hKey3<br />	invoke	RegCloseKey, hKey2<br />	invoke	RegCloseKey, hKey<br /><br /><br />    	invoke	RegCreateKey, HKEY_CLASSES_ROOT, ADDR nsh_txt, ADDR hKey	; &#91;HKEY_CLASSES_ROOT\<br />	cmp	eax, ERROR_SUCCESS						; PROTOCOLS\Name-Space Handler\http\iecm&#93;<br />	jne	@ret								; &quot;iecm&quot;='GUID'<br /><br />   	invoke	RegSetValueEx, hKey, ADDR clsid_txt, 0, REG_SZ, ADDR obj_GUID_txt, sizeof obj_GUID_txt<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	RegCloseKey, hKey<br /><br />	xor	eax, eax<br />@ret&#58;	ret<br /><br />DllRegisterServer ENDP<br /><br /><br /><br />;============================================================================================================<br />; unregisters the COM object<br />; <br />; returns&#58;	EAX = 0 on success. API function return value otherwise.<br />;<br />;============================================================================================================<br /><br />DllUnregisterServer PROC<br /><br />	Local	hKey&#58;DWORD<br /><br />	invoke	SHDeleteKey, HKEY_CLASSES_ROOT, ADDR obj_name<br /><br />	invoke	RegOpenKey, HKEY_CLASSES_ROOT, ADDR clsid_txt, ADDR hKey<br />	cmp	eax, ERROR_SUCCESS<br />	jne	@ret<br /><br />	invoke	SHDeleteKey, hKey, ADDR obj_GUID_txt<br /><br />	xor	eax, eax<br />@ret&#58;	ret<br /><br />DllUnregisterServer ENDP<br /><br /><br /><br />;============================================================================================================<br />; returns a pointer to a specific interface   &#40;IClassFactory&#41;<br />; <br />; returns&#58;	EAX = S_OK\E_NOINTERFACE<br />;<br />;============================================================================================================<br /><br />QueryInterface PROC this_&#58;DWORD, iid&#58;DWORD,  ppvObject&#58;DWORD<br /><br />	invoke  IsEqualGUID, iid, ADDR IID_IClassFactory<br />    push eax<br />	invoke  IsEqualGUID, iid, ADDR IID_IUnknown<br />    pop edx<br />	or	eax, edx<br /><br />	.if eax == TRUE          <br />        mov	eax, this_<br />        mov	edx, ppvObject<br />        mov	&#91;edx&#93;, eax<br />        invoke	AddRef, eax<br />		mov	eax, S_OK<br />        ret<br />	.endif     <br /><br />	mov	&#91;ppvObject&#93;, 0<br />	mov	eax, E_NOINTERFACE<br />	ret<br /><br />QueryInterface ENDP<br /><br /><br /><br />;============================================================================================================<br />; increments reference count   &#40;IClassFactory&#41;<br />; <br />; returns&#58;	EAX = current reference count<br />;<br />;============================================================================================================<br /><br />AddRef PROC this_&#58;DWORD<br /><br />	inc	&#91;IECMObject.nRefCount&#93;<br />	mov	eax, &#91;IECMObject.nRefCount&#93;<br />	ret<br /><br />AddRef ENDP<br /><br /><br /><br />;============================================================================================================<br />; decrements reference count   &#40;IClassFactory&#41;<br />; <br />; returns&#58;	EAX = current reference count<br />;<br />;============================================================================================================<br /><br />Release proc this_&#58;DWORD<br /><br />	dec	&#91;IECMObject.nRefCount&#93;<br />	mov	eax, &#91;IECMObject.nRefCount&#93;<br />	ret<br /><br />Release endp<br /><br /><br /><br />;============================================================================================================<br />; creates an object   &#40;IClassFactory&#41;<br />; <br />; returns&#58;	EAX = E_OUTOFMEMORY\pointer to com object<br />;<br />;============================================================================================================<br /> <br />CreateInstance PROC uses ebx this_&#58;DWORD, pUnkOuter&#58;DWORD, riid&#58;DWORD, ppvObject&#58;DWORD<br /><br />	invoke	CoTaskMemAlloc, sizeof IECMObjectStruc<br />	test	eax, eax<br />	je	memout<br /><br />        mov	&#40;IECMObjectStruc PTR &#91;eax&#93;&#41;.lpVtbl, offset vtIMyCom<br />        mov	&#40;IECMObjectStruc PTR &#91;eax&#93;&#41;.nRefCount, 1<br />        mov	&#40;IECMObjectStruc PTR &#91;eax&#93;&#41;.nValue, 0<br /><br />	inc	&#91;IECMObject.nRefCount&#93;<br /><br />	mov ebx, eax<br />	invoke	iecm_QueryInterface, eax, riid, ppvObject<br /><br />	push eax<br />	.if &#40;eax == S_OK&#41;<br />    	invoke OutputDebugString, CStr&#40;&lt;&quot;CreateInstance OK&quot;,13,10&gt;&#41;<br />    .else<br />    	invoke OutputDebugString, CStr&#40;&lt;&quot;CreateInstance not OK&quot;,10,10&gt;&#41;<br />    .endif<br />    pop eax<br />;	ShowProgress &quot;&#40;IClassFactory&#41;CreateInstance -&gt; &#40;IIECM&#41;iecm_QueryInterface = &quot;<br /><br />	push eax<br />	invoke	iecm_Release, ebx<br />    pop eax<br />	ret<br /><br />memout&#58;<br />   	invoke OutputDebugString, CStr&#40;&lt;&quot;CreateInstance OUTOFMEMORY&quot;,13,10&gt;&#41;<br />	mov	eax, E_OUTOFMEMORY<br />	ret<br /><br />CreateInstance ENDP<br /><br /><br /><br />;============================================================================================================<br />; keeps the server open in memory<br />; <br />; returns&#58;	EAX = always S_OK<br />;<br />;============================================================================================================<br /><br />LockServer PROC fLock&#58;DWORD<br /><br />	.if fLock == TRUE<br /><br />	inc	&#91;IECMObject.nRefCount&#93;<br /><br />	.else<br /><br />        dec	&#91;IECMObject.nRefCount&#93;<br /><br />	.endif<br /><br />	mov	eax, S_OK<br />	ret<br /> <br />LockServer ENDP<br /><br /><br /><br />;============================================================================================================<br />; returns a pointer to a specific interface   &#40;IIECM&#41;<br />; <br />; returns&#58;	<br />;<br />;============================================================================================================<br /><br />iecm_QueryInterface PROC this_&#58;DWORD, iid&#58;DWORD,  ppvObject&#58;DWORD<br /><br />	invoke  IsEqualGUID, iid, ADDR IID_IUnknown<br />    .if &#40;eax != TRUE&#41;<br />		invoke  IsEqualGUID, iid, ADDR IID_IInternetProtocolRoot<br />        .if &#40;eax != TRUE&#41;<br />			invoke  IsEqualGUID, iid, ADDR IID_IInternetProtocol<br />        .endif<br />    .endif<br />	.if &#40;eax == TRUE&#41;<br />	mov	eax, this_<br />	mov	edx, ppvObject<br />	mov	&#91;edx&#93;, eax<br />	invoke	iecm_AddRef, eax<br />    invoke OutputDebugString, CStr&#40;&lt;&quot;iecm_QueryInterface OK&quot;,13,10&gt;&#41;<br />	mov	eax, S_OK<br />	ret<br />	.endif<br /><br />	mov	edx, ppvObject<br />	mov	&#91;edx&#93;, dword ptr 0<br />    invoke OutputDebugString, CStr&#40;&lt;&quot;iecm_QueryInterface failed&quot;,13,10&gt;&#41;<br />	mov	eax, E_NOINTERFACE<br />	ret<br /><br />iecm_QueryInterface endp<br /><br /><br /><br />;============================================================================================================<br />; increments reference count   &#40;IIECM&#41;<br />; <br />; returns&#58;	EAX = current reference count<br />;<br />;============================================================================================================<br /><br />iecm_AddRef PROC this_&#58;DWORD<br /><br />	mov	eax, this_<br />	inc	&#40;IECMObjectStruc ptr &#91;eax&#93;&#41;.nRefCount<br />	mov	eax, &#40;IECMObjectStruc ptr &#91;eax&#93;&#41;.nRefCount<br />	ret<br /><br />iecm_AddRef ENDP<br /><br /><br /><br />;============================================================================================================<br />; decrements reference count   &#40;IIECM&#41;<br />; <br />; returns&#58;	EAX = current reference count<br />;<br />;============================================================================================================<br /><br />iecm_Release PROC this_&#58;DWORD<br /><br />	mov	eax, this_<br />	dec	&#40;IECMObjectStruc ptr &#91;eax&#93;&#41;.nRefCount<br />	mov	eax, &#40;IECMObjectStruc ptr &#91;eax&#93;&#41;.nRefCount<br />	test	eax, eax<br />	jne	@ret<br /><br />	invoke	CoTaskMemFree, this_<br />	dec	&#91;IECMObject.nRefCount&#93;<br />        xor	eax, eax<br />@ret&#58;	ret<br /><br />iecm_Release ENDP<br /><br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Start<br />; <br />; returns&#58;	should return INET_E_USE_DEFAULT_PROTOCOLHANDLER or S_OK<br />;<br />;============================================================================================================<br /><br />iecm_Start PROC szUrl&#58;DWORD, OIProtSink&#58;DWORD, OIBindInfo&#58;DWORD, grfPI&#58;DWORD, dwReserved&#58;DWORD<br /><br />	invoke OutputDebugString, CStr&#40;&lt;&quot;&#40;IIECM&#41;IInternetProtocol&#58;&#58;Start - &quot;,13,10&gt;&#41;<br /><br />	mov	eax, INET_E_USE_DEFAULT_PROTOCOLHANDLER<br />	ret<br /><br />iecm_Start ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Read<br />; <br />; returns&#58;	EAX = always S_OK<br />;<br />;============================================================================================================<br /><br />iecm_Read PROC pv&#58;DWORD, cb&#58;DWORD, cbRead&#58;DWORD<br /><br />	mov	eax, S_OK<br />	ret<br /><br />iecm_Read ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Terminate<br />; <br />; returns&#58;	EAX = always S_OK<br />;<br />;============================================================================================================<br /><br />iecm_Terminate PROC dwOptions&#58;DWORD<br /><br />	mov	eax, S_OK<br />	ret<br /><br />iecm_Terminate ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;LockRequest<br />; <br />; returns&#58;	EAX = always S_OK<br />;<br />;============================================================================================================<br /><br />iecm_LockRequest PROC dwOptions&#58;DWORD<br /><br />	mov	eax, S_OK<br />	ret<br />iecm_LockRequest ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;UnlockRequest<br />; <br />; returns&#58;	EAX = always S_OK<br />;<br />;============================================================================================================<br /><br />iecm_UnlockRequest PROC<br /><br />	mov	eax, S_OK<br />	ret<br /><br />iecm_UnlockRequest ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Continue<br />; <br />; returns&#58;	EAX = always S_OK<br />;<br />;============================================================================================================<br /><br />iecm_Continue PROC ProtocolData&#58;DWORD<br /><br />	mov	eax, S_OK<br />	ret<br /><br />iecm_Continue ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Abort<br />; <br />; returns&#58;	EAX = always E_NOTIMPL<br />;<br />;============================================================================================================<br /><br />iecm_Abort PROC hrReason&#58;DWORD, dwOptions&#58;DWORD<br /><br />	mov	eax, E_NOTIMPL<br />	ret<br /><br />iecm_Abort ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Suspend<br />; <br />; returns&#58;	EAX = always E_NOTIMPL<br />;<br />;============================================================================================================<br /><br />iecm_Suspend PROC<br /><br />	mov	eax, E_NOTIMPL<br />	ret<br /><br />iecm_Suspend ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Resume<br />; <br />; returns&#58;	EAX = always E_NOTIMPL<br />;<br />;============================================================================================================<br /><br />iecm_Resume PROC<br /><br />	mov	eax, E_NOTIMPL<br />	ret<br /><br />iecm_Resume ENDP<br /><br /><br />;============================================================================================================<br />; IInternetProtocol&#58;&#58;Seek<br />; <br />; returns&#58;	EAX = always E_NOTIMPL<br />;<br />;============================================================================================================<br /><br />iecm_Seek PROC dlibMove&#58;DWORD, dwOrigin&#58;DWORD, libNewPosition&#58;DWORD<br /><br />	mov	eax, E_NOTIMPL<br />	ret<br /><br />iecm_Seek ENDP<br /><br /><br />end DllMain<br /></code></pre></code></pre></div>
    <div class="meta">Posted on 2004-12-26 05:44:53 by japheth</div>
   </div>
   <div class="post" id="post-154917">
    <div class="subject"><a href="#post-154917">url monikers. help!!!</a></div>
    <div class="body">exactly as i suspected - dumb mistakes prevented start to execute..  :oops: <br /><br />i didn't know that IInternetProtocol\Root IIDs should be checked in QueryInterface though.<br /><br />thanks japheth!</div>
    <div class="meta">Posted on 2004-12-28 15:32:48 by arafel</div>
   </div>
  </div>
 </body>
</html>