<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Can't pipe or redirect stdout from gas program on RHEL5.5 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30527" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=117">Unix</a> &raquo; <a href="../?id=30527">Can't pipe or redirect stdout from gas program on RHEL5.5</a></p>
   <div class="post" id="post-214250">
    <div class="subject"><a href="#post-214250">Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Hi there, <br /><br />Disclaimer: total and utter assembler noob<br /><br />I&#039;ve written a small program to read the contents of the sys_getdents function and parse its output, printing the output to stdout using a call to C&#039;s printf function. However, although I can see the (expected) output on-screen, I can&#039;t redirect or pipe the output using &#039;&gt;&#039; or &#039;|&#039;. <br /><br />Can anyone suggest why this is happening? The program&#039;s dynamically linked and was compiled with as and linked with ld. <br /><br />Cheers<br /><br />Michael</div>
    <div class="meta">Posted on 2011-04-08 10:19:26 by michaelg</div>
   </div>
   <div class="post" id="post-214252">
    <div class="subject"><a href="#post-214252">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">I don&#039;t think this accounts for what you&#039;re seeing, but I&#039;ll mention it anyway. I&#039;ve noticed an &quot;oddity&quot; to printf: it doesn&#039;t actually print anything until the buffer is flushed. Printing a linefeed (&quot;\n&quot; or 0x0A) will flush the buffer, as will doing buffered input, as will exiting the program. However if I, for example, say &quot;Please tell me your name &quot; using printf - no linefeed, I want the input on the same line - and then get the name using sys_read, nothing is printed. It waits for input with no &quot;prompt&quot;. Then, at the end, prints &quot;Please tell me your name &quot;/ &quot;Hello Frank&quot;. I guess that&#039;s why the manual advises us not to mix &quot;buffered I/O&quot; with &quot;low level I/O&quot;. I would ASSume that redirected output would be &quot;printed&quot; at the end, too... but maybe not... I don&#039;t think that&#039;s &quot;it&quot;, but it&#039;s the only thing I can think of. If you&#039;re not ending your format string with a linefeed, try it.<br /><br />If this is 32-bit code, I&#039;ll test it for ya if you post it (old Slackware distro). Can&#039;t help with 64-bit.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-04-08 14:03:08 by fbkotler</div>
   </div>
   <div class="post" id="post-214253">
    <div class="subject"><a href="#post-214253">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">@Michael:<br /><br />Huh!?<br /><br />Seeing some code here would probably help, but I&#039;m going to take a wild shot in the dark and suggest the following.<br /><br /><pre><code>./sgdapp &amp;&gt; file.log</code></pre><br /><br />Or if you are trying to pass it to another command, try something like this.<br /><br /><pre><code>./sgdapp 2&gt;&amp;1 | awk &#039;{print $1,$3;}&#039;</code></pre><br /><br />That command takes the first and third column of output from ./sgdapp and displays it. If either of these work, then your output is getting lost on it&#039;s path to stdout and ending up in stderr. In that case check your file handles. If it doesn&#039;t work, I would probably agree with fbkotler, there might not be a terminating newline at the end of your output, either insert one manually or call fflush() to force the I/O buffer to be drawn to the screen.<br /><br />@Frank:<br /><br /><div class="quote">I&#039;ve noticed an &quot;oddity&quot; to printf: it doesn&#039;t actually print anything until the buffer is flushed. Printing a linefeed (&quot;\n&quot; or 0x0A) will flush the buffer, as will doing buffered input, as will exiting the program. However if I, for example, say &quot;Please tell me your name &quot; using printf - no linefeed, I want the input on the same line - and then get the name using sys_read, nothing is printed. It waits for input with no &quot;prompt&quot;. Then, at the end, prints &quot;Please tell me your name &quot;/ &quot;Hello Frank&quot;. I guess that&#039;s why the manual advises us not to mix &quot;buffered I/O&quot; with &quot;low level I/O&quot;.</div><br /><br />This behavior is completely expected and yes it&#039;s why they warn about using buffered vs low level I/O together. However, there is a solution. fflush() can be called to force the buffered routine to flush the contents of the file descriptor without needing a linefeed.</div>
    <div class="meta">Posted on 2011-04-08 15:04:54 by Synfire</div>
   </div>
   <div class="post" id="post-214256">
    <div class="subject"><a href="#post-214256">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Hi Guys, <br /><br />Thanks for your replies!<br /><br />The file below is my attempt at something to call and interpret the response from sys_getdents/syscall 141. I&#039;ve added my Makefile just in case that holds the problem (it&#039;s pretty vanilla). The RHEL 5.5 install is a 64-bit install, but I&#039;m building and linking it in 32 bit mode. <br /><br />Cheers<br /><br />Michael<br /><br />---------------------------------8&lt;----------------------------------<br /><br />dents: dents.o<br />	ld -melf_i386 --dynamic-linker /lib/ld-linux.so.2 -o dents -lc dents.o<br /><br />dents.o:<br />	as --32 -o dents.o dents.s<br /><br /><br />---------------------------------8&lt;----------------------------------<br /><br />#<br /># see /usr/include/asm-i386/unistd.h for the syscall numbers<br />#<br /><br />.section .data<br />	asciz_dot:&nbsp; &nbsp; 	.asciz	&quot;.&quot;<br />	header_str:	.asciz	&quot;%10s\t%10s\t%10s\t%s\n&quot;<br />	dirent_str:	.asciz	&quot;%10d\t%10d\t%10d\t%s\n&quot;<br />	inode_str:	.asciz	&quot;inode&quot;<br />	offset_str:	.asciz	&quot;offset&quot;<br />	len_str:	.asciz	&quot;length&quot;<br />	name_str:	.asciz	&quot;name&quot;<br />	<br />.section .bss<br /><br />	.lcomm	buffer, 2048<br /><br />.section .text<br /><br />.globl _start<br /><br /># parameter: base-address in EAX<br /># Returns: <br />#	EAX	inode<br />#	EBX	offset<br />#	ECX	length<br />#	EDX	.asciz name[0]-address<br />#<br /># Where dirent struct looks like <br />#&nbsp; struct dirent {<br />#	&nbsp; long d_ino;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /* inode number */<br />#	&nbsp; off_t d_off;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* offset to next dirent */<br />#	&nbsp; unsigned short d_reclen;&nbsp; &nbsp; /* length of this dirent */<br />#	&nbsp; char d_name ;&nbsp;  /* filename (null-terminated) */<br />#&nbsp; }<br />#<br /># d_ino&nbsp; is&nbsp; an&nbsp; inode number.&nbsp; <br /># d_off is the distance from the start of the directory to the start of the next dirent.<br /># d_reclen is the size of this entire dirent.&nbsp; <br /># d_name is a null-terminated filename.<br />#<br />read_dirent:<br />	addl	$8, %eax		# point EAX at the &#039;length&#039; field<br />	xorl	%ecx, %ecx		# clear ECX<br />	movw	(%eax), %cx		# copy u16 value at (EAX) into CX<br />	<br />	addl	$2, %eax		# point EAX at the &#039;name&#039; field<br />	movl	%eax, %edx			# copy address value to EDX<br /><br />	subl	$6, %eax		# point EAX at the &#039;offset&#039; field<br />	movl	(%eax), %ebx		# copy &#039;offset&#039; field value into EBX<br /><br />	subl	$4, %eax		# point EAX at the &#039;inode&#039; field<br />	movl	(%eax), %eax	# copy value at (EAX) into EAX<br /><br />	ret	<br /><br />_start:<br /><br />	movl	%esp, %ebp		# store SP in BP<br />	<br />	cmp	$1, (%esp)		# check ARGC<br />	je	curr_dir		# if == 1 jump to curr_dir<br />	movl	8(%ebp), %ebx		# use ARG[1] as directory name<br />	jmp	open_dir<br />	<br />curr_dir:	<br />	movl	$asciz_dot, %ebx	# pointer to asciz filename<br />	<br />open_dir:<br />	movl	$5, %eax		# EAX sys_open<br />	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  		# EBX was set above, as ARG[1] or &#039;.&#039;<br />	movl	$0, %ecx		# ECX file access bits: read only<br />	movl	$256, %edx		# EDX file permission flags: read by owner<br /><br />	int	$0x80<br /><br />	pushl	%eax			# store FD on stack: -4(%ebp)<br /><br />	movl	$141, %eax		# sys_getdents<br />	movl	-4(%ebp), %ebx		# File descriptor<br />	movl	$buffer, %ecx		# struct dirent* pointer<br />	movl	$2048, %edx		# count<br /><br />	int	$0x80<br /><br />	pushl	$buffer			# store base-address&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  -8(%ebp)<br />	pushl	%eax			# store number of bytes read: -12(%ebp)<br />	addl	$buffer, %eax		# calc end of buffer<br />	pushl	%eax			# store end-of-records:&nbsp; &nbsp; &nbsp;  -16(%ebp)<br /><br />write_header:<br />	pushl	$name_str		# write heading<br />	pushl	$len_str<br />	pushl	$offset_str<br />	pushl	$inode_str<br />	pushl	$header_str<br />	call	printf<br />	addl	$20, %esp		# clear parameters<br /><br />	movl	$buffer, %eax		# move buffer address -&gt; EAX<br />	pushl	%eax			# store base-address on stack<br />	xorl	%ebx, %ebx		# zero-out EBX<br /><br />write_line:<br />	#<br />	# in:&nbsp; EAX to contain start of record<br />	#<br />	# EBX contains byte-length of current record<br />	#<br /><br />	call	read_dirent<br />	<br />	pushl	%edx<br />	pushl	%ecx<br />	pushl	%ebx<br />	pushl	%eax<br />	pushl	$dirent_str		# push format string onto the stack<br />	call	printf<br /><br />	movl	12(%esp), %ecx		# restore ECX (length) from _stack_ (using ESP, not EBP)<br />	<br />	addl	$20, %esp		# clear parameters<br />	<br />	movl	-8(%ebp), %eax		# restore base-address from stack-variable<br /><br />	addl	%ecx, %eax		# add length+base to store address of next record in EAX<br />	cmpl	-16(%ebp), %eax		# compare with end-of-records pointer<br /><br />	je	close_fd		# if equal, jump to exit<br /><br />	movl	%eax, -8(%ebp)		# store new base-address in stack variable (and allow it to persist in EAX for next call to read_dirent)<br /><br />	jmp	write_line		# if not, repeat loop<br /><br />close_fd:<br /><br />	movl	$6, %eax		# system.close<br />	movl	-4(%ebp), %ebx		# FD from stack location<br />	int	$0x80<br /><br />exit:<br /><br />	movl	$1, %eax<br />	movl	$0, %ebx<br />	int	$0x80<br /><br />---------------------------------8&lt;----------------------------------</div>
    <div class="meta">Posted on 2011-04-09 03:04:23 by michaelg</div>
   </div>
   <div class="post" id="post-214257">
    <div class="subject"><a href="#post-214257">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Nice!!! It redirects as expected for me (old Slackware distro), so it appears to be something &quot;system related&quot;. I can&#039;t imagine what.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-04-09 04:48:24 by fbkotler</div>
   </div>
   <div class="post" id="post-214260">
    <div class="subject"><a href="#post-214260">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Hi Frank, <br /><br />Thanks for taking the time to have a look at it. I&#039;ve just tried it on an old Ubuntu laptop (Lemur;2.6.32-30-generic;Athlon64 CPU;32-bit distro (getconf LONG_BIT gives 32)) and have run into the exact same problem as on the 64-bit RHEL server I was using before (where I was having to create 32-bit binaries as it would otherwise complain about corrupted libraries). <br /><br />It&#039;s the same problem as before: if I run <pre><code>./dents &gt; tmp.out</code></pre><br />tmp.out is 0 bytes in length. Similarly, <pre><code>./dents | awk &#039;{print $0}&#039;</code></pre><br />results in a blank line. I really have no idea what might be happening. <br /><br />BTW, did you use the Makefile contents I posted? <br /><br />Cheers<br /><br />Michael</div>
    <div class="meta">Posted on 2011-04-09 15:30:31 by michaelg</div>
   </div>
   <div class="post" id="post-214275">
    <div class="subject"><a href="#post-214275">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">I did not initially use your makefile - the &quot;--32&quot; and &quot;-melf_i386&quot; aren&#039;t required on my system (but don&#039;t hurt). I just tried it with your makefile... same result - works fine!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-04-12 13:30:14 by fbkotler</div>
   </div>
   <div class="post" id="post-214279">
    <div class="subject"><a href="#post-214279">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Thanks for having a look, Frank, I&#039;m at a loss as to why that&#039;s behaving like it is!</div>
    <div class="meta">Posted on 2011-04-12 15:47:31 by michaelg</div>
   </div>
   <div class="post" id="post-214280">
    <div class="subject"><a href="#post-214280">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body"><div class="quote"><br />It&#039;s the same problem as before: if I run <pre><code>./dents &gt; tmp.out</code></pre><br />tmp.out is 0 bytes in length. Similarly, <pre><code>./dents | awk &#039;{print $0}&#039;</code></pre><br />results in a blank line. I really have no idea what might be happening. <br /></div><br /><br />You basically removed the part of those commands that were important. :P &#039;2&gt;&amp;1&#039; basically means that we are directing both /dev/stderr and /dev/stdout to the console output. so in the event something funny happened to those character devices, this would work to allow you to pipe your string. Also, if that works, I would suggest looking into a clean install or checking for updates cause that would mean a vital part of your system has been corrupted and could possibly have damaging affects later on. I was just trying to weed out if it was possible your system was messed up. :P</div>
    <div class="meta">Posted on 2011-04-12 15:58:07 by Synfire</div>
   </div>
   <div class="post" id="post-214283">
    <div class="subject"><a href="#post-214283">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Hi Bryant, <br /><br />I&#039;ve just added the redirection 2&gt;&amp;1 as you originally suggested but to no avail: the output is still going &quot;somewhere else&quot;. Incidentally, I checked FDs 2-6 with the same lack of results. <br /><br />Is there a tool available which can show the source of bytes being written to screen? After all, output is being produced, I just can&#039;t pipe or redirect it. <br /><br />Thanks for taking the time to think about this again. <br /><br />Regards<br /><br />Michael</div>
    <div class="meta">Posted on 2011-04-13 02:09:47 by michaelg</div>
   </div>
   <div class="post" id="post-214285">
    <div class="subject"><a href="#post-214285">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body"><div class="quote"><br />I&#039;ve just added the redirection 2&gt;&amp;1 as you originally suggested but to no avail: the output is still going &quot;somewhere else&quot;. Incidentally, I checked FDs 2-6 with the same lack of results.</div><br /><br />I&#039;ll download the code and give it a good test run on the slackware box, though I doubt it&#039;ll be too much different than on frank&#039;s slackware box. I&#039;ve also got a fedora live CD I can run it on (probably closer to RH than the slackware setup) so I&#039;ll let you know what I find.<br /><br /><div class="quote"><br />Is there a tool available which can show the source of bytes being written to screen? After all, output is being produced, I just can&#039;t pipe or redirect it.</div><br /><br />Actually, YES! It&#039;s called lsof (LiSt Open Files). Just check your man pages, you might need to login as root or at least set /usr/sbin in your path on RH. At least last time I used RH it came stock.. you might need to install it, they change things too often.</div>
    <div class="meta">Posted on 2011-04-13 21:53:18 by Synfire</div>
   </div>
   <div class="post" id="post-214286">
    <div class="subject"><a href="#post-214286">Re: Can't pipe or redirect stdout from gas program on RHEL5.5</a></div>
    <div class="body">Hi Bryant, <br /><br />I&#039;ve had a look using lsof, but to be honest, I&#039;m not sure I&#039;m seeing anything unusual. I&#039;ve run the dents application using gdb and installed a break-point just after the call to printf. I&#039;m not sure that it&#039;s important that it&#039;s before or after that call as it&#039;s not as if the FD is &quot;opened&quot;, merely that it doesn&#039;t close till I&#039;ve run lsof. I hope that analysis is right. <br /><br />With regards to what I&#039;m seeing from lsof, the following lines seem relevant but don&#039;t appear to show anything out of the ordinary:<br /><pre><code><br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 0u&nbsp; &nbsp; &nbsp; CHR&nbsp; 136,1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  3 /dev/pts/1<br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 1u&nbsp; &nbsp; &nbsp; CHR&nbsp; 136,1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  3 /dev/pts/1<br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 2u&nbsp; &nbsp; &nbsp; CHR&nbsp; 136,1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  3 /dev/pts/1<br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 3r&nbsp; &nbsp;  FIFO&nbsp; &nbsp; 0,6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 853400 pipe<br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 4w&nbsp; &nbsp;  FIFO&nbsp; &nbsp; 0,6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 853400 pipe<br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 5r&nbsp; &nbsp; &nbsp; REG&nbsp;  0,37&nbsp; &nbsp;  2990&nbsp;  18256457 /_elided_/getdents/dents (_symbolic_:/_mount_)<br />dents&nbsp;  23635 michaelg&nbsp; &nbsp; 6r&nbsp; &nbsp; &nbsp; DIR&nbsp;  0,37&nbsp; &nbsp;  4096&nbsp;  18256455 /_elided_/getdents (_symbolic_:/_mount_)<br /></code></pre><br /><br />Thanks for your continued interest/patience/perseverance!<br /><br />Best wishes,<br /><br />Michael<br /><br /></div>
    <div class="meta">Posted on 2011-04-14 03:15:57 by michaelg</div>
   </div>
  </div>
 </body>
</html>