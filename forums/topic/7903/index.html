<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Can I speed this up? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7903" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=7903">Can I speed this up?</a></p>
   <div class="post" id="post-57582">
    <div class="subject"><a href="#post-57582">Can I speed this up?</a></div>
    <div class="body">For a reason I need to allocate 757 120 Byte, and I've tried the following:<br /> Attempting (and failing) with using CreateHeap, HeapAlloc; I've given up on that now...<br /> Using the BSs (.data?) section, I'm using this and there is only one problem (one against 743 errror using the above way...) speed/time. I takes forever to compile, so I wonder if I (or you :) ) can speed up the process?<br /><br />When I first tried:<br /> _test_	db 520*1456 dup (?)<br />it took forever, so I thought may bee an larger data type is faster so I tried:<br /> _test_ dd (757120/4) dup (?)<br />it too is too slow, so I finally tried:<br /> _test_ qword (757120/8) dup (?)<br />it's also too damn slow.<br /><br />As I said I've tried the HeapAlloc thing, it doesn't work (data written and read is not matching, why :confused: ), the slow way is working perfectly though. Any suggestions? (I have a struct every 520 byte so it must work with that).<br /><br />It's is Friday the 13th... (may bee I'm too tired and simply have a bad luck with HeapAlloc...)</div>
    <div class="meta">Posted on 2002-09-13 14:00:08 by scientica</div>
   </div>
   <div class="post" id="post-57585">
    <div class="subject"><a href="#post-57585">Can I speed this up?</a></div>
    <div class="body">Put it in a separate object file and just LINK it in.  Use NMAKE to automate the rebuild when changes are made to second file. ;)</div>
    <div class="meta">Posted on 2002-09-13 14:14:19 by bitRAKE</div>
   </div>
   <div class="post" id="post-57616">
    <div class="subject"><a href="#post-57616">Can I speed this up?</a></div>
    <div class="body">Can't understand why HeapAlloc doesn't work, but<br />invoke GlobalAlloc,GPTR,757120 <br />certainly should.</div>
    <div class="meta">Posted on 2002-09-13 17:14:53 by EÃ³in</div>
   </div>
   <div class="post" id="post-57676">
    <div class="subject"><a href="#post-57676">Can I speed this up?</a></div>
    <div class="body">If you specified dwMaximumSize calling HeapCreate, have you read this?<br /><em>&quot;If the heap specified by the hHeap parameter is a &quot;non-growable&quot; heap, dwBytes must be less than <strong>0x7FFF8</strong>.&quot;</em><br /><br />You can speed up Heap manager spicifying HEAP_NO_SERIALIZE flag in flOptions parameter,<br />if you know for sure that only one thread have acess to the heap.<br />If HEAP_NO_SERIALIZE is not set heap manager will not create synchronisation object (mutex) to syncronize acess to the heap. It works faster. <br />Also don't add HEAP_ZERO_MEMORY flag if you really don't need it.<br />How do you create/alloc heap?<br /><br />AFAIK, the fastest way to allocate/manage memory is to create Memory Map File (CreateFileMapping).<br />Because all other methods (CreateHeap, VirtualAlloc etc.) are based on MMF.</div>
    <div class="meta">Posted on 2002-09-14 04:07:11 by Four-F</div>
   </div>
   <div class="post" id="post-57678">
    <div class="subject"><a href="#post-57678">Can I speed this up?</a></div>
    <div class="body">GetProcessHeap - to get the handle to the heap...<br />HeapAlloc<br />HeapFree</div>
    <div class="meta">Posted on 2002-09-14 04:10:20 by stryker</div>
   </div>
   <div class="post" id="post-57691">
    <div class="subject"><a href="#post-57691">Can I speed this up?</a></div>
    <div class="body">Four-F, I've read it, but I never thougt that might be the problem (the size I need is 0B 8D80h witch is greater than 7 FFF8h).<br /><br />I created the heap via &quot;invoke HeapCreate,HEAP_GENERATE_EXCEPTIONS,520,1456*520&quot;, but since the dwMaximumSize is larget then allowed this doesn't work, they direct me to VirtualAlloc. I'd rather not like to play with the HeapAlloc or other such function, I simply want an array of this 520 byte struct that is simple to access. The HEAP_NO_SERIALIZE, how dumb am I? (I read the description as this &quot;to allow multithreading&quot;, while it is &quot;only allows one process to access the heap at a time&quot;...)<br /><br />bitRAKE, said &quot;Put it in a separate object file and just LINK it in. Use NMAKE to automate the rebuild when changes are made to second file.&quot;<br />It sound like an good idea, since the slow way is working and I have to get over this problem soon; I must continue with the project I'm working on now, and this has stalled it some what, for now speed isn't the to priority (it will be a later project to optimize), there is one problem though, I know I have a copy of NMAKE somwhere but I don't have any clue what so ever how to use NMAKE, it there some manual I can read (or do one of you know the arguments I need to send)?</div>
    <div class="meta">Posted on 2002-09-14 04:55:33 by scientica</div>
   </div>
   <div class="post" id="post-57719">
    <div class="subject"><a href="#post-57719">Can I speed this up?</a></div>
    <div class="body"><div class="quote">but since the dwMaximumSize is larget then allowed this doesn't work</div>OK. You understand.<br /><br /><div class="quote">(I read the description as this &quot;to allow multithreading&quot;...</div>Because of my far from good knowledge of english, let me quote:<br /><br /><em>By default, a heap will serialize access to itself so that multiple threads can allocate and free blocks from the heap without the danger of corrupting the heap. When an attempt is made to allocate a block of memory from the heap, the HeapAlloc function (discussed later) must do the following:<br /><br />1.Traverse the linked list of allocated and freed memory blocks<br />2. Find the address of a free block<br />3. Allocate the new block by marking the free block as allocated<br />4. Add a new entry to the linked list of memory blocks<br /><br />Here's an example that illustrates why you should avoid using the HEAP_NO_SERIALIZE flag.<br />Let's say that two threads attempt to allocate blocks of memory from the same heap at the same time.<br />Thread 1 executes steps 1 and 2 above and gets the address of a free memory block.<br />However, before Thread 1 can execute step 3, it is preempted and Thread 2 gets a chance to execute steps 1 and 2.<br />Because Thread 1 has not yet executed step 3, Thread 2 finds the address to the same free memory block.<br /><br />With both threads having found what they believe to be a free memory block in the heap,<br />Thread 1 updates the linked list, marking the new block as allocated.<br />Thread 2 then also updates the linked list, marking the same block as allocated.<br />Neither thread has detected a problem so far, but both threads receive an address to the exact same block of memory.<br /><br />This type of bug can be very difficult to track down because it usually doesn't manifest itself immediately.</em><br />                                                                                                                                                  <strong>J. Richter</strong><br /><br />It was about avoiding HEAP_NO_SERIALIZE in multy-threaded processes. But...<br /><br />The system acomplishes serialization of heap (allows only one thread have access to the heap at the same time)<br />by creating internal mutex object. If thread try to have access (allocate/free) to the heap,<br />system sets mutex to non-signaled state (if mutex is not owned).<br />If another thread wants to access (allocate/free) heap, it should wait untill first thread will complete heap operation.<br />Then system releases ownership of the mutex, and second thread can have it.<br />All this takes extra time. And bassically, if you create heap in single-threaded process (i guess most asm-projects is single-threaded),<br />you should specify HEAP_NO_SERIALIZE. It speeds up the heap operations.<br />If you have only one thread, there is no reason to syncronyze it to whatever.<br /><br />Hope it's clear now.<br /><br />BTW, what reason for HEAP_GENERATE_EXCEPTIONS?<br />An exception is just another way for the system to notify your application about error (for example, out-of-memory).<br />If you have specifyed this flag you have to handle exceptions by yourself.<br />And i guess it's not what you want. In your case, IMHO, much simplier to allow the system do it for you.<br />This way you have only to check for returning NULL from HeapCreate/HeapAlloc.<br /><br /><div class="quote">...while it is &quot;only allows one process to access the heap at a time&quot;...)</div>Not process but thread. The process itself has no access to anything. It's only container for objects.</div>
    <div class="meta">Posted on 2002-09-14 06:49:28 by Four-F</div>
   </div>
   <div class="post" id="post-57734">
    <div class="subject"><a href="#post-57734">Can I speed this up?</a></div>
    <div class="body"><div class="quote">BTW, what reason for HEAP_GENERATE_EXCEPTIONS?</div><br />Well, it's <strong>pure laziness</strong>. At this stage in the project I just try to get the basic sceleton running, and I only use pre-decided conditions (thus user can't really do anything); so letting the SEH take care of some errors is a temporary solution, and it's far from perfect (or good)...<br /><br /><div class="quote">Not process but thread. The process itself has no access to anything. It's only container for objects.</div><br />I mean thread, wrote the wrong word.<br /><br />&quot;(I read the description as this 'to allow multithreading'&quot; means: I read the text wrong... :)</div>
    <div class="meta">Posted on 2002-09-14 08:19:31 by scientica</div>
   </div>
   <div class="post" id="post-57743">
    <div class="subject"><a href="#post-57743">Can I speed this up?</a></div>
    <div class="body">Here is a RadASM project using NMAKE:</div>
    <div class="meta">Posted on 2002-09-14 09:12:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-57761">
    <div class="subject"><a href="#post-57761">Can I speed this up?</a></div>
    <div class="body">:confused: :confused: :confused:  !<br /><br />How the HLL ( :rollwyes: ) is these .mak file structured? (no offense to the writer)<br />Ok, let me guess what happens (red text is my guess):<br /><div class="quote"><br /># objs needed to build the executable  A comment <br /><br /># This is the main project name: A comment <br />_MAIN_FILE_ = Rad-Modular some kind of definition<br /><br /># Set-up Environment # Could also assume it's already been set? A comment<br /><br />PATH = C:\Program Files\Microsoft Visual Studio.NET\Vc7\bin;$(PATH) adding more to the eviroment strings<br />LIB = C:\Program Files\Microsoft Visual Studio.NET\Vc7\lib;C:\RadASM\Lib;$(LIB) same as above<br />INCLUDE = C:\RadASM\Include\WinXP;C:\RadASM\Include;$(INCLUDE) same as above<br /><br />LINK = LINK /nologo /SUBSYSTEM:WINDOWS /ENTRY:start /OUT:$(_MAIN_FILE_).exe  setting up some sort of LINK textequ &lt;&quot;link /nologo ....&quot;&gt;<br />AFLAGS = /c /coff /nologo  same here<br /><br /><br /><br />OBJS = $(_MAIN_FILE_).obj $(_MAIN_FILE_).res Private-A.obj Private-B.obj  some strange definition<br /><br /># Dependancies # A comment<br /><br />$(_MAIN_FILE_).exe : $(OBJS) WTF happens here?<br />  $(LINK) $(OBJS) kernel32.lib user32.lib  what happens here<br /><br /><br />$(_MAIN_FILE_).obj : $(_MAIN_FILE_).asm $(_MAIN_FILE_).Inc Public.Inc  Some label thingy?<br /><br /># $(_MAIN_FILE_).res : ? # When should the resource file be rebuilt?  What?<br /><br />Private-A.obj : Private-A.Asm Public.Inc label thing?<br /><br />Private-B.obj : Private-B.Asm Public.Inc  same ??? as above<br /><br />clean :  some standard label?<br />    del $(OBJS) dos command?<br />    del $(_MAIN_FILE_).exe  -- | | --<br /></div></div>
    <div class="meta">Posted on 2002-09-14 10:55:35 by scientica</div>
   </div>
   <div class="post" id="post-57770">
    <div class="subject"><a href="#post-57770">Can I speed this up?</a></div>
    <div class="body"><strong>scientica</strong>, good to see you understand it. :)<br />Did you google for NMAKE? ...or read any docs?<br /><br />Private-A.obj : Private-A.Asm Public.Inc<br /><br />These lines define dependancies.  It says, &quot;If either two files change then rebuild the target.&quot;<br /><br />$(_MAIN_FILE_) is replaced by the equate name.<br /><br />Also, by default NMAKE creates the first dependancy it finds.<br />$(_MAIN_FILE_).exe in this file.<br /><br />Using this info you should be able to follow the dependancy chain:<br /><br />$(_MAIN_FILE_).exe --&gt;<br /><br />$(_MAIN_FILE_).obj $(_MAIN_FILE_).res Private-A.obj Private-B.obj<br /><br />--------- Private-A.obj --&gt; Private-A.Asm Public.Inc<br /><br />--------- Private-B.obj --&gt; Private-B.Asm Public.Inc<br /><br />Now NMAKE knows what is required to build each file.  Internally NMAKE has the rules to know what to do with a ASM or OBJ file - the defaults are used.  Here are default rules:<pre><code>Microsoft &#40;R&#41; Program Maintenance Utility Version 7.00.9254<br />Copyright &#40;C&#41; Microsoft Corporation.  All rights reserved.<br /><br />INCLUDE =<br />_NMAKE_VER = 7.00.9254<br />MAKE = nmake<br />COBOL = cobol<br />BC = bc<br />CC = cl<br />MAKEFLAGS = &#123;commandline&#125;<br />AS = ml<br />RC = rc<br />PASCAL = pl<br />LIB =<br />CPP = cl<br />FOR = fl32<br />CXX = cl<br />MAKEDIR =<br /><br /># INFERENCE RULES&#58;<br />#<br /># .asm.exe&#58;   commands&#58;       $&#40;AS&#41; $&#40;AFLAGS&#41; $*.asm<br /># .asm.obj&#58;   commands&#58;       $&#40;AS&#41; $&#40;AFLAGS&#41; /c $*.asm<br /># .c.exe&#58;     commands&#58;       $&#40;CC&#41; $&#40;CFLAGS&#41; $&lt;<br /># .c.obj&#58;     commands&#58;       $&#40;CC&#41; $&#40;CFLAGS&#41; /c $&lt;<br /># .cpp.exe&#58;   commands&#58;       $&#40;CPP&#41; $&#40;CPPFLAGS&#41; $&lt;<br /># .cpp.obj&#58;   commands&#58;       $&#40;CPP&#41; $&#40;CPPFLAGS&#41; /c $&lt;<br /># .cxx.exe&#58;   commands&#58;       $&#40;CXX&#41; $&#40;CXXFLAGS&#41; $&lt;<br /># .cxx.obj&#58;   commands&#58;       $&#40;CXX&#41; $&#40;CXXFLAGS&#41; /c $&lt;<br /># .bas.obj&#58;   commands&#58;       $&#40;BC&#41; $&#40;BFLAGS&#41; $*.bas;<br /># .cbl.exe&#58;   commands&#58;       $&#40;COBOL&#41; $&#40;COBFLAGS&#41; $*.cbl, $*.exe;<br /># .cbl.obj&#58;   commands&#58;       $&#40;COBOL&#41; $&#40;COBFLAGS&#41; $*.cbl;<br /># .f.exe&#58;     commands&#58;       $&#40;FOR&#41; $&#40;FFLAGS&#41; $*.f<br /># .f.obj&#58;     commands&#58;       $&#40;FOR&#41; /c $&#40;FFLAGS&#41; $*.f<br /># .f90.exe&#58;   commands&#58;       $&#40;FOR&#41; $&#40;FFLAGS&#41; $*.f90<br /># .f90.obj&#58;   commands&#58;       $&#40;FOR&#41; /c $&#40;FFLAGS&#41; $*.f90<br /># .for.exe&#58;   commands&#58;       $&#40;FOR&#41; $&#40;FFLAGS&#41; $*.for<br /># .for.obj&#58;   commands&#58;       $&#40;FOR&#41; /c $&#40;FFLAGS&#41; $*.for<br /># .pas.exe&#58;   commands&#58;       $&#40;PASCAL&#41; $&#40;PFLAGS&#41; $*.pas<br /># .pas.obj&#58;   commands&#58;       $&#40;PASCAL&#41; /c $&#40;PFLAGS&#41; $*.pas<br /># .rc.res&#58;    commands&#58;       $&#40;RC&#41; $&#40;RFLAGS&#41; /r $*<br />#<br /># .SUFFIXES&#58; .exe .obj .asm .c .cpp .cxx .bas .cbl .f .f90 .for .pas .res .rc</code></pre></div>
    <div class="meta">Posted on 2002-09-14 11:35:33 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>