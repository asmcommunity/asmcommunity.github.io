<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>[New release] Shredder v1.0 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24986" />
    <link rel="next" href="../?id=24986&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24986">[New release] Shredder v1.0</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=24986&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=24986&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="24986" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=24986&amp;page=2">&gt;</a><a href="../?id=24986&amp;page=2">&raquo;</a></form>   <div class="post" id="post-182912">
    <div class="subject"><a href="#post-182912">[New release] Shredder v1.0</a></div>
    <div class="body">Some of you might know my current project (see sig), well i needed a function to securely delete a file if users wants to.<br />I&#39;ve implemented the function in TableCrypt, but also decided to write another program around it.<br />This is the idea:<br />1. run installer<br />2. right-click file and select &quot;Shredder&quot;.<br />3. Confirm that you want to delete it.<br />4. file is deleted securely (total times overwritten = 10).<br /><br />finally you can run installer once more to uninstall the program.<br /><br />Source is included in the archive: <a target="_blank" href="http://www.white-scorpion.nl/programs/shredder.zip">Shredder</a>.<br /><br />PS. I&#39;m always happy to hear any comments on my programs ;)</div>
    <div class="meta">Posted on 2006-07-04 17:11:31 by white scorpion</div>
   </div>
   <div class="post" id="post-182913">
    <div class="subject"><a href="#post-182913">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Nice Work!<br />Although i have to confess the installer will be 10x more useful to me than the program! <br />Thanks for sharing. :)</div>
    <div class="meta">Posted on 2006-07-04 17:16:29 by asmrixstar</div>
   </div>
   <div class="post" id="post-182940">
    <div class="subject"><a href="#post-182940">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Have you tried to recover the trashed file, just to test how effective the shredder is? (just out of curiocity), and man, you pump out code like crazy, lol.<br /><br />I guess that&#39;s what I get for being a hobbyist coder who can&#39;t seem to get anything right.</div>
    <div class="meta">Posted on 2006-07-05 03:06:00 by Bobbias</div>
   </div>
   <div class="post" id="post-182945">
    <div class="subject"><a href="#post-182945">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Suggestions:<br /><br />Don&#39;t use filemapping, it&#39;s a bit slower than &quot;raw&quot; I/O with WriteFile. Actually in your case, it might be plenty slower, since you get a read-modify-writeback cycle when using MMF.<br /><br />Instead I&#39;d advice you to open the file in FILE_FLAG_NO_BUFFERING mode - this ensures that writes don&#39;t go through the disk cache system. If you don&#39;t do this, wiping a small file could theoretically end with only a single wipe, if windows for some reason decides that FlushFileBuffers doesn&#39;t have to flush the FS cache.<br /><br />As for the security aspects of the patterns to use (a new random byte for each byte in the file, alternating patterns of some form, bla bla) I&#39;m not really sure what&#39;s most effective - reading off magnetic residual data is not something I&#39;ve dealt with :)</div>
    <div class="meta">Posted on 2006-07-05 03:17:23 by f0dder</div>
   </div>
   <div class="post" id="post-182948">
    <div class="subject"><a href="#post-182948">Re: [New release] Shredder v1.0</a></div>
    <div class="body">If you REALLY wanted to be safe, you could write the section over with random data (coming from whatever) untill you basically break that section of disk :P but that&#39;s pretty abusive, and would probably take quite some time...</div>
    <div class="meta">Posted on 2006-07-05 03:22:31 by Bobbias</div>
   </div>
   <div class="post" id="post-182959">
    <div class="subject"><a href="#post-182959">Re: [New release] Shredder v1.0</a></div>
    <div class="body"><div class="quote">Have you tried to recover the trashed file, just to test how effective the shredder is? (just out of curiocity), and man, you pump out code like crazy, lol.</div><br />Not with this release, but i&#39;ve already written this program in 2005, but never released it.<br />In that program i&#39;ve tested it. <br />And although you can retrieve the file without any problems, it only has random content and so rendering the file useless.<br />The only better way will probably be to rename the file first to a random name.<br /><br /><div class="quote"><br />Don&#39;t use filemapping, it&#39;s a bit slower than &quot;raw&quot; I/O with WriteFile. Actually in your case, it might be plenty slower, since you get a read-modify-writeback cycle when using MMF.<br /><br />Instead I&#39;d advice you to open the file in FILE_FLAG_NO_BUFFERING mode - this ensures that writes don&#39;t go through the disk cache system. If you don&#39;t do this, wiping a small file could theoretically end with only a single wipe, if windows for some reason decides that FlushFileBuffers doesn&#39;t have to flush the FS cache.<br /></div><br />I will look into this this evening. You&#39;re probably right. I&#39;ve used this approach since the original program where this program is based on, encrypted the file with a singlekey XOR encryption. There it was a lot faster to memorymap. But since i do not have to read here, WriteFile will probably be a lot faster.<br /><br />Thanks for the feedback! I really appreciate it!<br /></div>
    <div class="meta">Posted on 2006-07-05 05:32:46 by white scorpion</div>
   </div>
   <div class="post" id="post-182960">
    <div class="subject"><a href="#post-182960">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Hm, sounds weird that filemapping was faster - if you&#39;re doing &quot;linear&quot; processing of a file, filemapping tends to be one of the slower alternatives, because it incurs a pagefault for each 4kb you process. With almost all I/O the (clock) time to process a file will be the same, but the CPU load while processing will be higher for mmapped files.</div>
    <div class="meta">Posted on 2006-07-05 05:38:38 by f0dder</div>
   </div>
   <div class="post" id="post-182963">
    <div class="subject"><a href="#post-182963">Re: [New release] Shredder v1.0</a></div>
    <div class="body">well theres that, and the possibility that mapped view of a file might not flush the buffers to the file, it might be kept in the cache... realistically for security the readfile/writefile method should be done, with a flushfilebuffers on each write, to ensure the data is purged to the disk, otherwise if a cache hit occours then the flush is not done, and the security goes out the window, as the data wont be written to the disk, thus the security is weakened... the multiple writes are &#39;standard&#39; security (dod etc) for overwriting data, done usually in 7 stages, 0, 1, checkerboard, inverse checkerboard, random byte, xor&#39;d random byte and so on... each stage attempting to permanently destroy any residual magnetic / binary pattern remaining on the disk sector......</div>
    <div class="meta">Posted on 2006-07-05 06:47:53 by evlncrn8</div>
   </div>
   <div class="post" id="post-182966">
    <div class="subject"><a href="#post-182966">Re: [New release] Shredder v1.0</a></div>
    <div class="body">I&#39;ve updated the program using the writefile method. Although its much slower now, i feel it&#39;s more secure.<br />I&#39;ve held open taskmgr during shredding a 66mb file.<br />It took 11 minutes, but you could see that 660MB&#39;s were written to disk.<br />With the FlushFile method not even 1 byte is visibly written to disk (although the data has changed.....).<br /></div>
    <div class="meta">Posted on 2006-07-05 07:24:42 by white scorpion</div>
   </div>
   <div class="post" id="post-182968">
    <div class="subject"><a href="#post-182968">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Scorpion, what buffer size do you use, and are you doing FILE_FLAG_NO_BUFFERING? It really should NOT be slower!</div>
    <div class="meta">Posted on 2006-07-05 08:49:02 by f0dder</div>
   </div>
   <div class="post" id="post-182969">
    <div class="subject"><a href="#post-182969">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Unless the other technique does not actually write that many bytes to disk.<br />here&#39;s the code for the function:<br /><pre><code><br />;##################################################<br />;procedure which removes the file. returns -1 on error<br />;##################################################<br />RemoveFile proc file_to_delete:DWORD,number_of_times:DWORD<br />&nbsp; &nbsp; LOCAL hFile:DWORD<br />&nbsp; &nbsp; LOCAL inputfilesize:DWORD<br />&nbsp; &nbsp; LOCAL backup:DWORD<br />&nbsp; &nbsp; LOCAL BytesWr:DWORD<br />&nbsp; &nbsp; LOCAL mybyte:BYTE<br /><br />&nbsp; &nbsp; cmp number_of_times,0<br />&nbsp; &nbsp; jnz @F&nbsp; <br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; ret<br />@@:<br />&nbsp; &nbsp; invoke CreateFile,file_to_delete,GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\<br />	&nbsp; &nbsp; FILE_ATTRIBUTE_NORMAL, NULL<br />&nbsp; &nbsp; .if eax==NULL<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle,hFile<br />&nbsp; &nbsp; &nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; ret<br />&nbsp; &nbsp; .endif&nbsp;  <br />&nbsp; &nbsp; mov hFile,eax<br />&nbsp; &nbsp; invoke GetFileSize,eax,NULL<br />&nbsp; &nbsp; mov inputfilesize,eax<br />&nbsp; &nbsp; <br />;----Rounds Start -----<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; &nbsp; &nbsp; mov backup,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,number_of_times<br />times_loop:<br />&nbsp; &nbsp; &nbsp; &nbsp; push edx<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,inputfilesize<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov mybyte,al<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr mybyte,1,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,backup<br />&nbsp; &nbsp; &nbsp; &nbsp; mov myseed,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,inputfilesize<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov mybyte,al<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr mybyte,1,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec edx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz times_loop&nbsp; &nbsp;  <br />;----Rounds End -------&nbsp; <br />&nbsp; &nbsp; invoke CloseHandle,hFile<br />&nbsp; &nbsp; invoke DeleteFile,file_to_delete<br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />RemoveFile endp<br /></code></pre><br />Since it takes 11 minutes to write 660mb&#39;s to disk it isn&#39;t that slow. It&#39;s just a lot slower then the previous function.<br />it writes about 1mb/s so perhaps i could improve speed, but i&#39;m not quite sure how.<br /></div>
    <div class="meta">Posted on 2006-07-05 09:38:07 by white scorpion</div>
   </div>
   <div class="post" id="post-182970">
    <div class="subject"><a href="#post-182970">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Omg, you&#39;re writing one byte at a time - eek! I said you should do a decent buffersize :)<br /><br />(and yes, there actually is a chance that the old routine didn&#39;t write just as much to disk, because of the &quot;lazy writeback&quot; nature of MMF).</div>
    <div class="meta">Posted on 2006-07-05 09:42:23 by f0dder</div>
   </div>
   <div class="post" id="post-182971">
    <div class="subject"><a href="#post-182971">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Scorp, <br />It&#39;s normal that it&#39;s slower as your calling Writefile for each byte your writing. <br />Try writing 4kb chuncks instead of just 1 byte, it should alot be faster.<br /></div>
    <div class="meta">Posted on 2006-07-05 09:51:20 by Axial</div>
   </div>
   <div class="post" id="post-182972">
    <div class="subject"><a href="#post-182972">Re: [New release] Shredder v1.0</a></div>
    <div class="body"><div class="quote"><br />Scorp, <br />It&#39;s normal that it&#39;s slower as your calling Writefile for each byte your writing. <br />Try writing 4kb chuncks instead of just 1 byte, it should alot be faster.<br /></div><br /><br />I would even suggest 64kb or larger buffers... with 4kb buffers you&#39;re getting around the same amount of the expensive user-&gt;kernel-&gt;usermode transitions as the MMF approach, even though you don&#39;t get the expensive #PF.</div>
    <div class="meta">Posted on 2006-07-05 10:03:47 by f0dder</div>
   </div>
   <div class="post" id="post-182978">
    <div class="subject"><a href="#post-182978">Re: [New release] Shredder v1.0</a></div>
    <div class="body">I know, i know... I was at work and a bit busy... :lol:<br />here&#39;s the updated code.<br />However, i am not able to use the no buffer flag since it requires writes which might overwrite other files or not the complete file.<br /><pre><code><br />RemoveFile proc file_to_delete:DWORD,number_of_times:DWORD<br />&nbsp; &nbsp; LOCAL hFile:DWORD<br />&nbsp; &nbsp; LOCAL inputfilesize:DWORD<br />&nbsp; &nbsp; LOCAL backup:DWORD<br />&nbsp; &nbsp; LOCAL BytesWr:DWORD<br />&nbsp; &nbsp; LOCAL shredbuf[1024*64]:BYTE<br />&nbsp; &nbsp; LOCAL buffer_times:DWORD<br />&nbsp; &nbsp; LOCAL my_remainder:DWORD<br /><br />&nbsp; &nbsp; cmp number_of_times,0<br />&nbsp; &nbsp; jnz @F&nbsp; <br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; ret<br />@@:<br />&nbsp; &nbsp; invoke CreateFile,file_to_delete,GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\<br />	&nbsp; &nbsp; FILE_ATTRIBUTE_NORMAL, NULL<br />&nbsp; &nbsp; .if eax==NULL<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle,hFile<br />&nbsp; &nbsp; &nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; ret<br />&nbsp; &nbsp; .endif&nbsp;  <br />&nbsp; &nbsp; mov hFile,eax<br />&nbsp; &nbsp; invoke GetFileSize,eax,NULL<br />&nbsp; &nbsp; mov inputfilesize,eax<br />&nbsp; &nbsp; <br />;----Rounds Start -----<br />&nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; mov backup,eax<br />&nbsp; &nbsp; mov myseed,eax<br />&nbsp;  .if inputfilesize&lt;=sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,number_of_times<br />times_loop_small: <br />&nbsp; &nbsp; &nbsp; &nbsp; push edx&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,inputfilesize&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf&nbsp; &nbsp; &nbsp;  <br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,backup<br />&nbsp; &nbsp; &nbsp; &nbsp; mov myseed,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,inputfilesize,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,inputfilesize<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,inputfilesize,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec edx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz times_loop_small&nbsp; &nbsp; <br />;----Rounds End -------&nbsp; <br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,inputfilesize<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ebx,sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edx,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; div ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov buffer_times,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov my_remainder,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,number_of_times<br />times_loop_big:<br />&nbsp; &nbsp; &nbsp; &nbsp; push edx<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,buffer_times<br />bufloop1:&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; push eax&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf&nbsp; &nbsp; &nbsp; &nbsp; <br />@@:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,sizeof shredbuf,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz bufloop1<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,my_remainder<br />&nbsp; &nbsp; &nbsp; &nbsp; .if ecx==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp second_round<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,my_remainder,addr BytesWr,NULL&nbsp;  <br />second_round:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,buffer_times<br />bufloop2:&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; push eax&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,sizeof shredbuf,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz bufloop2<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,my_remainder<br />&nbsp; &nbsp; &nbsp; &nbsp; .if ecx==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp finish_round<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,my_remainder,addr BytesWr,NULL&nbsp; &nbsp; &nbsp; &nbsp; <br />finish_round:<br />&nbsp; &nbsp; &nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec edx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz times_loop_big<br />&nbsp; &nbsp; .endif&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; invoke CloseHandle,hFile<br />&nbsp; &nbsp; invoke DeleteFile,file_to_delete<br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />RemoveFile endp<br /></code></pre><br />I had 10kb buffer, but changed to 64.<br /><br />Any ideas on the flag though?</div>
    <div class="meta">Posted on 2006-07-05 12:36:27 by white scorpion</div>
   </div>
   <div class="post" id="post-182980">
    <div class="subject"><a href="#post-182980">Re: [New release] Shredder v1.0</a></div>
    <div class="body"><div class="quote"><br />However, i am not able to use the no buffer flag since it requires writes which might overwrite other files or not the complete file.<br /></div><br />Huh?<br /><br />All the nobuffer flag requires is that your reads/writes are sector aligned. What this means is that you should write a bit more than the real length of the file, but that&#39;s not a problem.<br /><br />Your new code looks weird.<br /></div>
    <div class="meta">Posted on 2006-07-05 12:45:40 by f0dder</div>
   </div>
   <div class="post" id="post-182981">
    <div class="subject"><a href="#post-182981">Re: [New release] Shredder v1.0</a></div>
    <div class="body"><div class="quote">Your new code looks weird.</div><br />thanks ;)<br />It doesn&#39;t really matter that it looks weird, but it works a lot faster (10kb buffer btw, 64kb makes the program crash... it&#39;s probably too much to push on stack ;) ).<br />total time for 40mb file was around 10 seconds with over 400mb&#39;s written.<br /><br />Will take a look at the no buffer story once more.<br /><br /><strong></strong><br />this should be it.<br />44MB file takes around 18 seconds to overwrite 10 times with flag no buffer.<br /><br /><pre><code><br />RemoveFile proc file_to_delete:DWORD,number_of_times:DWORD<br />&nbsp; &nbsp; LOCAL hFile:DWORD<br />&nbsp; &nbsp; LOCAL inputfilesize:DWORD<br />&nbsp; &nbsp; LOCAL backup:DWORD<br />&nbsp; &nbsp; LOCAL BytesWr:DWORD<br />&nbsp; &nbsp; LOCAL shredbuf[1024*10]:BYTE<br />&nbsp; &nbsp; LOCAL buffer_times:DWORD<br />&nbsp; &nbsp; LOCAL my_remainder:DWORD<br /><br />&nbsp; &nbsp; cmp number_of_times,0<br />&nbsp; &nbsp; jnz @F&nbsp; <br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; ret<br />@@:<br />&nbsp; &nbsp; invoke CreateFile,file_to_delete,GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\<br />	&nbsp; &nbsp; FILE_ATTRIBUTE_NORMAL or FILE_FLAG_NO_BUFFERING, NULL<br />&nbsp; &nbsp; .if eax==NULL<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle,hFile<br />&nbsp; &nbsp; &nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; ret<br />&nbsp; &nbsp; .endif&nbsp;  <br />&nbsp; &nbsp; mov hFile,eax<br />&nbsp; &nbsp; invoke GetFileSize,eax,NULL<br />&nbsp; &nbsp; mov ebx,512<br />&nbsp; &nbsp; xor edx,edx<br />&nbsp; &nbsp; div ebx<br />&nbsp; &nbsp; .if edx==0<br />&nbsp; &nbsp; &nbsp; &nbsp; mul ebx<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; mul ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax,512<br />&nbsp; &nbsp; .endif&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; mov inputfilesize,eax<br />&nbsp; &nbsp; <br />;----Rounds Start -----<br />&nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; mov backup,eax<br />&nbsp; &nbsp; mov myseed,eax<br />&nbsp;  .if inputfilesize&lt;=sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,number_of_times<br />times_loop_small: <br />&nbsp; &nbsp; &nbsp; &nbsp; push edx&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,inputfilesize&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf&nbsp; &nbsp; &nbsp;  <br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,backup<br />&nbsp; &nbsp; &nbsp; &nbsp; mov myseed,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,inputfilesize,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,inputfilesize<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,inputfilesize,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec edx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz times_loop_small&nbsp; &nbsp; <br />;----Rounds End -------&nbsp; <br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,inputfilesize<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ebx,sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edx,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; div ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov buffer_times,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov my_remainder,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,number_of_times<br />times_loop_big:<br />&nbsp; &nbsp; &nbsp; &nbsp; push edx<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,buffer_times<br />bufloop1:&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; push eax&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf&nbsp; &nbsp; &nbsp; &nbsp; <br />@@:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,sizeof shredbuf,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz bufloop1<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,my_remainder<br />&nbsp; &nbsp; &nbsp; &nbsp; .if ecx==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp second_round<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,my_remainder,addr BytesWr,NULL&nbsp;  <br />second_round:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SetFilePointer,hFile,0,0,FILE_BEGIN<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,buffer_times<br />bufloop2:&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; push eax&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,sizeof shredbuf<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,sizeof shredbuf,addr BytesWr,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec eax<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz bufloop2<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,my_remainder<br />&nbsp; &nbsp; &nbsp; &nbsp; .if ecx==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp finish_round<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; lea esi,shredbuf<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GenerateRandomByte<br />&nbsp; &nbsp; &nbsp; &nbsp; not eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov byte ptr ,al<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; &nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz @B<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile,hFile,addr shredbuf,my_remainder,addr BytesWr,NULL&nbsp; &nbsp; &nbsp; &nbsp; <br />finish_round:<br />&nbsp; &nbsp; &nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; &nbsp; &nbsp; dec edx<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz times_loop_big<br />&nbsp; &nbsp; .endif&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; invoke CloseHandle,hFile<br />&nbsp; &nbsp; invoke DeleteFile,file_to_delete<br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />RemoveFile endp<br /></code></pre><br /><br />Any other suggestions?<br /></div>
    <div class="meta">Posted on 2006-07-05 12:52:28 by white scorpion</div>
   </div>
   <div class="post" id="post-182984">
    <div class="subject"><a href="#post-182984">Re: [New release] Shredder v1.0</a></div>
    <div class="body">using above code the average deletion speed will be around 2,4MB&#39;s per second.<br />This is on my 1600mhz system (running at 50% cpu) with my 4200rpm harddisk.<br />so if i had a faster harddisk it might come up to 5mb&#39;s per second.<br /><br />One final question though: how can i retrieve the sector size on a harddisk?<br />i now used 512bytes, but i&#39;m not sure if this will be effective on all harddisks....<br /><br /></div>
    <div class="meta">Posted on 2006-07-05 14:21:03 by white scorpion</div>
   </div>
   <div class="post" id="post-182992">
    <div class="subject"><a href="#post-182992">Re: [New release] Shredder v1.0</a></div>
    <div class="body">White Scorpion,<br /><br />The DISK_GEOMETRY structure describes the geometry of disk devices and media. <br /><br />typedef struct _DISK_GEOMETRY {&nbsp; <br />&nbsp;  LARGE_INTEGER&nbsp; Cylinders; <br />&nbsp;  MEDIA_TYPE&nbsp; MediaType; <br />&nbsp;  DWORD&nbsp; TracksPerCylinder; <br />&nbsp;  DWORD&nbsp; SectorsPerTrack; <br />&nbsp;  DWORD&nbsp; BytesPerSector; <br />} DISK_GEOMETRY ; <br /><br />That is the structure.&nbsp; Look at DeviceIOControl function to see how to get it.<br /><br />Paul<br /></div>
    <div class="meta">Posted on 2006-07-05 18:11:38 by PBrennick</div>
   </div>
   <div class="post" id="post-183006">
    <div class="subject"><a href="#post-183006">Re: [New release] Shredder v1.0</a></div>
    <div class="body">Thanks a lot.<br />That is exactly what i&#39;m looking for!<br /><br /></div>
    <div class="meta">Posted on 2006-07-06 01:16:42 by white scorpion</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=24986&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=24986&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="24986" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=24986&amp;page=2">&gt;</a><a href="../?id=24986&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>