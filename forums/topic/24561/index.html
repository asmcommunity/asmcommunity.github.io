<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>The perils of high level constructs - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24561" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24561">The perils of high level constructs</a></p>
   <div class="post" id="post-179349">
    <div class="subject"><a href="#post-179349">The perils of high level constructs</a></div>
    <div class="body">I was recently translating a peice of MASM code and ran across this<br /><br /><pre><code>.while byte ptr <br />	lodsb<br />	.if al==&#39;\&#39;<br />		mov al,&#39;/&#39;<br />	.endif<br />	stosb<br />.endw</code></pre><br /><br />While it might look benign at first glance, being obfuscated by high level constructs, it assembles as follows...<br /><br /><pre><code>0x10001310: 8B7508&nbsp; &nbsp; &nbsp; &nbsp;  mov&nbsp; &nbsp; &nbsp; esi,&nbsp; &nbsp;  ; ARG:0x8<br />0x10001313: 8DBDFCFEFFFF&nbsp;  lea&nbsp; &nbsp; &nbsp; edi,buffer&nbsp;  ; VAR:0x104<br />0x10001319: EB08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  jmp&nbsp; &nbsp; &nbsp; 0x10001323&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (*+0xA) <br />0x1000131B: AC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &lt;==0x10001326(*+0xB)<br />0x1000131C: 3C5C&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cmp&nbsp; &nbsp; &nbsp; al,0x5c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />0x1000131E: 7502&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  jnz&nbsp; &nbsp; &nbsp; 0x10001322&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (*+0x4) <br />0x10001320: B02F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  mov&nbsp; &nbsp; &nbsp; al,0x2f&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />0x10001322: AA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  stosb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &lt;==0x1000131E(*-0x4)<br />0x10001323: 803E00&nbsp; &nbsp; &nbsp; &nbsp;  cmp&nbsp; &nbsp; &nbsp; byte ptr ,0x0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &lt;==0x10001319(*-0xA)<br />0x10001326: 75F3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  jnz&nbsp; &nbsp; &nbsp; 0x1000131b&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; (*-0xB) </code></pre><br /><br />Now all it really does is replace occurences of &quot;\&quot; in a string with &quot;/&quot; so it doesn&#39;t have to be fast but it demonstrates how using high level constructs can lead you to bad code. 3 jumps for a very simple loop, and as MASM has no built in use of the CMOV series of instructions, the obvious replacement of 1 jump is not made.<br /><br /><pre><code>mov ecx,&quot;/&quot;<br />L2:<br />	mov al,<br />	cmp al,&quot;\&quot;<br />	cmove eax,ecx<br />	mov ,al<br />	inc edi,esi<br />	test al,al<br />jnz &lt;L2</code></pre><br /><br />Since the default branch prediction circuitry assumes that backwards jumps are always taken there is little trashing of the cache and using CMOVE eliminates a jump completely. Using GoAsm you are forced to think about your loops and will generally take the more logical path while other assemblers allow you the easy way out by hiding sloppy code behind high level constructs.<br /><br />Donkey</div>
    <div class="meta">Posted on 2006-04-09 16:35:03 by donkey</div>
   </div>
   <div class="post" id="post-179374">
    <div class="subject"><a href="#post-179374">Re: The perils of high level constructs</a></div>
    <div class="body">While it&#39;s true that code doesn&#39;t have to be very fast and that I&#39;m personally against micro-optimizations that don&#39;t matter, I still feel that&#39;s there no reason to do &quot;code pessimization&quot; either. The use of HLL constructs in that piece of code buys very little (if any at all), and certainly doesn&#39;t produce nice code (and checking a memory operand when we already have the value in a register? Eek!)<br /></div>
    <div class="meta">Posted on 2006-04-10 04:58:48 by f0dder</div>
   </div>
   <div class="post" id="post-179404">
    <div class="subject"><a href="#post-179404">Re: The perils of high level constructs</a></div>
    <div class="body">donkey, i think it is always a question of readability vs. optimization:<br /><br /><pre><code>.while byte ptr <br />	lodsb<br />	.if al==&#39;\&#39;<br />		mov al,&#39;/&#39;<br />	.endif<br />	stosb<br />.endw</code></pre><br /><br /><pre><code>mov ecx,&quot;/&quot;<br />L2:<br />	mov al,<br />	cmp al,&quot;\&quot;<br />	cmove eax,ecx<br />	mov ,al<br />	inc edi,esi<br />	test al,al<br />jnz &lt;L2</code></pre><br /><br />In most cases, we need readable code. Why I like MASM is I can always choose between HLL constructs and pure, hand-optimized assembly code.</div>
    <div class="meta">Posted on 2006-04-11 03:09:34 by MazeGen</div>
   </div>
   <div class="post" id="post-179405">
    <div class="subject"><a href="#post-179405">Re: The perils of high level constructs</a></div>
    <div class="body">I guess readability is in the eye of the beholder - for this particular snippet, I actually find the &quot;raw&quot; approach more readable... and that&#39;s even though my main area of work is HLL these days.</div>
    <div class="meta">Posted on 2006-04-11 03:14:43 by f0dder</div>
   </div>
   <div class="post" id="post-179407">
    <div class="subject"><a href="#post-179407">Re: The perils of high level constructs</a></div>
    <div class="body">Interesting :), I find more readable and intuitive the HLL construct.</div>
    <div class="meta">Posted on 2006-04-11 03:19:43 by MazeGen</div>
   </div>
   <div class="post" id="post-179408">
    <div class="subject"><a href="#post-179408">Re: The perils of high level constructs</a></div>
    <div class="body">I guess it&#39;s because I think differently depending on the language I code in :)</div>
    <div class="meta">Posted on 2006-04-11 03:31:50 by f0dder</div>
   </div>
   <div class="post" id="post-179412">
    <div class="subject"><a href="#post-179412">Re: The perils of high level constructs</a></div>
    <div class="body">the most usable thing in about HLL constructs is that i don&#39;t have to make up label names<br />for every meaningless loop<br /><pre><code><br />.repeat<br />	mov al,<br />	cmp al,&quot;\&quot;<br />	cmove eax,ecx<br />	mov ,al<br />	inc edi,esi<br />	test al,al<br />.until zero?<br /></code></pre><br />of course there are situations where label raw approach is better (like: a bunch of &quot;call api,<br /> if error go to xxxx&quot; ) , but generally its the HLL constructs that are more readable</div>
    <div class="meta">Posted on 2006-04-11 06:22:21 by drizz</div>
   </div>
   <div class="post" id="post-179889">
    <div class="subject"><a href="#post-179889">Re: The perils of high level constructs</a></div>
    <div class="body">Donkey,<br />&nbsp; &nbsp; Sorry I did not get to this sooner.&nbsp; Yes, one can usually outsmart the algo MASM uses to generate the HLL code.&nbsp; MASM does not have all the possible HLL constructs, and does not know anything about CMOV as it pertains to HLL.&nbsp; However, your comparision is not quite fair because you included the instructions for loading ESI and EDI in the assembly listing, which were not in the source.&nbsp; So without further ado, let me present my version of the snippet.&nbsp; First the source.<br /><br /><div class="quote"><br />;--------------------------------<br /> MOV CL,&#39;/&#39;<br /> mov ecx,&#39;/&#39;<br /> .while byte ptr <br />	lodsb<br />	.if al==&#39;\&#39;<br />		mov al,&#39;/&#39;<br />	.endif<br />	stosb<br /> .endw<br />;-------------------------------<br /> mov ecx,&#39;/&#39;<br /> .repeat<br />	mov al,<br />	cmp al,&quot;\&quot;<br />	cmove eax,ecx<br />	mov ,al<br />	inc edi<br />&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br />	test al,al<br /> .until zero?<br />;-------------------------------<br />B EQU BYTE PTR<br /> .WHILE TRUE<br />&nbsp;  MOVSB<br /> .BREAK .IF !AL<br /> .CONTINUE .IF B != &#39;\&#39;<br />&nbsp;  MOV B,&#39;/&#39;<br /> .ENDW<br />;--------------------------------<br /><br /></div><br />Now the assembly<br /><pre><code><br />				;--------------------------------<br /> 00000000&nbsp; B1 2F		 MOV CL,&#39;/&#39;<br /> 00000002&nbsp; B9 0000002F		 mov ecx,&#39;/&#39;<br />				 .while byte ptr <br /> 00000007&nbsp; EB 08	&nbsp;  *	&nbsp; &nbsp; jmp&nbsp; &nbsp; @C0001<br /> 00000009		&nbsp;  *@C0002:<br /> 00000009&nbsp; AC				lodsb<br />					.if al==&#39;\&#39;<br /> 0000000A&nbsp; 3C 5C	&nbsp;  *	&nbsp; &nbsp; cmp&nbsp; &nbsp; al, &#39;\&#39;<br /> 0000000C&nbsp; 75 02	&nbsp;  *	&nbsp; &nbsp; jne&nbsp; &nbsp; @C0003<br /> 0000000E&nbsp; B0 2F				mov al,&#39;/&#39;<br />					.endif<br /> 00000010		&nbsp;  *@C0003:<br /> 00000010&nbsp; AA				stosb<br />				 .endw<br /> 00000011		&nbsp;  *@C0001:<br /> 00000011&nbsp; 80 3E 00	&nbsp;  *	&nbsp; &nbsp; cmp&nbsp; &nbsp; byte ptr , 000h<br /> 00000014&nbsp; 75 F3	&nbsp;  *	&nbsp; &nbsp; jne&nbsp; &nbsp; @C0002<br />				;-------------------------------<br /> 00000016&nbsp; B9 0000002F		 mov ecx,&#39;/&#39;<br />				 .repeat<br /> 0000001B		&nbsp;  *@C0006:<br /> 0000001B&nbsp; 8A 06			mov al,<br /> 0000001D&nbsp; 3C 5C			cmp al,&quot;\&quot;<br /> 0000001F&nbsp; 0F 44 C1			cmove eax,ecx<br /> 00000022&nbsp; 88 07			mov ,al<br /> 00000024&nbsp; 47				inc edi<br /> 00000025&nbsp; 46			&nbsp; &nbsp; &nbsp; &nbsp; inc esi<br /> 00000026&nbsp; 84 C0			test al,al<br />				 .until zero?<br /> 00000028&nbsp; 75 F1	&nbsp;  *	&nbsp; &nbsp; jne&nbsp; &nbsp; @C0006<br />				;-------------------------------<br /> = BYTE PTR			B EQU BYTE PTR<br />				 .WHILE TRUE<br /> 0000002A		&nbsp;  *@C0008:<br /> 0000002A&nbsp; A4			&nbsp;  MOVSB<br />				 .BREAK .IF !AL<br /> 0000002B&nbsp; 0A C0	&nbsp;  *	&nbsp; &nbsp; or	al, al<br /> 0000002D&nbsp; 74 0B	&nbsp;  *	&nbsp; &nbsp; je&nbsp; &nbsp;  @C0009<br />				 .CONTINUE .IF B != &#39;\&#39;<br /> 0000002F&nbsp; 80 3E 5C	&nbsp;  *	&nbsp; &nbsp; cmp&nbsp; &nbsp; byte ptr , &#39;\&#39;<br /> 00000032&nbsp; 75 F6	&nbsp;  *	&nbsp; &nbsp; jne&nbsp; &nbsp; @C0008<br /> 00000034&nbsp; C6 47 FF 2F		&nbsp;  MOV B,&#39;/&#39;<br />				 .ENDW<br /> 00000038&nbsp; EB F0	&nbsp;  *	&nbsp; &nbsp; jmp&nbsp; &nbsp; @C0008<br /> 0000003A		&nbsp;  *@C0009:<br />				;--------------------------------<br /></code></pre><br /><br />&nbsp; &nbsp;  Notice that my code does not complete the loop unless it finds the backslash.&nbsp; Also it does not use the ECX register.&nbsp; And only one byte for the MOVSB instruction.&nbsp; By the way, notice how much shorter MOV CL,&#39;/&#39; is compared to MOV ECX,&#39;/&#39;&nbsp; .&nbsp; Ratch<br /></div>
    <div class="meta">Posted on 2006-04-20 01:00:46 by Ratch</div>
   </div>
   <div class="post" id="post-179892">
    <div class="subject"><a href="#post-179892">Re: The perils of high level constructs</a></div>
    <div class="body"><div class="quote"><br />Donkey,<br />&nbsp; &nbsp; Sorry I did not get to this sooner.&nbsp; Yes, one can usually outsmart the algo MASM uses to generate the HLL code.&nbsp; MASM does not have all the possible HLL constructs, and does not know anything about CMOV as it pertains to HLL.&nbsp; However, your comparision is not quite fair because you included the instructions for loading ESI and EDI in the assembly listing, which were not in the source.&nbsp; So without further ado, let me present my version of the snippet.&nbsp; First the source.</div><br /><br />Hi Ratch,<br /><br />I had assumed that including loading esi and edi weren&#39;t necessary as they are assumed by the lodsb and movsb instructions so I didn&#39;t include them in the source but they ended up in the Olly dump mainly because I didn&#39;t think to remove them. I do realize that MASM&#39;s HLCs do not know about CMOV and that is the whole point, this was just a small example to demonstrate the perils of relying on them. I have seen code with intensive loops using HLCs and the resulting code was horrible. One of the biggest offenders is using a test/jcc in a loop which should now be replaced by CMOV as that is a much more efficient way to accomplish the same thing.<br /><br /><div class="quote">Notice that my code does not complete the loop unless it finds the backslash.&nbsp; Also it does not use the ECX register.&nbsp; And only one byte for the MOVSB instruction.&nbsp; By the way, notice how much shorter MOV CL,&#39;/&#39; is compared to MOV ECX,&#39;/&#39;&nbsp; .&nbsp; Ratch</div><br /><br />ECX is a discardable register in all my code, even more so than EAX in some cases, personal thing but I don&#39;t usually think twice about using it or trashing it. I could not rely on ECX being empty so rather than zero the register then move only the byte (CMOV requires 32 bit moves) I just move the &quot;\&quot; as&nbsp; a DWORD.<br /><br />But as I said, the code I posted was only an example to demonstrate the problem of relying on the constructs and to remind people that they are not always the way to go. Personally I don&#39;t use them even on the rare occasion I code in MASM.<br /><br />GoAsm supports better scoping of labels than MASM so the problem of label names drizz posted is not an issue.</div>
    <div class="meta">Posted on 2006-04-20 01:16:27 by donkey</div>
   </div>
  </div>
 </body>
</html>