<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Question about Disassembly - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13585" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=13585">Question about Disassembly</a></p>
   <div class="post" id="post-105284">
    <div class="subject"><a href="#post-105284">Question about Disassembly</a></div>
    <div class="body">Hi there! First sorry for my poor English. I want to ask something about Disassembly. (I've read the excellent threads from The Svin. :alright: )<br /><br />Here it starts:<br /><br />When I got a opcode:<br /><br />8B03<br /><br />I know it means &quot;Mov eax, &quot;<br /><br />Because:<br /><br />8B is one of the opcodes of instruction &quot;Mov&quot;, and &quot;03&quot; is the ModR/M.<br /><br />03 = 00 000 011<br />;00(mod) - no displacement<br />;000 - eax<br />;011 - <br /><br />So, I can manually translate opcodes into instructions. But when I wrote a program, I don't know how to let the program recognize and organize the opcodes. For example, when the program gets a byte &quot;8B&quot;, how can it knows whether to go on getting the next byte(&quot;03&quot;) or not?<br /><br />My idea is to create a opcode table to let the program to look-up from it. But if I use this method, it will make the table very big, so I don't know if this will be a good idea. :stupid: <br /><br />Could anybody give me some ideas? Any helps will be greatly appreciated! :alright:<br /><br />Thanks!</div>
    <div class="meta">Posted on 2003-05-29 09:39:31 by pazuluo</div>
   </div>
   <div class="post" id="post-105288">
    <div class="subject"><a href="#post-105288">Question about Disassembly</a></div>
    <div class="body"><div class="quote">My idea is to create a opcode table to let the program to look-up from it. But if I use this method, it will make the table very big, so I don't know if this will be a good idea. </div> <br />The idea is not new. I have seen people creating such a list. But of course the list is long.<br /><br />Well you could try<br />-scan for prefix<br />-if prefix present, set some flag somewhere (remember that prefixes can stack)<br />-loop through the 1 byte opcodes like inc/dec/xchg eax,reg/push reg/pop reg/lodsx/ etc<br />-scan for the opcode 0Fh -&gt; and then work on the opcodes beginning with 0Fh ie bswap<br />-work on the other opcodes -&gt; decrypt the direction and mod <br />-work on fpu<br />-work on MMX<br />-work on XMM<br /><br />Something like that would do I suppose.  Alot of coding. <br /><br />I have some code for scanning<br /><pre><code><br />prefix_66h		equ	02h<br />prefix_67h		equ 04h<br />prefix_F0h		equ 08h<br />prefix_F2h		equ	010h<br />prefix_F3h		equ	020h<br />prefix_2Eh		equ	040h<br />prefix_36h		equ	080h<br />prefix_3Eh		equ	0100h<br />prefix_26h		equ	0200h<br />prefix_64h		equ	0400h<br />prefix_65h		equ	0800h<br />.data<br />prefix_scan		dd 	066h, prefix_66h, 067h, prefix_67h, 0F0h, prefix_F0h, 0F2h, prefix_F2h<br />				dd	0F3h, prefix_F3h, 02Eh, prefix_2Eh, 036h, prefix_36h, 03Eh, prefix_3Eh<br />				dd	026h, prefix_26h, 064h, prefix_64h, 065h, prefix_65h<br /><br />.code<br />dasm proc uses esi edi ebx pCode&#58;dword,_size<br />	mov		esi,pCode<br />	mov		edx,_size<br />	mov		bit,0<br />_begin&#58;<br />	mov		ecx,11<br />	lea		edi,prefix_scan<br />prefixloop&#58;<br />	mov		al,&#91;edi&#93;<br />	cmp		byte ptr&#91;esi&#93;,al<br />	jnz		@F<br />	or		bit,DWORD PTR&#91;edi+4&#93;<br />	inc		esi<br />	dec		edx<br />	jnz		_begin<br />@@&#58;<br />	add		edi,8<br />	dec		ecx<br />	jnz		prefixloop<br />	mov		ecx,4<br />....<br />dasm endp<br /></code></pre><br />of course it is uncompleted as I could not be bothered to continue with it :)</div>
    <div class="meta">Posted on 2003-05-29 10:36:29 by roticv</div>
   </div>
   <div class="post" id="post-105292">
    <div class="subject"><a href="#post-105292">Question about Disassembly</a></div>
    <div class="body">sadly, you won't get around creating said table.</div>
    <div class="meta">Posted on 2003-05-29 10:44:14 by Tola</div>
   </div>
   <div class="post" id="post-105300">
    <div class="subject"><a href="#post-105300">Question about Disassembly</a></div>
    <div class="body">The idea is to parse the byte stream, reading and advancing in stream as required, a little just like CPU does :P<br />Based on state machines of course ...<br /><br />it is not quite an 100% sure process after all<br /><br />esp if you go backwards and/or unsure of starting point and/or if app uses simple anti debugging/disassembler techniques like calculating the next instruction and./or jumping based on calculations...<br /><br />the above stuff will require a little execution also</div>
    <div class="meta">Posted on 2003-05-29 11:44:51 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-105302">
    <div class="subject"><a href="#post-105302">Question about Disassembly</a></div>
    <div class="body">Thank you all above! (Especially roticv) :alright: <br /><br />It seems that I have to use the table, it's a lot of work, but I'll try. :) <br /><br />Anybody could still give me some ideas? I'm appreciated! :)</div>
    <div class="meta">Posted on 2003-05-29 12:05:32 by pazuluo</div>
   </div>
   <div class="post" id="post-105360">
    <div class="subject"><a href="#post-105360">Question about Disassembly</a></div>
    <div class="body">Start to work, thank you all!<br /><br />Anybody else give me some ideas?</div>
    <div class="meta">Posted on 2003-05-29 22:07:44 by pazuluo</div>
   </div>
   <div class="post" id="post-105362">
    <div class="subject"><a href="#post-105362">Question about Disassembly</a></div>
    <div class="body">Here is a disassembler to study:<br /><a target="_blank" href="http://home.no.net/tkos/src/debug/">http://home.no.net/tkos/src/debug/</a></div>
    <div class="meta">Posted on 2003-05-29 22:13:02 by bitRAKE</div>
   </div>
   <div class="post" id="post-105963">
    <div class="subject"><a href="#post-105963">Question about Disassembly</a></div>
    <div class="body">I did abit of recoding and my code ends up becoming like:<br /><pre><code><br />prefix_66h		equ	02h<br />prefix_67h		equ 04h<br />prefix_F0h		equ 08h<br />prefix_F2h		equ	010h<br />prefix_F3h		equ	020h<br />prefix_2Eh		equ	040h<br />prefix_36h		equ	080h<br />prefix_3Eh		equ	0100h<br />prefix_26h		equ	0200h<br />prefix_64h		equ	0400h<br />prefix_65h		equ	0800h<br />.data<br />reg32			db	&quot;eax&quot;,0,&quot;ecx&quot;,0,&quot;edx&quot;,0,&quot;ebx&quot;,0,&quot;esp&quot;,0,&quot;ebp&quot;,0,&quot;esi&quot;,0,&quot;edi&quot;,0<br />reg16			db	&quot;ax&quot;,0,&quot;cx&quot;,0,&quot;dx&quot;,0,&quot;bx&quot;,0,&quot;sp&quot;,0,&quot;bp&quot;,0,&quot;si&quot;,0,&quot;di&quot;,0<br />reg8			db	&quot;al&quot;,0,&quot;cl&quot;,0,&quot;dl&quot;,0,&quot;bl&quot;,0,&quot;ah&quot;,0,&quot;ch&quot;,0,&quot;dh&quot;,0,&quot;bh&quot;,0<br />;_1byteopcode1<br />_daa			db	&quot;daa&quot;,0<br />_das			db	&quot;das&quot;,0<br />_aaa			db	&quot;aaa&quot;,0<br />_aas			db	&quot;aas&quot;,0<br />_pushes			db	&quot;push es&quot;,0<br />_popes			db	&quot;pop es&quot;,0<br />_pushcs			db	&quot;push cs&quot;,0<br />_pushss			db	&quot;push ss&quot;,0<br />_popss			db	&quot;pop ss&quot;,0<br />_pushds			db	&quot;push ds&quot;,0<br />_popds			db	&quot;pop ds&quot;,0<br />_wait			db	&quot;wait&quot;,0<br />_sahf			db	&quot;sahf&quot;,0<br />_lahf			db	&quot;lahf&quot;,0<br />_retn			db	&quot;retn&quot;,0<br />_leave			db	&quot;leave&quot;,0<br />_retf			db	&quot;retf&quot;,0<br />_int3			db	&quot;int 3&quot;,0<br />_into			db	&quot;into&quot;,0<br />_salc			db	&quot;salc&quot;,0<br />_xlat			db	&quot;xlat&quot;,0<br />_int01			db	&quot;int01&quot;,0<br />_hlt			db	&quot;hlt&quot;,0<br />_cmc			db	&quot;cmc&quot;,0<br />_clc			db	&quot;clc&quot;,0<br />_stc			db	&quot;stc&quot;,0<br />_cli			db	&quot;cli&quot;,0<br />_sti			db	&quot;sti&quot;,0<br />_cld			db	&quot;cld&quot;,0<br />_std			db	&quot;std&quot;,0<br />_nop			db	&quot;nop&quot;,0<br />;_1byteopcode2<br />_pushad			db	&quot;pushad&quot;,0<br />_popad			db	&quot;popad&quot;,0<br />_pushfd			db	&quot;pushfd&quot;,0<br />_popfd			db	&quot;popfd&quot;,0<br />_cwde			db	&quot;cwde&quot;,0<br />_cdq			db	&quot;cdq&quot;,0<br />_pusha			db	&quot;pusha&quot;,0<br />_popa			db	&quot;popa&quot;,0<br />_pushf			db	&quot;pushf&quot;,0<br />_popf			db	&quot;popf&quot;,0<br />_cbw			db	&quot;cbw&quot;,0<br />_cwd			db	&quot;cwd&quot;,0<br />;<br />_inc			db	&quot;inc&quot;,0<br />_dec			db	&quot;dec&quot;,0<br />_push			db	&quot;push&quot;,0<br />_pop			db	&quot;pop&quot;,0<br />_xchgeax		db	&quot;xchg eax, &quot;,0<br />_xchgax			db	&quot;xchg ax, &quot;,0<br />align 4<br />prefix_scan		dd 	066h, prefix_66h, 067h, prefix_67h, 0F0h, prefix_F0h, 0F2h, prefix_F2h<br />				dd	0F3h, prefix_F3h, 02Eh, prefix_2Eh, 036h, prefix_36h, 03Eh, prefix_3Eh<br />				dd	026h, prefix_26h, 064h, prefix_64h, 065h, prefix_65h<br />;lbyteopcode_1	dd	08h, OFFSET _inc, 09h, OFFSET _dec,  0Ah, OFFSET _push, 0Bh, OFFSET _pop<br />_1byteopcode	dd	027h, offset _daa, 02Fh, offset _das, 037h, offset _aaa, 03Fh, offset _aas<br />				dd	06h, offset _pushes, 07h, offset _popes, 0Eh, offset _pushcs, 016h, offset _pushss<br />				dd	017h, offset _popss, 01Eh, offset _pushds, 01Fh, offset _popds, 09Bh, offset _wait<br />				dd	09Eh, offset _sahf, 09Fh, offset _lahf, 0C3h, offset _retn, 0C9h,offset _leave<br />				dd	0CCh, offset _int3, 0CEh, offset _into, 0D6h, offset _salc, 0D7h, offset _xlat<br />				dd	0F1h, offset _int01, 0F4h, offset _hlt, 0F5h, offset _cmc, 0F8h, offset _clc<br />				dd	0F9h, offset _stc, 0FAh, offset _cli, 0FBh, offset _sti, 0FCh, offset _cld<br />				dd	0FDh, offset _std, 090h, offset _nop<br />_1bytescan		db	060h, 061h, 09Ch, 09Dh, 098h, 099h<br />align 4<br />_1bytetable1	dd	offset _pushad, offset _popad, offset _pushfd, offset _popfd, offset _cwde, offset _cdq <br />_1bytetable2	dd	offset _pusha, offset _popa, offset _pushf, offset _popf, offset _cbw, offset _cwd<br />_1byteopcode2	dd	08h, 09h, 0Ah, 0Bh, 12h<br />_1bytetable3	dd	offset _inc, offset _dec, offset _push, offset _pop, offset _xchgeax<br />_1bytetable4	dd	offset _inc, offset _dec, offset _push, offset _pop, offset _xchgax<br />.code<br />x86&#58;<br />;&#91;esp+4&#93; = pointer to opcode to decode<br />;&#91;esp+8&#93; = pointer to string to store decoded opcode<br />;eax return size of opcode decoded<br />	mov		esi,&#91;esp+4&#93;<br />	xor		ebx,ebx<br />	xor		eax,eax<br />_begin&#58;<br />	mov		ecx,11<br />	lea		edi,prefix_scan<br />_prefixscan&#58;<br />	mov		dl,&#91;edi&#93;<br />	cmp		&#91;esi&#93;,dl<br />	jnz		@F<br />	or		ebx,&#91;edi+4&#93;<br />	inc		eax<br />	inc		esi<br />	jmp		_begin<br />@@&#58;<br />	add		edi,8<br />	dec		ecx<br />	jnz		_prefixscan<br />	mov		ecx,31<br />	lea		edi,_1byteopcode<br />_1byte1&#58;<br />	mov		dl,&#91;edi&#93;<br />	cmp		&#91;esi&#93;,dl<br />	jnz		@F<br />	push	&#91;edi+4&#93;<br />	push	&#91;esp+8&#93;&#91;4&#93;<br />	call	stringcopy<br />	inc		eax<br />	ret 8<br />@@&#58;<br />	add		edi,8<br />	dec		ecx<br />	jnz		_1byte1<br />	lea		edi,_1bytescan<br />_1byte2&#58;<br />	mov		dl,&#91;esi&#93;<br />	cmp		&#91;edi&#93;,dl<br />	jnz		@F<br />	lea		edi, _1bytetable1<br />	lea		edx, _1bytetable2<br />	test	ebx, prefix_66h<br />	cmovnz	edi,edx<br />	lea		edx,&#91;edi+ecx*4&#93;<br />	push	edx<br />	push	&#91;esp+8&#93;&#91;4&#93;<br />	call	stringcopy<br />	inc		eax<br />	ret 8<br />@@&#58;<br />	inc 	edi<br />	inc 	ecx<br />	cmp		ecx,6<br />	jnz		_1byte2<br />	xor		ecx,ecx<br />	lea		edi,_1byteopcode2<br />_1byte3&#58;<br />	movzx	edx, byte ptr &#91;esi&#93;<br />	push	edx<br />	shr		edx,3<br />	cmp		edx, &#91;edi&#93;<br />	jnz		@F<br />	pop		edx<br />	and		edx, 0111y		;last 3 bits = register<br />	test	ebx, prefix_66h<br />	jz		_32bit1byteopcode<br />	lea		edi, _1bytetable4<br />	shl		ecx,2<br />	add		ecx,edi<br />	push	ecx<br />	push	&#91;esp+8&#93;&#91;4&#93;<br />	call	stringcopy<br />	lea		edi, reg16<br />	lea		edx, &#91;edx+ edx*2&#93;<br />	add		edx, edi<br />	push	edx<br />	push	&#91;esp+8&#93;&#91;4&#93;<br />	call	strcat<br />	inc		eax<br />	ret 8<br />_32bit1byteopcode&#58;<br />	lea		edi, _1bytetable3<br />	shl		ecx,2<br />	add		ecx,edi<br />	push	ecx<br />	push	&#91;esp+8&#93;&#91;4&#93;<br />	call	stringcopy<br />	lea		edi,reg32<br />	shl		edx,2<br />	add		edx,edi<br />	push	edi<br />	push	&#91;esp+8&#93;&#91;4&#93;<br />	call	strcat<br />	inc		eax<br />	ret 8<br />@@&#58;<br />	pop		edx<br />	add		edi,4<br />	inc		ecx<br />	cmp		ecx,5<br />	jnz		_1byte3<br />	ret 8<br /><br />stringcopy&#58;<br />;&#91;esp+4&#93; = pointer to string destination<br />;&#91;esp+8&#93; = pointer to string source<br />	pushad<br />	mov		esi,&#91;esp+8&#93;&#91;4*8&#93;<br />	mov		edi,&#91;esp+4&#93;&#91;4*8&#93;<br />@@&#58;<br />	mov		al,&#91;esi&#93;<br />	inc		esi<br />	mov		&#91;edi&#93;,al<br />	inc		edi<br />	or		al,al<br />	jnz		@B<br />	popad<br />	ret 8<br /><br />strcat&#58;<br />;&#91;esp+4&#93; = pointer to string destination<br />;&#91;esp+8&#93; = pointer to string to add<br />	pushad<br />	mov		edx,&#91;esp+8&#93;&#91;4*8&#93;<br />	mov		ecx,&#91;esp+4&#93;&#91;4*8&#93;<br />_scanfornull&#58;<br />	mov 	al,&#91;edx&#93;<br />	inc 	edx<br />	or 		al,al<br />	jnz 	_scanfornull<br />	dec		edx<br />_copystring&#58;<br />	mov 	al,&#91;ecx&#93;<br />	inc 	ecx<br />	mov 	&#91;edx&#93;,al<br />	inc 	edx<br />	or 		al,al<br />	jnz 	_copystring<br />	popad<br />	ret 8<br /></code></pre></div>
    <div class="meta">Posted on 2003-06-04 08:24:46 by roticv</div>
   </div>
  </div>
 </body>
</html>