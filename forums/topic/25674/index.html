<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>small letters and in reverse order. ! - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25674" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25674">small letters and in reverse order. !</a></p>
   <div class="post" id="post-187344">
    <div class="subject"><a href="#post-187344">small letters and in reverse order. !</a></div>
    <div class="body"><br /><br />Hello...<br /><br />i&#39;m working on : <br /><br /> a program that will take as an input 5 Capital Letters and then <br /><br />display on next line in small letters and in reverse order.<br /><br />----------------------------<br /><br />I want to know how to &quot;Use Logical operator to convert the letters <br /><br />to small letters&quot;<br /><br />is it like :<br /><br /><br />and DL,11111111b<br /><br /><br />?<br /><br /><br /><br />and How can I Save the input letters in an array named W ?<br /><br />is it :<br /><br />W DW &quot;Than what will come here ? &quot;<br /><br /><br /><br />how can I&nbsp; reverse the input letters , without using STACK ?<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-01-04 07:27:42 by Rooro</div>
   </div>
   <div class="post" id="post-187351">
    <div class="subject"><a href="#post-187351">Re: small letters and in reverse order. !</a></div>
    <div class="body">First things first: you should know that an array must have a length and in Assembly, due to its very nature, you can cross an array?s boundary to its adjacent variable or block in the same segment. For example, if you create a WORD variable which is 16-bits long, you can use its address (OFFSET) to access the next variable which can be of any other sizes. Therefore, you should create a mechanism with which you would realize your array?s real length. A lot of programmers, as per strings that store characters, rather have their array terminated by a null-byte (ASCII Code = 0x00). This allows you to see where your array is terminated. For example, you have a string ?Hello? and then a byte 0x00. When you search in that string, starting from the first character, you can go forward until you reach the character 0x00. There you will realize your string is ended.<br /><br />About the letters and their case (Upper-case or Lower-case), lower case letters start from the ASCII code 97 (0x61) and end at 122 (0x7A). Upper-case letters start at ASCII code 65 (0x41) and end at 90 (0x5A). You can confirm this by holding the ALT key down and pressing for example 65 on your keypad which would print an ?A? character. Now converting upper-case letters to lower is pretty easy and also trickery. If you take a look at the ASCII code of ?A? which is 65 and also at the ASCII code of ?a? which is 97, you will notice that the difference here is 32 or 0x20. Therefore, if you add this value of 32 to an upper-case letter, that letter would become a lower-case one. For example, let us say that the AL register holds the character ?F? and we need to convert it to ?f?, all we have to do is to perform a logical OR instruction like this:<br /><br /><br /><pre><span style="font-size:2>MOV&nbsp; &nbsp;  AL , ?F?<br />OR&nbsp; &nbsp;  AL , 020h</span></pre>The trickery part is that you *must* check if the character that you are performing this operation on is really an upper-case letter or not. For reversing a string or an array of characters assuming that the string is terminated by a null-byte as I already explained above, you should first find the length of the string, and then read one byte from the beginning and replace it with the byte at the end and vice versa. You can perform tricks at this part too: you can obtain the length of the string which in your case I guess is 5 and then divide this value by 2 using ?SHR 1?, this would yield in the value 2. This means that you should exchange at most 2 characters which is precisely right. Now look at the below example:<br /><br /><pre><span style="font-size:2>String1&nbsp; &nbsp; &nbsp;  DB&nbsp; &nbsp; &nbsp;  ?Hello?, 0</span></pre>This is how I would create a null-terminated string. Now the length is 5 and when divided by 2 would result in 2 (the fraction 1 is gone then). Therefore, if you replace the ending ?o? with the beginning ?H? and the next-to-the-end ?l? with ?e?, you will have the reversed string of ?olleH?. Strings with even number of bytes are reversed in the same order except that you will not have to leave any characters behind in the operations as you should do in strings with odd number of characters.<br /><br />Note that in the string ?Hello?, we need not reverse the order of the character in the middle ?l? because no matter what you do, you can not reverse that with any other characters and it should always stay in the middle. About the stack, there really is no need to use the stack, you can simply load the OFFSET of your string into index registers such as ?BX?, ?SI? and ?DI? and then navigate through individual bytes inside those. Below is an example I have written in TASM which does this for you:<br /><br /><pre><span style="font-size:2>ReverseStr PROC<br />&nbsp; MOV&nbsp; &nbsp;  SI , OFFSET String1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; We load the offset of our string in SI<br />&nbsp; MOV&nbsp; &nbsp;  AL , BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Read one byte from the string immediately<br />&nbsp; TEST&nbsp; &nbsp; AL , AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if the byte is zero<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__ReverseStrEP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Jump to the end of the procedure if yes<br />&nbsp; MOV&nbsp; &nbsp;  BX , SI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; BX and SI now point to String1<br />&nbsp; XOR&nbsp; &nbsp;  CX , CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; CX will be set to our string&#39;s length later<br />&nbsp; @@__ReachEndOfTheString:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; The loop to find the end of the string<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AL , BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Read one byte from the string<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move to the next byte immediately<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Add one to our string&#39;s length now<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; AL , AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if we have reached the null-byte yet<br />&nbsp; &nbsp; JNE&nbsp; &nbsp;  @@__ReachEndOfTheString&nbsp; &nbsp; &nbsp;  ; Keep searching if not<br />&nbsp; SUB&nbsp; &nbsp;  BX , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move back 2 bytes, I will explain this later<br />&nbsp; SHR&nbsp; &nbsp;  CX , 01h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Divide our string&#39;s length by 2<br />&nbsp; @@__ReverseString:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; The main loop of the procedure<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AL , BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Read one byte from the right of the string<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AH , BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Read one byte from the left of the string<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Put the right byte into the left side<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , AH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Put the left byte into the right side<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  SI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move to the next byte from the left<br />&nbsp; &nbsp; DEC&nbsp; &nbsp;  BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move back to the previous byte from the right<br />&nbsp; &nbsp; DEC&nbsp; &nbsp;  CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Decrement our string&#39;s length<br />&nbsp; &nbsp; JNE&nbsp; &nbsp;  @@__ReverseString&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Keep doing these if CX is not zero yet<br />&nbsp; @@__ReverseStrEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; End of the procedure routine<br />&nbsp; &nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return to the calling procedure<br />ReverseStr ENDP</span></pre>Note that your data segment should contain a null-terminated string called ?String1?. For example, like this:<br /><br /><pre><span style="font-size:2>.DATA<br />&nbsp; String1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;Assembly&#39;, 0</span></pre>And then you should invoke this procedure in this way:<br /><br /><pre><span style="font-size:2>.CODE<br />&nbsp; CALL ReverseStr</span></pre>About the ?SUB BX , 0002h? at the 14th step of the above procedure, you should note that we are reading one byte at a time from the string and then, using the ?INC BX?, skipping over that byte immediately. Now let us say that the last byte is the null-byte and we are skipping over it. Therefore, we should, to be able to reach the last character in the string, walk back to the null-byte and then walk back again one character to reach the ending one. This would be 2 decrements which is done using ?SUB BX , 0002h?.<br /><br />Hope I could help.<br /></div>
    <div class="meta">Posted on 2007-01-04 09:51:29 by XCHG</div>
   </div>
   <div class="post" id="post-187365">
    <div class="subject"><a href="#post-187365">Re: small letters and in reverse order. !</a></div>
    <div class="body">Great ! what a useful info !<br /><br />XCHG&nbsp; Thanks a lot <br /><br /><br /><br />can I ask you if I try to&nbsp; do the same program &quot; but the user will enter the letters&nbsp; &quot; how can i do it ?<br /><br /><br /><br /><br />i&#39;m startting my program before i read your program code carfeully :<br /><br />with some missed code which i do no how can i compleat it !<br /><br /><br /><pre><code>.MODEL SMALL<br />.STACK 100H<br />.DATA<br /><br />MSG1 DB &#39;Please Enter Capital letters: $&#39;<br />MSG2 DB 0DH,0AH,&#39;Small Letters are:&nbsp; $&#39;<br /><br />W&nbsp; &nbsp; &nbsp; &nbsp;DW 0,0,0,0,0<br /><br />.CODE<br /><br />MAIN PROC<br /><br />;--------------------<br />MOV AX,@DATA	;INTILAIZE DS<br />MOV DS,AX<br />;---------------------<br /><br /><br />;DISPLAY MSG1<br /><br />LEA DX,MSG1 	;GET MSG1<br />MOV AH,9	;DISPLAY STRING<br />INT 21H		;DISPLAY MSG1<br /><br />	<br />;----------<br /><br /><br />loop_top:<br /><br />MOV AH,1&nbsp; 	;READ A CHARACTDR<br />INT 21h<br />cmp al,0dh 	; end of line?<br />je Display1 	; yes, then stop<br /><br /><br /><br />MOV W,AX<br /><br />and SI,11111111b<br /><br />loop_end:<br /><br />jmp loop_top<br />	<br /><br /><br /><br />;-----------<br /><br />Display1:<br /><br /><br />XOR SI,SI<br /><br /><br />LOOOP:<br /><br />MOV DX,W<br /><br />INT 21H<br /><br />ADD SI,2<br /><br />LOOP LOOOP<br /><br />;--------------<br /><br /><br />;DISPLAY MSG2<br /><br />LEA DX,MSG2 	;GET MSG2<br />MOV AH,9		;DISPLAY STRING<br />INT 21H		;DISPLAY MSG2<br /><br /><br />;---------------<br /><br />MOV AH,4CH	; return control to DOS<br />INT 21H<br /><br /><br /><br />MAIN ENDP<br /><br />	END MAIN<br /><br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2007-01-04 19:28:51 by Rooro</div>
   </div>
  </div>
 </body>
</html>