<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>HLA Adventure Game Notes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16119" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=16119">HLA Adventure Game Notes</a></p>
   <div class="post" id="post-125031">
    <div class="subject"><a href="#post-125031">HLA Adventure Game Notes</a></div>
    <div class="body">Here's a response I made to Paul (HLAAdv Game Author)<br />about some programming techniques in HLA vis-a-vis<br />the str.tokenize and table lookup facilities in the HLA<br />Standard Library. Thought I'd repost the article here<br />as it contains a lot of useful information:<br />------------------------------------------------------------------------------------------<br /><br />Hi Paul,<br /><br />For an &quot;adventure&quot; style game, there are two facilities<br />in the HLA Standard Library that you'll definitely want<br />to consider: the str.tokenize function which breaks up<br />a string into individual words, and the HLA table class<br />that makes looking up strings a breeze.<br /><br />==================================================<br />Consider the str.tokenize (and str.tokenize2) function:<br /><br />str.tokenize( src: string; var dest:dword ); @returns( &quot;eax&quot; );<br />str.tokenize2( src: string; var dest:dword; delims:cset ); @returns( &quot;eax&quot; );<br /><br />These two routines lexically scan13 a string and break it up into<br />&quot;lexemes&quot; (words), returning an array of pointers to each of the<br />lexemes. The only difference between the two routines is that<br />the tokenize routine uses the following default set of delimiter<br />characters:<br /><br />{' ', #9, ',', '&lt;', '&gt;', '|', '\', '/', '-'}<br /><br />This character set roughly corresponds to the delimiters used<br />by the Windows Command Window interpreter or typical<br />Linux shells. If you do not wish to use this particular set of<br />delimiter characters, you may call str.tokenize2 and specify<br />the characters you're interested in.<br /><br />The tokenize routines begin by skipping over all delimiter<br />characters at the beginning of the string. Once they locate<br />a non-delimiter character, they skip forward until they find<br />the end of the string or the next delimiter character. Then<br />they allocate storage for a new string on the heap and copy<br />the delimited text to this new string. A pointer to the new<br />string is stored into the dword array passed as the first parameter<br />to tokenize(2). This process is repeated for each lexeme found in<br />the src string.<br /><br />As these functions are intended for processing command lines,<br />any quoted string (a sequence of characters surrounded by quotes<br />or apostrophies) is treated as a single token/string by these functions.<br />If this behavior is a problem for you, it's real easy to modify the<br />str.tokenize source file to handle this issue.<br /><br />Warning: the dest parameter should be an array of strings. This array<br />must be large enough to hold pointers to each lexeme found in the<br />string. In theory, there could be as many as str.length(src)/2 lexemes<br />in the source string.<br /><br />On return from these functions, the EAX register will contain the<br />number of lexemes found and processed in the src string (i.e., EAX<br />will contain the number of valid elements in the dest array).<br /><br />When you are done with the strings allocated on the heap,<br />you should free them by calling strfree.<br />Note that you need to call strfree for each active pointer stored in<br />the dest array.<br />Here is an example of a call to the str.tokenize routine:<br /><br /><br />program tokenizeDemo;<br />#include( &quot;stdio.hhf&quot; );<br />#include( &quot;string.hhf&quot; );<br />#include( &quot;memory.hhf&quot; );<br /><br />static<br />   strings: string[16];<br />    ParseMe: string := &quot;This string contains five words&quot;;<br /><br />begin tokenizeDemo;<br /><br />    str.tokenize( strings, ParseMe );<br />    mov( 0, ebx );<br />    while( ebx &lt; eax ) do<br /><br />        stdout.put<br />        (<br />            &quot;string[&quot;,<br />            (type uns32 ebx),<br />            &quot;]=&quot;&quot;&quot;,<br />            strings,<br />            &quot;&quot;&quot;&quot;,<br />            nl<br />        );<br />        strfree( strings );<br />        inc( ebx );<br />    endwhile;<br /><br />end tokenizeDemo;<br /><br /><br />This program produces the following output:<br /><br />string[0]=&quot;This&quot;<br />string[1]=&quot;string&quot;<br />string[2]=&quot;contains&quot;<br />string[3]=&quot;five&quot;<br />string[4]=&quot;words&quot;<br /><br />=======================================<br /><br />The HLA Standard Library provides a &quot;table&quot; class that<br />lets you easily create and manipulate &quot;associative arrays.&quot;<br />An &quot;associative array&quot; is, effectively, an array whose index<br />is a string rather than some integer quantity, e.g.,<br /><br />   lookupTable[ &quot;somestring&quot; ] = somevalue;<br /><br />The cool thing about a table, of course, is that you can<br />use the words you've extract with str.tokenize as indicies<br />into a lookup table to produce a small integer value that<br />is easy to manipulate in your assembly program.<br /><br />The &quot;table&quot; type provided by the HLA Standard Library<br />is actually a class type (yep, you're headed into the realm<br />of object-oriented programming here; fortunately, you don't<br />need to know much about OOP to use tables). The table<br />class provides the following procedures, methods, and<br />iterators:<br /><br />procedure table.create( HashSize:uns32 );<br />method table.destroy( FreeValue:procedure );<br />method table.getNode( id:string );<br />method table.lookup( id:string );<br />iterator table.item();<br /><br />The create procedure is used to initialize a lookup table.<br />The destroy method (procedure) is used to clean up a<br />table data structure when you're done using it (in particular,<br />this call frees all the storage that the table routines allocate<br />internally during operation). For our purposes, we're just<br />going to create a table of reserved words for the game,<br />so the destroy method isn't that useful (we'll want to keep<br />the table around until the game is done, and when the<br />program quits, all the storage will be freed up anyway).<br /><br />The item iterator, combined with HLA's foreach loop,<br />will &quot;iterator&quot; over each item in the table. This probably<br />isn't very useful for an adventure game, but it is useful<br />in other applications. We'll ignore the item iterator here.<br /><br />The getNode and lookup methods are of primary interest<br />to us when building an adventure game. These are the<br />methods that we'll use to fill  the lookup table and<br />lookup nouns and verbs in the table.<br /><br />Both routines look up the string you pass as the parameter<br />in the specified lookup table. The difference between the<br />two is what happens when the lookup routines *do not*<br />find the string in the table. In this situation, getNode *adds*<br />the string to the lookup table and returns a pointer to the<br />corresponding table entry in the EAX register. lookup,<br />on the other hand, returns NULL in the EAX register<br />if it cannot find the string in the table. Both routines<br />return a pointer to the table entry in EAX if they find<br />the entry in the table.<br /><br />A table entry is a record of the following type:<br /><br />tableNode:<br />    record<br /><br />        link: pointer to tableNode;<br />        Value: dword;<br />        id: string;<br /><br />    endrecord;<br /><br />The *only* field you should mess with is &quot;Value&quot;. You<br />can use &quot;Value&quot; for any purpose you want. You must<br />not modify the other fields of this data structure.<br /><br />In the example I've attached to this post, I use the Value<br />field to hold a small (unique) integer value to identify the<br />word. These integer constants are defined using the HLA<br />enumerated data type declaration:<br /><br />type<br />    words:enum<br />    {<br />        illegal_c,<br />        goVerb_c,<br />        quitVerb_c,<br />        northNoun_c,<br />        southNoun_c,<br />        eastNoun_c,<br />        westNoun_c<br />    };<br /><br />Specifically, note that goVerb_c = 1, quitVerb_c=2,<br />northNoun_c=3, etc.<br /><br />To use the table class in an HLA program, the first thing<br />you've got to do is declare a table variable. In the example<br />at the end of this post, I've declared the &quot;tbl&quot; variable in the<br />static section as follows:<br /><br />    tbl             :table;                 // Noun/verb table.<br /><br />Before you can use the tbl variable in your program,<br />you must first initialize this table object. This is done<br />by calling the &quot;class constructor&quot; for the table class.<br />By convention, most classes use the procedure name<br />&quot;create&quot; for the class constructor; the table class follows<br />this convention. The create procedure requires a single<br />parameter that specifies the minimum size of the hash<br />table that the tbl object will use. Generally, this value should<br />be between two and four times the maximum number of<br />words you intend to put into the table. This value effects<br />the efficiency, not the correctness, of the table lookup<br />operations. If this value is too small, your searches will<br />take a little longer, if this value is too large, you're going to<br />waste a little memory. For an adventure game, the speed<br />of the lookup is irrelevant (much faster than user input).<br />OTOH, since we've only got one lookup table, the amount<br />of wasted space in this table isn't very important either.<br />I just chose the value &quot;100&quot; out of the blue (this is probably<br />much larger than it needs to be, but we're only taking about<br />400 bytes for the table...).<br /><br />Here's the call to initialize tbl:<br /><br />    tbl.create(100);<br /><br />You *must* make this call before doing anything else with<br />tbl.<br /><br />Once you've initialized the tbl object, the next step is to fill<br />the lookup table with the words you want to recognize and<br />their associated Value fields. In the demo that appears later,<br />I've just supplied six words: go, quit, north, south, east, west.<br />It should be pretty obvious how to extend this to any number<br />of words (modify the words enum type and just add more<br />calls to tbl.getNode). Here's a typical initialization sequence<br />for one word:<br /><br />    // Put the word into the table and return a pointer to the<br />    // new table node:<br /><br />    tbl.getNode( &quot;go&quot; );<br /><br />    // store the associated integer constant into the Value<br />    // field of this node:<br /><br />    mov( goVerb_c, (type tableNode ).Value );<br /><br /><br />Once you've repeated these two instructions for each word<br />you want in the table, looking up a word in the table is a<br />trivial process:<br /><br />    tbl.lookup( someStr );<br /><br />This call returns a pointer to the associated table node if<br />the string is found in the table, it returns NULL if the string<br />is not in the table. The return value is in EAX.<br /><br />I hope that this quick exposition has sparked your imagination<br />and given  you some ideas about how easy it is to lexically<br />scan and parse an input command from the user when using<br />HLA Standard Library routines.<br /><br />As Rene (Betov) says earlier, you could:<br /><br />&quot;Use a decent Assembler written by some<br />decent Assembly programmer&quot;<br /><br />The problem with Rene's approach, alas, is that<br />you'd have to write all this code yourself. Why bother<br />when it's already available in the HLA Standard Library<br />waiting to be used?<br /><br />Cheers,<br />Randy Hyde<br /><br />/*****************************************/<br />/*                                       */<br />/* This is a simple program that         */<br />/* demonstrates HLA tables. It shows     */<br />/* how to use an HLA table to lookup     */<br />/* and identify words you've stored      */<br />/* in a table such as the commands you'd */<br />/* normal expect in an &quot;adventure&quot; type  */<br />/* game.                                 */<br />/*                                       */<br />/*****************************************/<br /><br /><br /><br /><br /><br />program tableDemo;<br /><br />#include( &quot;stdlib.hhf&quot; );<br /><br />// Create a list of constants for each of the<br />// words we're going to recognize in our<br />// noun/verb list:<br /><br />type<br />    words:enum<br />    {<br />        illegal_c,<br />        goVerb_c,<br />        quitVerb_c,<br />        northNoun_c,<br />        southNoun_c,<br />        eastNoun_c,<br />        westNoun_c<br />    };<br /><br />// Some variables this program uses:<br /><br />static<br />    cnt             :uns32;<br />    s               :str.strvar(256);       // user Input string.<br />    tokens          :string[128];<br />    tbl             :table;                 // Noun/verb table.<br /><br />    cmdTbl          :string[] :=<br />                    [<br />                        &quot;illegal_c&quot;,<br />                        &quot;goVerb_c&quot;,<br />                        &quot;quitVerb_c&quot;,<br />                        &quot;northNoun_c&quot;,<br />                        &quot;southNoun_c&quot;,<br />                        &quot;eastNoun_c&quot;,<br />                        &quot;westNoun_c&quot;<br />                    ];<br /><br /><br />    // All tables must have a &quot;destructor&quot; that<br />    // cleans up after the object when the object<br />    // is destroyed. For adventure game noun/verb<br />    // lists no action is really necessary because<br />    // we quit after destorying the object.<br />    // Nonetheless, you need to supply an empty<br />    // procedure to satisfy the table class.<br /><br />    procedure destroyTable; @noframe;<br />    begin destroyTable;<br />        ret();<br />    end destroyTable;<br /><br /><br /><br /><br />begin tableDemo;<br /><br />    // Create the table and its corresponding hash<br />    // table.  The &quot;100&quot; parameter suggests that<br />    // there are probably about 100 unique words<br />    // in this file (the exact count isn't important,<br />    // if this value is too small, the program<br />    // runs a little slower; if this value is too<br />    // large, the program wastes a little memory).<br /><br />    tbl.create( 100 );<br /><br /><br />    // for each word in the noun/verb list, enter the<br />    // word into the table and assign a value to the<br />    // &quot;Value&quot; field that we will retrive later:<br /><br />    tbl.getNode( &quot;go&quot; );<br />    mov( goVerb_c, (type tableNode ).Value );<br />    tbl.getNode( &quot;quit&quot; );<br />    mov( quitVerb_c, (type tableNode ).Value );<br />    tbl.getNode( &quot;north&quot; );<br />    mov( northNoun_c, (type tableNode ).Value );<br />    tbl.getNode( &quot;south&quot; );<br />    mov( southNoun_c, (type tableNode ).Value );<br />    tbl.getNode( &quot;east&quot; );<br />    mov( eastNoun_c, (type tableNode ).Value );<br />    tbl.getNode( &quot;west&quot; );<br />    mov( westNoun_c, (type tableNode ).Value );<br /><br />    // Okay, now demonstrate how to use this table:<br /><br />    begin mainloop; forever<br /><br />        stdout.put( &quot;Enter a cmd: &quot; );<br />        stdin.gets( s );<br />        str.tokenize( s, tokens );<br />        mov( eax, cnt );<br />        for( mov( 0, ecx ); ecx &lt; cnt; inc( ecx )) do<br /><br />            tbl.lookup( tokens[ ecx*4 ] );<br />            if( eax &lt;&gt; NULL ) then<br /><br />                mov( (type tableNode).Value, ebx );<br />                stdout.put<br />                (<br />                    &quot;Command value: &quot;,<br />                    (type uns32 ebx),<br />                    &quot; cmd:&quot;,<br />                    cmdTbl[ ebx*4 ],<br />                    nl<br />                );<br />                exitif( ebx == quitVerb_c ) mainloop;<br /><br />            else<br /><br />                stdout.put( &quot;illegal word!&quot; nl );<br /><br />            endif;<br /><br />            // Be nice, free the storage associated with<br />            // the current word. We won't free the last<br />            // line input, but that's okay 'cause the<br />            // pgm is about to quit and all storage<br />            // is freed then, anyway.<br /><br />            strfree( tokens[ ecx*4 ] );<br /><br />        endfor;<br /><br /><br />    endfor; end mainloop;<br /><br /><br />    // The destructor calls destroyTable for each node it frees.<br />    // This displays the frequency and text associated with<br />    // each word entered into the table.<br /><br />    tbl.destroy( &amp;destroyTable );<br /><br />end tableDemo;</div>
    <div class="meta">Posted on 2003-11-21 14:07:33 by rhyde</div>
   </div>
   <div class="post" id="post-125067">
    <div class="subject"><a href="#post-125067">HLA Adventure Game Notes</a></div>
    <div class="body">Note on the TokenizeDemo program:<br /><br />As it appears in the HLA referrence, this program will no longer compile with the current version of HLA.<br /><br />Here is the updated version:<br /><br /><pre><code><br />program tokenizeDemo;<br /><br />// changes have been commented<br /><br />#include&#40; &quot;stdio.hhf&quot; &#41;<br />#include&#40; &quot;strings.hhf&quot; &#41;        // &lt;- changed to strings.hhf<br />#include&#40; &quot;memory.hhf&quot; &#41;<br />#include&#40; &quot;stdout.hhf&quot;&#41;         // &lt;- need to include this separately<br /><br />static<br />strings&#58; string&#91;16&#93;;<br />ParseMe&#58; string &#58;= &quot;This string contains five words&quot;;<br /><br />begin tokenizeDemo;<br /><br />str.tokenize&#40; ParseMe, strings &#41;;     // &lt;- source/destination switched positions<br />mov&#40; 0, ebx &#41;;<br />while&#40; ebx &lt; eax &#41; do<br /><br />stdout.put<br />&#40;<br />&quot;string&#91;&quot;,<br />&#40;type uns32 ebx&#41;,<br />&quot;&#93;=&quot;&quot;&quot;,<br />strings&#91;ebx*4&#93;,<br />&quot;&quot;&quot;&quot;,<br />nl<br />&#41;;<br />strfree&#40; strings&#91;ebx*4&#93; &#41;;<br />inc&#40; ebx &#41;;<br />endwhile;<br /><br />end tokenizeDemo;<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-11-21 20:36:53 by Kain</div>
   </div>
   <div class="post" id="post-126329">
    <div class="subject"><a href="#post-126329">HLA Adventure Game Notes</a></div>
    <div class="body">I love how your code works Randall but mine doesn't:)  I was just seeing what i could do, so i tried to write a program that accepts a string from the user and reverses every lexeme in it...... well it works to what i want it to, but if u want to get technical it raises a memory access violation lol....i guess that isn't good, not sure why this is happening maybe i'm trying to print like negative elements in the string....making a problem with memory......not sure tho<br /><br /><br />*Note obvious borrowing of code from randalls code  above:-D*<br /><br /><br /><pre><code><br /><br /><br /><br />program tokenizeDemo;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;;<br />static<br />strings&#58; string&#91;16&#93;;<br />ParseMe&#58; string;<br />begin tokenizeDemo;<br />stdin.a_gets&#40;&#41;;<br />mov&#40;eax,ParseMe&#41;;<br />str.tokenize&#40; ParseMe, strings &#41;;<br />mov&#40;eax,ebx&#41;;<br />dec&#40;ebx&#41;;<br />MoreArrayLeft&#58;<br />cmp&#40;ebx,0&#41;;<br />jnae FinishedArray;<br />stdout.put&#40; ' ' ,strings&#91;ebx*4&#93;&#41;;<br />dec&#40;ebx&#41;;<br />jmp MoreArrayLeft;<br />FinishedArray&#58;<br /><br />end tokenizeDemo;<br /></code></pre></div>
    <div class="meta">Posted on 2003-12-02 18:07:39 by WhiteDwarf</div>
   </div>
   <div class="post" id="post-126334">
    <div class="subject"><a href="#post-126334">HLA Adventure Game Notes</a></div>
    <div class="body">WhiteDwarf,  <br /><br />You can't use the jnae instruction because thats for unsigned comparisons so you should use jnge instead which if for signed comparisons.  0-1 is FFFFF.... which is a positive unsigned number but its negative if you look at it as a signed number. So with jnae 0-1 is greater than zero but with jnge its less than zero. Sorry I couldn't give you a better explanation but hopefully you get the idea :) <br /><br /><pre><code> <br />program tokenizeDemo;<br /><br />#include&#40; &quot;stdlib.hhf&quot; &#41;;<br /><br />static<br /><br />strings&#58; string&#91;16&#93;;<br />ParseMe&#58; string;<br /><br />begin tokenizeDemo;<br /><br />    stdin.a_gets&#40;&#41;;<br />    mov&#40; eax, ParseMe &#41;;<br />    str.tokenize&#40; ParseMe, strings &#41;;<br />    mov&#40; eax, ebx &#41;;<br />    dec&#40; ebx &#41;;<br />MoreArrayLeft&#58;<br />    cmp&#40;  ebx,0 &#41;;<br />    //jnae FinishedArray;<br />    jnge FinishedArray;<br />    stdout.put&#40; ' ' ,strings&#91;ebx*4&#93;&#41;;<br />    dec&#40; ebx &#41;;<br />    jmp MoreArrayLeft;<br />FinishedArray&#58;<br /><br />end tokenizeDemo; <br /></code></pre></div>
    <div class="meta">Posted on 2003-12-02 19:24:41 by Odyssey</div>
   </div>
   <div class="post" id="post-126341">
    <div class="subject"><a href="#post-126341">HLA Adventure Game Notes</a></div>
    <div class="body">lol ohhhh i was thinking that &quot;jnae + jnge&quot; family of similar jumps was kind of unnecessary but now i see, so why is eax signed?</div>
    <div class="meta">Posted on 2003-12-02 20:44:27 by WhiteDwarf</div>
   </div>
   <div class="post" id="post-126376">
    <div class="subject"><a href="#post-126376">HLA Adventure Game Notes</a></div>
    <div class="body"><pre><code> <br />MoreArrayLeft&#58;<br />    cmp&#40;  ebx,0 &#41;;<br />    //jnae FinishedArray;<br />    jnge FinishedArray;<br />    stdout.put&#40; ' ' ,strings&#91;ebx*4&#93;&#41;;<br />    dec&#40; ebx &#41;;<br />    jmp MoreArrayLeft;<br />FinishedArray&#58;<br /></code></pre> <br /><br />Your code stops printing the strings from the array when ebx is less than zero. EBX could only be less than zero if you look at it as a signed number because all unsigned numbers are positive.  There aren't really signed numbers or unsigned numbers, a number is a number. It's up to you to decide if you'll interpret it as signed or unsigned. You should check out the data representation chapter in AOA for better explanations :).</div>
    <div class="meta">Posted on 2003-12-03 04:40:33 by Odyssey</div>
   </div>
  </div>
 </body>
</html>