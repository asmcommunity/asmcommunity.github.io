<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BrowseForFolder procedure from SP2 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=666" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=666">BrowseForFolder procedure from SP2</a></p>
   <div class="post" id="post-4004">
    <div class="subject"><a href="#post-4004">BrowseForFolder procedure from SP2</a></div>
    <div class="body">This is a part of  procedure from second Service Pack for MASM32:<br />======================<br />    .if lpIDList == 0<br />      mov eax, 0      ; if CANCEL return FALSE<br />      push eax<br />      jmp @F<br />    .else<br />      invoke SHGetPathFromIDList,lpIDList,lpBuffer<br />      mov eax, 1        ; if OK, return TRUE   (5 bytes)<br />      push eax<br />      jmp @F<br />    .endif<br /><br />    @@:<br />=======================<br />I think, that it's not optimized at all.<br />I didn't tested, but I think, that my sample will work normal:<br />======================<br />    .if lpIDList == 0<br />      xor eax, eax      ; if CANCEL return FALSE<br />      push eax<br />         ; jmp @F - JUMP not needed<br />    .else<br />      invoke SHGetPathFromIDList,lpIDList,lpBuffer<br />      xor eax,eax                                   ; (2 bytes)<br />      inc eax              ; if OK, return TRUE (1 byte)<br />      push eax<br />        ; jmp @F - JUMP not needed<br />    .endif<br />=======================</div>
    <div class="meta">Posted on 2001-08-17 19:47:24 by MemoBreaker</div>
   </div>
   <div class="post" id="post-4007">
    <div class="subject"><a href="#post-4007">BrowseForFolder procedure from SP2</a></div>
    <div class="body">MemoBreaker, there isn't really any reason to optimize code around<br />an API call... especially not speed optimizations. As for size optimizations,<br />you say this is a proc... so the few bytes you can shave off won't<br />matter much either.</div>
    <div class="meta">Posted on 2001-08-17 20:21:38 by f0dder</div>
   </div>
   <div class="post" id="post-4012">
    <div class="subject"><a href="#post-4012">BrowseForFolder...</a></div>
    <div class="body">But JUMPs in this part of code is not needed! And it's a reason to update this procedure in next MASM32-package/service pack.</div>
    <div class="meta">Posted on 2001-08-17 21:06:05 by MemoBreaker</div>
   </div>
   <div class="post" id="post-4013">
    <div class="subject"><a href="#post-4013">BrowseForFolder procedure from SP2</a></div>
    <div class="body">True, I failed to see the jmp @F, sorry. I should go to bed I guess...<br />tired and struck by influenza...</div>
    <div class="meta">Posted on 2001-08-17 21:12:04 by f0dder</div>
   </div>
   <div class="post" id="post-4205">
    <div class="subject"><a href="#post-4205">BrowseForFolder procedure from SP2</a></div>
    <div class="body"><div class="quote"><br />MemoBreaker, there isn't really any reason to optimize code around<br />an API call... especially not speed optimizations. As for size optimizations,<br />you say this is a proc... so the few bytes you can shave off won't<br />matter much either. </div><br /><br />Code around API calls has absolutly no difference to any other<br />code.<br />Bytes are always bytes, and clock are always clocks.<br />If you think that speed and size are important and have smaller or (and) faster version you are always replace the old version with the new one.<br />It may be just a little better, or much better, but it's always BETTER.</div>
    <div class="meta">Posted on 2001-08-20 05:11:18 by The Svin</div>
   </div>
   <div class="post" id="post-4210">
    <div class="subject"><a href="#post-4210">BrowseForFolder procedure from SP2</a></div>
    <div class="body">Guys,<br /><br />Its a matter of fact that the 2 jumps are not needed, from memory to make the code easier to read after I wrote it, I changed it to .IF syntax and forgot to remove the jumps.<br /><br />Performance is another matter, in the context of an API call, the size increase of 2 jumps is trivial, the block .IF syntax has a jump already there so there is no extra code being executed, just a couple of extra bytes for the two jumps.<br /><br />I pursue speed where it matters, I try for clear code that is reliable other than that, I have seen too many optimisations in the past that were supposed to be genius but did not run so I am inclined to view reliability above that style of optimisation.<br /><br />Like it or not, an API call is very slow alongside assembler instructions so a size or speed optimisation in the presence of an API call is wasted effort, it simply does not matter.<br /><br />The pursuit of &quot;byte perfect&quot; code is a leftover from the DOS days, in win 32 on late model processors, cache, branch prediction, memory access speed, disk IO speed are the things that make code go faster, not nitpicking bytes.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-08-20 06:51:19 by hutch--</div>
   </div>
   <div class="post" id="post-4214">
    <div class="subject"><a href="#post-4214">BrowseForFolder procedure from SP2</a></div>
    <div class="body">Regarding speed and size there is no such a &quot;general&quot; diffinition as &quot;API call&quot;. <br />API functions are very different in metter of speed and size.<br />Among other things is always importent if some particular API func thuncks into kernel mode (cause it itself costs more than 1000 clocks apart from time needed to execute the function itself)<br />And there are API functions that runs only 10 clocks (GetCommandLine for example).<br /><br />About clear coding its very personal opinion - for example for<br />me raw dissasebled code looks clearer than C++ code. For any person &quot;clear code&quot; is the code he can better understand.<br />And more - I don't see any reason why optimized code SHOULD<br />look unclear.<br /><br />Talking of code in std lybraries - what a difference if you don't optimize procedures that use API or doesn't use it - in any case<br />unoptimized code will increase code size in modules that use<br />this proc libraries, and will make it slow.<br /><br />I see that it is very popular point of view on code around API -<br />that if it's near API it not need to be optimized <br />And yet I haven't seen any logical or math explonation why near presence of API function can justify sluppy coding.<br />I think's there just can't be one - or you right optimized code or not - there is nothing special excuse of API around for unoptimized code.<br /><br />I think it because of absence of knowlege and expirience regarding code in API.<br />If we agree that API do a lot of work, then it worth to know how<br />and how long it runs, cause neither processor no user know if your program fast or slow because of yourown code or API -<br />for processor it's just chain of instructions, for the user it's just time taken to perform some work, size taken on harddrive and memory needed to run.</div>
    <div class="meta">Posted on 2001-08-20 07:45:21 by The Svin</div>
   </div>
   <div class="post" id="post-4267">
    <div class="subject"><a href="#post-4267">BrowseForFolder procedure from SP2</a></div>
    <div class="body">I agree, that pair of bytes do not influence speed in the given example. But If always add two bytes to each procedure, assembly code will be bigger than in other programming languages...  :)</div>
    <div class="meta">Posted on 2001-08-20 17:25:46 by MemoBreaker</div>
   </div>
   <div class="post" id="post-6593">
    <div class="subject"><a href="#post-6593">BrowseForFolder procedure from SP2</a></div>
    <div class="body">I think Hutch's point is well taken.  What he means if I'm not mistaken is that the execution time of the api calls swamps the relatively short time of the inline (Masm) code - in most cases.  The few clocks you might save by hand optimizing that section of code for speed will not constitute a large enough percentagee of the OVERALL execution time of that section.  The time it takes to do the optimization for such a small speed gain amounts to nitpicking.<br /><br />If the cpu spends over 1000 clocks in the api call shaving off 100 clocks (a considerable feat) would reduce the execution time by less than 10%.  Noone would suggest testing each api call to see how many clocks it uses because the typicall code using the api is sufficient.<br /><br />Speed optimization generaly woon't be noticeable anyway in simple &quot;one-time only&quot; code.  Where it really comes into play is in looping code and iteratively processing array type structures.  But then again if there is an api call in the loop...  <br /><br />However one can and should always try to minimize code size except of course where it would interfere with existing speed optimizations.</div>
    <div class="meta">Posted on 2001-09-08 09:35:19 by gfalen</div>
   </div>
   <div class="post" id="post-6627">
    <div class="subject"><a href="#post-6627">BrowseForFolder procedure from SP2</a></div>
    <div class="body">gfalen: and when you can shave off less than 100 cycles... who cares.<br />Optimize where it matters :)</div>
    <div class="meta">Posted on 2001-09-08 17:50:46 by f0dder</div>
   </div>
   <div class="post" id="post-6831">
    <div class="subject"><a href="#post-6831">BrowseForFolder procedure from SP2</a></div>
    <div class="body">The important thing to remeber is that we are talking of std library<br />procedure.<br />That means that size and speed of the procedure affect not one<br />module but all the modules that use it.<br />Comulative effect of size and speed.<br />Lots of slow apps can blame for it just a few akward proc from (for example) C library. Rewrite those procs and recompile all projects and it will make not one but all those procs faster.<br />It's so obvious for me that I didn't even answer to childish boolshit when one stated that it didn't worth it to spend time for<br />fastest algo to convert value to string 'cause (he said) one number doesn't worth it. Of course such algos are made to convert as many millions numbers as programmers need. Not one.<br />The same about optimization of any standart purpose proc.<br />If you don't care to do the optimization - it's up to you - do what you want. But be at least reasonable not blaming other people for the &quot;unworthy optimization job&quot; they are doing for.<br />Some times I almost shocked that ones could even declare those<br />who do optimization for free &quot;gilty!&quot;.<br /> They do things better , not worse - it's clear.<br />So if you don't - it's fine - but at least don't buzzzzzz about what have or doesn't have point.<br />Zero if canceled, not zero if the user has chosen a folder:<br /><pre><code><br />======================<br />; #########################################################################<br /><br />    .386<br />    .model flat, stdcall  ; 32 bit memory model<br />    option casemap &#58;none  ; case sensitive<br /><br />    include \masm32\include\windows.inc<br />    include \masm32\include\shell32.inc<br />    include \masm32\include\user32.inc<br />    include \masm32\include\ole32.inc<br /><br />    cbBrowse  PROTO<br /><br />    .code<br /><br />; #########################################################################<br /><br />BrowseForFolder proc hParent&#58;DWORD, lpBuffer&#58;DWORD, lpTitle&#58;DWORD, lpString&#58;DWORD<br /><br />  ; ------------------------------------------------------<br />  ; hParent  = parent window handle<br />  ; lpBuffer = 260 byte buffer to receive path<br />  ; lpTitle  = zero terminated string with dialog title<br />  ; lpString = zero terminated string for secondary text<br />  ; ------------------------------------------------------<br /><br />    LOCAL lpIDList &#58;DWORD<br />    LOCAL bi  &#58; BROWSEINFO<br /><br />    mov eax,                hParent         ; parent handle<br />    mov bi.pidlRoot,        0<br />    mov bi.hwndOwner,       eax<br />    mov bi.pszDisplayName,  0<br />    mov eax,                lpString        ; secondary text<br />    mov bi.ulFlags,         BIF_RETURNONLYFSDIRS or BIF_DONTGOBELOWDOMAIN<br />    mov bi.lpszTitle,       eax<br />    mov eax,                lpTitle         ; main title<br />    mov bi.lpfn,            offset cbBrowse<br />    mov bi.lParam,          eax<br />    mov bi.iImage,          0<br />  <br />    invoke SHBrowseForFolder,ADDR bi<br />	test eax,eax<br />	push eax<br />	je    @F<br />	invoke SHGetPathFromIDList,eax,lpBuffer<br />@@&#58;	<br />    	call CoTaskMemFree<br />	mov eax,&#91;esp-4&#93;<br />    	ret<br /><br />BrowseForFolder endp<br /><br />; #########################################################################<br /><br />cbBrowse proc<br /><br />    invoke SetWindowText,&#91;esp+8&#93;,&#91;esp+16&#93;<br /><br />    ret 16<br /><br />cbBrowse endp<br /><br />; #########################################################################<br /><br />end<br /></code></pre></div>
    <div class="meta">Posted on 2001-09-10 23:29:44 by The Svin</div>
   </div>
   <div class="post" id="post-6888">
    <div class="subject"><a href="#post-6888">BrowseForFolder procedure from SP2</a></div>
    <div class="body">I agree with The Svin,<br />The good programming style is important for me rather<br />processors, cache, memory access speed, disk IO speed, etc<br />because that is HARDWARE and we are ASSEMBLY programmers rather JAVA, C++/bla bla programmers....<br />If you don't agree you can delete the book of Agner Fog<br />from your computer and start coding in #C or VB...</div>
    <div class="meta">Posted on 2001-09-11 17:23:27 by buliaNaza</div>
   </div>
   <div class="post" id="post-6897">
    <div class="subject"><a href="#post-6897">BrowseForFolder procedure from SP2</a></div>
    <div class="body">I guess it depends on what you consider important, out of date DOS style code where nitpicking bytes is the achievement or objectively measured performance that can be seen in working and living applications.<br /><br />If the performance considerations of cache, disk IO speed, memory access speed, processor capacity and similar do not matter as long as the code is DOS style byte perfect, why bother at all, join the script kiddies where performance is not a consideration and feel profound at scripting.<br /><br />Much of the reason why the programming world at large sees assembler as irrelevant is because much of what is written as assembler IS irrelevant. When you can confront the world with a dialogue box loading routine that is 1 cycle faster, the programming world at large will die laughing.<br /><br />Introspecting at you naval may feel good but if you want to make a dent in the programming community at large, you will do it with sheer performance.<br /><br />Nothing stings like sheer speed and it is not without purpose, as modern computers get bigger and faster, so do the tasks that are being solved by programmers and while many of the modern languages use this increase in power to cover up its templating style of coding, its good old fashioned low level procedural coding that does the hard stuff at competitive speeds.<br /><br />This is where assembler has a lot to offer as it can actually deliver the performance required but messing around with irrelevancies fails to capture the real advantage of assembler. Saving a single byte here and there will not deliver the performance gains needed to handle ever increasing demands for performance where cache, processor, disk IO, opcode choice and algorithm design will.<br /><br />I opt for the latter, have PHUN with the nitpicking.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-09-11 20:13:00 by hutch--</div>
   </div>
   <div class="post" id="post-6903">
    <div class="subject"><a href="#post-6903">BrowseForFolder procedure from SP2</a></div>
    <div class="body">Masm is good, but not very good for good optimization because of the jmp/call thing every time to invoke.<br /><br />Just my oppinion though...</div>
    <div class="meta">Posted on 2001-09-11 22:01:59 by Kenny</div>
   </div>
   <div class="post" id="post-6914">
    <div class="subject"><a href="#post-6914">BrowseForFolder procedure from SP2</a></div>
    <div class="body">Hutch,<br />I respect your opinion but prefer Agner Fog...Sorry!<pre><code><br /><br />How to optimize for the Pentium family of microprocessors<br />Copyright ? 1996, 2000 by Agner Fog. Last modified 2000-03-31. <br /><br /><br />23. Reducing code size &#40;all processors&#41;<br />As explained in chapter 7, the code cache is 8 or 16 kb. If you have problems keeping the critical parts of your code within the code cache, then you may consider reducing the size of your code. <br />32 bit code is usually bigger than 16 bit code because addresses and data constants take 4 bytes in 32 bit code and only 2 bytes in 16 bit code. However, 16 bit code has other penalties such as prefixes and problems with accessing adjacent words simultaneously &#40;see chapter 10.2 above&#41;. Some other methods for reducing the size or your code are discussed below. <br /><br />Both jump addresses, data addresses, and data constants take less space if they can be expressed as a sign-extended byte, i.e. if they are within the interval from -128 to +127. <br /><br />For jump addresses this means that short jumps take two bytes of code, whereas jumps beyond 127 bytes take 5 bytes if unconditional and 6 bytes if conditional. <br /><br />Likewise, data addresses take less space if they can be expressed as a pointer and a displacement between -128 and +127. Example&#58;<br /><br />MOV EBX,DS&#58;&#91;100000&#93; / ADD EBX,DS&#58;&#91;100004&#93; ; 12 bytes<br />Reduce to&#58;<br />MOV EAX,100000 / MOV EBX,&#91;EAX&#93; / ADD EBX,&#91;EAX+4&#93; ; 10 bytes <br /><br />The advantage of using a pointer obviously increases if you use it many times. Storing data on the stack and using EBP or ESP as pointer will thus make your code smaller than if you use static memory locations and absolute addresses, provided of course that your data are within +/-127 bytes of the pointer. Using PUSH and POP to write and read temporary data is even shorter. <br /><br />Data constants may also take less space if they are between -128 and +127. Most instructions with immediate operands have a short form where the operand is a sign-extended single byte. Examples&#58; <br /><br />    PUSH 200      ; 5 bytes<br />    PUSH 100      ; 2 bytes<br /> <br />    ADD EBX,128   ; 6 bytes<br />    SUB EBX,-128  ; 3 bytes<br />The most important instruction with an immediate operand which doesn't have such a short form is MOV.<br />Examples&#58; <br /><br />    MOV EAX, 0              ; 5 bytes<br />May be changed to&#58;<br /><br />    XOR EAX,EAX             ; 2 bytes<br />And <br />    MOV EAX, 1              ; 5 bytes<br />May be changed to&#58; <br />    XOR EAX,EAX / INC EAX   ; 3 bytes<br />or&#58; <br />    PUSH 1 / POP EAX        ; 3 bytes<br />And <br />    MOV EAX, -1             ; 5 bytes<br />May be changed to&#58; <br />    OR EAX, -1              ; 3 bytes<br />If the same address or constant is used more than once then you may load it into a register. A MOV with a 4-byte immediate operand may sometimes be replaced by an arithmetic instruction if the value of the register before the MOV is known. Example&#58; <br /><br />        MOV     &#91;mem1&#93;,200             ; 10 bytes<br />        MOV     &#91;mem2&#93;,200             ; 10 bytes<br />        MOV     &#91;mem3&#93;,201             ; 10 bytes<br />        MOV     EAX,100                ;  5 bytes<br />        MOV     EBX,150                ;  5 bytes<br />Assuming that mem1 and mem3 are both within -128/+127 bytes of mem2, this may be changed to&#58; <br /><br />        MOV     EBX, OFFSET mem2       ;  5 bytes<br />        MOV     EAX,200                ;  5 bytes<br />        MOV     &#91;EBX+mem1-mem2&#93;,EAX    ;  3 bytes<br />        MOV     &#91;EBX&#93;,EAX              ;  2 bytes<br />        INC     EAX                    ;  1 byte<br />        MOV     &#91;EBX+mem3-mem2&#93;,EAX    ;  3 bytes<br />        SUB     EAX,101                ;  3 bytes<br />        LEA     EBX,&#91;EAX+50&#93;           ;  3 bytes<br />Be aware of the AGI stall in the LEA instruction &#40;for PPlain and PMMX&#41;. <br /><br />You may also consider that different instructions have different lengths. The following instructions take only one byte and are therefore very attractive&#58; PUSH reg, POP reg, INC reg32, DEC reg32.<br />INC and DEC with 8 bit registers take 2 bytes, so INC EAX is shorter than INC AL. <br /><br />XCHG EAX,reg is also a single-byte instruction and thus takes less space than MOV EAX,reg, but it is slower. <br /><br />Some instructions take one byte less when they use the accumulator than when they use any other register. <br />Examples&#58; <br /><br />    MOV EAX,DS&#58;&#91;100000&#93;  is smaller than  MOV EBX,DS&#58;&#91;100000&#93;<br />    ADD EAX,1000         is smaller than  ADD EBX,1000<br />Instructions with pointers take one byte less when they have only a base pointer &#40;not ESP&#41; and a displacement than when they have a scaled index register, or both base pointer and index register, or ESP as base pointer. <br />Examples&#58; <br /><br />    MOV EAX,&#91;array&#93;&#91;EBX&#93;  is smaller than  MOV EAX,&#91;array&#93;&#91;EBX*4&#93;<br />    MOV EAX,&#91;EBP+12&#93;      is smaller than  MOV EAX,&#91;ESP+12&#93;<br />Instructions with EBP as base pointer and no displacement and no index take one byte more than with other registers&#58; <br /><br />    MOV EAX,&#91;EBX&#93;    is smaller than  MOV EAX,&#91;EBP&#93;,  but<br />    MOV EAX,&#91;EBX+4&#93;  is same size as  MOV EAX,&#91;EBP+4&#93;.<br />Instructions with a scaled index pointer and no base pointer must have a four byte displacement, even when it is 0&#58; <br /><br />    LEA EAX,&#91;EBX+EBX&#93;  is shorter than  LEA EAX,&#91;2*EBX&#93;. </code></pre></div>
    <div class="meta">Posted on 2001-09-11 23:49:38 by buliaNaza</div>
   </div>
   <div class="post" id="post-6915">
    <div class="subject"><a href="#post-6915">BrowseForFolder procedure from SP2</a></div>
    <div class="body">buliaNaza,<br /><br />I will let you in on a little secret, I produced the Winhelp format file for Agner Fog because the research he has done is so important to assembler programming.<br /><br />The section of his work that you quoted does not address the original problem reported here, 2 non executed jumps in a piece of API code and there relevance to code execution speed.<br /><br />Its relevance to cache size is lost when you apply it to an API call as it is a set of procedures in the system DLLs that are much larger than the code you are executing.<br /><br />The reference work you quote is an area that is well known, there are good opcode lists available that give you the byte size but assuming that smaller code in byte count is faster is a mistake, there is a lot more to code speed than nitpicking bytes, considerations like instruction choice, order and fundamental algorithm design are the things that effect the speed of code.<br /><br />The only objective test is the clock and there is no immediate correlation between pre built theories and the time taken to execute code.<br /><br />On an effort to time basis, I will always give priority to code that requires performance over code that does not matter. I would rather have a fast algorithm than a nitpicked piece of API code that does not run any faster.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-09-12 02:05:56 by hutch--</div>
   </div>
   <div class="post" id="post-6931">
    <div class="subject"><a href="#post-6931">BrowseForFolder procedure from SP2</a></div>
    <div class="body"><div class="quote">The section of his work that you quoted does not address the original problem reported here, 2 non executed jumps in a piece of API code and there relevance to code execution speed. </div> <br />Steve, I respect you very much so let me be honest :)<br />Those &quot;2 non executed jumps &quot; were a piece of stupidity :)<br />which we all do from time to time when we are tired or in a harry.<br />In similar case if somebody points out to such things for me I always say: &quot;Thanks, friend, I did a mistake&quot;. And really mean it :)<br />What I don't understand is why f0dder started on MemoBreaker when MemoBreaker pointed out to obvious mistake.<br />Correcting the mistake would not do revolution of course but it at least does:<br />1. Code clearer 'cause those jmps look wierd<br />2. A little shorter<br />3. Microscopically faster.<br />And to do it you need 1 second which I think is at least 1000 times smaller that time spent in thith thead for useless talks.<br />I absolutly don't understand what's wrong MemoBreaker'h done<br />I think, he just helped.(talking of friendly forum ;)<br /><br /><br />As for the rest what I hate of these philosopical talk that nodody give himself job to count and time before started spread his ideas.<br /><br />For example I am almost sure that none of discussers take a job<br />to check size of old and new version of the proc and perform some comparation and calculation before having started talks.<br /><br />We are doing intellegent job, a partionally sientific.<br />And needed to be up to scratch, armed with data,real and not imaginary data before final conculsion.</div>
    <div class="meta">Posted on 2001-09-12 07:22:29 by The Svin</div>
   </div>
   <div class="post" id="post-6932">
    <div class="subject"><a href="#post-6932">BrowseForFolder procedure from SP2</a></div>
    <div class="body">Alex,<br /><br />I have already agreed that the two jumps were not necessary and I have no criticism about MemoBreaker for either finding the mistake or posting it, my complaint has been about the importance of such a mistake, effectively changing a piece of code and forgetting to take out 2 unused jumps.<br /><br />My comment has been that the omission is trivial and that the importance placed in removing them is not proportional to the lack of any reasonable gain. I am currently working on sort algorithms as I see them useful for assembler programmers where I see byte nitpicking as useless.<br /><br />It is as I have said, a time based priority, I would prefer to work on worthwhile algorithms than saving 2 jumps that were not used. It is as simple as that. Next time I get time to play with the dialog boxes, I may remove the extra jumps if I remember but it will be for no speed gain whatsoever, only to try and make the code clearer to read for someone who is looking at how its done.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a><br /><br />PS, if you have time, would you post the last qword to ascii conversion as a file as my netscape messes up the display of code posted inbetween the code tags. Commenting for people to read would be appreciated.</div>
    <div class="meta">Posted on 2001-09-12 07:54:34 by hutch--</div>
   </div>
   <div class="post" id="post-7079">
    <div class="subject"><a href="#post-7079">BrowseForFolder procedure from SP2</a></div>
    <div class="body">Yes, Steve, I understand.<br />And I very proud of you for the last tasks you work.<br />There are still a lot of asm programmers but even searching<br />through whole inet you can find just a few who try chellenge a<br />classical jeneral purpose tasks.<br />From my point of view those tasks and NEW algos peforming them  have FUNDAMENTAL uncompareble value to all creative, thinkable programmers world.<br />The rest are just users no matter what do they think of themself and what their official speciality.<br />Actually ,I don't like words for me to be remembered as &quot;optimization&quot; or<br />&quot;implementation&quot;. First of all I wish to be an inventor and  a creator.<br />The same way I want to think of you.<br />And hope buliaNaza will make us huppy also with NEW ideas.<br />So wish good luck to you with your job and want you remember that I think that though not too many people will applode it - I personally<br />think this work is one of the most important job in general programming.<br /> Not nice pictures of fancy controls can let feel real good asm programs - only hard and lenthy tasks such as compessions, searching whole disk for files with given words in, games and database processing .ect are real jobs with real chellenge.<br />Talking of fast hardware to justify bad programming is absolute boolshit 'cause ANYBODY who professionaly use PC can name hundred of tasks wich make them wait seconds and minutes and hours.<br /> If fact, avaredge nowdays software is so slow that usual users<br />having tried those tasks once and having suffered waiting those<br />turtles to make a job usually forget about the task for the future.<br />This way software provoke users degradation.<br />I don't understand what happens to PC M$ world. <br />'Cause in other computer world there still a lot of carefull programming including assembly.<br /><br />That's why I deleberatly distanced myself from usual Win32Asm<br />topics, and choose to discuss basics of common programming blocks realization in asm32. I don't consider myself an expert but I was almost shocked that a lot people here expirienced as in general programmers did not know even basics of using assembly.<br /><br />I say it once again:<br />before anybody use anything somebody needs to create it.<br />And of course this &quot;somebody&quot; is a real man, and there always<br />other real man who can try to solve the task in other better way and it is named &quot;progress&quot;. <br />So I buffled - why the progress almost stoped in PC algorithm research in assembly?<br />Really there are just a few people of the world of MILLIONS PC programmers who tried to move progress.<br />Taking the job - you're one of the few.<br />Good luck!</div>
    <div class="meta">Posted on 2001-09-14 01:00:33 by The Svin</div>
   </div>
   <div class="post" id="post-7109">
    <div class="subject"><a href="#post-7109">BrowseForFolder procedure from SP2</a></div>
    <div class="body">This sounds like a topic for the Crusades!<br /><br />However, I do agree with The Svin--most asm programmers write just as bad code in asm as they do in C++. The whole purpose of using asm is to optimize the programs to run faster, not use asm to think you're getting some sort of speed increase. Like it or not, most compilers optimize the code as it's compiled, and it will actually run faster than readable asm code generated by humans. However, readable, like The Svin said, is a matter of opinion...<br /><br />I guess what I'm trying to say is: asm programming gives the person an oppertunity to optimize code, not because of programming in asm makes the code faster by default.</div>
    <div class="meta">Posted on 2001-09-14 11:43:33 by Kenny</div>
   </div>
  </div>
 </body>
</html>