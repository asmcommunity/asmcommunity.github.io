<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Winsock File transfer - buffer to file - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29233" />
  <link rel="prev" href="../?id=29233&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29233">Winsock File transfer - buffer to file</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29233&amp;page=1" style="">&laquo;</a><a href="../?id=29233&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29233" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-206535">
    <div class="subject"><a href="#post-206535">Re: Winsock File transfer - buffer to file</a></div>
    <div class="body">You really need to do file setup and memory allocation <strong>outside</strong> your SocketGetfile in case you&#039;re responding to a FD_READ event - otherwise you&#039;re going to keep overwriting the file data.<br /><br />Try starting with a simple blocking socket and no events, and try the following code snippet. If that works, we can move on to some proper program structure and event-based handling. Written off top of my head, not tested btw :)<br /><pre><code><br />SocketGetFile PROC<br />	invoke CreateFile, addr lpszDiskFile, GENERIC_WRITE, FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL<br />	.if eax == INVALID_HANDLE_VALUE<br />		MessageBox, 0, addr szErr1, addr szErr1, MB_OK<br />		ret<br />	.endif<br />	mov		esi, eax<br /><br />	invoke	GetProcessHeap<br />	invoke	HeapAlloc, eax, 0, MEMSIZE<br />	mov		edi, eax<br /><br />@@doTheFunkyLoop:<br />	invoke	recv, , edi, MEMSIZE, 0<br /><br />	.if sdword ptr eax &lt; 0<br />		; note: memory + file handle leak<br />		MessageBox, 0, addr szErr2, addr szErr2, MB_OK<br />		ret<br />	.endif<br />	.if eax &gt; 0<br />		invoke WriteFile, esi, edi, eax, addr fwritten, NULL<br />		jmp @@doTheFunkyLoop<br />	.endif<br /><br />	invoke	GetProcessHeap<br />	invoke	HeapFree, eax, 0, edi<br />	invoke	CloseHandle, esi<br />	ret<br />SocketGetFile ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2008-12-18 13:27:12 by f0dder</div>
   </div>
   <div class="post" id="post-206536">
    <div class="subject"><a href="#post-206536">Re: Winsock File transfer - buffer to file</a></div>
    <div class="body">Thank you for your reply! Your code works wonders on a blocking socket (apart from some missing &quot;invoke&quot;s)<br /><br />What&#039;s the main difference between using GlobalAlloc and GetProcessHeap?<br /><br />According to MSDN GlobalAlloc &quot;Allocates the specified number of bytes from the heap.&quot; while GetProcessHeap &quot;Retrieves a handle to the heap of the calling process. This handle can then be used in subsequent calls to the heap functions.&quot;<br /><br />Pardon my minor knowledge of english and/or my tired brain. But I did not understand the wizzy wizzy tech talk. Or at least not what the difference is.<br /><br />I really appreciate your help guys, you are champs!</div>
    <div class="meta">Posted on 2008-12-18 14:15:38 by n1mda</div>
   </div>
   <div class="post" id="post-206537">
    <div class="subject"><a href="#post-206537">Re: Winsock File transfer - buffer to file</a></div>
    <div class="body">Local* and Global* functions are deprecated leftovers from the 16-bit days of Win3.x - new code should be written using the Heap* functions instead. On NT, Local* and Global* point to the same functions, and end up calling Heap* anyway.<br /><br /><u><em>GetProcessHeap()</em></u> returns the current process heap (which is a &quot;pseudo-handle&quot; on all windows versions I know of, but you should still call the function for future compatibility - it&#039;s not like it costs a lot of time anyway). This handle is required for the rest of the Heap* functions.<br /><br />Now, as for event-based async sockets, I&#039;m going for a little explanation and pseudo-code, since writing a proper example takes too much time :)<br /><br />First off, you will want a per-connection struct with the info you need. This would be State (not connected, connected, error - perhaps more, depending on your needs), probably a BufferPtr, probably a hFile, a Socket, perhaps a Type indicator.<br /><br />You&#039;ll want to allocate an array of these, with <strong>MAXIMUM_WAIT_OBJECTS</strong> entries. If you want to handle a lot of sockets, make each entry a linked-list or other dynamically growing data structure (and keep track of each pool size, distributing connections evenly across this pool).<br /><br />Depending on your needs, either reserve slot 0 as a &quot;program shutdown&quot; even, or specify a timeout on your <u><em>WaitForMultipleObjects()</em></u> and check a global &quot;shuttingDown&quot; flag.<br /><br />Create your sockets in async mode, set up Connection structure (with &quot;unconnected&quot; state), allocate buffers, hFile and whatever other state you need, and use <u><em>WSAEventSelect()</em></u> to associate the socket with the EVENT for the slot you assign the connection to.<br /><br />When <u><em>WaitForMultipleObjects()</em></u> returns &gt;= WAIT_OBJECT_0, loop through <em>all the sockets</em> for the givent event slot and call <u><em>WSAEnumNetworkEvents()</em></u> for each socket, to check whether to process this socket or not.<br /><br />When calling <u><em>recv()</em></u> on a (nonblocking) socket, remember that 0 means &quot;connection closed gracefully&quot;, and that you need processing for <strong>SOCKET_ERROR</strong> - even if <u><em>WSAEnumNetworkEvents()</em></u> signalled that the socket has an event. Call <u><em>WSAGetLastError()</em></u> and check for <strong>WSAEWOULDBLOCK</strong> and <strong>WSAEALREADY</strong> which are non-fatal, and mean you should retry operation next time you get the event.<br /><br />And umm... that&#039;s basically it. Try implementing the above pseudo-code and I&#039;ll try finding the time to give you a hand with problems. Remember that memory allocation, file creation etc. happens <strong>outside</strong> the connection-handler.<br /></div>
    <div class="meta">Posted on 2008-12-18 14:47:19 by f0dder</div>
   </div>
   <div class="post" id="post-206539">
    <div class="subject"><a href="#post-206539">Re: Winsock File transfer - buffer to file</a></div>
    <div class="body">I see. It seems that the guides that I&#039;ve been using for memory allocation is a bit outdated.<br /><br />I will try to implement your pseudo-code, though it&#039;d probably take a while. I&#039;ve so far only been working with events, not objects. I&#039;ve been googling a bit but havn&#039;t found what the difference is between the two. I know that events is obviously events and objects is objects. But what&#039;s the better one to use.<br /><br />My needs are quite simple. The program needs to be notified if the socket is closed (in any way) so it can reconnect.<br /><br />I&#039;ll go back to the drawing board and figure out if I need multiple sockets. Perhaps for multiple files and other socket functions while files are transfering.</div>
    <div class="meta">Posted on 2008-12-19 13:20:16 by n1mda</div>
   </div>
   <div class="post" id="post-206540">
    <div class="subject"><a href="#post-206540">Re: Winsock File transfer - buffer to file</a></div>
    <div class="body">Event is an object. If you&#039;re refering to the &quot;WaitForMultipleObjects&quot; name, then -for the purpose of your application- I can tell you that it could as well be named &quot;WaitForMultipleEvents&quot;. Whole Windows OS is event-driven. Everything just waits for something and acts when particular event occurs. Try to see it this way ^^</div>
    <div class="meta">Posted on 2008-12-19 17:32:30 by ti_mo_n</div>
   </div>
   <div class="post" id="post-206549">
    <div class="subject"><a href="#post-206549">Re: Winsock File transfer - buffer to file</a></div>
    <div class="body">Not to beat a dead horse, but I would assume the reason your early versions were not working was because you were leaving out the ADDR directive for each instance of &#039;buff_sock&#039; (except the one you commented out, RtlZeroMemory).<br /><br />Homer,<br />Calling NULL - Zero tends to be one of my pet pieves. Reason being that 0xBFFF4332 could very well be NULL. NULL isn&#039;t a value or an indentifier as much a description of a common occurance in programming. A NULL is properly defined as a &quot;void pointer to zero&quot;, which means that any value that dereferences to zero is NULL. I get so annoyed when I see Assembly programmers using the equate NULL all over the place as a substitute for zero when they should know better. (you should know better) O o . :p<br /><br />But that&#039;s just my two cents.</div>
    <div class="meta">Posted on 2008-12-22 20:59:30 by Synfire</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29233&amp;page=1" style="">&laquo;</a><a href="../?id=29233&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29233" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>