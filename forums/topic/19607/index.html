<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Stack variables alignment - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19607" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19607">Stack variables alignment</a></p>
   <div class="post" id="post-150953">
    <div class="subject"><a href="#post-150953">Stack variables alignment</a></div>
    <div class="body">I know there is align directive in MASM for aligning variables in .data and .data? segments, but is it possible to align variables on the stack when LOCAL statement is used?</div>
    <div class="meta">Posted on 2004-10-05 10:44:21 by Mikky</div>
   </div>
   <div class="post" id="post-150963">
    <div class="subject"><a href="#post-150963">Stack variables alignment</a></div>
    <div class="body">Hi Mikky,<br /><br />It looks like that by default, MASM aligns the stack to DWORD<br /><pre><code><br />.code<br />start&#58;<br />        call main<br />        invoke ExitProcess,0<br />main PROC<br />        LOCAL var&#91;6&#93;&#58;BYTE ; not a multiple of 4 the DWORD alignment value<br />        mov var,1<br />        ret<br />main ENDP<br />END start<br /></code></pre><br /><br />Disassembly of code<br /><pre><code><br /> start&#58;<br />                                   call   loc_0040100c<br />                                   push   00h<br />                                   call   _ExitProcess<br />              ;                                   XREFS First&#58; 1000&#58;00401000 Number &#58; 1<br />              loc_0040100c&#58;<br />                                   push   ebp<br />                                   mov    ebp, esp<br />                                   add    esp, -08h ; DWORD alignment<br />                                   mov    byte ptr &#91;ebp-06h&#93;, 01h<br />                                   leave  <br />                                   ret<br /></code></pre></div>
    <div class="meta">Posted on 2004-10-05 13:14:01 by Vortex</div>
   </div>
   <div class="post" id="post-150968">
    <div class="subject"><a href="#post-150968">Stack variables alignment</a></div>
    <div class="body">hi mikky<br />i feel it is possible to align local stack variables.<br />i have never tried this but the logic behind wat i feel is that<br />element of structure, an array or even particular variables must be aligned by addresses that are multiples of a specific power of 2 but since the stack top pointer is undefined in any compiler hence the compiler does not know the index value.For this it has a trick to overcome the problem.it just discards the lower order bits esp register.<br /><br />as u must have known local variales are addressed by negative offsets.<br />like if u see in older disassemblers u ll find stack variable like this<br />add esp, <br />and in debuggers as add esp, fffffffc<br />however, modern disassemblers like ida omits the minus sign and gives names to local variables.this creates a big mess however, because the smallest index of an aray is at smaller address, but it is addressed by a larger offset relative to the pointer register of the stack frame.<br /><br />i feel i am diverting so lets get back to know how ida just escapes showing messy big hex no.(however it  creates another big mess.)now u might ask, how does it align local stack variables???<br /><br />well, compiler does not know the index value.For this it has a trick to overcome the problem.it just discards the lower order bits esp register.<br />the lower order bit of an even no. is 0.to ensure that the value of the stack top varianle is divisible by 2 without a remainder, it just simply forces the lower order bits to 0.now, if 2 lower order bits are set to 0, the resulting value will be a multiple of four.If 3 lower order bits are set to 0, then it ll be a multiple of eight and so on.<br />in most cases bits are reset using and instruction.For example <br />and esp, fffffff0<br />makes esp a multiple of 16.how??just convert fffffff0 to its binary form.<br />it is 11111111 11111111 11111111 11110000<br />the 4 zeros means that four lower order bits of any no. will be masked.<br />the no. will divisible by 2 to power of 4, which is 16<br /><br /><br />If i have not misunderstood u i guess this is ur answer else please correct me.<br />thank you <br />nickdigital</div>
    <div class="meta">Posted on 2004-10-05 14:55:53 by nickdigital</div>
   </div>
   <div class="post" id="post-150969">
    <div class="subject"><a href="#post-150969">Stack variables alignment</a></div>
    <div class="body">Hey guys,<br />Vortex I think you are right about MASM always allocates 4byte divisable <br />memory on the stack, but it appears to me that variables are not starting on the 4byte boundary.<br /><br />So let's suppose we dont mess with esp and ebp registers, and that they always point on the memory that is dword aligned.<br />to put it simply my problem, let's consider this snippet<br /><pre><code><br />DummyProc 	proc<br />LOCAL	a&#58;byte<br />LOCAL	b&#58;byte	<br /><br />	mov a,1<br />	mov b,2<br />	ret<br /><br />DummyProc  endp<br /></code></pre><br /><br />Here MASM will generate stack buffer of 4 bytes even though I need only two, but what I need is to have &quot;a&quot; and &quot;b&quot; variables aligned on the 4 byte boundary. This means in my pseudo disassembly, stack will look like this<br /><br /><pre><code><br />1000&#58;     LOCAL a&#58;byte<br />1001&#58;     dummy byte<br />1002&#58;     dummy byte<br />1003&#58;     dummy byte<br />1004&#58;     LOCAL b&#58;byte<br />1005&#58;     dummy byte<br />1006&#58;     dummy byte<br />1007&#58;     dummy byte<br /></code></pre><br /><br />but this is not how MASM generates the code, instead it will be like this<br /><pre><code><br />1000&#58;     LOCAL a&#58;byte<br />1001&#58;     LOCAL b&#58;byte<br />1002&#58;     dummy byte<br />1003&#58;     dummy byte<br /></code></pre><br /><br />So, variable &quot;b&quot; starts exactly 1 byte after var &quot;a&quot;, so if &quot;a&quot; is dword aligned &quot;b&quot; will not be.<br /><br /><br />In case someone asks why I need all this, it's because of the performance and also in some rare cases API's will just return error if you don't provide them buffer that starts on the dword alignment.</div>
    <div class="meta">Posted on 2004-10-05 16:57:52 by Mikky</div>
   </div>
   <div class="post" id="post-150974">
    <div class="subject"><a href="#post-150974">Stack variables alignment</a></div>
    <div class="body">hey mikky<br />&quot;variables are not starting on the 4byte boundary.&quot;<br /><br />i dont agree to this.why??? the reason is given below.<br /><br />i forgot to add that if 2 lower order bits are set to 0, the resulting value will be a multiple of 4 (which is a minimal value as for all 32 bits computers have minimal 4 bytes boundary limit ).<br /><br />one more thing, as u pointed out <br /><br />&quot;So, variable &quot;b&quot; starts exactly 1 byte after var &quot;a&quot;, so if &quot;a&quot; is dword aligned &quot;b&quot; will not be. &quot;<br /><br />i guess the esp value has nothing to do with that. it stores the boundry value under which all variables can come.its 4 bytes minimally <br />however as u have tried compiling the code <br /><pre><code><br />DummyProc proc <br />LOCAL a&#58;byte <br />LOCAL b&#58;byte <br /><br />mov a,1 <br />mov b,2 <br />ret <br />DummyProc endp <br /></code></pre><br />u must notice the add esp, fffffffch in the dissassembly. which means that since ur local variables are under the 4 bytes boundary limit hence it show just add -4h bytes to ebp and store it in esp(fffffffch which means -4h bytes.)<br />dasm of ur code<br /><pre><code><br />.text&#58;00401000                 public start<br />.text&#58;00401000 start           proc near<br />.text&#58;00401000<br />.text&#58;00401000 var_2           = byte ptr -2<br />.text&#58;00401000 var_1           = byte ptr -1<br />.text&#58;00401000<br />.text&#58;00401000                 push    ebp<br />.text&#58;00401001                 mov     ebp, esp<br />.text&#58;00401003                 add     esp, 0FFFFFFFCh &lt;---this is i am talking about<br />.text&#58;00401006                 mov     &#91;ebp+var_1&#93;, 1        <br />.text&#58;0040100A                 mov     &#91;ebp+var_2&#93;, 2<br />.text&#58;0040100E                 leave<br />.text&#58;0040100F                 retn<br />.text&#58;0040100F start           endp<br />.text&#58;0040100F<br /></code></pre><br />however if u try compiling<br /><pre><code><br />DummyProc proc <br />LOCAL a&#58;dword <br />LOCAL b&#58;byte <br />local p&#58;byte<br /><br />mov a,66666666<br />mov b,2 <br />mov p,4<br />ret <br />DummyProc endp <br /></code></pre><br />you will notice add esp,fffffff8h which means -8h bytes are added to ebp and saved in esp.<br /><br />dasm of my code<br /><pre><code><br />.text&#58;00401000                 public start<br />.text&#58;00401000 start           proc near<br />.text&#58;00401000<br />.text&#58;00401000 var_6           = byte ptr -6<br />.text&#58;00401000 var_5           = byte ptr -5<br />.text&#58;00401000 var_4           = dword ptr -4<br />.text&#58;00401000<br />.text&#58;00401000                 push    ebp<br />.text&#58;00401001                 mov     ebp, esp<br />.text&#58;00401003                 add     esp, 0FFFFFFF8h &lt;---this is i am talking about<br />.text&#58;00401006                 mov     &#91;ebp+var_4&#93;, 3F940AAh    <br />.text&#58;0040100D                 mov     &#91;ebp+var_5&#93;, 2<br />.text&#58;00401011                 mov     &#91;ebp+var_6&#93;, 4<br />.text&#58;00401015                 leave<br />.text&#58;00401016                 retn<br />.text&#58;00401016 start           endp<br /></code></pre><br />Hence i conclude that value moved into esp is changed only if it is above 4 bytes boundary.If it is below as was the case with ur code then it just takes 4bytes of space in memory.<br />however if its above 4 bytes, like in my case then it is incremnted by another 4 bytes to make <br />esp ==ebp-8h and store it in memory<br />to allocate space of 8bytes<br /><br />If i have not misunderstood u i guess this is ur answer else please correct me. <br />thank you <br />nickdigital</div>
    <div class="meta">Posted on 2004-10-05 18:45:21 by nickdigital</div>
   </div>
   <div class="post" id="post-150975">
    <div class="subject"><a href="#post-150975">Stack variables alignment</a></div>
    <div class="body">and mikky as far as indexing is concerned like var4 var5 and var6<br />it gets it the way i told u earlier, but that does not affect the esp register value.Its solely done by ida to change negative offsets to name also removing the minus sign.for the variables<br />to be more specific <br />p is dword ptr so -4 so it becomes removing sign var4<br />b is byte ptr so -1 becomes var(4+1) = var5<br />a is byte ptr so -1 becomes var var(4+1+1) = var6<br /><br />however this creates a messy code for us when disassembling and trying to figure out things.but thats a different topic.<br />please lemme know if i am wrong.ill love to correct myself<br />nickdigital</div>
    <div class="meta">Posted on 2004-10-05 19:05:10 by nickdigital</div>
   </div>
   <div class="post" id="post-151020">
    <div class="subject"><a href="#post-151020">Stack variables alignment</a></div>
    <div class="body">nickdigital, I appreciate your effort but dont get me wrong with this,you are talking much but actually say a little. I dont understand what you are trying to explain me and I am not sure if it has to do much with my question. <br />So lets put things simple without much theory, can you make a 2 local byte vars to be dword aligned on the stack by using MASM? That's all I need :)</div>
    <div class="meta">Posted on 2004-10-06 15:21:03 by Mikky</div>
   </div>
   <div class="post" id="post-151030">
    <div class="subject"><a href="#post-151030">Stack variables alignment</a></div>
    <div class="body">Mickey,<br /><br />The trick is to write a simple test piece and disassemble it to see what the  address are. From memory MASM will 4 byte align a BYTE size parameter on the stack because for obvious reasons you cannot push a BYTE value but I have never bothered to look at locals that are byte size.<br /><br />You can directly write a local to ensure it IS aligned the way you need but usually a BYTE value does not need more than BYTE alignment. If you are using a stack frame in normal procs,<br /><pre><code><br />mov &#91;ebp-4&#93;, BYTE PTR 127<br />mov &#91;ebp-8&#93;, WORD PTR 65534<br />mov &#91;ebp-12&#93;, DWORD PTR -1<br /></code></pre><br />Without a stack frame you can write to ESP instead.</div>
    <div class="meta">Posted on 2004-10-06 19:46:00 by hutch--</div>
   </div>
  </div>
 </body>
</html>