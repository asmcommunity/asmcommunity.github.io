<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Looking for a color filter algo - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14313" />
    <link rel="next" href="../?id=14313&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=14313">Looking for a color filter algo</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=14313&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=14313&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="14313" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=14313&amp;page=2">&gt;</a><a href="../?id=14313&amp;page=2">&raquo;</a></form>   <div class="post" id="post-110737">
    <div class="subject"><a href="#post-110737">Looking for a color filter algo</a></div>
    <div class="body">Hi<br />I'm looking for a way to process an image, something like this:<br /><br />- convert the image to grayscale<br />- apply a color to the image, so all colors in the picture will be the same, at a different intensity (something like looking at things through a coloured glass :grin: )<br /><br />I know how to convert to grayscale:<br /><br />Grayscale = .59 * Green + .11 * Blue + .3 * Red<br /><br />I just need the second part. I've been trying to figure it out by myself, but didn't succeed. Couldn't find it in google, either.<br /><br />This is some of the code I have used (uses raw bitmap access). The full source is in the thread &quot;Treeview with background image&quot;.<br /><pre><code><br />    invoke GdiFlush<br />    push esi<br />    push edi<br />    push ebx<br />    mov esi,pbits<br />    mov edi,esi<br />    mov eax,bmi.bmiHeader.biHeight<br />    test eax,eax<br />    .if sign?<br />        neg eax<br />    .endif<br />    mul bmi.bmiHeader.biWidth<br />    shl eax,1<br />    shl eax,1<br />    add edi,eax<br />    mov edx,color_window    ;edx = 007F7F7Fh - COLOR_WINDOW<br />    neg dl<br />    add dl,07Fh<br />    neg dh<br />    add dh,07Fh<br />    ror edx,16<br />    neg dl<br />    add dl,07Fh<br />    rol edx,16<br />    .repeat<br />        mov ebx,&#91;esi&#93;       ;Get current pixel color<br />        mov al,bl           ;Blue<br />        mov ah,30<br />        mul ah<br />        and eax,0FFFFh<br />        mov ecx,eax<br />        mov al,bh           ;Green<br />        mov ah,11<br />        mul ah<br />        and eax,0FFFFh<br />        add ecx,eax<br />        shr ebx,16          ;Red<br />        mov al,bl<br />        mov ah,59<br />        mul ah<br />        and eax,0FFFFh<br />        add eax,ecx<br />        mov cl,100          ;Grayscale = .59 * Green + .11 * Blue + .3 * Red<br />        div cl<br />        rcl ah,1<br />        adc al,0<br />        mov ah,al<br />        shl eax,8<br />        mov al,ah<br />        sub al,dl               ;Combine with color_window<br />        sub ah,dh               ; If you comment out this<br />        ror edx,16              ; part, you will get a<br />        ror eax,16              ; grayscale background,<br />        sub al,dl               ; instead of a combination<br />        rol edx,16              ; with the default system<br />        rol eax,16              ; colors.<br />        mov &#91;esi&#93;,eax       ;Set new pixel color<br />        add esi,4<br />    .until esi &gt;= edi<br />    pop ebx<br />    pop edi<br />    pop esi<br /></code></pre><br /><br />This is how it's supposed to work (BUT DOESN'T):</div>
    <div class="meta">Posted on 2003-07-16 09:32:57 by QvasiModo</div>
   </div>
   <div class="post" id="post-110738">
    <div class="subject"><a href="#post-110738">Looking for a color filter algo</a></div>
    <div class="body">By the way, the color for the filter shouldn't be red, green or blue. In those cases it's simpler, just calculate the grayscale value and set it in one of the three RGB components, instead of all of them:<br /><br />00xxxxxxh    grayscale<br />00xx0000h   red<br />0000xx00h   green<br />000000xxh   blue<br /><br />I'm looking for a way to do this with ANY color...</div>
    <div class="meta">Posted on 2003-07-16 09:37:30 by QvasiModo</div>
   </div>
   <div class="post" id="post-110752">
    <div class="subject"><a href="#post-110752">Looking for a color filter algo</a></div>
    <div class="body">IIRC, <strong>Qwerdy</strong> was working on this, too.<br /><br />I don't know how good this solution is, but here goes:<br /><br />Convert from HSL to RGB - the H and S values are chosen for the whole image based on the color you want, and the L values for each pixel are the cooresponding gray scale values from the picture.<br /><br />I'm sure there is a better way, but I haven't researched it.</div>
    <div class="meta">Posted on 2003-07-16 11:37:06 by bitRAKE</div>
   </div>
   <div class="post" id="post-110762">
    <div class="subject"><a href="#post-110762">Looking for a color filter algo</a></div>
    <div class="body">1. Convert the image to greyscale<br />2. Divide each greyscale value by 255 to get a floating-point number between 0 and 1<br />3. Multiply each RGB component of the &quot;filter&quot; color by the floating-point  number<br />4. Round the result to an integer and put back in the correct format<br /><br />That ought to give you the effect you want<br /><br />If you don't want to use floating-point numbers, you can multiply the greyscale and RGB component<br />directly (in a dword register so it doesn't overflow), and then divide by 255.</div>
    <div class="meta">Posted on 2003-07-16 12:22:02 by evwr</div>
   </div>
   <div class="post" id="post-110773">
    <div class="subject"><a href="#post-110773">Looking for a color filter algo</a></div>
    <div class="body">It depends on how you map the colors to their corresponding greyscale index.<br /><br />For example, if<br /><strong>XXXXXXXXXXXXXXXX</strong><br /><br />maps to:<br /><strong>XXXXXXXXXXXXXXXX</strong><br /><br />Then it's more complicated than taking n/255 * the color you want, since here the gradient goes from black -&gt; green -&gt; white.   I think the best method would be to create a 256x3 table and map the colors you want in, then transforming the colors will be as simple as looking up the table index.</div>
    <div class="meta">Posted on 2003-07-16 13:08:22 by iblis</div>
   </div>
   <div class="post" id="post-110801">
    <div class="subject"><a href="#post-110801">Looking for a color filter algo</a></div>
    <div class="body">Thank you for your replies, I was totally lost on this one :) <br /><br /><strong>iblis</strong>: You're right, I want the colors to map like you said, but I don't know how to create such color table (I want this done on runtime, based on the system colors). It's still probably more efficient to create that table on process startup, and update it if the system colors change by processing WM_SYSCOLORCHANGE or WM_DISPLAYCHANGE.<br /><br /><strong>evwr</strong>: It's still a good idea, I'll try that first. If it looks good, it might be enough fo what I want. By the way, wich way is more efficient, using FPU instructions or integer operations? I suppose integers are faster... :confused: <br /><br /><strong>bitRake</strong>: If evwr's idea fails, I'll try the one you suggested... as soon as I find out how to convert RGB to HSL and visceversa :grin:</div>
    <div class="meta">Posted on 2003-07-16 16:21:15 by QvasiModo</div>
   </div>
   <div class="post" id="post-110850">
    <div class="subject"><a href="#post-110850">Looking for a color filter algo</a></div>
    <div class="body">Actually, it seems that you don't need to convert the image to greyscale first.  You can get better-looking results<br />if you just multiply each component of the source image by the corresponding component of the &quot;filter&quot; color and <br />divide by 255.  This ought to solve the problem that iblis was talking about.<br /><br />This method may not produce images with all of the same color (although it will be close), it instead acts more like <br />a real colored filter would, only letting a certain percentage of each color component pass through unblocked. <br /><br />Integer instructions are going to be much faster in this case, because the conversion between integer<br />and floating-point is quite expensive compared to an integer divide and multiply.  If we were doing a lot<br />more calculations, or if we didn't need to convert back to an integer, the floating-point might be a more<br />attractive option.</div>
    <div class="meta">Posted on 2003-07-16 23:08:27 by evwr</div>
   </div>
   <div class="post" id="post-110904">
    <div class="subject"><a href="#post-110904">Looking for a color filter algo</a></div>
    <div class="body">OK, I've implemented evwr's algo (probably needs lots of optimization... but I've seen it run, and i'ts fast enough anyway). It looks good when the mixing color is very bright, but when the color is darker the image looks too dark. I have yet to try without converting to grayscale.<br /><br /><pre><code><br />    mov eax,pbits<br />    .if eax != 0<br />        invoke GdiFlush<br />        push esi<br />        push edi<br />        push ebx<br />        mov esi,pbits<br />        mov edi,esi<br />        mov eax,bmi.bmiHeader.biHeight<br />        test eax,eax<br />        .if sign?<br />            neg eax<br />        .endif<br />        mul bmi.bmiHeader.biWidth<br />        shl eax,1<br />        shl eax,1<br />        add edi,eax<br />        mov edx,color_window    ;edx = COLOR_WINDOW<br />        align DWORD<br />        .repeat<br />            mov ebx,&#91;esi&#93;       ;Get current pixel color<br />            mov al,bl           ;Blue<br />            mov ah,30<br />            mul ah<br />            and eax,0FFFFh<br />            mov ecx,eax<br />            mov al,bh           ;Green<br />            mov ah,11<br />            mul ah<br />            and eax,0FFFFh<br />            add ecx,eax<br />            shr ebx,16          ;Red<br />            mov al,bl<br />            mov ah,59<br />            mul ah<br />            and eax,0FFFFh<br />            add eax,ecx<br />            mov cl,100          ;Grayscale = .59 * Green + .11 * Blue + .3 * Red<br />            div cl<br />            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />            ; This converts the picture to<br />            ; grayscale, without combining<br />            ; with the system colors<br />            ; &#40;you have to comment out the<br />            ; next one&#41;<br /> ;             mov ah,al<br /> ;             shl eax,8<br /> ;             mov al,ah<br />            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />            ; This converts the picture to<br />            ; grayscale, and combines it<br />            ; with the system colors<br />            ; &#40;you have to comment out the<br />            ; previous one&#41;<br />            and eax,0FFh<br />            push ebx<br />            push ecx<br />            push edx<br />            push edi<br />            push esi<br />            mov edi,eax     ;edi gray<br />            mov esi,edx     ;esi color<br />            xor ebx,ebx     ;ebx result<br />            xor ecx,ecx<br />            mov cl,dl       ;blue   0000xx<br />            mul ecx<br />            .if eax != 0<br />                mov cl,255<br />                div ecx<br />            .endif<br />            rcl dl,1<br />            adc eax,0<br />            mov bl,al<br />            mov ecx,esi     ;green  00xx00<br />            mov eax,edi<br />            shr ecx,8<br />            and ecx,0FFh<br />            mul ecx<br />            .if eax != 0<br />                mov cl,255<br />                div ecx<br />            .endif<br />            rcl dl,1<br />            adc eax,0<br />            mov bh,al<br />            mov ecx,esi     ;red    xx0000<br />            mov eax,edi<br />            shr ecx,16<br />            mul ecx<br />            .if eax != 0<br />                mov cl,255<br />                div ecx<br />            .endif<br />            rcl dl,1<br />            adc eax,0<br />            and eax,0FFh<br />            shl eax,16<br />            or eax,ebx<br />            mov edx,esi<br />            pop esi<br />            pop edi<br />            pop edx<br />            pop ecx<br />            pop ebx<br />            ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />            mov &#91;esi&#93;,eax       ;Set new pixel color<br />            add esi,4<br />        .until esi &gt;= edi<br />        pop ebx<br />        pop edi<br />        pop esi<br />    .endif<br /></code></pre><br /><br />I think BitRake's idea was better, but since I'm after an aesthetical effect, I would make a change:<br /><br /><pre><code><br />mov eax,L1    ;luminosity of source pixel<br />add eax,L2    ;luminosity of mixing color<br />shr eax,1<br /></code></pre><br /><br />I think this way the luminosity of the mixing color would not be ignored, and so colors white, black, or anything in the gray scale wouldn't map the same color table. If used with a color conversion table for speed optimization, it should be the best choice.</div>
    <div class="meta">Posted on 2003-07-17 12:17:59 by QvasiModo</div>
   </div>
   <div class="post" id="post-110945">
    <div class="subject"><a href="#post-110945">Looking for a color filter algo</a></div>
    <div class="body"><div class="quote"><br />If evwr's idea fails, I'll try the one you suggested... as soon as I find out how to convert RGB to HSL and visceversa :grin: </div><br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/attachment.php?s=&amp;postid=88192">http://www.asmcommunity.net/board/attachment.php?s=&amp;postid=88192</a><br />:alright:</div>
    <div class="meta">Posted on 2003-07-17 18:16:12 by iblis</div>
   </div>
   <div class="post" id="post-111006">
    <div class="subject"><a href="#post-111006">Looking for a color filter algo</a></div>
    <div class="body">Yes, I did something similar for my PngSkin program. It was very simple snippet because most of the work was done by Iblis' conversion code :) Of course it wasn't exactly optimal but if it's only startup code that shouldn't matter much.</div>
    <div class="meta">Posted on 2003-07-18 06:49:13 by Qweerdy</div>
   </div>
   <div class="post" id="post-111030">
    <div class="subject"><a href="#post-111030">Looking for a color filter algo</a></div>
    <div class="body"><strong>iblis</strong>, thanks for the link! :alright: <br />I've been gloogling for it, but somehow I forgot about searching in the board... (dumb)<br /><br /><strong>evwr</strong>, here's a better implementation of your algo, this time it doesn't convert to grayscale, and works just great. I still have to see if there's a way to fix the problem when the mixing color is black (you can't see the picture).<br /><pre><code><br />mov eax,pbits<br />.if eax != 0<br />    invoke GdiFlush<br />    push esi<br />    push edi<br />    push ebx<br />    mov esi,pbits<br />    mov edi,esi<br />    mov eax,bmi.bmiHeader.biHeight<br />    test eax,eax<br />    .if sign?<br />        neg eax<br />    .endif<br />    mul bmi.bmiHeader.biWidth<br />    shl eax,1<br />    shl eax,1<br />    add edi,eax<br />    mov edx,color_window    ;edx = COLOR_WINDOW<br />    align DWORD<br />    .repeat<br />        mov ebx,&#91;esi&#93;       ;Get current pixel color<br />        mov ecx,3<br />        xor eax,eax<br />        align DWORD<br />        .repeat<br />            mov al,bl<br />            mul dl<br />            .if eax != 0<br />                mov bl,255<br />                div bl<br />            .endif<br />            mov bl,al<br />            ror ebx,8<br />            ror edx,8<br />            dec ecx<br />        .until zero?<br />        ror ebx,8<br />        ror edx,8<br />        mov &#91;esi&#93;,ebx       ;Set new pixel color<br />        add esi,4<br />    .until esi &gt;= edi<br />    pop ebx<br />    pop edi<br />    pop esi<br />.endif<br /></code></pre></div>
    <div class="meta">Posted on 2003-07-18 09:34:11 by QvasiModo</div>
   </div>
   <div class="post" id="post-111066">
    <div class="subject"><a href="#post-111066">Looking for a color filter algo</a></div>
    <div class="body">QvasiModo,<pre><code>      mov   esi,pbits<br />      xor   eax,eax<br />      movzx edx,byte ptr &#91;color_window&#93;     ; edx=COLOR_WINDOW my be with BSWAP?<br />      add   esi,1                           ; edx=7F7F7F00h -&gt;COLOR_WINDOW<br />F_Loop1&#58;<br />      movzx ebx,&#91;esi+eax&#93;<br />      add   eax,1<br />      imul  ebx,edx<br />      movzx edx,byte ptr &#91;color_window+eax&#93; ; edx=COLOR_WINDOW<br />      shr   ebx,8                           ; /256<br />      cmp   eax,4<br />      mov   &#91;esi+eax-1&#93;,bl<br />      jne   F_Loop1<br />      movzx edx, byte ptr &#91;color_window&#93;    ; edx=COLOR_WINDOW<br />      add   esi,eax<br />      xor   eax,eax<br />      cmp   esi,edi<br />      jc    F_Loop1</code></pre><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-07-18 14:21:44 by lingo12</div>
   </div>
   <div class="post" id="post-111071">
    <div class="subject"><a href="#post-111071">Looking for a color filter algo</a></div>
    <div class="body">@lingo12<br /><br />I'm afraid this code won't work:<br />   <br />mov   ecx,ebx<br />shr   ebx,8                           ; /256<br />add   ebx,ecx                         ; ebx/255<br /><br />Here's an example:<br /><br />; ebx = 512<br />mov   ecx, ebx   ; ebx = 512, ecx = 512<br />shr   ebx, 8     ; ebx = 2, ecx = 512<br />add   ebx, ecx   ; ebx = 514, ecx = 512<br /><br />ebx ends up being greater than its initial value, not its<br />initial value / 255.  Since we're not looking for scientific results,<br />I'd say that just a shr ebx, 8 would be fine. The maximum possible <br />error, (255 * 255) / 255 compared to (255 * 255) / 256,<br />differs by a little less than one.<br /><br />@QvasiModo:<br />   <br />Any algorithm that gives reasonable-looking results is going to have<br />an all-black image when the mixing color is black, since a black mixing<br />color represents a filter that lets no light through.  You should be able<br />to fudge something though, like:<br />1. add up the r, g, and b components of the mixing color<br />2. If the sum is &gt; a certain arbitrary # chosen by trial and error, then<br />   go to the regular mixing routine, otherwise continue<br />3. Add an arbitrary value # to each of the r, g, and b components of the<br />   mixing color, so we keep the same hue, but increase the brightness<br />4. Use this new mixing color in the regular routine</div>
    <div class="meta">Posted on 2003-07-18 15:05:07 by evwr</div>
   </div>
   <div class="post" id="post-111087">
    <div class="subject"><a href="#post-111087">Looking for a color filter algo</a></div>
    <div class="body">Thanks  evwr,<br />It was:<pre><code><br />      shr   ebx,8                           ; /256<br />      mov   ecx,ebx<br />      shr   ecx,8                           ; /256<br />      add   ebx,ecx                         ; ebx/255</code></pre><br />I'll correct it<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-07-18 17:37:55 by lingo12</div>
   </div>
   <div class="post" id="post-111090">
    <div class="subject"><a href="#post-111090">Looking for a color filter algo</a></div>
    <div class="body"><strong>QvasiModo</strong>, for best results only use the hue of the filter color - providing the best range of color for the image.  Black will give a grayscale image in this case.</div>
    <div class="meta">Posted on 2003-07-18 17:52:43 by bitRAKE</div>
   </div>
   <div class="post" id="post-111094">
    <div class="subject"><a href="#post-111094">Looking for a color filter algo</a></div>
    <div class="body">Well, this would be my implemenation of bitRake's first suggestion:<br /><pre><code>mov eax,pbits<br />.if eax != 0<br />    invoke GdiFlush<br />    push esi<br />    push edi<br />    push ebx<br />    mov esi,pbits<br />    mov edi,esi<br />    mov eax,bmi.bmiHeader.biHeight<br />    test eax,eax<br />    .if sign?<br />        neg eax<br />    .endif<br />    mul bmi.bmiHeader.biWidth<br />    shl eax,1<br />    shl eax,1<br />    add edi,eax<br />    invoke RGB2HSL,color_window<br />    and eax,0FFFFh<br />    xchg eax,ebx<br />    .repeat<br />        invoke RGB2HSL,dword ptr &#91;esi&#93;<br />        and eax,0FF0000h<br />        or eax,ebx<br />        mov dword ptr &#91;esi&#93;,$invoke &#40;HSL2RGB,eax&#41;<br />        add esi,4<br />    .until esi &gt;= edi<br />    pop ebx<br />    pop edi<br />    pop esi<br />.endif</code></pre><br />And this would be my version:<br /><pre><code>mov eax,pbits<br />.if eax != 0<br />    invoke GdiFlush<br />    push esi<br />    push edi    ;preserve the registers<br />    push ebx<br />    mov esi,pbits<br />    mov edi,esi<br />    mov eax,bmi.bmiHeader.biHeight<br />    test eax,eax<br />    .if sign?<br />        neg eax<br />    .endif<br />    mul bmi.bmiHeader.biWidth<br />    shl eax,1<br />    shl eax,1<br />    add edi,eax<br />    push $invoke &#40;RGB2HSL,color_window&#41;<br />    .repeat<br />        invoke RGB2HSL,dword ptr &#91;esi&#93;<br />        pop edx<br />        push edx<br />        mov ecx,edx<br />        shr eax,16<br />        shr edx,16<br />        add eax,edx<br />        shl eax,15<br />        and ecx,0FFFFh<br />        and eax,0FF0000h<br />        or eax,ecx<br />        mov dword ptr &#91;esi&#93;,$invoke &#40;HSL2RGB,eax&#41;<br />        add esi,4<br />    .until esi &gt;= edi<br />    pop eax<br />    pop ebx<br />    pop edi     ;restore the registers<br />    pop esi<br />.endif</code></pre><br />The second one looks better... when the mixing color is black, it doesn't map everything to black. The only drawback is, perhaps, that it looks a bit too bright when the mixing color is white (nothing is perfect). And of course it's grayscale. It might be better for applying a texture, not a background image (something like the sample image in my first post). evwr's algo still has the advantage of preserving the image colors.<br /><div class="quote"><em>Originally posted by bitRAKE&gt;</em><br /><strong>QvasiModo, for best results only use the hue of the filter color - providing the best range of color for the image. Black will give a grayscale image in this case.</div><br />I'll try that...*<br /><span style="font-size:9px>(*): At this point, and at the risk of looking either dumb or ignorant, I'll have to ask someone exactly what this HSL values represent, and why they are floats from 0 to 1 :grin:</span></div>
    <div class="meta">Posted on 2003-07-18 18:15:26 by QvasiModo</div>
   </div>
   <div class="post" id="post-111096">
    <div class="subject"><a href="#post-111096">Looking for a color filter algo</a></div>
    <div class="body"><strong>H</strong> Hue (color)<br /><strong>S</strong> Saturation (richness of color)<br /><strong>L</strong> Luminesence (amount of light)<br /><br />They don't have to be floats - they can be mapped to any range - like RGB values.</div>
    <div class="meta">Posted on 2003-07-18 18:22:19 by bitRAKE</div>
   </div>
   <div class="post" id="post-111098">
    <div class="subject"><a href="#post-111098">Looking for a color filter algo</a></div>
    <div class="body">Luminance (or however it's spelled) was pretty much intuitive :rolleyes: If I have two HSL pairs with the same hue and saturation, but a different luminance, one will look brighter then the other. Right.<br /><br />Hue and Saturation were confusing me, though... suppose you have two HSL pairs, both with the same saturation and luminance, but a different hue. What does it mean? That they are a different color, with the same brightness and intensity?:confused:</div>
    <div class="meta">Posted on 2003-07-18 18:51:14 by QvasiModo</div>
   </div>
   <div class="post" id="post-111108">
    <div class="subject"><a href="#post-111108">Looking for a color filter algo</a></div>
    <div class="body"><strong>QvasiModo</strong>, yeah, the colors should look good next to each other on the screen. :)</div>
    <div class="meta">Posted on 2003-07-18 19:48:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-111173">
    <div class="subject"><a href="#post-111173">Looking for a color filter algo</a></div>
    <div class="body">Hue is the color's placement on the 'color wheel' so to speak.  It goes from red-&gt;orange-&gt;yellow-&gt;green-&gt;cyan-&gt;blue-&gt;magenta-&gt; and back to red.<br /><br />Saturation is how far away the color is from grey.  It goes from grey -&gt; x.<br /><br />Luminance is the intensity.  It goes from black -&gt; x -&gt; white.<br /><br /><br />Remember that the RGB2HSL and HSL2RGB routines use the COLORREF format, so to convert them from/to a pixel format, bswap, then shift right by 8.</div>
    <div class="meta">Posted on 2003-07-19 10:03:44 by iblis</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=14313&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=14313&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="14313" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=14313&amp;page=2">&gt;</a><a href="../?id=14313&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>