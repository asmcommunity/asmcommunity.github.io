<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C++ Question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29417" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=29417">C++ Question</a></p>
   <div class="post" id="post-207673">
    <div class="subject"><a href="#post-207673">C++ Question</a></div>
    <div class="body">Say I have a super class called VObject(). I want this class to have a static method called Alloc() and I want allow to do an allocation of the class and return a pointer. Something like this:<br /><br /><pre><code>//---------------------------------------------------------------------------<br /><br />class VObject{<br />	public:<br /><br />		static VObject* Alloc(){<br />			VObject *Result = new VObject();<br />			return(Result);<br />		}<br /><br />};<br /><br />//---------------------------------------------------------------------------<br /><br />class MyObject : public VObject{<br /><br />};<br /><br />//---------------------------------------------------------------------------<br /><br />void __fastcall TForm1::FormCreate(TObject *Sender)<br />{<br />	VObject *Object = VObject::Alloc();<br />	MyObject *Value = MyObject::Alloc(); /* Error here */<br /><br />}<br /><br />//---------------------------------------------------------------------------</code></pre><br /><br />The last line throws an error because VObject&#039;s Alloc() method allocated objects of type VObject(). How can I allow the VObject() super class to hide the Alloc() method inside itself without needing any of the sub classes to have the Alloc() method? So somehow make the MyObject object to inherit the Alloc() method but let it return an object of type MyObject() without needing to rewrite that method.</div>
    <div class="meta">Posted on 2009-05-20 19:42:47 by XCHG</div>
   </div>
   <div class="post" id="post-207690">
    <div class="subject"><a href="#post-207690">Re: C++ Question</a></div>
    <div class="body">Okay I found my solution:<br /><br /><pre><code>class VObject{<br /><br />	public:<br /><br />		unsigned int Value;<br />	<br />		unsigned int RetainCount;<br /><br />		virtual void Dealloc(){<br />			delete this;<br />		}<br />		<br />		template&lt;class T&gt;<br />		static T *Alloc(T* t){<br />			T* NewClass = new T();<br />			NewClass-&gt;RetainCount = 1;<br />			return(NewClass);<br />		}<br /><br />		virtual bool Release(){<br />			if (this-&gt;RetainCount &gt; 0) {<br />				this-&gt;RetainCount--;<br />				if (this-&gt;RetainCount == 0) {<br />					this-&gt;Dealloc();<br />				}<br />				return(true);<br />			} else {<br />				return(false);<br />			}<br />		<br />		}<br /><br />		template&lt;class T&gt;<br />		T *Retain(T* t){<br />			this-&gt;RetainCount++;<br />			return(this);<br />		}<br />};<br /></code></pre></div>
    <div class="meta">Posted on 2009-05-22 04:52:37 by XCHG</div>
   </div>
   <div class="post" id="post-207692">
    <div class="subject"><a href="#post-207692">Re: C++ Question</a></div>
    <div class="body">Don&#039;t reinvent the wheel. Read about COM :)</div>
    <div class="meta">Posted on 2009-05-22 21:08:04 by ti_mo_n</div>
   </div>
   <div class="post" id="post-207698">
    <div class="subject"><a href="#post-207698">Re: C++ Question</a></div>
    <div class="body">Hey,<br /><br />I don&#039;t think COM is for other platforms but Microsoft hm? I am creating my own library of C++ files for making games and the VObject is the core object from which other classes will inherit. I am planning on using this code on other platforms like on Mac OS X so I don&#039;t know if I&#039;m going to benefit from COM?</div>
    <div class="meta">Posted on 2009-05-23 08:36:45 by XCHG</div>
   </div>
   <div class="post" id="post-207700">
    <div class="subject"><a href="#post-207700">Re: C++ Question</a></div>
    <div class="body">COM is usually mistaken (quite justifiably) for THE MS implementation, while actually it&#039;s just a method of creating objects, very similar to yours.<br />It would be easier for you to see what objects already are in COM specs (like streams, allocators, etc) and implement your own using existing ideas. The result will be easier to code (no planning required because you already see what you want), and easier to debug/test/play with because those familiar with COM will be able to help you with any problems. It&#039;s not really THE MS COM what I&#039;m suggesting you, but &#039;the COM idea&#039; of writing object oriented code.<br /><br />So there are 2 main benefits of COM for you:<br />1) Known interface names. If you want a memory allocator, write your own IMalloc interface. If you want a universal stack, write IStack. Everyone will know how it works (or how it&#039;s supposed to work and if it doesn&#039;t you&#039;ll get more descriptive bugreport) and how to use it (you can focus on writing the code instead of documenting it).<br />2) COM mechanics allow easy extensions to the existing code. If an application uses a function from a DLL, then when this function is updated the app may stop working. This is not the case with COM. You can your libraries with new functions, update existing functions and every app written using some given version of your library will never stop working (as long as there is at least this version provided and -of course- as long as there are no bugs in the IUnknown interface of the library). So, for example, let&#039;s say I have a function called &quot;add&quot; in a library and this function takes 2 integers and returns an integer. In some next version of this library this &quot;add&quot; may take floats instead of integers. In the standard approach my app would crash/stop working correctly if I updated the library without recompiling the app. In the COM approach it will still function properly and NEW applications can use this new version of &quot;add&quot; (which takes floats instead of integers) as well as the old version (with integers). There may even be some newer version of &quot;add&quot; in the future and no existing code will stop functioning (as long as it&#039;s written properly). The &quot;add&quot; may even be deprecated/deleted in some new version and any extisting apps will still work properly without any changes to them.<br /><br />COM is the only way I write ObjectOriented code and IMHO it&#039;s a great way of writing OO code. And I&#039;m talking about the mechanics here, not THE MS COM. Or, in other words, I&#039;m talking about the programming technique, not the COM implementation on Windows.<br /><br />And that&#039;s what I&#039;m suggesting you ^^<br /><br /><a target="_blank" href="http://gsraj.tripod.com/com/com_ravings.html">Here you can read about the benefits of COM</a>.<br /><br />The neatest fun starts if you want make UI elements (you said you wanted to make a game, right?). Having 3 versions of the same menu without conflicts, or 4 versions of 3D-model renderers is really nice. Upgrading COM code is as easy as copying new DLL to the game directory.<br /><br />I haven&#039;t slept for like 30 hours so I hope this text isn&#039;t very chaotic/erratic/bugged and you get the idea ^^&#039;</div>
    <div class="meta">Posted on 2009-05-23 20:06:20 by ti_mo_n</div>
   </div>
   <div class="post" id="post-207708">
    <div class="subject"><a href="#post-207708">Re: C++ Question</a></div>
    <div class="body">I&#039;m wondering what the use of your Alloc method is.<br />It&#039;s cheaper to issue a New() than it is to call the Alloc method (unless its an inline method) and either way it costs more to type the Alloc call than it does to type the New directive.<br />What do you have in mind here?</div>
    <div class="meta">Posted on 2009-05-24 03:19:20 by Homer</div>
   </div>
   <div class="post" id="post-207711">
    <div class="subject"><a href="#post-207711">Re: C++ Question</a></div>
    <div class="body">Hm, to me it seems like a wrong idea to mess with manual reference counting this way - you&#039;re probably better off using something like boost::shared_ptr . (And you really should be setting refcount in your constructor rather than some custom alloc function that might not even be called).<br /><br />What&#039;s with the &quot;T* t&quot; arguments to Alloc and Retain that aren&#039;t used?</div>
    <div class="meta">Posted on 2009-05-24 16:43:31 by f0dder</div>
   </div>
   <div class="post" id="post-207716">
    <div class="subject"><a href="#post-207716">Re: C++ Question</a></div>
    <div class="body"><div class="quote"><br />Hm, to me it seems like a wrong idea to mess with manual reference counting this way - you&#039;re probably better off using something like boost::shared_ptr . (And you really should be setting refcount in your constructor rather than some custom alloc function that might not even be called).<br /><br />What&#039;s with the &quot;T* t&quot; arguments to Alloc and Retain that aren&#039;t used?<br /></div><br /><br />I am not doing anything in the constructor because I want another method which is  to be my actual constructor. I want all my objects to have one constructor which will eventually allow my new()&nbsp; to work in the Alloc() static function. If they have a different constructor then Allloc() might not work because it assumes the object&#039;s constructor doesn&#039;t have any parameters. So I will define that as abstract = (0) in my base class and I will force all my other classes to have that. So basically the lifecycle of my objects will be like this:<br /><br />1) Alloc (allocate memory for the object)<br />2) Init (initialize parameters, something like a constructor).<br />3) Retain, Release, Retain, Release as much as we want.<br />4) Dealloc.<br /><br />I am using the function templates so I can do this:<br /><br />class SObject : public VObject{<br />}<br /><br />SObject *Bla = SObject::Alloc(Bla);<br /><br />So this way SObject inherits its Alloc() from VObject() defined in my previous post and that will save me writing the Alloc() and Retain() functions for every class I create. If you have a better way of doing this, I will be glad to see that really. I don&#039;t like using Templates much.</div>
    <div class="meta">Posted on 2009-05-25 09:47:02 by XCHG</div>
   </div>
   <div class="post" id="post-207720">
    <div class="subject"><a href="#post-207720">Re: C++ Question</a></div>
    <div class="body">As mentioned previously, for a lot of uses I&#039;d simply depend on a shared_ptr to manage reference counting, and use clean-and-dependable <a target="_blank" href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>, which also fairs well in case of exceptions.<br /><br />I&#039;m also not sure what it is you really want to do wrt. the memory allocation thing. I&#039;d prefer to overload operation new/delete per-class as necessary, which allows you to instantiate your objects on the stack as well as on the heap as wanted... and supports constructors.<br /><br />Even with your scheme, I don&#039;t see the point of the alloc routine at all - the &quot;retainCount = 1&quot; should be done in the constructor instead, and derived classes should of course call it&#039;s superclass&#039; constructor :)</div>
    <div class="meta">Posted on 2009-05-25 14:35:49 by f0dder</div>
   </div>
   <div class="post" id="post-207724">
    <div class="subject"><a href="#post-207724">Re: C++ Question</a></div>
    <div class="body"><div class="quote"><br />As mentioned previously, for a lot of uses I&#039;d simply depend on a shared_ptr to manage reference counting, and use clean-and-dependable <a target="_blank" href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>, which also fairs well in case of exceptions.<br /><br />I&#039;m also not sure what it is you really want to do wrt. the memory allocation thing. I&#039;d prefer to overload operation new/delete per-class as necessary, which allows you to instantiate your objects on the stack as well as on the heap as wanted... and supports constructors.<br /><br />Even with your scheme, I don&#039;t see the point of the alloc routine at all - the &quot;retainCount = 1&quot; should be done in the constructor instead, and derived classes should of course call it&#039;s superclass&#039; constructor :)<br /></div><br /><br />Actually to be honest with you, I think a shared pointer should not modify the reference count since it is a shared pointer. If the instance is deallocated, since it is &quot;shared&quot;, it has to be deallocated everywhere else. The way I will write a shared ptr in C++ and especially in Objective C is like this:<br /><br /><pre><code><br />static MyClass *SharedInstance(){<br /> &nbsp;static MyClass *SharedInstanceVariable = NULL;<br /> &nbsp;if (SharedInstanceVariable == NULL){<br /> &nbsp; &nbsp;SharedInstanceVariable = new MyClass();<br /> &nbsp;}<br /> &nbsp;return(SharedInstanceVariable);<br />}<br /></code></pre><br /><br />So basically keep the reference count to 1 when SharedInstanceVariable is allocated and don&#039;t change the reference count. That&#039;s how Objective C works and I think it makes sense.<br /><br />The thing I want to do is this:<br /><br />In Objective C, the head of the hierarchy is NSObject. Then you can inherit from it like this (h file):<br /><br /><pre><code>#import &lt;Foundation/Foundation.h&gt;<br /><br /><br />@interface MyObject : NSObject {<br /><br />}<br /><br />@end</code></pre><br /><br />And this class, without any implementation, will be able to be allocated like this:<br /><br /><pre><code>MyObject *Bla = [ init];</code></pre><br /><br />alloc is defined in NSObject and it will return an object of type (id) which is the wrapper for all classes. Then init will initialize the class. You can override the init function like this:<br /><br /><pre><code><br />- (id) init {<br /> &nbsp;self = ;<br /> &nbsp;if (self != nil){<br /> &nbsp; &nbsp;/* Do your things here */<br /> &nbsp;}<br /> &nbsp;return(self);<br />}</code></pre><br /><br />So alloc is defined in NSObject and you don&#039;t have to override this for every object that inherits from it. The init() function as well.</div>
    <div class="meta">Posted on 2009-05-26 04:42:46 by XCHG</div>
   </div>
   <div class="post" id="post-207725">
    <div class="subject"><a href="#post-207725">Re: C++ Question</a></div>
    <div class="body">A shared_ptr (of the boost kind, which was adopted by the C++ committee, will be included in C++0x and is already present in TR1) <strong>does</strong> handle reference counting properly, and is even threadsafe. The shared_ptr constructor (and copy constructor) increments the refcount, the destructor decrements it. If refcount==0 on decrement, the pointed-to object is deleted. Of course this does mean that to use <strong>shared_ptr</strong>s for reference counting you&#039;d more or less need to always pass shared_ptrs around rather than your <em>raw</em> pointers.<br /><br />I think you&#039;re trying to program in C++ but thinking in an Objective-C mindset? You &quot;init&quot; pretty much corresponds to a C++ constructor. And I still don&#039;t see your reason for the custom allocator; sure, right now it&#039;s used to set up reference counting, but that belongs in a constructor, and would only need to be done in the base class anyway.</div>
    <div class="meta">Posted on 2009-05-26 05:00:33 by f0dder</div>
   </div>
   <div class="post" id="post-207726">
    <div class="subject"><a href="#post-207726">Re: C++ Question</a></div>
    <div class="body"><div class="quote"><br />A shared_ptr (of the boost kind, which was adopted by the C++ committee, will be included in C++0x and is already present in TR1) <strong>does</strong> handle reference counting properly, and is even threadsafe. The shared_ptr constructor (and copy constructor) increments the refcount, the destructor decrements it. If refcount==0 on decrement, the pointed-to object is deleted. Of course this does mean that to use <strong>shared_ptr</strong>s for reference counting you&#039;d more or less need to always pass shared_ptrs around rather than your <em>raw</em> pointers.<br /><br />I think you&#039;re trying to program in C++ but thinking in an Objective-C mindset? You &quot;init&quot; pretty much corresponds to a C++ constructor. And I still don&#039;t see your reason for the custom allocator; sure, right now it&#039;s used to set up reference counting, but that belongs in a constructor, and would only need to be done in the base class anyway.<br /></div><br /><br />Yeah I can say that I really am in an Objective-C mindset. I have been working with it for about 8 months now and it&#039;s amazingly clean and organized once you get used to it (which won&#039;t take long really). My problem is that I want to have New just allocate my objects. That&#039;s what it is supposed to do. I don&#039;t want it to Initialize my objects through the constructor and for this I have to have one simple constructor with no parameters so in my base class I can call that constructor without parameters and then allow the programmer to initialize the objects using a separate call.<br /><br />So:<br /><br />1) Allocate (don&#039;t initialize. These two are in my opinion two different things and I hate the fact that New mixes them together). (x1)<br />2) Initialize. (x1)<br />3) Retain. (xn)<br />4) Release. (xn)<br />5) Deallocate (x1)<br /><br /></div>
    <div class="meta">Posted on 2009-05-26 05:13:56 by XCHG</div>
   </div>
   <div class="post" id="post-207727">
    <div class="subject"><a href="#post-207727">Re: C++ Question</a></div>
    <div class="body">I used to dislike initialization done in constructors (and especially constructor member initializers), but it does have a bunch of advantages - it&#039;s pretty consistent, helps a lot wrt. exception safety, and can help getting more optimal code with some compilers: your method would have class members getting default-initialized, and then afterwards being re-&quot;initialized&quot; by your Init() routine.<br /><br />Doing it &quot;your way&quot; is of course possible, but it isn&#039;t &quot;the C++ way&quot; of doing things :)</div>
    <div class="meta">Posted on 2009-05-26 05:21:06 by f0dder</div>
   </div>
   <div class="post" id="post-207728">
    <div class="subject"><a href="#post-207728">Re: C++ Question</a></div>
    <div class="body"><div class="quote"><br />I used to dislike initialization done in constructors (and especially constructor member initializers), but it does have a bunch of advantages - it&#039;s pretty consistent, helps a lot wrt. exception safety, and can help getting more optimal code with some compilers: your method would have class members getting default-initialized, and then afterwards being re-&quot;initialized&quot; by your Init() routine.<br /><br />Doing it &quot;your way&quot; is of course possible, but it isn&#039;t &quot;the C++ way&quot; of doing things :)<br /></div><br /><br />You are right. I think I should start to accept that these two languages are structured differently. I wish C++ Builder (which is my main C++ IDE) could work with GNU Objective-C compiler. In XCode on the Mac I can write C, C++, Objective C in one file and have the compiler understand the whole thing. It&#039;s pretty intense.</div>
    <div class="meta">Posted on 2009-05-26 05:25:55 by XCHG</div>
   </div>
   <div class="post" id="post-207729">
    <div class="subject"><a href="#post-207729">Re: C++ Question</a></div>
    <div class="body">Btw, another important rationale behind initializing objects via constructors is that you can ensure that an object will always be in a consistent state.<br /><br />Putting multiple languages in one source module seems dirty, but linking several modules in different language can be useful. That&#039;d let me use Obj-C exclusively for the GUI stuff and stick with C++ for the core parts of the app, should I ever need to do Mac programming :)</div>
    <div class="meta">Posted on 2009-05-26 05:30:04 by f0dder</div>
   </div>
   <div class="post" id="post-207730">
    <div class="subject"><a href="#post-207730">Re: C++ Question</a></div>
    <div class="body"><div class="quote"><br />Btw, another important rationale behind initializing objects via constructors is that you can ensure that an object will always be in a consistent state.<br /><br />Putting multiple languages in one source module seems dirty, but linking several modules in different language can be useful. That&#039;d let me use Obj-C exclusively for the GUI stuff and stick with C++ for the core parts of the app, should I ever need to do Mac programming :)<br /></div><br /><br />Yeah mixing them could sometimes be dirty but sometimes really useful :P I probably will consider changing this Alloc() scheme that I had in mind then :-s</div>
    <div class="meta">Posted on 2009-05-26 05:36:00 by XCHG</div>
   </div>
   <div class="post" id="post-207731">
    <div class="subject"><a href="#post-207731">Re: C++ Question</a></div>
    <div class="body">It&#039;s of course your choice, but all I can say is that languages are different. When I started writing C++, I did so with a C/ObjectivePascal mindset. I feel that my code has become cleaner after I&#039;ve accepted more and more of &quot;the C++ way&quot;. That has also brought me to realize that C++ isn&#039;t the perfect tool for every job, and that raw win32 API programming isn&#039;t the most joyful way of doing GUIs (although it <strong>is</strong> one of the LEAN_AND_MEANEST ways :)).</div>
    <div class="meta">Posted on 2009-05-26 05:47:24 by f0dder</div>
   </div>
   <div class="post" id="post-207732">
    <div class="subject"><a href="#post-207732">Re: C++ Question</a></div>
    <div class="body"><div class="quote"><br />It&#039;s of course your choice, but all I can say is that languages are different. When I started writing C++, I did so with a C/ObjectivePascal mindset. I feel that my code has become cleaner after I&#039;ve accepted more and more of &quot;the C++ way&quot;. That has also brought me to realize that C++ isn&#039;t the perfect tool for every job, and that raw win32 API programming isn&#039;t the most joyful way of doing GUIs (although it <strong>is</strong> one of the LEAN_AND_MEANEST ways :)).<br /></div><br /><br />Yeah I totally agree with the fact that once you accept a programming language as it is, you will write cleaner code. I had the same problem with Delphi. I think it&#039;s best to understand the programming language and most/all its tools but sometimes it could be really hard to adjust to them since you might have experience in other programming languages more and essentially you will end up comparing how harsh the new language is compared to the one you are used to coding in for example. (sigh) Yeah I guess I have to go the C++ route instead. Oh well...</div>
    <div class="meta">Posted on 2009-05-26 06:30:15 by XCHG</div>
   </div>
   <div class="post" id="post-207733">
    <div class="subject"><a href="#post-207733">Re: C++ Question</a></div>
    <div class="body">Well, at least going objpascal/objc -&gt; C++ isn&#039;t <strong>that</strong> bad a step (although there <em>are</em> a damn lot of things you need to know about to write clean <strong>and</strong> efficient C++ code) - it&#039;s an &quot;ideologically&quot; smaller step than picking up, say, the Python mindset :)</div>
    <div class="meta">Posted on 2009-05-26 06:37:59 by f0dder</div>
   </div>
   <div class="post" id="post-207753">
    <div class="subject"><a href="#post-207753">Re: C++ Question</a></div>
    <div class="body">Jumping from ObjectPascal to C++ would be difficult but from Delphi (especially with all the changes made to the language since Delphi 7) there is not much difference between these two worlds really. Templates are still missing from Delphi though :P</div>
    <div class="meta">Posted on 2009-05-28 11:52:10 by XCHG</div>
   </div>
  </div>
 </body>
</html>