<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>x86 decoder - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19965" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19965">x86 decoder</a></p>
   <div class="post" id="post-153208">
    <div class="subject"><a href="#post-153208">x86 decoder</a></div>
    <div class="body">Hi all,<br /><br />I created this little gem during some boring classes:<br /><pre><code><br />int instructionCount&#40;unsigned char *func&#41;<br />&#123;<br />	int count = 0;<br /><br />	while&#40;*func != 0xCC&#41;<br />	&#123;<br />		// Skip prefixes F0h, F2h, F3h, 66h, 67h, D8h-DFh<br />		int operandSize = 4;<br />		int FPU = 0;<br />		while&#40;*func == 0xF0 ||<br />		      *func == 0xF2 ||<br />			  *func == 0xF3 ||<br />			  &#40;*func &amp; 0xFE&#41; == 0x66 ||<br />			  &#40;*func &amp; 0xF8&#41; == 0xD8&#41;<br />		&#123;<br />			if&#40;*func == 0x66&#41;<br />			&#123;<br />				operandSize = 2;<br />			&#125;<br />			else if&#40;&#40;*func &amp; 0xF8&#41; == 0xD8&#41;<br />			&#123;<br />				FPU = *func++;<br />				break;<br />			&#125;<br /><br />			func++;<br />		&#125;<br /><br />		// Skip two-byte opcode byte<br />		bool twoByte = false;<br />		if&#40;*func == 0x0F&#41;<br />		&#123;<br />			twoByte = true;<br />			func++;<br />		&#125;<br /><br />		// Skip opcode byte<br />		unsigned char opcode = *func++;<br /><br />		// Skip mod R/M byte<br />		unsigned char modRM = 0xFF;<br />		if&#40;FPU&#41;<br />		&#123;<br />			if&#40;&#40;opcode &amp; 0xC0&#41; != 0xC0&#41;<br />			&#123;<br />				modRM = opcode;<br />			&#125;<br />		&#125;<br />		else if&#40;!twoByte&#41;<br />		&#123;<br />			if&#40;&#40;opcode &amp; 0xC4&#41; == 0x00 ||<br />			   &#40;opcode &amp; 0xF4&#41; == 0x60 &amp;&amp; &#40;&#40;opcode &amp; 0x0A&#41; == 0x02 || &#40;opcode &amp; 0x09&#41; == 0x9&#41; ||<br />			   &#40;opcode &amp; 0xF0&#41; == 0x80 ||<br />			   &#40;opcode &amp; 0xF8&#41; == 0xC0 &amp;&amp; &#40;opcode &amp; 0x0E&#41; != 0x02 ||<br />			   &#40;opcode &amp; 0xFC&#41; == 0xD0 ||<br />			   &#40;opcode &amp; 0xF6&#41; == 0xF6&#41;<br />			&#123;<br />				modRM = *func++;<br />			&#125;<br />		&#125;<br />		else<br />		&#123;<br />			if&#40;&#40;opcode &amp; 0xF0&#41; == 0x00 &amp;&amp; &#40;opcode &amp; 0x0F&#41; &gt;= 0x04 &amp;&amp; &#40;opcode &amp; 0x0D&#41; != 0x0D ||<br />			   &#40;opcode &amp; 0xF0&#41; == 0x30 ||<br />			   opcode == 0x77 ||<br />			   &#40;opcode &amp; 0xF0&#41; == 0x80 ||<br />			   &#40;opcode &amp; 0xF0&#41; == 0xA0 &amp;&amp; &#40;opcode &amp; 0x07&#41; &lt;= 0x02 ||<br />			   &#40;opcode &amp; 0xF8&#41; == 0xC8&#41;<br />			&#123;<br />				// No mod R/M byte<br />			&#125;<br />			else<br />			&#123;<br />				modRM = *func++;<br />			&#125;<br />		&#125;<br /><br />		// Skip SIB and displacement<br />		if&#40;&#40;modRM &amp; 0x07&#41; == 0x04&#41; func += 1;	// SIB<br />		if&#40;&#40;modRM &amp; 0xC5&#41; == 0x05&#41; func += 4;	// Dword displacement, no base<br />		if&#40;&#40;modRM &amp; 0xC0&#41; == 0x40&#41; func += 1;	// Byte displacement<br />		if&#40;&#40;modRM &amp; 0xC0&#41; == 0x80&#41; func += 4;	// Dword displacement<br /><br />		// Skip immediate<br />		if&#40;FPU&#41;<br />		&#123;<br />			// Can't have immediate operand<br />		&#125;<br />		else if&#40;!twoByte&#41;<br />		&#123;<br />			if&#40;&#40;opcode &amp; 0xC7&#41; == 0x04 ||<br />			   &#40;opcode &amp; 0xFE&#41; == 0x6A ||	// PUSH/POP/IMUL<br />			   &#40;opcode &amp; 0xF0&#41; == 0x70 ||	// Jcc<br />			   opcode == 0x80 ||<br />			   opcode == 0x83 ||<br />			   &#40;opcode &amp; 0xFD&#41; == 0xA0 ||	// MOV<br />			   opcode == 0xA8 ||			// TEST<br />			   opcode == 0xB0 ||			// MOV<br />			   &#40;opcode &amp; 0xFE&#41; == 0xC0 ||	// RCL<br />			   opcode == 0xC6 ||			// MOV<br />			   opcode == 0xCD ||			// INT<br />			   &#40;opcode &amp; 0xFE&#41; == 0xD4 ||	// AAD/AAM<br />			   &#40;opcode &amp; 0xF8&#41; == 0xE0 ||	// LOOP/JCXZ<br />			   opcode == 0xEB ||<br />			   opcode == 0xF6 &amp;&amp; &#40;modRM &amp; 0x30&#41; == 0x00&#41;	// TEST<br />			&#123;<br />				func += 1;<br />			&#125;<br />			else if&#40;&#40;opcode &amp; 0xF7&#41; == 0xC2&#41;<br />			&#123;<br />				func += 2;   // RET<br />			&#125;<br />			else if&#40;&#40;opcode &amp; 0xFC&#41; == 0x80 ||<br />			        &#40;opcode &amp; 0xC7&#41; == 0x05 ||<br />			        &#40;opcode &amp; 0xFE&#41; == 0xE8 ||		// CALL/Jcc<br />			        &#40;opcode &amp; 0xFE&#41; == 0x68 ||<br />			        &#40;opcode &amp; 0xFC&#41; == 0xA0 ||<br />			        &#40;opcode &amp; 0xEE&#41; == 0xA8 ||<br />			        opcode == 0xC7 ||<br />			        opcode == 0xF7 &amp;&amp; &#40;modRM &amp; 0x30&#41; == 0x00&#41;<br />			&#123;<br />				func += operandSize;<br />			&#125;<br />		&#125;<br />		else<br />		&#123;<br />			if&#40;opcode == 0xBA ||			// BT<br />			   opcode == 0x0F ||			// 3DNow!<br />			   &#40;opcode &amp; 0xFC&#41; == 0x70 ||	// PSLLW<br />			   &#40;opcode &amp; 0xF7&#41; == 0xA4 ||	// SHLD<br />			   opcode == 0xC2 ||<br />			   opcode == 0xC4 ||<br />			   opcode == 0xC5 ||<br />			   opcode == 0xC6&#41;<br />			&#123;<br />				func += 1;<br />			&#125;<br />			else if&#40;&#40;opcode &amp; 0xF0&#41; == 0x80&#41;<br />			&#123;<br />				func += operandSize;   // Jcc -i<br />			&#125;<br />		&#125;<br /><br />		count++;<br />	&#125;<br /><br />	return count;<br />&#125;<br /></code></pre><br />It actually only counts the number of instructions in a binary buffer. But it's very easy to extend to a full decoder. It's this compact because it doesn't store a full instruction table at all. It actually works the way an x86 processor does its decoding. So it's also useful for a processor emulator. It has been tested extensively with, what else, SoftWire. I hope it's of use to anyone...<br /><br />Enjoy!<br /><br />Nicolas</div>
    <div class="meta">Posted on 2004-11-18 22:03:14 by C0D1F1ED</div>
   </div>
   <div class="post" id="post-153221">
    <div class="subject"><a href="#post-153221">x86 decoder</a></div>
    <div class="body">very useful :)<br /><br />thanks</div>
    <div class="meta">Posted on 2004-11-19 09:21:55 by comrade</div>
   </div>
   <div class="post" id="post-153227">
    <div class="subject"><a href="#post-153227">x86 decoder</a></div>
    <div class="body">Nice.</div>
    <div class="meta">Posted on 2004-11-19 11:00:45 by rea</div>
   </div>
   <div class="post" id="post-153236">
    <div class="subject"><a href="#post-153236">x86 decoder</a></div>
    <div class="body">heh, i just thought &quot;i recognize this code&quot;. funny to meet your alter-ego on that other site too :)</div>
    <div class="meta">Posted on 2004-11-19 14:37:00 by lifewire</div>
   </div>
   <div class="post" id="post-153390">
    <div class="subject"><a href="#post-153390">x86 decoder</a></div>
    <div class="body">IMO its much more efficient to compress a table index-wise, a quasi-RLE, and write a full LDE instead. my version was around ~420b, using the same table-compression technique as RGBLDE (which is by far the smallest technique yet :) ). hand-encoding the structions for a full decoder is not only bulky, but there are various discreptencies that must be dealt with as well.</div>
    <div class="meta">Posted on 2004-11-22 22:47:38 by Drocon</div>
   </div>
   <div class="post" id="post-153530">
    <div class="subject"><a href="#post-153530">x86 decoder</a></div>
    <div class="body">00401B40 55                   push        ebp<br />00401B41 8B EC              mov         ebp,esp<br />00401B43 6A FF               push        0FFh<br />00401B45 CC                   int          3<br /><br />your code seems can't return the correct count of above code snippet</div>
    <div class="meta">Posted on 2004-12-01 04:11:46 by Ares</div>
   </div>
   <div class="post" id="post-153611">
    <div class="subject"><a href="#post-153611">x86 decoder</a></div>
    <div class="body">Hi C0D1F1ED,<br />Here is my modification, hope I haven't made any mistake.<br /><pre><code><br />int instructionCount&#40;unsigned char *func&#41; <br />&#123; <br />   int count = 0; <br /><br />   while&#40;*func != 0xCC&#41; <br />   &#123; <br />      // Skip prefixes F0h, F2h, F3h, 66h, 67h, D8h-DFh <br />	// also need to skip segment prefixes, 2Eh,26h,36h,64h,65h<br />      int operandSize = 4; <br />      int FPU = 0; <br />      while&#40;*func == 0xF0 || <br />            *func == 0xF2 || <br />           *func == 0xF3 || <br />           &#40;*func &amp; 0xFE&#41; == 0x66 || <br />           &#40;*func &amp; 0xF8&#41; == 0xD8 ||<br />            *func == 0x2E || <br />            *func == 0x26 || <br />            *func == 0x36 || <br />            *func == 0x64 || <br />            *func == 0x65<br />		   &#41; <br />      &#123; <br />         if&#40;*func == 0x66&#41; <br />         &#123; <br />            operandSize = 2; <br />         &#125; <br />         else if&#40;&#40;*func &amp; 0xF8&#41; == 0xD8&#41; <br />         &#123; <br />            FPU = *func++; <br />            break; <br />         &#125; <br /><br />         func++; <br />      &#125; <br /><br />      // Skip two-byte opcode byte <br />      bool twoByte = false; <br />      if&#40;*func == 0x0F&#41; <br />      &#123; <br />         twoByte = true; <br />         func++; <br />      &#125; <br /><br />      // Skip opcode byte <br />      unsigned char opcode = *func++; <br /><br />      // Skip mod R/M byte <br />      unsigned char modRM = 0xFF; <br />      if&#40;FPU&#41; <br />      &#123; <br />         if&#40;&#40;opcode &amp; 0xC0&#41; != 0xC0&#41; <br />         &#123; <br />            modRM = opcode; <br />         &#125; <br />      &#125; <br />      else if&#40;!twoByte&#41; <br />      &#123; <br />         if&#40;&#40;opcode &amp; 0xC4&#41; == 0x00 || <br />            &#40;opcode &amp; 0xF4&#41; == 0x60 &amp;&amp; &#40;&#40;opcode &amp; 0x0A&#41; == 0x02 || &#40;opcode &amp; 0x09&#41; == 0x9&#41; || <br />            &#40;opcode &amp; 0xF0&#41; == 0x80 || <br />            &#40;opcode &amp; 0xF8&#41; == 0xC0 &amp;&amp; &#40;opcode &amp; 0x0E&#41; != 0x02 || <br />            &#40;opcode &amp; 0xFC&#41; == 0xD0 || <br />            &#40;opcode &amp; 0xF6&#41; == 0xF6&#41; <br />         &#123; <br />            modRM = *func++; <br />         &#125; <br />      &#125; <br />      else <br />      &#123; <br />         if&#40;&#40;opcode &amp; 0xF0&#41; == 0x00 &amp;&amp; &#40;opcode &amp; 0x0F&#41; &gt;= 0x04 &amp;&amp; &#40;opcode &amp; 0x0D&#41; != 0x0D || <br />            &#40;opcode &amp; 0xF0&#41; == 0x30 || <br />            opcode == 0x77 || <br />            &#40;opcode &amp; 0xF0&#41; == 0x80 || <br />            &#40;opcode &amp; 0xF0&#41; == 0xA0 &amp;&amp; &#40;opcode &amp; 0x07&#41; &lt;= 0x02 || <br />            &#40;opcode &amp; 0xF8&#41; == 0xC8&#41; <br />         &#123; <br />            // No mod R/M byte <br />         &#125; <br />         else <br />         &#123; <br />            modRM = *func++; <br />         &#125; <br />      &#125; <br /><br />      // Skip SIB and displacement <br />      if&#40;&#40;modRM &amp; 0x07&#41; == 0x04 &amp;&amp; &#40;modRM &gt;&gt; 6&#41; &amp; 3 != 3&#41; func += 1;   // SIB <br />      if&#40;&#40;modRM &amp; 0xC5&#41; == 0x05&#41; func += 4;   // Dword displacement, no base <br />      if&#40;&#40;modRM &amp; 0xC0&#41; == 0x40&#41; func += 1;   // Byte displacement <br />      if&#40;&#40;modRM &amp; 0xC0&#41; == 0x80&#41; func += 4;   // Dword displacement <br /><br />      // Skip immediate <br />      if&#40;FPU&#41; <br />      &#123; <br />         // Can't have immediate operand <br />      &#125; <br />      else if&#40;!twoByte&#41; <br />      &#123; <br />         if&#40;&#40;opcode &amp; 0xC7&#41; == 0x04 || <br />            &#40;opcode &amp; 0xFE&#41; == 0x6A ||   // PUSH/POP/IMUL <br />            &#40;opcode &amp; 0xF0&#41; == 0x70 ||   // Jcc <br />            opcode == 0x80 || <br />            opcode == 0x83 || <br />            &#40;opcode &amp; 0xFD&#41; == 0xA0 ||   // MOV <br />            opcode == 0xA8 ||         // TEST <br />            opcode == 0xB0 ||         // MOV <br />            &#40;opcode &amp; 0xFE&#41; == 0xC0 ||   // RCL <br />            opcode == 0xC6 ||         // MOV <br />            opcode == 0xCD ||         // INT <br />            &#40;opcode &amp; 0xFE&#41; == 0xD4 ||   // AAD/AAM <br />            &#40;opcode &amp; 0xF8&#41; == 0xE0 ||   // LOOP/JCXZ <br />            opcode == 0xEB || <br />            opcode == 0xF6 &amp;&amp; &#40;modRM &amp; 0x30&#41; == 0x00&#41;   // TEST <br />         &#123; <br />            func += 1; <br />         &#125; <br />         else if&#40;&#40;opcode &amp; 0xF7&#41; == 0xC2&#41; <br />         &#123; <br />            func += 2;   // RET <br />         &#125; <br />         else if&#40;&#40;opcode &amp; 0xFC&#41; == 0x80 || <br />                 &#40;opcode &amp; 0xC7&#41; == 0x05 || <br />                 &#40;opcode &amp; 0xFE&#41; == 0xE8 ||      // CALL/Jcc <br />                 &#40;opcode &amp; 0xFE&#41; == 0x68 || <br />                 &#40;opcode &amp; 0xFC&#41; == 0xA0 || <br />                 &#40;opcode &amp; 0xEE&#41; == 0xA8 || <br />                 opcode == 0xC7 || <br />                 opcode == 0xF7 &amp;&amp; &#40;modRM &amp; 0x30&#41; == 0x00&#41; <br />         &#123; <br />            func += operandSize; <br />         &#125; <br />      &#125; <br />      else <br />      &#123; <br />         if&#40;opcode == 0xBA ||         // BT <br />            opcode == 0x0F ||         // 3DNow! <br />            &#40;opcode &amp; 0xFC&#41; == 0x70 ||   // PSLLW <br />            &#40;opcode &amp; 0xF7&#41; == 0xA4 ||   // SHLD <br />            opcode == 0xC2 || <br />            opcode == 0xC4 || <br />            opcode == 0xC5 || <br />            opcode == 0xC6&#41; <br />         &#123; <br />            func += 1; <br />         &#125; <br />         else if&#40;&#40;opcode &amp; 0xF0&#41; == 0x80&#41; <br />         &#123; <br />            func += operandSize;   // Jcc -i <br />         &#125; <br />      &#125; <br /><br />      count++; <br />   &#125; <br /><br />   return count; <br />&#125;</code></pre><br />regards,</div>
    <div class="meta">Posted on 2004-12-02 08:12:44 by Ares</div>
   </div>
   <div class="post" id="post-153660">
    <div class="subject"><a href="#post-153660">x86 decoder</a></div>
    <div class="body">Hmm... we need three more changes...<br /><br />(1)<br /><pre><code><br />while&#40;*func == 0xF0 || <br />            *func == 0xF2 || <br />           *func == 0xF3 || <br />           &#40;*func &amp; 0xFE&#41; == 0x66 || <br />           &#40;*func &amp; 0xF8&#41; == 0xD8 || <br />            *func == 0x2E || <br />            *func == 0x26 || <br />            *func == 0x36 || <br />            *func == 0x64 || <br />            *func == 0x65 <br />         &#41;<br /></code></pre><br /> add the prefix 0x3E (DS segment override)<br /><br />(2)<br /><pre><code><br /> if&#40;&#40;modRM &amp; 0x07&#41; == 0x04 &amp;&amp; &#40;modRM &gt;&gt; 6&#41; &amp; 3 != 3&#41;<br /></code></pre><br />oops, a parenthesis:<br /><pre><code><br /> if&#40;&#40;modRM &amp; 0x07&#41; == 0x04 &amp;&amp; &#40;modRM &gt;&gt; 6 &amp; 3&#41; != 3&#41;<br /></code></pre><br />else the code &lt;8B 34 01&gt;      mov esi,dword ptr <br />is assigned 2 bytes<br /><br />(3)<br /><pre><code><br /> if&#40;&#40;modRM &amp; 0x07&#41; == 0x04 &amp;&amp; &#40;modRM &gt;&gt; 6&#41; &amp; 3 != 3&#41; func += 1;   // SIB<br /></code></pre><br />should be replaced with<br /><pre><code><br /> if&#40;&#40;modRM &amp; 0x07&#41; == 0x04 &amp;&amp; &#40;modRM&gt;&gt;6 &amp; 3&#41; != 3<br />         &#41; &#123;  // SIB<br />     unsigned char SIB = *func;<br />     func += 1;<br />     if &#40;&#40;SIB &amp; 0x7&#41; == 5&#41; func += 4;  // disp32<br />     &#125;<br /></code></pre><br />to take into account SIBs followed by disp32, e.g.<br />&lt;8B 15 00 00 40 00&gt;              mov edx,dword ptr ds:[400000h]<br /><br />Regards, bilbo<br /><br />P.S. it looks like Drocon is right... google for RGBLDE.ZIP...</div>
    <div class="meta">Posted on 2004-12-03 07:55:34 by bilbo</div>
   </div>
   <div class="post" id="post-157861">
    <div class="subject"><a href="#post-157861">Re: x86 decoder</a></div>
    <div class="body">This is realy great code :) I&#39;ve seen this a long time ago, and I was afraid that this was deleted during hack attack :(<br />Thanks god it is still here :)<br /><br />Great job man, really great job...</div>
    <div class="meta">Posted on 2005-03-10 18:17:57 by deroko</div>
   </div>
   <div class="post" id="post-158830">
    <div class="subject"><a href="#post-158830">Re: x86 decoder</a></div>
    <div class="body">C0D1F1ED,<br /><br />Do you have updated code after all these comments. <br /><br />I made one myself but it is best if you can check and repost.<br /><br />Anyway, great work.<br /><br />Visu<br /></div>
    <div class="meta">Posted on 2005-04-09 11:19:43 by visu</div>
   </div>
  </div>
 </body>
</html>