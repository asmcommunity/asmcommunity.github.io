<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>first impressions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15705" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=15705">first impressions</a></p>
   <div class="post" id="post-121692">
    <div class="subject"><a href="#post-121692">first impressions</a></div>
    <div class="body">After testing and losing time with nearly all languages in the Pascal family (Delphi, OBERON, Eiffel and many others), i finally consider HLA as my programming language.<br />The extensive docs and tutorials are impressive.<br /><br />I plan to use HLA as a replacement for OBERON.<br />My top criteria when evaluating a language are:<br />1. readibility<br />2. control<br />3. support<br /><br />HLLs such as OBERON usually give more readibility and more support.<br />But HLA gives much more control.<br />Lack of control is a plague when you know how to do advanced control but are stopped because the compiler enforces type safety, garbage collection, dynamic loading, execution environment and other services.<br /><br />I have read most of the docs, no other language is as well documented as HLA. The HLA documentation is the only one that also covers the CPU and the OS environments, both are usually considered as off-topic. The educationnal effort is remarkable and really facilitates the transition.<br /><br />Here are my first impressions, or at least the ones that i can formulate in an articulated manner:<br /><br />Fasm<br /><br />If hlatemp is used then Fasm fails with &quot;error: file not found&quot;.<br />So i have switched back to ML.EXE<br /><br /><br />Memory functions<br /><br />* is malloc-ed memory 0-ed or not (seems it is not)?<br />* so is there a stdlib function to fill memory?<br />* does malloc-ed mem-blocks have to be freed before program termination?<br />* is there a stdlib function to copy (possibly overlapping) memory?<br /><br /><br />Type coercion<br /><br />With a &quot;::&quot; type coercion operator i could write:<br /><br />  if( ::node.Prev &lt;&gt; NULL ) then<br />    add( 2, ::dword);<br />  else<br />    push (1::dword);   // simulates pushd(1)<br />  endif;<br /><br />instead of:<br /><br />  if( (type node ).Prev &lt;&gt; NULL ) then<br />    add( 2, (type dword ));<br />  else<br />    push( dword(1) );   // simulates pushd(1)<br />  endif;<br /><br />which is more cumbersome (more parenthesis) and less consistent (constant coercion and memory coercion should be the same) in my opinion.<br /><br /><br />Classes and methods<br /><br />I plan to use classes extensively so i need good support.<br />Basically what i need is an option so that &quot;this&quot; is preserved, ESI could be saved in stack frame at entrance, and then restored after any CALL. I know it seems like another code overhead but actually it's &quot;this&quot; registeration, so it's real speed improvement when &quot;this&quot; is accessed many times.<br /><br /><br />Iterators<br /><br />It's the best thing since sliced bread, HLA is really high level.<br /><br /><br />Regards,<br /><br />Damien<br /><a target="_blank" href="http://perso.wanadoo.fr/alphablock/">http://perso.wanadoo.fr/alphablock/</a><br /><a target="_blank" href="http://membres.lycos.fr/brickcaster/">http://membres.lycos.fr/brickcaster/</a></div>
    <div class="meta">Posted on 2003-10-18 16:24:22 by SpiceGuid</div>
   </div>
   <div class="post" id="post-121774">
    <div class="subject"><a href="#post-121774">Re: first impressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by SpiceGuid </em><br />After testing and losing time with nearly all languages in the Pascal family (Delphi, OBERON, Eiffel and many others), i finally consider HLA as my programming language.<br />The extensive docs and tutorials are impressive.<br /></div><br />Thank you. Welcome aboard.<br /><br /><div class="quote"><br />Here are my first impressions, or at least the ones that i can formulate in an articulated manner:<br /><br />Fasm<br /><br />If hlatemp is used then Fasm fails with &quot;error: file not found&quot;.<br />So i have switched back to ML.EXE<br /></div><br />I will look into this someday. FASM support has been weak recently (because<br />of many other recent changes in HLA), but I am interested in a totally free version<br />of HLA (and this requires something like FASM).<br /><br /><br /><div class="quote"><br />Memory functions<br /><br />* is malloc-ed memory 0-ed or not (seems it is not)?<br /></div><br /><br />You cannot assume this to be the case, in general.<br />Under Windows, I call Win32 API functions, so whatever they do...<br />Under Linux, I allocate the memory myself and I do not zero it out (why waste<br />the time doing this if most of the time it doesn't matter?).<br /><br /><div class="quote"><br />* so is there a stdlib function to fill memory?<br /></div><br /><br />No. But you can use the STOSD instruction to do this just as easily.<br /><br /><div class="quote"><br />* does malloc-ed mem-blocks have to be freed before program termination?<br /></div><br /><br />No. The OS reclaims the storage (at least, in all current implementations<br />of the HLA Standard Library).<br /><br /><br /><div class="quote"><br />* is there a stdlib function to copy (possibly overlapping) memory?<br /></div><br /><br />MOVSB/W/D does this job, depending on how you've set the direction<br />flag. The HLA StdLib doesn't provide the equivalent of &quot;bcopy&quot;, but that's<br />a trivial function to write using the MOVSB instruction.<br /><br /><br /><div class="quote"><br />Type coercion<br /><br />With a &quot;::&quot; type coercion operator i could write:<br /><br />  if( ::node.Prev &lt;&gt; NULL ) then<br />    add( 2, ::dword);<br />  else<br />    push (1::dword);   // simulates pushd(1)<br />  endif;<br /><br />instead of:<br /><br />  if( (type node ).Prev &lt;&gt; NULL ) then<br />    add( 2, (type dword ));<br />  else<br />    push( dword(1) );   // simulates pushd(1)<br />  endif;<br /><br />which is more cumbersome (more parenthesis) and less consistent (constant coercion and memory coercion should be the same) in my opinion.<br /></div><br /><br />Constant coercion and memory coercion should be the same, but I ran into problems with HLA's LALR grammar when attempting to do that. Your idea is interesting (though &quot;::&quot; is already used as scope operator in HLA). Definitely trying to make the two forms consistent is a goal in HLA v2.0.<br /><br /><br /><div class="quote"><br />Classes and methods<br /><br />I plan to use classes extensively so i need good support.<br />Basically what i need is an option so that &quot;this&quot; is preserved, ESI could be saved in stack frame at entrance, and then restored after any CALL. I know it seems like another code overhead but actually it's &quot;this&quot; registeration, so it's real speed improvement when &quot;this&quot; is accessed many times.<br /></div><br /><br />You should be able to do this with a little work using HLA macros.<br />I'd have to think through the details, but I don't think it would be that much work.<br /><br />What I really want to do in HLA v2.0 is to let the programmer decide which registers to use for THIS <br />and the VMT pointer. It's too much of a mess to fix in HLA v1.x (tried, didn't work out), but this is<br />a goal for HLA v2.0.<br /><br /><div class="quote"><br />Iterators<br /><br />It's the best thing since sliced bread, HLA is really high level.<br /></div><br /><br />I think iterators are pretty cool too :-)<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-10-19 15:01:26 by rhyde</div>
   </div>
   <div class="post" id="post-121875">
    <div class="subject"><a href="#post-121875">first impressions</a></div>
    <div class="body">Thanks for the infos and support.<br /><br />- Damien</div>
    <div class="meta">Posted on 2003-10-20 16:07:45 by SpiceGuid</div>
   </div>
   <div class="post" id="post-122025">
    <div class="subject"><a href="#post-122025">Re: first impressions</a></div>
    <div class="body"><div class="quote"><br />Type coercion<br /><br />With a &quot;::&quot; type coercion operator i could write:<br /><br />  if( ::node.Prev &lt;&gt; NULL ) then<br />    add( 2, ::dword);<br />  else<br />    push (1::dword);   // simulates pushd(1)<br />  endif;<br /><br />instead of:<br /><br />  if( (type node ).Prev &lt;&gt; NULL ) then<br />    add( 2, (type dword ));<br />  else<br />    push( dword(1) );   // simulates pushd(1)<br />  endif;<br /><br />which is more cumbersome (more parenthesis) and less consistent (constant coercion and memory coercion should be the same) in my opinion.<br /><br /><br /></div><br /><br />Well, I'm not able to help you with the &quot;less cumbersome&quot; issue yet, but the inconsistency of type coercion for constants and memory locations has been bugging me for some time and your post finally motivated me to do something about this. As of HLA v1.59 (when it appears), you will be able to use the same syntax for constant and memory type coercion, i.e.,<br /><br />(type &lt;typename&gt; &lt;memory or const&gt;)<br /><br />e.g., <br /><br />However, you still can't get away with &quot;push( (type dword 1));&quot;, nor can you<br />do something like &quot;mov( (type dword 1),  );&quot; because you must specify<br />the memory size, not the constant's size (e.g., use pushd or use (type dword )).<br />pushd/pushw is necessary because &quot;push( (type word 1) );&quot; is still ambiguous<br />(it's perfectly reasonable to push a word constant, appropriately extended, as<br />a double word value; ditto for the mov instruction).<br /><br />The main use for this common syntax is going to be in macros. This allows you<br />to do something like the following:<br /><br />#macro xxx( yyy );<br /><br />   mov( (type byte yyy), al );<br /><br />#endmacro<br /><br />and not have the compiler choke because you fed it a constant rather than<br />a memory location.<br /><br />As for the condensed syntax, well, I'll worry about a more consistent syntax<br />for HLA v2.0.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-10-21 19:42:08 by rhyde</div>
   </div>
  </div>
 </body>
</html>