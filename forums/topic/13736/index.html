<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Athlon &amp; P4: optimization difference - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13736" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13736">Athlon &amp; P4: optimization difference</a></p>
   <div class="post" id="post-106364">
    <div class="subject"><a href="#post-106364">Athlon &amp; P4: optimization difference</a></div>
    <div class="body">Friend of mine ask me to speed up one of his function, written in C. After scratching a head (I never playing with FPU before) I've managed to translate it. Here is C source:<br /><br /><pre><code>double	cur_discr = 0.0;	//current temperature difference<br />double	max_cur_discr = 0.0;//maximum cur_discr in iter.<br />double	max_discr = 1.0;	//-=-, after 1000 iter.<br />double	t0;					//temperature before recalc<br />long	needCountDiscr = false;//do we need to calc discrepancy<br /><br />do<br />&#123;<br />	for &#40;int i = 1; i &lt; height-1; i++&#41;<br />	&#123;<br />	//if &#40;0 == i || &#40;height - 1&#41; == i&#41; continue;<br />		for &#40;int j = 0; j &lt; width; j++&#41;<br />		&#123;<br />			left = j - 1;<br />			top = i - 1;<br />			right = j + 1;<br />			bottom = i + 1;<br />			if &#40;0 == j&#41;<br />					left = width - 1;<br />			if &#40;&#40;width - 1&#41; == j&#41;<br />					right = 0;<br />			<br />			t0 = Tmp&#40;i, j&#41;;<br />				double test1 = Cleft &#40;i, j&#41;;<br />				double test2 = Ctop &#40;i, j&#41;;<br />				double test3 = Cright &#40;i, j&#41;;<br />				double test4 = Cbottom &#40;i, j&#41;;<br />			Tmp&#40;i, j&#41; = <br />				Tmp&#40;i, left&#41;	/ Cleft &#40;i, j&#41;		+<br />				Tmp&#40;top, j&#41;		/ Ctop &#40;i, j&#41;		+<br />				Tmp&#40;i, right&#41;	/ Cright &#40;i, j&#41;		+<br />				Tmp&#40;bottom, j&#41;	/ Cbottom &#40;i, j&#41;;<br />								<br />			if &#40;needCountDiscr&#41;<br />			&#123;<br />				cur_discr = Tmp&#40;i, j&#41; - t0;<br />				if &#40;cur_discr &lt; 0.0&#41; cur_discr *= -1.0;<br />				if &#40;cur_discr &gt; max_cur_discr&#41; <br />					max_cur_discr = cur_discr;<br />			&#125;<br />		&#125;<br />	&#125; <br />	if &#40;needCountDiscr&#41; <br />	&#123;<br />		max_discr = max_cur_discr;<br />		max_cur_discr = 0.0;<br />	&#125;<br />	m_IterCount++;<br />	if&#40;!&#40;m_IterCount % 1000&#41;&#41; <br />		needCountDiscr = true;<br />	else <br />		needCountDiscr = false;<br />&#125; while &#40;max_discr &gt; m_Props.discrepancy&#41;;</code></pre><br /><br />And here is assembly:<br /><pre><code>_asm &#123;<br />		//int 3<br />		mov esi, Tmp<br />		mov esi, &#91;esi+10h&#93;<br />		mov esi, &#91;esi+4&#93; ; esi is a start of doubles<br /><br /><br />__do&#58;<br />		xor ecx, ecx<br />	__next_inner&#58;<br />		inc ecx<br />		cmp ecx, total<br />		jae __end_outer<br />		emms<br />		//int 3<br />		mov edi, Cbottom+10h<br />		mov edi, &#91;edi+4&#93;<br />		lea edi, &#91;edi+ecx*8&#93;<br />		fld qword ptr &#91;edi&#93; ; st3<br />		mov edi, Ctop+10h<br />		mov edi, &#91;edi+4&#93;<br />		lea edi, &#91;edi+ecx*8&#93;<br />		fld qword ptr &#91;edi&#93; ; st2<br />		mov edi, Cright+10h<br />		mov edi, &#91;edi+4&#93;<br />		lea edi, &#91;edi+ecx*8&#93;<br />		fld qword ptr &#91;edi&#93; ; st1<br />		mov edi, Cleft+10h<br />		mov edi, &#91;edi+4&#93;<br />		lea edi, &#91;edi+ecx*8&#93;<br />		fld qword ptr &#91;edi&#93; ; st0<br /><br />		<br />		lea edi, &#91;esi+ecx*8-8&#93; // left<br />		fld qword ptr &#91;edi&#93;<br />		fxch<br />		fdivp st&#40;1&#41;, st&#40;0&#41; // Tmp/left<br /><br />		lea edi, &#91;esi+ecx*8+8&#93; ; right<br />		fld qword ptr &#91;edi&#93;<br />		fdiv st&#40;0&#41;, st&#40;2&#41; ; Tmp/right<br />		faddp st&#40;1&#41;, st&#40;0&#41; ; sum<br /><br />		mov edx, width<br />		shl edx, 3 ; *8<br />		mov eax, edx<br />		neg eax<br />		lea eax, &#91;ecx*8+eax&#93;<br />		lea edi, &#91;esi+eax&#93; ; top<br />		fld qword ptr &#91;edi&#93;<br />		fdiv st&#40;0&#41;, st&#40;3&#41; ; Tmp/top<br />		faddp st&#40;1&#41;, st&#40;0&#41; ; sum<br /><br />		lea eax, &#91;ecx*8+edx&#93;<br />		lea edi, &#91;esi+eax&#93; ; bottom<br />		fld qword ptr &#91;edi&#93;<br />		fdiv st&#40;0&#41;, st&#40;4&#41; ; Tmp/bottom<br />		faddp st&#40;1&#41;, st&#40;0&#41; ; sum<br /><br />		lea edi, &#91;esi+ecx*8&#93;<br />		fld qword ptr &#91;edi&#93; ; t0<br /><br />		fxch<br /><br />		fst qword ptr &#91;edi&#93; ; save current Tmp&#40;i, j&#41;<br />					<br />		mov eax, needCountDiscr<br />		test eax, eax<br />		jz __next_inner<br />			//int 3<br />			fsub st&#40;0&#41;, st&#40;1&#41;<br />			fldz<br />			fcomip st&#40;0&#41;, st&#40;1&#41;<br />			jz __nextcmp<br />			jc __nextcmp<br />				fchs ; *-1<br />		__nextcmp&#58;<br />				lea eax, cur_discr<br />				lea edx, max_cur_discr<br />				fst qword ptr &#91;eax&#93;<br />				fld qword ptr &#91;edx&#93;<br />				fcomip st&#40;0&#41;, st&#40;1&#41;<br />				jnc __next_inner<br />					fst qword ptr &#91;edx&#93;<br />		<br />		jmp __next_inner<br />	__end_outer&#58;	<br />		mov eax, needCountDiscr<br />		test eax, eax<br />		jz __inc_iter<br />		//int 3<br />		emms<br />		lea eax, max_discr<br />		lea edx, max_cur_discr<br />		fld qword ptr &#91;edx&#93;<br />		fstp qword ptr &#91;eax&#93;<br />		fldz<br />		fstp qword ptr &#91;edx&#93;<br />	__inc_iter&#58;<br />		inc IterCount<br />		mov eax, IterCount<br />		mov ebx, 1000<br />		cdq<br />		idiv ebx<br />		xor eax, eax<br />		test edx, edx<br />		cmp edx, 1<br />		adc eax, eax<br />		mov needCountDiscr, eax<br />		<br />		lea eax, max_discr<br />		fld qword ptr &#91;eax&#93;<br />		lea eax, discr<br />		fld qword ptr &#91;eax&#93;<br />		; st1 = max_discr, st0 = discr<br />		fcomip st&#40;0&#41;, st&#40;1&#41;<br />		jc __do<br />		jz __do<br />	&#125;<br /></code></pre><br /><br />Quite a big piece of code :)<br />This code is executed about 200 000 of iteration and each iteration include running through every Tmp(i, j) element, which is a REAL8 (or double in C), length of Tmp field is a little more than 20 000 element, Cxxxx all have the same size. The problem is Athlon execute this code much more faster than P4.<br />Approximately, Athlon XP 2200+ spends about 33 minutes, P4 2 GHz with non-optimized C code spends about 50 minites, but with optimization more than 5 times slower. I know about Athlon executes FPU operation a little faster than P4, but difference is to huge... All data aligned properly.<br />Any suggestions?</div>
    <div class="meta">Posted on 2003-06-08 09:43:09 by masquer</div>
   </div>
   <div class="post" id="post-106368">
    <div class="subject"><a href="#post-106368">Athlon &amp; P4: optimization difference</a></div>
    <div class="body">Lame low level analysis:<br /><pre><code>jc __?<br />jz __?<br /><br />&#91;b&#93;Same as&#58;&#91;/b&#93;<br /><br />jna __?</code></pre><br /><br /><pre><code><br />lea	edi, &#91;edi+ecx*8&#93;<br />fld	qword ptr &#91;edi&#93;<br /><br />&#91;b&#93;Same as&#58;&#91;/b&#93;<br /><br />fld	qword ptr &#91;edi+ecx*8&#93;</code></pre><br /><br />FXCH is virtually free, but...<pre><code><br />fld qword ptr &#91;edi&#93;<br />fxch<br />fdivp st&#40;1&#41;, st&#40;0&#41; // Tmp/left<br /><br />&#91;b&#93;Same as&#58;&#91;/b&#93;<br /><br />fld qword ptr &#91;edi&#93;<br />fdivrp // Tmp/left</code></pre><br /><br /><pre><code><br />mov edx, width<br />shl edx, 3 ; *8<br />mov eax, edx<br />neg eax<br />lea eax, &#91;ecx*8+eax&#93;<br />lea edi, &#91;esi+eax&#93; ; top<br /><br />&#91;b&#93;Same as&#58;&#91;/b&#93;<br /><br />mov edx, width<br />mov eax, ecx<br />sub eax, edx<br />shl edx, 3<br />fld qword ptr &#91;esi + eax*8&#93;<br /></code></pre><br /><br />No branch needed here!<pre><code><br />if &#40;cur_discr &lt; 0.0&#41; cur_discr *= -1.0;<br /><br />&#91;b&#93;Same as&#58;&#91;/b&#93;<br /><br />fabs cur_discr</code></pre>I have not looked at the algorithm at a higher level, just instruction usage.  There is much work to be done here, imho.  Intel has given up on improving the FPU -- SSE2 should be used if possible.</div>
    <div class="meta">Posted on 2003-06-08 10:53:30 by bitRAKE</div>
   </div>
   <div class="post" id="post-106375">
    <div class="subject"><a href="#post-106375">Athlon &amp; P4: optimization difference</a></div>
    <div class="body">Thanks <strong>bitRAKE</strong>,<br /><br /><div class="quote">Lame low level analysis</div><br />Absolutely agree :)<br /><br />But is P4 so slow with FPU? And what is your forecast about using SSE2 here?</div>
    <div class="meta">Posted on 2003-06-08 11:23:59 by masquer</div>
   </div>
   <div class="post" id="post-106377">
    <div class="subject"><a href="#post-106377">Athlon &amp; P4: optimization difference</a></div>
    <div class="body">SSE2 should be much faster on P4.</div>
    <div class="meta">Posted on 2003-06-08 11:41:13 by EÃ³in</div>
   </div>
   <div class="post" id="post-106378">
    <div class="subject"><a href="#post-106378">Athlon &amp; P4: optimization difference</a></div>
    <div class="body"><div class="quote"><em>Originally posted by masquer </em><br />But is P4 so slow with FPU? And what is your forecast about using SSE2 here?</div>In comparison to a similarly clocked Athon, yes - the P4 is only half the machine when comes to FPU.  The problems in the code above are the result of other factors as well - there is much more branching than needed (the nasty unpredicatable type, too).  P4's really suffer for random branching - give them a straight piece of code and they'll plow right through it.<br /><br />Using SSE2 here should help to remove all of the bad branching.<br /><br />Yes, the &quot;5 times slower&quot; is not what I would expect, but I'd have to see the code generated by the compiler to comment on that.</div>
    <div class="meta">Posted on 2003-06-08 11:45:26 by bitRAKE</div>
   </div>
   <div class="post" id="post-106499">
    <div class="subject"><a href="#post-106499">Athlon &amp; P4: optimization difference</a></div>
    <div class="body">Hate to think about SSE2, since I have no P4 around, only Athlons :)<br />I can remove some branching here but seems it does nothing on P4 :(<br />OK, here is compiler's output in attachment.</div>
    <div class="meta">Posted on 2003-06-09 09:16:01 by masquer</div>
   </div>
  </div>
 </body>
</html>