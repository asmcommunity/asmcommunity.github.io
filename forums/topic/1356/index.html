<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>MASM Interpreter? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1356" />
    <link rel="next" href="../?id=1356&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1356">MASM Interpreter?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=1356&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=1356&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="1356" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=1356&amp;page=2">&gt;</a><a href="../?id=1356&amp;page=2">&raquo;</a></form>   <div class="post" id="post-8732">
    <div class="subject"><a href="#post-8732">MASM Interpreter?</a></div>
    <div class="body">This wouldn't be a 100% architecturallly acurate interpreter.  It will let you modify your source while it's executing though to track down workflow issues and constants and stuff, and even keep making changes to your incorrect algorithms without having to constantly recompile or restart the interpreter, but real debugging will need a debugger still.</div>
    <div class="meta">Posted on 2001-10-05 16:35:48 by _Shawn</div>
   </div>
   <div class="post" id="post-8735">
    <div class="subject"><a href="#post-8735">since you were too scared to tell it like it is</a></div>
    <div class="body">what about custom macros? won't it choke on that?<br />further more isn't this 'overkill'? it doesn't take that long to rebuild things does it?<br /><br />If we could build it in a webserver then we'd have Asm Server Pages :alright:<br /><br />I edited your last option a bit :grin:</div>
    <div class="meta">Posted on 2001-10-05 17:01:31 by Hiroshimator</div>
   </div>
   <div class="post" id="post-8737">
    <div class="subject"><a href="#post-8737">MASM Interpreter?</a></div>
    <div class="body">I'm gonna work on it anyway... &amp; you can't stop me... so NAna NAna NA :tongue:  So I guess i vote don't care<br />-------------------------------<br />Hiro, yes it's definitely overkill... &amp; so's having psychedelic colors &amp; drag-n-drop on any ide that doesn't mean that there isn't a niche for it anyway. Actually, there are tons of reasons for NOT doing it &amp; only a few FOR doing it.<br />---------------<br />Anywho, this is all smoke &amp; mirrors until it gets done. Can't prove to you the why of it until I/we stop blowing smoke :grin:</div>
    <div class="meta">Posted on 2001-10-05 17:31:19 by rafe</div>
   </div>
   <div class="post" id="post-8738">
    <div class="subject"><a href="#post-8738">MASM Interpreter?</a></div>
    <div class="body"><div class="quote">If we could build it in a webserver then we'd have Asm Server Pages</div><br /><br />Funny enough I just decided I wanted to implement AHP (<strong>A</strong>ssembly <strong>H</strong>ypertext <strong>P</strong>reprocessor) in the webserver I'm writing for HTTPFT (file transfer program) :grin: .<br />But not in the same manner as you mean, it will be nothing special, it will be a combination of HTML and special codes that can call parts of normal code, written in asm of course.. I created it to make a good combination of easy to edit HTML code and some kind of scripting/executable code.<br /><br />_Shawn: about your idea, I discussed it with NaN already like he said in the other post...<br />Actually I don't know if I want such a parser.<br />Every additional layer onto 'pure assembler' (whatever that may be :)) you loose control and you're moving to a higher level language...<br />Okay, I am not writing code in hex, and yes I'm using MASM's IFs and ELSEs which are not perfectly optimized but I can see what happens and I know what MASM will make of it. <br />The objects.inc for our OOP project also shows exactly what happens, and while I was first sceptic about macros (mostly about their speed), I now see they are really powerfull and actually quite fast. On the other hand, it could make life easier to have some higher level things the parser can handle... But I'm probably not going to use it... <br />I'm happy with what MASM has to offer and with macros you can add a lot of functionality. <br />It's a personal opinion.. Some people may like it, some may not..<br />Let's wait for the poll results :) <br /><br />Thomas</div>
    <div class="meta">Posted on 2001-10-05 17:37:03 by Thomas</div>
   </div>
   <div class="post" id="post-8739">
    <div class="subject"><a href="#post-8739">MASM Interpreter?</a></div>
    <div class="body">Yeah, it probly would choke on macros, I suppose that leaves Ernie and Thomas?? out of the equation with their OOP stuff.  Seriously, there's a way to overcome that and where there's a will, there's a way.<br /><br /><br />Thanks,<br />Shawn</div>
    <div class="meta">Posted on 2001-10-05 17:38:03 by _Shawn</div>
   </div>
   <div class="post" id="post-8740">
    <div class="subject"><a href="#post-8740">MASM Interpreter?</a></div>
    <div class="body">People are misunderstanding the interpreter.  There have been times when trying to track down a bug and tweak for the right constand or make changes until the mathmatics came out properly means GPF's or change then compile and run then crash then compile and run.  If it can be run in an interpreter, it will allow you to &quot;Preview&quot; your program and make those changes on the fly and then compile and run it once you've worked out the issues. <br /><br />Ya'll may not use it but I will.<br /><br /><br />Thanks,<br />Shawn</div>
    <div class="meta">Posted on 2001-10-05 17:41:09 by _Shawn</div>
   </div>
   <div class="post" id="post-8741">
    <div class="subject"><a href="#post-8741">MASM Interpreter?</a></div>
    <div class="body">it would be cool to be able to do that. Even cooler would be to have special debug functions<br />may starting with ;Debug<br />like ;DebugMessageBox &quot;text&quot; :)<br /><br />that only execute in the interpreter like that. No more worries about including debug/test code</div>
    <div class="meta">Posted on 2001-10-05 17:55:09 by Hiroshimator</div>
   </div>
   <div class="post" id="post-8762">
    <div class="subject"><a href="#post-8762">MASM Interpreter?</a></div>
    <div class="body">Its not that I think the idea is without merit but it has some very big problems. A compiler effectively converts human coded text to binary code and it has enough tests to ensure that the conversion works within a set of rules, usually related to what will actually work.<br /><br />An assembler already does that within a set of rules but if you layer it, you lose the method of testing if something works correctly.<br /><br />To a reasonable extent you can correct this problem by building enough libraries to encapsulate a lot of code and then use some well written macros to make them a lot easier to use but you are shifting to a compiler by doing this.<br /><br />What you have to look at is if a compiler will already do it better. Its easy enough to write code that a compiler will beat if you have not done it well or it is a difficult algorithm but layering assembler code rather than building a compiler directly leaves you open to wasting your time.<br /><br />Still, I don't like to take the fun out of anybodies effort so don't let a preference for some good hex get in the way of writing a new toy, variation and flexibility is still where the action is as long as it delivers the goods.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-10-06 02:46:54 by hutch--</div>
   </div>
   <div class="post" id="post-8773">
    <div class="subject"><a href="#post-8773">Could someone explain to me...</a></div>
    <div class="body">What can a interpreter do that a debugger can't? A debugger sounds like a lot less work, even if you choose to hide the fact that it really is a debugger (meaning you show the user's code, not the disasm) I think it's be less work. And another thing, the way the Pentium chips handle opcodes is better documented then the way MASM handles your commands. And macro's wouldn't be a problem if you know the source to a program (this is a cheap solution however :) )<br /><br />Anyway, if I'm being stupid tell me :)... and good luck.</div>
    <div class="meta">Posted on 2001-10-06 07:31:28 by Qweerdy</div>
   </div>
   <div class="post" id="post-8792">
    <div class="subject"><a href="#post-8792">Just my opinion</a></div>
    <div class="body">Qweerdy,  Good question &amp; one I seriously considered before I started on this Quixotic quest.  Hutch is correct this is a BIG project. I may not be up to the task.  Here's how my twisted logic went... I wanted to learn about asm &amp; effcient programming &amp; change to things on the fly.  Debuggers will let you do that in a rather limited way.  I also want to have at my fingertips optimization info &amp; other info not presented in classical debuggers like cache state etc.  Debuggers are excellent at machine state not so good at on the fly changes or partial program fragments &amp; they're no good about trying code frags on different chips etc.  So then I got the idea of writing the uber-debugger geared toward asm.  Note that there's a bit of interpreter in every debugger to start with &amp; by the time I got done thinking about the god's-gift-to-debuggers project I realized that there was little debugger left &amp; mostly interpreter. Logical chioce, start from the ground up w/ interpreter. <br /><br />Please note: that I firmly beleive in learning asm, even tho I'm currently writing perl &amp; c/c++ &amp; sql at work I believe that asm is truly helping me be a better programmer in those areas.  I need a windmill to tilt at because just reading up wasn't getting me any good at it.  For some it's games (HE) for others it's OSs still others sorts (hutch--) for me it's this project. written so as the modular parts may possibly have wider applicability.  I'm not really looking for converts just yet &amp; it may wind up being total crap when I'm done... but the journey will have been fun &amp; worth it.</div>
    <div class="meta">Posted on 2001-10-06 12:59:50 by rafe</div>
   </div>
   <div class="post" id="post-8794">
    <div class="subject"><a href="#post-8794">MASM Interpreter?</a></div>
    <div class="body">Good word rafe.  You summed it up.  Peronsally, I know that there have been times in my quest with MASM that I've spent code-run-error-code-run-error-code-run-error-repeat until I finally got some constant correct, or figured out that I forgot an instruction, or had them in the wrong order or had an extra instruction.  I gets annoying after a while when it's a small change but you have to reassemble every change.<br /><br />To me, the interpreter allows me to do what a debugger won't.  It allows me to break into the source code of the program, step by step execute my assembly instructions, figure out exactly what instruction or block of instructions is causing the error, make changes, specially if it's just a Windows constant or something, and keep going or keep setting the currently executing code back a few instructions and keep tweaking it until it works.  To me, it's more efficient to debug in that manner since I am interacting with the code itself and the registers and everything (emulated, nonetheless) until I get it right and then I can compile it and rest assured that it will work.<br /><br />People are talking about adding layers onto the assembler and slowing it down.  This interpreter is not to execute the program in the end.  It's only to make debugging more interactive becuase a debugger won't allow you to change the source code and constants and add lines of code and remove lines of code while it's still executing and to see the state of all the variables themselves since a debugger doesn't know what the variables are, just locations of memory.<br /><br />This is a tool.  Nothing more.  How well it'll emulate the x86 architecture remains to be seen.  At the least, it'll allow you to fine tune some algorithms while the program is still running and will allow you to see all the variable, modify the values of the variables, add/remove lines of code, change lines of code, and other stuff without having to keep recompiling and watching through a debugger showing the compiled result, instead, this shows you your actual source code.<br /><br />People may not like it.  Fine.  But I'll tell you, tools like this make it much easier to debug because it's real-time, interactive, and based on the actual source which means you can interact with the variables and structures and such themselves, which most debuggers won't do, since they don't know they variable names and so on.  In the end, the program will be compiled with MASM like it is today.  The interpreter is just a different kind of debugging tool.<br /><br />Just my $.02<br />Shawn</div>
    <div class="meta">Posted on 2001-10-06 14:05:00 by _Shawn</div>
   </div>
   <div class="post" id="post-8841">
    <div class="subject"><a href="#post-8841">MASM Interpreter?</a></div>
    <div class="body">You guys seen the VC debugger. It allows me to change the source while debugging and i can even change all the values in the variables. It seems almost like an interpreter to me.</div>
    <div class="meta">Posted on 2001-10-07 00:38:53 by MovingFulcrum</div>
   </div>
   <div class="post" id="post-8843">
    <div class="subject"><a href="#post-8843">MASM Interpreter?</a></div>
    <div class="body">An assembly interpreter for 16 bit code already exists,<br />and works very well (see my home page, follow the<br />link from 'A Ketman Page' to the creator's home<br />page). It does indeed make working out ideas and<br />algorithms much easier. <br /><br />Don't let sceptics get you down, guys. Fact is, I have<br />felt horribly restricted ever since I moved from<br />learning 16-bit assembly on the Ketman assembly<br />interpreter to 32-bit assembly with MASM. The<br />interpreter let me single step, observe effects in<br />register windows, custom data windows, etc., then<br />either make changes to the code, back step and<br />run again, or make changes to some block of memory<br />and run another few lines, or whatever I cared to<br />do.<br /><br />So go for it. I will certainly try it if you get it done;<br />I MISS my back-stepping, dang it! Oh, and the<br />16-bit interpreter isn't a simulation; it actually runs<br />the machine code created by your assembly directly<br />on the processor, retrieving resulting states and displaying them. <br /><br />craig</div>
    <div class="meta">Posted on 2001-10-07 02:08:59 by bitnaut</div>
   </div>
   <div class="post" id="post-8869">
    <div class="subject"><a href="#post-8869">MASM Interpreter?</a></div>
    <div class="body">Falcrum,<br /><br />The VC++ debugger doesn't run you're MASM source, tho, does it?  Yeah, it'll debug anything.  But will it integrate with the source of your MASM project?  Maybe there is a way, but it's not an interpreter.  When it compiles the project, it leaves lots of NOP's so you can make changes but there are points where you simply can't make changes without having to stop the debugger.  Therefore, this idea is still superior.<br /><br />I'm not preaching to you guys, anyway.  If you don't want to use it, fine.  You don't have to.  But there are some who are at least willing to consider what it does.  I think by having the word &quot;Interpreter&quot; it's giving the wrong message.  It's a &quot;live, interactive debugger that emulates the source code and lets you change, add, or remove source code during runtime&quot;.  Once you've worked out certain things in real-time you can compile in MASM like you do today.<br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2001-10-07 12:45:10 by _Shawn</div>
   </div>
   <div class="post" id="post-8873">
    <div class="subject"><a href="#post-8873">MASM Interpreter?</a></div>
    <div class="body">If your implying it would act sorta like a resource editor would, where you can &quot;see&quot; and test menus, dialog boxes etc,  before you compile it into your exe... this would be a most impressive tool in an assembly sense.  (providing the overhead is efficient).  <br /><br />But i have to admitt that something like that for assembly in general would be VERY difficult, as a resource editor has certain boundries, but assembly in general can go practially anywhere with its code...<br /><br />NaN</div>
    <div class="meta">Posted on 2001-10-07 15:03:52 by NaN</div>
   </div>
   <div class="post" id="post-8905">
    <div class="subject"><a href="#post-8905">MASM Interpreter?</a></div>
    <div class="body">Will it be coded in asm?  What processors will it support?  Will it be easy to add new processors?  How will you represent the machine description?  Could this serve as a translator as well?<br /><br />It is a <u>big</u> project.  I like the idea very much. :)</div>
    <div class="meta">Posted on 2001-10-08 00:41:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-8910">
    <div class="subject"><a href="#post-8910">MASM Interpreter?</a></div>
    <div class="body">Generation 1 is a little simple.  We are planning on just making it read an instruction or macro command, and emulating it's use.  NOt really a .286 or .386p or .586 thingy, really.  Read an intruction, execute.  Generation 2 may be a little more complex.  We've got our work.  It appears to be easier to emulate C++ but this is fun :d<br /><br /><br />_Shawn</div>
    <div class="meta">Posted on 2001-10-08 02:17:54 by _Shawn</div>
   </div>
   <div class="post" id="post-8913">
    <div class="subject"><a href="#post-8913">MASM Interpreter?</a></div>
    <div class="body">Shawn,<br />  I am all for the intrepreter project. I know vc debugger cant handle masm source. All i wanted to say was that even if u make something like it, it would be excellent  :alright:</div>
    <div class="meta">Posted on 2001-10-08 03:19:51 by MovingFulcrum</div>
   </div>
   <div class="post" id="post-8942">
    <div class="subject"><a href="#post-8942">MASM Interpreter?</a></div>
    <div class="body">My parts of it will be written as asm DLLs. Should they prove useful &amp; timely to Shawn then he may use them.  Of course, one test of the usefulness of the interpreter is try &amp; use it to rewrite itself, even the asm parts.  It's a strategy as old as Lisp.</div>
    <div class="meta">Posted on 2001-10-08 10:18:37 by rafe</div>
   </div>
   <div class="post" id="post-8945">
    <div class="subject"><a href="#post-8945">MASM Interpreter?</a></div>
    <div class="body">Yes, rafe is writing the parser, scanner, and lexer... I'll be doing the actual interpretation part in C++.  I have intentions to optimize it but to first get it working.<br /><br />I have a plaging question I'd like to ask of people in this group.  One thing that we'll have to do it give it the ability to perform API's and to read into .obj files, in the case you're including someone's asm lib or something... how would we go about reading an obj file and then executing a function?  In most cases, it would already exist in a dll.  For example, if my project that I'm going to interpret for debugging purposes includes the masm32 lib then how would we go about that?<br /><br />Would we use the included .inc and then use that for type checking and so on, but then just loadfunction into the proc address in the dll?  What about the variables that need to be accesses, that could be a tough one.  I know it can be done, Borland and MS do it, so can we.<br /><br />The other tough part will be to make the resource files run in the interpreter but that shouldn't be too difficult.<br /><br />I think this can be done once we figure out how to get the flags and all that stuff working properly then the rest &quot;falls into place&quot;.<br /><br />For interpretation, we'll decode the instruction and then simulate it using all the internally simulated registers and flags and memory addresses and heaps and stacks and so on.  There will be opimizations to make it not too slow.  Of course, with it running through a emulation layer it won't be too fast, but then, since this isn't for normal program execution, that shouldn't matter.  Once we have it working we'll clean it up and make it faster and better and more capable.<br /><br />our ultimate intentions are to write an engine so that we can plug NASM, FASM, SPASM, MASM, TASM, HLA, or any other assembly syntax into it and it'll work.  This means it has to be some kind of virtual machine but we're hoping to avoid that.  But we'll see.  We don't want to lock it down to MASM.<br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2001-10-08 10:45:25 by _Shawn</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=1356&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=1356&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="1356" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=1356&amp;page=2">&gt;</a><a href="../?id=1356&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>