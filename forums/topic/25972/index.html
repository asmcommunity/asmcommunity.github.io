<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Project : XASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25972" />
    <link rel="next" href="../?id=25972&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=22">Recruitment</a> &raquo; <a href="../?id=25972">Project : XASM</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=25972&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=25972&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="25972" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=25972&amp;page=2">&gt;</a><a href="../?id=25972&amp;page=2">&raquo;</a></form>   <div class="post" id="post-189277">
    <div class="subject"><a href="#post-189277">Project : XASM</a></div>
    <div class="body">This is my first formal request for expressions of interest in my CROSS ASSEMBLER project.. If enough users are willing to help where they can, I will ask Spook to create a discussion space here, under Hosted Projects, and use it to share and maintain the project sourcecode, which is public domain under the MoreBeerWare license (not GPL&#39;d).<br /><br />Since I have already offered the use of the name XASM to an interested party, I will and do consider this a WORKING TITLE ONLY, subject to said party getting off their posterior and using it before I go Beta :P<br /><br />Who:<br />You, me and Bobby McGee<br /><br />What:<br />XASM is a multi-syntax, multi-platform compiler/assembler hybrid (&#39;compembler&#39;), which abstracts all notions of a Physical Machine, and allows the user more control : for example, to define entities such as Registers and OpCode Encodings.<br /><br />When:<br />Tokenizer and Lexical Parser written over 2 years ago, all other code written within the past 6 months, at my leisure.<br /><br />Where:<br />So far, mostly in my kitchen, since that&#39;s where the coffee is.<br /><br />Why: (my pet hates)<br />I hate porting code.<br />I hate switching from one assembler to another, and having to remember/learn the various subtle differences in Grammar and Syntax.<br />I hate that no one assembler can produce output for arbitrary hardware platforms, including those which don&#39;t yet exist.<br />I hate that I can&#39;t always easily port my macros between assemblers.<br />I hate that I can&#39;t use assembler macros within INLINE ASM blocks in C/C++.<br />I hate that the corporate universe is determined to kill off my language of choice.<br /><br />I felt that VM concepts were sound, but had been aimed at the highlevel aspects of programming (by highlevel programmers) for too long.<br />With the rebirth of OOPASM as a formal programming paradigm, the line between assembler and compiler becomes blurred.<br />I decided to wash that pesky line away altogether, and to apply VM concepts beginning with most lowlevel aspects of programming - to do away with the notion of a Physical Machine entirely.<br /><br />I&#39;ve written XASM to allow for loose syntax - I intend it to support the free mixing of all major assembler, C and C++ syntaxes, and to support output to arbitrary hardware platforms and operating systems.<br /><br />XASM is based on VM concepts, and is written for MASM/OA32.<br /><br />If you are interested in joining the XASM Development Team, please respond within this thread and/or via the PM facility on this board.<br /><br />H.</div>
    <div class="meta">Posted on 2007-05-18 01:19:44 by Homer</div>
   </div>
   <div class="post" id="post-189299">
    <div class="subject"><a href="#post-189299">Re: Project : XASM</a></div>
    <div class="body">Just random thoughts:<br /><br />won&#39;t little-endian/bigE introduce trouble when doing low-level byte-addressing of dwords, for instance? <br /><br />Syntax... there&#39;s already one such &quot;assembler&quot; or preparser for nasm - I can&#39;t remember/find its name. <br /><br />The VM integration is interesting - but managed memory is what springs to mind as the only viable reference to that idea.&nbsp; So, a language like the D language, but accessible in arbitrary syntax is what can be a good vector :) . I feel the need for managed memory sometimes (especially around complex undo/redo)... Just make sure to do auto-garbage collection when a large memory chunk is dereferenced completely. Non-cooperative memory-hogging Java applications is what everyone&#39;s sick of. <br /><br />Why base the assembler on VM, instead of compilation? Portability of Java &quot;binaries&quot; is a sick joke of marketing, it really takes 100 hours instead of 10 hours to port real Java software to another platform successfully. And in those 100 hours one can hear developers scream and break things in the office :). <br /><br />A flaw in the design of XASM imho is that you can attain portability only of simple code, that doesn&#39;t rely on features of platforms. Unless you make huge supporting libraries, each with versions for each platform to support. Same &quot;flaws&quot; as C/C++ - and same way of fixing them. <br /><br />I can see (and would use) XASM only as an alternative to C/C++/D, as a compiler. Where speed matters, I&#39;d always use the appropriate assembler (though I usually change the syntax a bit to be comfortable for me). The modern instruction sets aren&#39;t that many: x86, x64, ARM, PIC, AVR, PowerPC, CellSPE; and few people have to learn more than 2 of them. <br />Syntax-differences in two assemblers for the same cpu is what could be bothersome, as you said. But I find it much more frustrating when there&#39;s no macro preprocessor at least as powerful as the one in MASM (as you noted). <br /><br /><div class="quote"><br />I hate that no one assembler can produce output for arbitrary hardware platforms, including those which don&#39;t yet exist.<br /></div><br />Wouldn&#39;t such an &quot;assembler&quot; then be called a &quot;compiler&quot;? No matter how one looks at different instruction-sets, the huge incompatibilities between cpus become obvious. Operations like &quot;stmdb sp!, {r4-r12,r14}&quot;&nbsp; (ARM) and &quot;btfsc STATUS,C&quot; (PIC) are often used on these cpus. The abstractions to use are so high-level, that the assembler is no longer an assembler. And the common denominator of possible computations after such an abstraction is small - just like in C. You can only tilt that just a bit by choosing a dominating instruction-set (where XASM will compile best), and then conforming it for other ISs.  But if you end up having to use a state-variable in order to conform to some specific operation - without TLB and often-repeated slow access to the TLB data, thread-safety is impossible. <strong></strong> Heck, even registers will need TLB - and guess what performance follows. (imagine you decide to provide 32 registers in XASM, you&#39;d need either globals in single-threaded apps, or TLB access on every instruction *gulp*). <br /><br /> my 2 cents</div>
    <div class="meta">Posted on 2007-05-20 03:41:23 by Ultrano</div>
   </div>
   <div class="post" id="post-189301">
    <div class="subject"><a href="#post-189301">Re: Project : XASM</a></div>
    <div class="body"><div class="quote"><br />Where:<br />So far, mostly in my kitchen, since that&#39;s where the coffee is.<br /><br /></div><br />Homer,<br />You really need to put a small table or something similar next to the computer desk,<br />to set the coffee maker on. Works for me. :)<br /><br /><br />Rags</div>
    <div class="meta">Posted on 2007-05-20 06:11:29 by rags</div>
   </div>
   <div class="post" id="post-189338">
    <div class="subject"><a href="#post-189338">Re: Project : XASM</a></div>
    <div class="body">Everyone - I&#39;ve just finished implementing &quot;infinite recursion prevention within the context of massively nested macro expansion&quot; :)<br /><br />Ultrano - I am supporting user-defined Types, which allow the user to define Types as &quot;an Array of N elements of Previously Defined Type&quot;, where the most Primitive element is &#39;Bit&#39;.<br />That allows for end-orientation of datatypes.<br />Syntax-wise, I simply extended the behaviour of our old friend TypeDef:<br /><div class="quote"><br />NewName TypeDef   ExistingTypedEntity<br /></div><br />The current implementation uses a dedicated &#39;internal virtual primitive&#39;, I intend to change it to use my Struct implementation which would allow for more complex declarations, such as describing RAX and its SubRegisters&nbsp; using unions..<br /><br />It&#39;s not a VM integration, it&#39;s an assembler based on VM concepts, and with a macro engine strong enough to support highlevel language directives introduced&nbsp; via macro headers.<br /><br />The current implementation&#39;s memory requirements are handled by OA32, and are thus Heap-oriented.. virtualizing this means adding a switch to OA32 itself, since I probably won&#39;t be internally reimplementing OA32 but rather loading its macros.. ie, XASM might not support OA32 internally, but will support it.<br />Bootstrapping of XASM will be the litmus test.<br /><br />Portability will be determined, like everything else, by standard header files.<br />If I support the parsing of C/C++ headers, I&#39;m over the moon.<br />I&#39;ll probably use libC when it comes time to self-port the x86-bootstrapped XASM binary, but what others wish to use in THEIR sources to solve this issue is totally up to them, it&#39;s not a buildtime issue.<br /><br />I don&#39;t call XASM an assembler, or a compiler, I call it a &#39;compembler&#39;.<br />Assemblers at least know one opcode set.. XASM is not so presumptuous.<br />Compilers don&#39;t let you define opcodes and their binary output.<br />Optimizing the output code is a curly one, I&#39;ll have to study that more, but I have faith it can be done reasonably well, perhaps it only requires some variant macros, some decisionmaking logic and a dumb switch..<br /><br />I do not have to solve the problems of opcode ambiguities across hardware platforms.. the user does.. guess how? Via macro header files :P<br />XASM allows for user-defined OpCodes and their Encodings.<br />You can define new OpCodes, and describe the Binary output expression, with a syntax that is very similar to a macro definition.<br />I am not hardcoding one single opcode.<br />Even the x86 opcode set is introduced via a header.<br /><br />The user is free to write their own interpretations of any opcodes that appear in their sourcecode, either as a softwired OpCode+Encoding(s), or as a Macro which expresses one or more OpCodes+Encodings.<br /><br />Everything physical is defineable at buildtime, with the current exception of the back-end&#39;s file format, which I also hope to template.. currently only support COFF obj file output, via an overloadable class.<br /><br />Rags - I&#39;m thinking of adding a can dispenser to my case (seriously) with a peltier device that cools one can while heating the coffee cup.<br /></div>
    <div class="meta">Posted on 2007-05-22 08:37:43 by Homer</div>
   </div>
   <div class="post" id="post-189522">
    <div class="subject"><a href="#post-189522">Re: Project : XASM</a></div>
    <div class="body">At a later time, I&#39;d be interested in having this sort of functionality integrated into <a target="_blank" href="http://www.neildickson.com/ide/">PwnIDE</a>.&nbsp; Of course, I&#39;ve got lots of work to do before then, &#39;cause the current state of PwnIDE is somewhat humorous and somewhat embarrassing at the same time.<br /><br />Anyway, I would like to eventually have integrated compilation and execution, including with C, and this sort of thing sounds similar to what I was thinking of for it.&nbsp; In the short term, however, I might be more interested in how you do the syntactic analysis, &#39;cause the way I do it now sucks (which is why it&#39;s largely unimplemented, resulting in the many red underlines in the screenshots).&nbsp; I like my exceedingly brute-force approach to type-checking and instruction documentation, though: <a target="_blank" href="http://pwnide.googlecode.com/svn/trunk/MASM32.txt">Here&#39;s my &quot;grammar&quot; file</a>&nbsp; ;)&nbsp; Man, it was a lot of typing, and it&#39;s maybe half done, hehe.<br /><br />Cheers</div>
    <div class="meta">Posted on 2007-06-06 03:50:27 by hackulous</div>
   </div>
   <div class="post" id="post-189525">
    <div class="subject"><a href="#post-189525">Re: Project : XASM</a></div>
    <div class="body">OI:<br />Thank you for your expression of interest.<br />I can, and would like to set up XASM as an IDE-aware assembler that builds projects in realtime, as you type them, and can tell the IDE what address a given line of sourcecode is assembled to, which would greatly assist debugging.<br />It&#39;s possible, if we can only agree and decide on how they should communicate.<br />It can&#39;t be via Window Messages, or any other platform-specific mechanism, so that narrows the range.<br /><br />KETILO:<br />This is an idea I&#39;ve held close ever since I saw Ketil Olsen&#39;s RADASM ide highlighting errors in response to assembler feedback.<br />If you read this Ketil0, tell me how masm does it, simply a console feed to stderr?<br /><br />ALL:<br />I can understand many of my projects are aimed at very narrow audiences, but I am suprised at the lack of general interest in this project.<br /><br />HEADS UP:<br />It has come to my attention that the zip&nbsp; support in RADASM is slightly broken, anyone who has downloaded the very early sourcecode attachment will not see the FOLDER it contains in WINZIP , or in the Windows Zip Explorer shell.<br />You can see it from WINRAR, and probably many other tools.<br />Don&#39;t be too disappointed if and when you find it, that sourcecode is very early stuff, development has been rapid since I posted it.<br /></div>
    <div class="meta">Posted on 2007-06-06 04:50:55 by Homer</div>
   </div>
   <div class="post" id="post-189527">
    <div class="subject"><a href="#post-189527">Re: Project : XASM</a></div>
    <div class="body">wouldn&#39;t it be enough to pick one opensource assembler you like, and add support for processors you need? like &quot;revolution&quot; did for FASM/ARM, for example...</div>
    <div class="meta">Posted on 2007-06-06 05:59:33 by vid</div>
   </div>
   <div class="post" id="post-189535">
    <div class="subject"><a href="#post-189535">Re: Project : XASM</a></div>
    <div class="body">Show me an open sourced assembler with a STRONG macro engine that is not under GPL or derivative license, and I&#39;ll pack this project up in mothballs and cheesecloth :)<br /><br />Most assemblers have relatively weak macro engines, with the major limiting factor being the length and complexity of general statements.<br />In the past, assembler macros have been relatively simplistic, and not required substantial support. Times have changed.<br /><br />XASM currently supports symbol names of up to 512 bytes, single line statements of up to 8192 bytes, and no limit on the total length of multi-line statements. It supports massively deep nesting of macro statements by default, inheritance of macro locals within a nested context, etc.<br />I&#39;m sick to death of running into glass ceilings...if something else was up to the task, I&#39;d be using it already, and recommending it.<br /><br />Although most asm programmers will never push their assembler to the extremes that I do, I know I am not alone.<br /><br />More to the point, existing assemblers are based around fixed machine concepts, and reworking them for a new physical machine architecture is worse than writing a new assembler, since you&#39;re stuck with all kinds of redundant functionality, syntax nuances and other headaches.<br /><br />I hope to expose more of the assembler internals to the macro engine, essentially giving the user the power to modify the internal behaviours of the assembler at a level usually only seen in machinecode monitors (&#39;mons&#39;) and in virtual machine systems.<br /><br /></div>
    <div class="meta">Posted on 2007-06-07 02:02:59 by Homer</div>
   </div>
   <div class="post" id="post-189540">
    <div class="subject"><a href="#post-189540">Re: Project : XASM</a></div>
    <div class="body">hmmm... FASM? :lol:<br />but it&#39;s written in x86-32 assembly, that will probably bother you...<br /><br /><div class="quote">XASM currently supports symbol names of up to 512 bytes, single line statements of up to 8192 bytes, and no limit on the total length of multi-line statements. It supports massively deep nesting of macro statements by default, inheritance of macro locals within a nested context, etc.</div><br />same does FASM, except 256 byte limit for symbol names, and no limit on single line statements.<br /><br />Can you give some excerpt of your macro syntax? I would really love to see it... (and find some problems within it ;) )</div>
    <div class="meta">Posted on 2007-06-07 07:38:44 by vid</div>
   </div>
   <div class="post" id="post-189543">
    <div class="subject"><a href="#post-189543">Re: Project : XASM</a></div>
    <div class="body">I&#39;m beginning with masm macro syntax, so as to support oa32 immediately (for the first bootstrap).<br />Some initial support for nasm syntax is also there, but I won&#39;t complete it until the masm directives are all implemented.<br />Already, I&#39;ve extended some of masm&#39;s directives, one example is typedef.<br />My alternative syntax is to allow an optional COUNT argument, thus it is possible to describe any Type as an Array of any existing Type, including your own.<br />Only BIT has been hardcoded as a physical Type, all other Types are provided via a Header, which the user can mess with directly or indirectly.<br />For example, BYTE typedef 8 BIT.<br />Another thing I did is allow the ENDP directive to work like ENDM, ie ENDP <br />Another example is the loose typing of immediate numerical values.<br />Hex values can use the 0x prefix instead of or as well as the h suffix.<br />Floats don&#39;t need to have an f suffix provided they contain a decimal point.<br />That sort of thing.<br />I&#39;ve tried to relax some of the unnecessary grammatical restrictions, because I hope to leave enough flexibility to implement entire highlevel languages via the macro engine (user-defined macro functions) and via the systemic header (which softwires the assembler behaviours via the macro engine, thus behavioural modifiers can be placed inline within your sourcecode if you want/need to.)<br />As you can see, with a little flexibility on the part of the assembler, it becomes possible to manipulate the interpreter VIA the interpreter.. this is nothing new, but its never been a major design consideration for assemblers generally, outside of some switches such as .OPTION directive.<br />Ultimately, I hope to have similar flexibility in the back-end (which is currently only supporting COFF file output).<br /><br /></div>
    <div class="meta">Posted on 2007-06-07 08:24:36 by Homer</div>
   </div>
   <div class="post" id="post-189560">
    <div class="subject"><a href="#post-189560">Re: Project : XASM</a></div>
    <div class="body">Be sure not to copy recursive macros from MASM ;)<br /><br />these are very bad design, rather use macro overloading.</div>
    <div class="meta">Posted on 2007-06-08 16:36:48 by vid</div>
   </div>
   <div class="post" id="post-189561">
    <div class="subject"><a href="#post-189561">Re: Project : XASM</a></div>
    <div class="body">Hi <br />I can not agree with you Vid, recursive macros are a great thing. I use them a lot. <br />Of course there are some things that can be done better, for instance, the recursion level is limited currently to 20, which in some cases is too less. The parameter passing is also annoying, but all in one, it is a nice feature that I don?t want to miss in XASM.<br /><br />Regards<br /><br />Biterider<br /></div>
    <div class="meta">Posted on 2007-06-09 01:14:56 by Biterider</div>
   </div>
   <div class="post" id="post-189562">
    <div class="subject"><a href="#post-189562">Re: Project : XASM</a></div>
    <div class="body">One type of thing I&#39;d like to see is something sort of like templates and sort of like method overloading, which could be implemented as something like a cross between a procedure and a macro.&nbsp; Basically, the procedure would receive macro parameters that could define types, but instead of necessarily inlining the whole procedure by making it a macro, the procedure could be duplicated for each different set of macro parameters used.<br /><br />Although the following isn&#39;t a great example, (since you could pass typeSize as a real parameter), it at least illustrates what I mean:<br /><pre><code><br />CopyObject&nbsp; EXTENDEDPROC&nbsp; &nbsp; pObject:DWORD,type:REQ<br />&nbsp; &nbsp; invoke&nbsp; LocalAlloc,LMEM_FIXED,sizeof type<br />&nbsp; &nbsp; push&nbsp; &nbsp; eax<br />&nbsp; &nbsp; invoke&nbsp; CopyMemory,eax,pObject,sizeof type<br />&nbsp; &nbsp; pop&nbsp; &nbsp;  eax<br />&nbsp; &nbsp; ret<br />CopyObject&nbsp; ENDP<br /></code></pre><br />This could be combined with IF/ELSEIF/ELSE/ENDIF statements on the type where type-specific code is needed inside the function, (of course there&#39;d need to be some type-independent code, otherwise the purpose of simplifying the code is defeated).<br /><br />There was something else that I was thinking of too, but I can&#39;t remember what it is right now, hehe.&nbsp; :)</div>
    <div class="meta">Posted on 2007-06-09 01:51:17 by hackulous</div>
   </div>
   <div class="post" id="post-189563">
    <div class="subject"><a href="#post-189563">Re: Project : XASM</a></div>
    <div class="body">What I have done:<br /><br />I treat procedures in a very similar way to macros.<br />Both support massively deep recursion.<br />It&#39;s possible to define more than one version of any named macro or procedure, provided that its argument names and/or types are different.<br />The only problem with multiple procedure definitions is when they have the same number of parameters, they cannot be exported with the same name.<br />The workaround for this is to create an Alias for each duplicate procedure, and export the Alias instead.<br />Since I am not writing my own Linker, I am stuck with the existing name-mangling schemes, and so we&#39;re forced to alias our way around this issue.<br />I may ultimately add code to detect and generate these aliases automagically, but since its critical that the more capable users understand whats happening (so they can marry the exported aliased symbol names in other modules), I&#39;ve decided at least for now to leave well enough alone :)<br /><br /><br /></div>
    <div class="meta">Posted on 2007-06-09 02:03:45 by Homer</div>
   </div>
   <div class="post" id="post-189564">
    <div class="subject"><a href="#post-189564">Re: Project : XASM</a></div>
    <div class="body">Good point, I hadn&#39;t fully considered the exporting thing, but yes, that&#39;d be an issue for such a procedure.<br /><br />This is a bit different than just type-checking, in that you only need one copy of the function in source code form, and you can pass extra type information, such as the type of the data held by a Vector object when passing the Vector.&nbsp; For an example (a rather sad one) of how this could be useful, take a look at <a target="_blank" href="http://pwnos.googlecode.com/svn/trunk/Libraries/Common/Vector.asm">my Vector implementation</a>, or even just look at the hillarious line count.&nbsp; Most of the procedures should be inlined anyway, but some not as much.&nbsp; The basic idea is that instead of having 5-10 copies of each function, I could just have one copy, with some type-specific stuff separated by IF blocks.&nbsp; This does run into the exporting issue, since it&#39;d be useful to export the functions, but I&#39;m planning on having PwnIDE automatically generate &quot;.def&quot; and/or external &quot;.inc&quot; and &quot;.h&quot; files anyway (based on which functions you flag to export), so as long as it knows the renaming scheme, it&#39;ll work.&nbsp; The external &quot;.inc&quot; file could even have macros in it to automatically do the name translation on the importer&#39;s side.<br /><br />One really nice hack that PwnIDE has like this already is enumerations.&nbsp; In the doc comment for a set of constants, it just keeps track of that it&#39;s an enumeration with a certain increment (+a,-a,shr,shl), and the constants stay just as if they were regular constants, so no changes to the assembler are needed for it.&nbsp; Mind you, PwnIDE STILL doesn&#39;t have basic code editing, so I better get to work, lol.&nbsp; ;)</div>
    <div class="meta">Posted on 2007-06-09 02:43:50 by hackulous</div>
   </div>
   <div class="post" id="post-189565">
    <div class="subject"><a href="#post-189565">Re: Project : XASM</a></div>
    <div class="body">Ah, now I remember what I forgot earlier.&nbsp; It&#39;d be nice to be able to specify that certain parameters should be passed by certain registers, and to indicate that the value is already in the register, you could pass that register there.&nbsp; It&#39;d be a bit more complicated for the assembler to figure out because of possible dependencies (e.g. ecx = eax and eax = ecx, or passing something in eax, and the content of ), but thanks to the xchg instructions, it shouldn&#39;t affect performance.&nbsp; I&#39;ve got a way to specify this in PwnIDE, but no way to enforce it since MASM doesn&#39;t support it (and it&#39;d be way too sketchy just to put it through my own preprocessor at this point).</div>
    <div class="meta">Posted on 2007-06-09 02:55:52 by hackulous</div>
   </div>
   <div class="post" id="post-189566">
    <div class="subject"><a href="#post-189566">Re: Project : XASM</a></div>
    <div class="body"><div class="quote"><br />I can not agree with you Vid, recursive macros are a great thing. I use them a lot. <br />Of course there are some things that can be done better, for instance, the recursion level is limited currently to 20, which in some cases is too less. The parameter passing is also annoying, but all in one, it is a nice feature that I don?t want to miss in XASM.</div><br /><br />You can &quot;emulate&quot; recursive macros with nested macros, but you cannot get effect of nested macros (macro overloading) with recursive macros. <br /><br />So nested macros can do anything that recursive macros can, and lot of extra stuff.<br /><br />The real beaty of nested macros is that you can slightly change behavior of macro/directive, without having to rewrite it&#39;s entire functionality. <br /><br />For example if you have ready PROC directive or macro, and you want to add extra symbol for every procedure. With recursive macros you would have to modify original PROC macro, or in case when PROC is directive, you are screwed. With nested macros you just overload original macro/directive, add bit of extra functionality you need, and let original PROC do all it wants:<br /><br />(simplified) example how it works in FASM:<br /><pre><code><br />macro proc name, <br />{&nbsp; <br />&nbsp; ;define symbol &quot;__is_stdcall_&lt;name of procedure&gt;&quot;<br />&nbsp; __is_stdcalll_#name = 1 <br /><br />&nbsp; ;let rest of things be done by original macro<br />&nbsp; proc name, args<br />}</code></pre></div>
    <div class="meta">Posted on 2007-06-09 04:27:10 by vid</div>
   </div>
   <div class="post" id="post-189568">
    <div class="subject"><a href="#post-189568">Re: Project : XASM</a></div>
    <div class="body">Hi<br />I see the benefits of the ?overloading? as you describe it before, but there are other ways to achieve this, without loosing the recursion functionality.<br /><br />Maybe you can explain how you can emulate a recursive macro with nested macros without knowing the recursion deep? What about the local symbols of each iteration?<br /><br />I can imagine a way to overload the macro name and calling the original macro from within it using special directives. This way, all remain possible: recursion and overloading.<br /><br /><pre><code>macro proc name, <br />{&nbsp; <br />&nbsp; ;define symbol &quot;__is_stdcall_&lt;name of procedure&gt;&quot;<br />&nbsp; __is_stdcalll_#name = 1 <br /><br />&nbsp; ;let rest of things be done by original macro<br />&nbsp; overloaded proc name, args<br />}</code></pre><br /><br />Regards,<br /><br />Biterider<br /><br /></div>
    <div class="meta">Posted on 2007-06-09 06:11:54 by Biterider</div>
   </div>
   <div class="post" id="post-189572">
    <div class="subject"><a href="#post-189572">Re: Project : XASM</a></div>
    <div class="body">Hi Homer<br />I think you have to do something about the name of your project<br /><br /><a target="_blank" href="http://xasm.webpark.pl/xasm/">http://xasm.webpark.pl/xasm/</a><br /><br />Regards<br /><br />Biterider</div>
    <div class="meta">Posted on 2007-06-09 14:12:54 by Biterider</div>
   </div>
   <div class="post" id="post-189577">
    <div class="subject"><a href="#post-189577">Re: Project : XASM</a></div>
    <div class="body"><div class="quote"><br />Hi<br />I see the benefits of the ?overloading? as you describe it before, but there are other ways to achieve this, without loosing the recursion functionality.</div><br />It is possible to directly emulate macro recursion by macro overloading, but not vice versa. You loose nothing with overloading.<br /><br /><div class="quote">Maybe you can explain how you can emulate a recursive macro with nested macros without knowing the recursion deep? What about the local symbols of each iteration?</div><br />Here is example of how macro recursion works in FASM, which has macro overloading:<br /><pre><code><br />;this macro defines macro &quot;a&quot;<br />macro define_a<br />{<br />&nbsp; ;this is body of macro &quot;a&quot;<br />&nbsp; macro a \{<br />&nbsp; &nbsp; define_a ;redefine &quot;a&quot; inside it&#39;s body<br />&nbsp; &nbsp; a ;and use it<br />&nbsp; \}<br />}<br />define_a ;define toplevel macro<br /></code></pre><br /><br /><div class="quote">I can imagine a way to overload the macro name and calling the original macro from within it using special directives. This way, all remain possible: recursion and overloading.</div><br />might be interesting... maybe we can compare when/if it&#39;s implemented.<br /><br />For sure it&#39;s interesting idea for XASM</div>
    <div class="meta">Posted on 2007-06-09 18:53:41 by vid</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=25972&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=25972&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="25972" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=25972&amp;page=2">&gt;</a><a href="../?id=25972&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>