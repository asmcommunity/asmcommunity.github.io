<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OOPSkinMesh question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22096" />
  <link rel="prev" href="../?id=22096&amp;page=1" />  <link rel="next" href="../?id=22096&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=22096">OOPSkinMesh question</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=22096&amp;page=1" style="">&laquo;</a><a href="../?id=22096&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="22096" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=22096&amp;page=3">&gt;</a><a href="../?id=22096&amp;page=4">&raquo;</a></form>   <div class="post" id="post-169139">
    <div class="subject"><a href="#post-169139">Re: OOPSkinMesh question</a></div>
    <div class="body">The new D3D application framework is stable.<br />The new SkinMesh class is at the point where models can be completely Loaded.<br />I&#39;m ready to implement rendering code, and then animation code.<br /><br />I&#39;ve been using the D3DXLoadMeshHierarchyFromX api function.<br />It basically performs the Xfile Template parsing, and construction of the Frame Hierarchy, but it still requires a fair bit of user code in the form of callbacks.<br /><br />I&#39;ve noticed that it does not handle XFiles which don&#39;t contain a SceneRoot frame.<br />These cause a crash within D3DXLoadMeshHierarchyFromX (which never returns), due to D3DXLoadMeshHierarchyFromX trying to destroy more Frames than it in fact allocated.. so there&#39;s still something to be said for parsing XFiles manually (microsoft coders are crackheads and/or assume that all XFiles contain a SceneRoot frame)..<br /><br />Anyway, progress is being made, which has to be a good thing, right?<br /><br /><br />Merry Christmas to all, three hoes and stockings if you&#39;ve been particularly good.<br /></div>
    <div class="meta">Posted on 2005-12-24 09:14:57 by Homer</div>
   </div>
   <div class="post" id="post-169141">
    <div class="subject"><a href="#post-169141">Re: OOPSkinMesh question</a></div>
    <div class="body">Hi Homer,<br /><br />The skeleton you use, and some of the functions, and callbacks related to it, are specifically DirectX 9.<br />My interest goes out for DirectX 8 in stead of DirectX 9. Because what works well under DirectX 8 should work well under DirectX 9 too.<br /><br />When you are parsing xFiles manually, there isn&#39;t any difference between doing it under DirectX 8 and doing it under DirectX 9, is there?. So why use DirectX 9?<br /><br />As I understand you are using the OA32 SDI-application. Can it be converted to ATC easily, which was and is my goal?<br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2005-12-24 12:57:27 by mdevries</div>
   </div>
   <div class="post" id="post-169144">
    <div class="subject"><a href="#post-169144">Re: OOPSkinMesh question</a></div>
    <div class="body">DX9 is slightly optimized, is supposed to use less memory, and supports more hadrware (and more capabilities of existing/new hardware).</div>
    <div class="meta">Posted on 2005-12-24 18:12:49 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169167">
    <div class="subject"><a href="#post-169167">Re: OOPSkinMesh question</a></div>
    <div class="body">No, I had problems when using the OA32 SDIApp object as the basis for D3D applications.<br />I wrote my own OA32 D3DApp object instead, which implements everything you need for your application main window, d3d initialization and cleanup, it also contains a dialog and code for enumerating and selecting video display modes, and contains several &quot;user callbacks&quot;, which are for rendering your stuff, and for loading and unloading &quot;device dependant resources&quot; on demand (stuff that gets trashed when the user alt-tabs or switches display modes / windowing mode at runtime).<br /><br />The idea was that I make it work, figure out where Biterider went wrong, so he can port the changes back into his own object.<br /><br />As for translating ANY oa32 stuff to atc, that is quite simple to do, but since oa has had several overhauls of its codebase, I no longer see a reason why you would want to convert them.<br />In terms of binary speed and size, oa32 is now on an even pegging with atc.<br />I am converted to oa32 and if you still have not taken the time to look at it, perhaps you should.<br /><br />Note that oa32&#39;s entire d3d support was based on my atc classes for d3d9.<br />I&#39;ve found no bugs in there at all, but just some stuff has been disabled with comments.<br />I&#39;ve been working closely with Biterider so that any changes I make are perpetuated in the next public release.. note that Configuration File is used to store the most recent video mode which was used, and that the Run method is a wrapper to WinMain (and MessagePump Loop)..<br /><br />Here is an example of a D3D application using my D3DApp object:<br /><pre><code><br />	;Create an instance of the D3D Application Class<br />	mov pApp,$New (D3DApp,Init,addr szConfigFileName)<br />	<br />	;Set up the CallBacks to User Code<br />	OCall pApp::D3DApp.SetUserRenderProc, addr MyRender<br />	OCall pApp::D3DApp.SetUserReloadVolatiles, addr MyReCreateGeometry<br />	OCall pApp::D3DApp.SetUserReleaseVolatiles, addr MyKillGeometry<br />	;Let&#39;s get things moving<br />	OCall pApp::D3DApp.Run	<br />	;Time to destroy the universe	<br />	Destroy pApp<br />	;Clean up OOP Support<br />	SysDone<br />	invoke ExitProcess,eax<br /></code></pre><br /></div>
    <div class="meta">Posted on 2005-12-26 00:58:29 by Homer</div>
   </div>
   <div class="post" id="post-169171">
    <div class="subject"><a href="#post-169171">Re: OOPSkinMesh question</a></div>
    <div class="body">Sounds quite reasonable, and convincing.<br /><br />What about D3DXLoadMeshHierarchyFromX? Do you think it&#39;s worth using it. Or do you prefer a manually parsing of xFiles?<br /><br />B.t.w: Can the project be downloaded by interested people?<br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2005-12-26 08:54:32 by mdevries</div>
   </div>
   <div class="post" id="post-169172">
    <div class="subject"><a href="#post-169172">Re: OOPSkinMesh question</a></div>
    <div class="body">I guess it depends apon how you look at this.<br />Basically using D3DXLoadMeshHierarchyFromX is a heck of a lot like writing your own xfile loader from the ground up (which incidentally I have done) because we are still implementing roughly two thirds of the code required.<br />The D3DXLoadMeshHierarchyFromX requires us to create an object instance containing pointers to the four main functions required to build a linkedlist hierarchy from the data stored in the xfile.<br />Not only do we have to provide an instance of the interface, we have to code the four methods that it contains pointers to.These are methods called createframe, createmeshcontainer, destroyframe, destroymeshcontainer.<br />What D3DXLoadMeshHierarchyFromX is really doing for us then is to perform all the file parsing for us, and via the interface and code we provide to create a data structure in memory&nbsp; (by linking object instances via pointers) whose hierarchy corresponds to that encountered in the file.<br />So really, we could say D3DXLoadMeshHierarchyFromX just contains all the loop and logic code, and we just have to provide it the code to make and break objects.<br />The only files it has problems loading with it I&#39;ve seen are exported via third party plugins of which I am a little dubious.<br />I should mention that its possible to embed custom data within an xfile and to add your own code for loading them but I haven&#39;t implemented that in the current example.<br />Not to use D3DXLoadMeshHierarchyFromX can&#39;t really be justified, at least not by me, not yet.<br /><br /></div>
    <div class="meta">Posted on 2005-12-26 09:26:29 by Homer</div>
   </div>
   <div class="post" id="post-169173">
    <div class="subject"><a href="#post-169173">Re: OOPSkinMesh question</a></div>
    <div class="body">Fair enough.<br /><br />And what about my other question:<br /><br /><div class="quote">Can the project be downloaded by interested people?</div><br /><br />I could add the word &quot;yet&quot; to the end of it.<br />So, can the project be downloaded by interested people yet?<br /><br />Regards,<br />mdevries.</div>
    <div class="meta">Posted on 2005-12-26 15:12:47 by mdevries</div>
   </div>
   <div class="post" id="post-169182">
    <div class="subject"><a href="#post-169182">Re: OOPSkinMesh question</a></div>
    <div class="body">I&#39;ll make the project download available by tomorrow, since you asked.<br />Bear in mind that it is quite beta (although its perfectly stable) and subject to change without notification.. furthermore, you will be required to make several changes to OA32 includes (unless you wanna wait for the next oa32 public release).<br /><br />I am willing to help you through the teething stage, as long as you are willing to accept that a teething stage exists !!<br /><br />OA32&#39;s D3D includes are relatively untested, as usual we are pressing the envelope, and leaving footprints in the sand for those who may follow.<br /><br />On the bright side, the number of changes is small and mostly only involve removing comments from api prototypes...<br /><br /></div>
    <div class="meta">Posted on 2005-12-27 06:01:51 by Homer</div>
   </div>
   <div class="post" id="post-169185">
    <div class="subject"><a href="#post-169185">Re: OOPSkinMesh question</a></div>
    <div class="body">I&#39;m looking forward to it.<br />And maybe/hopefully some others too.<br /><br />Friendly regards,<br />mdevries</div>
    <div class="meta">Posted on 2005-12-27 10:51:15 by mdevries</div>
   </div>
   <div class="post" id="post-169196">
    <div class="subject"><a href="#post-169196">Re: OOPSkinMesh question</a></div>
    <div class="body">Today I implemented all the code for Rendering the skinmesh.<br />Argh, Grrr, it doesn&#39;t work.<br /><br />I have spent my time translating the &quot;Modular SkinMesh&quot; source posted at flipcode.org, which is basically a modified version of the sdk skinmesh sample.. the author has moved a bunch of stuff around in order to make the skinmesh class less closely associated with the SDK Sample and more useful as a generic skinmesh class.<br />Of course, there&#39;s no binary included, because the bloody thing doesn&#39;t work.<br /><br />Sigh.<br /><br />Well, I have a bunch of broken skinmesh code, where do we go from here?<br />I suggest that it might be mutually beneficial to translate the original DX9 SDK skinmesh sample here, in public, with the hope that more eyes mean less bugfixes, and so that you guys can see what is involved in translating a cpp source to oa32.<br /><br />As such, perhaps I shouldn&#39;t post my D3DApp class just yet, since that will only serve to confuse us during this process - the SDK skinmesh sample is closely tied to microsoft&#39;s own application framework, which will be an obstacle in itself.<br />We&#39;d be better off to create a light framework, implementing only what the sample demands from it.<br />We might decide to rework my D3DApp with this in mind, but let&#39;s just begin with translating the sample code and worry about the gui framework along the way, shall we?<br /><br />That being said, I feel a linear approach to the translation of the sample code is warranted.<br />Unless someone can tell me why I should not, I will begin posting slabs of the original file, in order of appearance, and follow each with the oa32 translation of it.<br /><br />Here&#39;s the beginning of skinnedmesh.cpp<br />Please don&#39;t sue us microsoft, this is purely for educational purposes.<br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// File: SkinnedMesh.cpp<br />//<br />// Starting point for new Direct3D applications<br />//<br />// Copyright (c) Microsoft Corporation. All rights reserved.<br />//--------------------------------------------------------------------------------------<br />#include &quot;dxstdafx.h&quot;<br />#include &quot;resource.h&quot;<br /><br />//#define DEBUG_VS   // Uncomment this line to debug vertex shaders <br />//#define DEBUG_PS   // Uncomment this line to debug pixel shaders <br /><br />#define MESHFILENAME L&quot;tiny\\tiny.x&quot;<br /><br /><br />WCHAR g_wszShaderSource[4][30] =<br />{<br />    L&quot;skinmesh1.vsh&quot;,<br />    L&quot;skinmesh2.vsh&quot;,<br />    L&quot;skinmesh3.vsh&quot;,<br />    L&quot;skinmesh4.vsh&quot;<br />};<br /><br /><br />// enum for various skinning modes possible<br />enum METHOD<br />{<br />    D3DNONINDEXED,<br />    D3DINDEXED,<br />    SOFTWARE,<br />    D3DINDEXEDVS,<br />    D3DINDEXEDHLSLVS,<br />    NONE<br />};<br /><br /><br />//--------------------------------------------------------------------------------------<br />// Name: struct D3DXFRAME_DERIVED<br />// Desc: Structure derived from D3DXFRAME so we can add some app-specific<br />//       info that will be stored with each frame<br />//--------------------------------------------------------------------------------------<br />struct D3DXFRAME_DERIVED: public D3DXFRAME<br />{<br />    D3DXMATRIXA16        CombinedTransformationMatrix;<br />};<br /><br /><br />//--------------------------------------------------------------------------------------<br />// Name: struct D3DXMESHCONTAINER_DERIVED<br />// Desc: Structure derived from D3DXMESHCONTAINER so we can add some app-specific<br />//       info that will be stored with each mesh<br />//--------------------------------------------------------------------------------------<br />struct D3DXMESHCONTAINER_DERIVED: public D3DXMESHCONTAINER<br />{<br />    LPDIRECT3DTEXTURE9*  ppTextures;       // array of textures, entries are NULL if no texture specified    <br />                                <br />    // SkinMesh info             <br />    LPD3DXMESH           pOrigMesh;<br />    LPD3DXATTRIBUTERANGE pAttributeTable;<br />    DWORD                NumAttributeGroups; <br />    DWORD                NumInfl;<br />    LPD3DXBUFFER         pBoneCombinationBuf;<br />    D3DXMATRIX**         ppBoneMatrixPtrs;<br />    D3DXMATRIX*          pBoneOffsetMatrices;<br />    DWORD                NumPaletteEntries;<br />    bool                 UseSoftwareVP;<br />    DWORD                iAttributeSW;     // used to denote the split between SW and HW if necessary for non-indexed skinning<br />};<br /></code></pre><br /><br />Here&#39;s my version of the that stuff :<br /><br /><pre><code><br />;--------------------------------------------------------------------------------------<br />; SkinnedMesh.inc<br />; OA32 Base Class for (you guessed it)<br />; Written by EvilHomer (and perhaps others?) <br />; Project started   : 28 December, 2005<br />; Project completed : (incomplete)<br />; This source is strongly based on Microsoft&#39;s SDK sample<br />; Don&#39;t sue me, this is a purely educational exercise.<br />;--------------------------------------------------------------------------------------<br /><br />;#include &quot;dxstdafx.h&quot;<br />;#include &quot;resource.h&quot;<br /><br />;//#define DEBUG_VS   // Uncomment this line to debug vertex shaders <br />;//#define DEBUG_PS   // Uncomment this line to debug pixel shaders <br /><br />MESHFILENAME  textequ &quot;tiny\tiny.x&quot;<br /><br />.data<br />g_wszShaderSource dw &quot;skinmesh1.vsh&quot;,0<br />    		  dw &quot;skinmesh2.vsh&quot;,0<br />    		  dw &quot;skinmesh3.vsh&quot;,0<br />    		  dw &quot;skinmesh4.vsh&quot;,0,0<br />.code<br /><br />;Enumerate possible skinning methods<br />    D3DNONINDEXED equ 0<br />    D3DINDEXED equ 1<br />    SOFTWARE equ 2<br />    D3DINDEXEDVS equ 3<br />    D3DINDEXEDHLSLVS equ 4<br />    NONE equ d0h<br /><br /><br />;Structure extends D3DXFRAME so we can add some app-specific<br />;info that will be stored with each frame<br />;--------------------------------------------------------------------------------------<br />D3DXFRAME_DERIVED struct<br />  ;Original D3DXFRAME structure fields<br />  Base D3DXFRAME &lt;&gt;<br />  ;Per-Frame combined matrix (this frame and its parent)<br />  CombinedTransformationMatrix D3DXMATRIX &lt;&gt;<br />D3DXFRAME_DERIVED ends<br /><br /><br />;Structure extends D3DXMESHCONTAINER so we can add some app-specific<br />;info that will be stored with each mesh<br />;--------------------------------------------------------------------------------------<br />D3DXMESHCONTAINER_DERIVED struct<br />  ;Original D3DXMESHCONTAINER structure fields<br />  Base D3DXMESHCONTAINER &lt;&gt;<br />  ;Array of textures, entries are NULL if no texture specified  <br />  ppTextures LPDIRECT3DTEXTURE9 ?<br />                                <br />;SkinMesh info             <br />    pOrigMesh LPD3DXMESH ?<br />    pAttributeTable LPD3DXATTRIBUTERANGE ?<br />    NumAttributeGroups dd ?<br />    NumInfl dd ?<br />    pBoneCombinationBuf LPD3DXBUFFER ?<br />    ppBoneMatrixPtrs dd ? 		;ptr to array of LPD3DXMATRIX<br />    pBoneOffsetMatrices LPD3DXMATRIX ? ;ptr to array of D3DXMATRIX<br />    NumPaletteEntries dd ?<br />    UseSoftwareVP dd ?<br />    iAttributeSW dd ?   ; used to denote the split between SW and HW if necessary for non-indexed skinning<br />D3DXMESHCONTAINER_DERIVED ends<br />;--------------------------------------------------------------------------------------<br /></code></pre><br /><br />If I translate each chunk of code in this fashion, we can analyse and discuss the code as we go.<br />If anyone thinks I shouldn&#39;t be doing this here, please say so.<br /><br /><br /></div>
    <div class="meta">Posted on 2005-12-28 00:26:49 by Homer</div>
   </div>
   <div class="post" id="post-169197">
    <div class="subject"><a href="#post-169197">Re: OOPSkinMesh question</a></div>
    <div class="body">All we have really done so far is to declare some equates and two structs.<br />These structs are really central to the entire project, but I&#39;d rather defer discussion of the individual fields of these structs until we can see them being applied.<br /><br />What we have done is to extend the original D3DXFRAME and D3DXMESHCONTAINER structs to incorporate some extra stuff.<br /><br />What&#39;s a Frame? What&#39;s a MeshContainer?<br /><br />Frames are &quot;frames of reference&quot; with regards to hierarchical rotation and translation.<br />We use frames to create a &quot;frame hierarchy&quot; representing the joints of the skinned mesh.<br />If you rotate or translate a frame, everything &quot;below&quot; that frame in the hierarchy is also rotated and translated.<br />Think about this - if you bend your knee, your lower leg, ankle and foot are displaced (they are all &quot;below&quot; the knee in your body hierarchy).<br />Frames can contain other frames, and may also contain a MeshContainer.<br />MeshContainers contain data specific to a single mesh.<br />Your skinnedmesh might just have one big mesh, or it might be comprised of several meshes.<br />That really depends on the modeller it was created with.<br />Just note that we can handle multiple meshes spread throughout the frame hierarchy, no problemo.<br /><br />Frames are linked together via Pointers.<br />If we were to write our own SkinMesh Loader from the ground up, we would have to set up all those pointers, but we will be using D3DXLoadMeshHierarchyFromX, which does that for us.<br /><br />Any Questions?</div>
    <div class="meta">Posted on 2005-12-28 00:40:54 by Homer</div>
   </div>
   <div class="post" id="post-169200">
    <div class="subject"><a href="#post-169200">Re: OOPSkinMesh question</a></div>
    <div class="body">Among the various parameters required by our call to D3DXLoadMeshHierarchyFromX is one called pAlloc.. this is a pointer to a COM interface called ID3DXAllocateHierarchy.<br /><br />The interface inherits from IUnknown, but aside from that it just contains four pointers to some functions which we must provide the code for.<br /><br />Here is the interface definition, directly from the SDK sample...<br /><br /><pre><code><br />// Name: class CAllocateHierarchy<br />// Desc: Custom version of ID3DXAllocateHierarchy with custom methods to create<br />//&nbsp; &nbsp; &nbsp;  frames and meshcontainers.<br />//--------------------------------------------------------------------------------------<br />class CAllocateHierarchy: public ID3DXAllocateHierarchy<br />{<br />public:<br />&nbsp; &nbsp; STDMETHOD(CreateFrame)(THIS_ LPCSTR Name, LPD3DXFRAME *ppNewFrame);<br />&nbsp; &nbsp; STDMETHOD(CreateMeshContainer)(THIS_ <br />&nbsp; &nbsp; &nbsp; &nbsp; LPCSTR Name, <br />&nbsp; &nbsp; &nbsp; &nbsp; CONST D3DXMESHDATA *pMeshData,<br />&nbsp; &nbsp; &nbsp; &nbsp; CONST D3DXMATERIAL *pMaterials, <br />&nbsp; &nbsp; &nbsp; &nbsp; CONST D3DXEFFECTINSTANCE *pEffectInstances, <br />&nbsp; &nbsp; &nbsp; &nbsp; DWORD NumMaterials, <br />&nbsp; &nbsp; &nbsp; &nbsp; CONST DWORD *pAdjacency, <br />&nbsp; &nbsp; &nbsp; &nbsp; LPD3DXSKININFO pSkinInfo, <br />&nbsp; &nbsp; &nbsp; &nbsp; LPD3DXMESHCONTAINER *ppNewMeshContainer);<br />&nbsp; &nbsp; STDMETHOD(DestroyFrame)(THIS_ LPD3DXFRAME pFrameToFree);<br />&nbsp; &nbsp; STDMETHOD(DestroyMeshContainer)(THIS_ LPD3DXMESHCONTAINER pMeshContainerBase);<br /><br />&nbsp; &nbsp; CAllocateHierarchy() {}<br />};<br /><br /></code></pre><br /><br /><br />... and here is the OA32 version of it.<br />Note that we are defining the interface as an OA32 Object which inherits from the IUnknown object (OA32&#39;s vanilla implementation of IUnknown interface).<br />Note that when we define objects with OA32, we should declare a unique &quot;class identifier&quot;.<br />The value of CAllocateHierarchyID is totally arbitrary, I tend to invent random numbers and hope that they don&#39;t collide with existing OA32 class identifiers :P<br />To define a class object under OA32, we use the format &quot;Object ClassName, ClassID[, AncestorClass]&quot;<br />Thus, CAllocateHierarchy inherits from IUnknown.<br />IUnknown is defined in the ComPrimers.inc file, so in order to successfully compile this code, you will need to ensure that you include the ComPrimers object near the top of your source (we&#39;ll cover this later when we start looking at the gui framework).. LoadObjects ComPrimers is what you need.<br /><br /><pre><code><br />CAllocateHierarchyID equ 66676<br />Object CAllocateHierarchy,CAllocateHierarchyID, IUnknown<br />&nbsp; InterfaceMethod CreateFrame,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer, Pointer<br />&nbsp; InterfaceMethod CreateMeshContainer,&nbsp; Pointer, Pointer, Pointer, Pointer, dword, Pointer, Pointer, Pointer<br />&nbsp; InterfaceMethod DestroyFrame,&nbsp; &nbsp; &nbsp; &nbsp;  Pointer<br />&nbsp; InterfaceMethod DestroyMeshContainer, Pointer<br />ObjectEnd<br /></code></pre><br /><br />Yay - we&#39;ve defined the interface itself, but we have not defined the code for its four methods.<br />We&#39;ll get to that shortly.<br />The SDK sample defines a bunch of global variables, we should do that now too.<br /><br /></div>
    <div class="meta">Posted on 2005-12-28 01:12:19 by Homer</div>
   </div>
   <div class="post" id="post-169201">
    <div class="subject"><a href="#post-169201">Re: OOPSkinMesh question</a></div>
    <div class="body">Here&#39;s a crapload of global variables<br /><pre><code><br />ID3DXFont*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_pFont = NULL;&nbsp; &nbsp; &nbsp; &nbsp;  // Font for drawing text<br />ID3DXSprite*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_pTextSprite = NULL;&nbsp;  // Sprite for batching draw text calls<br />ID3DXEffect*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_pEffect = NULL;&nbsp; &nbsp; &nbsp;  // D3DX effect interface<br />CD3DArcBall&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_ArcBall;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Arcball for model control<br />bool&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_bShowHelp = true;&nbsp; &nbsp;  // If true, it renders the UI control text<br />CDXUTDialogResourceManager g_DialogResourceManager; // manager for shared resources of dialogs<br />CD3DSettingsDlg&nbsp; &nbsp; &nbsp; &nbsp;  g_SettingsDlg;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Device settings dialog<br />CDXUTDialog&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_HUD;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // dialog for standard controls<br />CDXUTDialog&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_SampleUI;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // dialog for sample specific controls<br />LPD3DXFRAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_pFrameRoot = NULL;<br />ID3DXAnimationController* g_pAnimController = NULL;<br />D3DXVECTOR3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_vObjectCenter;&nbsp; &nbsp; &nbsp; &nbsp; // Center of bounding sphere of object<br />FLOAT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_fObjectRadius;&nbsp; &nbsp; &nbsp; &nbsp; // Radius of bounding sphere of object<br />METHOD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_SkinningMethod = D3DNONINDEXED; // Current skinning method<br />D3DXMATRIXA16*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_pBoneMatrices = NULL;<br />UINT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_NumBoneMatricesMax = 0;<br />IDirect3DVertexShader9* g_pIndexedVertexShader[4];<br />D3DXMATRIXA16&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_matView;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // View matrix<br />D3DXMATRIXA16&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_matProj;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Projection matrix<br />D3DXMATRIXA16&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_matProjT;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Transpose of projection matrix (for asm shader)<br />DWORD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_dwBehaviorFlags;&nbsp; &nbsp; &nbsp; // Behavior flags of the 3D device<br />bool&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g_bUseSoftwareVP;&nbsp; &nbsp; &nbsp;  // Flag to indicate whether software vp is<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // required due to lack of hardware<br /></code></pre><br /><br />and here&#39;s our translation<br /><pre><code><br />;--------------------------------------------------------------------------------------<br />; Global variables<br />;--------------------------------------------------------------------------------------<br />g_pFont dd NULL&nbsp;  ;&nbsp; &nbsp;  ID3DXFont for drawing text<br />g_pTextSprite dd NULL;&nbsp; ID3DXSprite for batching draw text calls<br />g_pEffect dd NULL;&nbsp; &nbsp;  ID3DXEffect effect interface<br />g_ArcBall dd NULL; CD3DArcBall&nbsp; for model control<br />g_bShowHelp dd TRUE;&nbsp; &nbsp;  If true, it renders the UI control text<br />g_DialogResourceManager dd NULL ;&nbsp; CDXUTDialogResourceManager for shared resources of dialogs<br />g_SettingsDlg dd NULL ; CD3DSettingsDlg&nbsp; Device settings dialog<br />g_HUD dd nULL; CDXUTDialog&nbsp; dialog for standard controls<br />g_SampleUI dd NULL; CDXUTDialog dialog for sample specific controls<br />g_pFrameRoot LPD3DXFRAME NULL ;points to root frame<br />g_pAnimController dd NULL;ID3DXAnimationController<br />g_vObjectCenter D3DXVECTOR3 &lt;&gt;;&nbsp; &nbsp; &nbsp; &nbsp;  Center of bounding sphere of object<br />g_fObjectRadius REAL4 0.0f;&nbsp; &nbsp; &nbsp; &nbsp;  Radius of bounding sphere of object<br />g_SkinningMethod dd D3DNONINDEXED;&nbsp; Current skinning method<br />g_pBoneMatrices LPD3DXMATRIX NULL ;Pointer to array of matrices<br />g_NumBoneMatricesMax dd 0;<br />g_pIndexedVertexShader dd 4 dup (0);IDirect3DVertexShader9<br />g_matView D3DXMATRIX &lt;&gt;;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // View matrix<br />g_matProj D3DXMATRIX &lt;&gt;;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Projection matrix<br />g_matProjT D3DXMATRIX &lt;&gt;;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Transpose of projection matrix (for asm shader)<br />g_dwBehaviorFlags dd NULL;&nbsp; &nbsp; &nbsp; // Behavior flags of the 3D device<br />g_bUseSoftwareVP dd TRUE;&nbsp; &nbsp; &nbsp;  // Flag to indicate whether software vp isrequired due to lack of hardware<br /></code></pre><br /><br />We can see from this that there are a number of support objects we&#39;ll need to implement, or avoid implementing... those whose names begin with CD3D or CDUT.<br />Generally, they comprise elements of the sample gui framework.<br /><br />In the Modular version I originally translated, a lot of these fields had been moved into the SkinMesh class instead of being global like this.<br /><br /></div>
    <div class="meta">Posted on 2005-12-28 01:26:44 by Homer</div>
   </div>
   <div class="post" id="post-169202">
    <div class="subject"><a href="#post-169202">Re: OOPSkinMesh question</a></div>
    <div class="body"><br />Here&#39;s the next chunk of original source.<br />There&#39;s another enumeration (we wil define), and a bunch of &quot;forwards reference&quot; prototypes (which for now, we will just comment out)<br /><br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// UI control IDs<br />//--------------------------------------------------------------------------------------<br />#define IDC_TOGGLEFULLSCREEN&nbsp; &nbsp; 1<br />#define IDC_TOGGLEREF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  3<br />#define IDC_CHANGEDEVICE&nbsp; &nbsp; &nbsp; &nbsp; 4<br />#define IDC_METHOD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<br /><br /><br /><br />//--------------------------------------------------------------------------------------<br />// Forward declarations <br />//--------------------------------------------------------------------------------------<br />bool&nbsp; &nbsp; CALLBACK IsDeviceAcceptable( D3DCAPS9* pCaps, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, bool bWindowed, void* pUserContext );<br />bool&nbsp; &nbsp; CALLBACK ModifyDeviceSettings( DXUTDeviceSettings* pDeviceSettings, const D3DCAPS9* pCaps, void* pUserContext );<br />HRESULT CALLBACK OnCreateDevice( IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc, void* pUserContext );<br />HRESULT CALLBACK OnResetDevice( IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc, void* pUserContext );<br />void&nbsp; &nbsp; CALLBACK OnFrameMove( IDirect3DDevice9* pd3dDevice, double fTime, float fElapsedTime, void* pUserContext );<br />void&nbsp; &nbsp; CALLBACK OnFrameRender( IDirect3DDevice9* pd3dDevice, double fTime, float fElapsedTime, void* pUserContext );<br />LRESULT CALLBACK MsgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool* pbNoFurtherProcessing, void* pUserContext );<br />void&nbsp; &nbsp; CALLBACK KeyboardProc( UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext );<br />void&nbsp; &nbsp; CALLBACK OnGUIEvent( UINT nEvent, int nControlID, CDXUTControl* pControl, void* pUserContext );<br />void&nbsp; &nbsp; CALLBACK OnLostDevice( void* pUserContext );<br />void&nbsp; &nbsp; CALLBACK OnDestroyDevice( void* pUserContext );<br /><br />void&nbsp; &nbsp; InitApp();<br />HRESULT LoadMesh( IDirect3DDevice9* pd3dDevice, WCHAR* strFileName, ID3DXMesh** ppMesh );<br />void&nbsp; &nbsp; RenderText();<br />void&nbsp; &nbsp; DrawMeshContainer( IDirect3DDevice9 *pd3dDevice, LPD3DXMESHCONTAINER pMeshContainerBase, LPD3DXFRAME pFrameBase );<br />void&nbsp; &nbsp; DrawFrame( IDirect3DDevice9 *pd3dDevice, LPD3DXFRAME pFrame );<br />HRESULT SetupBoneMatrixPointersOnMesh( LPD3DXMESHCONTAINER pMeshContainer );<br />HRESULT SetupBoneMatrixPointers( LPD3DXFRAME pFrame );<br />void&nbsp; &nbsp; UpdateFrameMatrices( LPD3DXFRAME pFrameBase, LPD3DXMATRIX pParentMatrix );<br />void&nbsp; &nbsp; UpdateSkinningMethod( LPD3DXFRAME pFrameBase );<br />HRESULT GenerateSkinnedMesh( IDirect3DDevice9 *pd3dDevice, D3DXMESHCONTAINER_DERIVED *pMeshContainer );<br />void&nbsp; &nbsp; ReleaseAttributeTable( LPD3DXFRAME pFrameBase );<br /><br /></code></pre><br /><br />Here is our version:<br /><pre><code><br />;--------------------------------------------------------------------------------------<br />; UI control IDs<br />;--------------------------------------------------------------------------------------<br />IDC_TOGGLEFULLSCREEN&nbsp; &nbsp; equ 1<br />IDC_TOGGLEREF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  equ 3<br />IDC_CHANGEDEVICE&nbsp; &nbsp; &nbsp; &nbsp; equ 4<br />IDC_METHOD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equ 5<br /><br /><br />;//--------------------------------------------------------------------------------------<br />;// Forward declarations <br />;//--------------------------------------------------------------------------------------<br />;bool&nbsp; &nbsp; CALLBACK IsDeviceAcceptable( D3DCAPS9* pCaps, D3DFORMAT AdapterFormat, D3DFORMAT BackBufferFormat, bool bWindowed, void* pUserContext );<br />;bool&nbsp; &nbsp; CALLBACK ModifyDeviceSettings( DXUTDeviceSettings* pDeviceSettings, const D3DCAPS9* pCaps, void* pUserContext );<br />;HRESULT CALLBACK OnCreateDevice( IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc, void* pUserContext );<br />;HRESULT CALLBACK OnResetDevice( IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc, void* pUserContext );<br />;void&nbsp; &nbsp; CALLBACK OnFrameMove( IDirect3DDevice9* pd3dDevice, double fTime, float fElapsedTime, void* pUserContext );<br />;void&nbsp; &nbsp; CALLBACK OnFrameRender( IDirect3DDevice9* pd3dDevice, double fTime, float fElapsedTime, void* pUserContext );<br />;LRESULT CALLBACK MsgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool* pbNoFurtherProcessing, void* pUserContext );<br />;void&nbsp; &nbsp; CALLBACK KeyboardProc( UINT nChar, bool bKeyDown, bool bAltDown, void* pUserContext );<br />;void&nbsp; &nbsp; CALLBACK OnGUIEvent( UINT nEvent, int nControlID, CDXUTControl* pControl, void* pUserContext );<br />;void&nbsp; &nbsp; CALLBACK OnLostDevice( void* pUserContext );<br />;void&nbsp; &nbsp; CALLBACK OnDestroyDevice( void* pUserContext );<br />;<br />;void&nbsp; &nbsp; InitApp();<br />;HRESULT LoadMesh( IDirect3DDevice9* pd3dDevice, WCHAR* strFileName, ID3DXMesh** ppMesh );<br />;void&nbsp; &nbsp; RenderText();<br />;void&nbsp; &nbsp; DrawMeshContainer( IDirect3DDevice9 *pd3dDevice, LPD3DXMESHCONTAINER pMeshContainerBase, LPD3DXFRAME pFrameBase );<br />;void&nbsp; &nbsp; DrawFrame( IDirect3DDevice9 *pd3dDevice, LPD3DXFRAME pFrame );<br />;HRESULT SetupBoneMatrixPointersOnMesh( LPD3DXMESHCONTAINER pMeshContainer );<br />;HRESULT SetupBoneMatrixPointers( LPD3DXFRAME pFrame );<br />;void&nbsp; &nbsp; UpdateFrameMatrices( LPD3DXFRAME pFrameBase, LPD3DXMATRIX pParentMatrix );<br />;void&nbsp; &nbsp; UpdateSkinningMethod( LPD3DXFRAME pFrameBase );<br />;HRESULT GenerateSkinnedMesh( IDirect3DDevice9 *pd3dDevice, D3DXMESHCONTAINER_DERIVED *pMeshContainer );<br />;void&nbsp; &nbsp; ReleaseAttributeTable( LPD3DXFRAME pFrameBase );<br /></code></pre><br /><br />Finally, we get to some good stuff - some actual code !! About Time !!<br /></div>
    <div class="meta">Posted on 2005-12-28 01:35:44 by Homer</div>
   </div>
   <div class="post" id="post-169203">
    <div class="subject"><a href="#post-169203">Re: OOPSkinMesh question</a></div>
    <div class="body">Our first actual code to translate is a helper procedure for allocating memory for a name string, and copying the name string into the allocated memory, and returning a pointer to the new copy.<br /><br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// Name: AllocateName()<br />// Desc: Allocates memory for a string to hold the name of a frame or mesh<br />//--------------------------------------------------------------------------------------<br />HRESULT AllocateName( LPCSTR Name, LPSTR *pNewName )<br />{<br />&nbsp; &nbsp; UINT cbLength;<br /><br />&nbsp; &nbsp; if( Name != NULL )<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; cbLength = (UINT)strlen(Name) + 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; *pNewName = new CHAR;<br />&nbsp; &nbsp; &nbsp; &nbsp; if (*pNewName == NULL)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return E_OUTOFMEMORY;<br />&nbsp; &nbsp; &nbsp; &nbsp; memcpy( *pNewName, Name, cbLength*sizeof(CHAR) );<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; *pNewName = NULL;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; return S_OK;<br />}<br /></code></pre><br /><br />Our version of this procedure uses OA32&#39;s MemAlloc macro.<br />More specifically, I use $MemAlloc, which is a lot like $invoke..<br />MemAlloc allocates memory on the Process Heap.<br />This may not be the best place to shove strings, but it&#39;ll do the job.<br />Right now I&#39;m not concerned about efficiency, just wanna make it work.<br /><pre><code><br />AllocateName proc uses esi,pName,ppNewName<br />&nbsp; &nbsp; .if pName != NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke lstrlen,pName<br />	inc eax<br />	mov esi,ppNewName<br />	mov dword ptr,$MemAlloc(eax,MEM_INIT_ZERO)<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return E_OUTOFMEMORY<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />	invoke lstrcpy,eax,pName<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; mov esi,ppNewName<br />&nbsp; &nbsp; &nbsp; &nbsp; mov dword ptr,NULL<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; return S_OK<br />AllocateName endp<br /></code></pre><br /><br />Please yell if you have any questions !!!<br /></div>
    <div class="meta">Posted on 2005-12-28 01:46:05 by Homer</div>
   </div>
   <div class="post" id="post-169204">
    <div class="subject"><a href="#post-169204">Re: OOPSkinMesh question</a></div>
    <div class="body">It&#39;s time to define the four functions associated with the interface we defined earlier.<br />I&#39;m going to diverge from the original source a little here, because it really doesn&#39;t matter what order we define these four functions, as long as we define them all.<br />Note that we will never be calling any of these functions ourselves.<br />D3DXLoadMeshHierarchyFromX will be calling them via our interface (which you should be seeing as just a table of pointers to our code by now).<br /><br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// Name: CAllocateHierarchy::CreateFrame()<br />// Desc: <br />//--------------------------------------------------------------------------------------<br />HRESULT CAllocateHierarchy::CreateFrame( LPCSTR Name, LPD3DXFRAME *ppNewFrame )<br />{<br />&nbsp; &nbsp; HRESULT hr = S_OK;<br />&nbsp; &nbsp; D3DXFRAME_DERIVED *pFrame;<br /><br />&nbsp; &nbsp; *ppNewFrame = NULL;<br /><br />&nbsp; &nbsp; pFrame = new D3DXFRAME_DERIVED;<br />&nbsp; &nbsp; if (pFrame == NULL)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; hr = E_OUTOFMEMORY;<br />&nbsp; &nbsp; &nbsp; &nbsp; goto e_Exit;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; hr = AllocateName(Name, &amp;pFrame-&gt;Name);<br />&nbsp; &nbsp; if (FAILED(hr))<br />&nbsp; &nbsp; &nbsp; &nbsp; goto e_Exit;<br /><br />&nbsp; &nbsp; // initialize other data members of the frame<br />&nbsp; &nbsp; D3DXMatrixIdentity(&amp;pFrame-&gt;TransformationMatrix);<br />&nbsp; &nbsp; D3DXMatrixIdentity(&amp;pFrame-&gt;CombinedTransformationMatrix);<br /><br />&nbsp; &nbsp; pFrame-&gt;pMeshContainer = NULL;<br />&nbsp; &nbsp; pFrame-&gt;pFrameSibling = NULL;<br />&nbsp; &nbsp; pFrame-&gt;pFrameFirstChild = NULL;<br /><br />&nbsp; &nbsp; *ppNewFrame = pFrame;<br />&nbsp; &nbsp; pFrame = NULL;<br /><br />e_Exit:<br />&nbsp; &nbsp; delete pFrame;<br />&nbsp; &nbsp; return hr;<br />}<br /></code></pre><br /><br />Here&#39;s our version of this Class Method.<br />In our version, we don&#39;t bother setting a bunch of fields to NULL..<br />Instead, we zero out the entire Frame object when we allocate its memory..<br /><pre><code><br />Method CAllocateHierarchy.CreateFrame,uses esi,pName,ppNewFrame<br />local pFrame<br />local hr<br />&nbsp; &nbsp; mov hr,S_OK<br /><br />&nbsp; &nbsp; ;Zero the output variable<br />&nbsp; &nbsp; mov eax,ppNewFrame <br />&nbsp; &nbsp; mov dword ptr, NULL<br /><br />&nbsp; &nbsp; mov pFrame,$MemAlloc(sizeof D3DXFRAME_DERIVED,MEM_INIT_ZERO)<br />&nbsp; &nbsp; .if eax == NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; return E_OUTOFMEMORY<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov hr , $invoke (AllocateName,pName, addr .D3DXFRAME.pName<br />&nbsp; &nbsp; .if (FAILED(eax)<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp e_Exit<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ; initialize other data members of the frame<br />&nbsp; &nbsp; mov eax,pFrame<br />&nbsp; &nbsp; invoke D3DXMatrixIdentity,addr .D3DXFRAME.TransformationMatrix<br />&nbsp; &nbsp; mov eax,pFrame<br />&nbsp; &nbsp; invoke D3DXMatrixIdentity,addr .D3DXFRAME_DERIVED.CombinedTransformationMatrix<br /><br />&nbsp; &nbsp; ;Set the output variable<br />&nbsp; &nbsp; mov eax,ppNewFrame<br />&nbsp; &nbsp; m2m dword ptr,pFrame<br />&nbsp; &nbsp; ;Return S_OK<br />&nbsp; &nbsp; return hr<br /><br />e_Exit: ;Something went wrong, lets deallocate Frame and return error<br />&nbsp; &nbsp; MemFree pFrame<br />&nbsp; &nbsp; return hr<br />MethodEnd<br /></code></pre><br /><br />Questions?<br /></div>
    <div class="meta">Posted on 2005-12-28 02:07:30 by Homer</div>
   </div>
   <div class="post" id="post-169205">
    <div class="subject"><a href="#post-169205">Re: OOPSkinMesh question</a></div>
    <div class="body">I said it didn&#39;t really matter what order these four functions were declared in, so here&#39;s the flipside to the previous function:<br /><br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// Name: CAllocateHierarchy::DestroyFrame()<br />// Desc: <br />//--------------------------------------------------------------------------------------<br />HRESULT CAllocateHierarchy::DestroyFrame(LPD3DXFRAME pFrameToFree) <br />{<br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pFrameToFree-&gt;Name );<br />&nbsp; &nbsp; SAFE_DELETE( pFrameToFree );<br />&nbsp; &nbsp; return S_OK; <br />}<br /></code></pre><br /><br />We will declare a helper macro called SafeFree<br />Our code looks like this:<br /><pre><code><br />SafeFree macro target<br />&nbsp;  .if target!=NULL<br />&nbsp; &nbsp; &nbsp; MemFree target<br />&nbsp; &nbsp; &nbsp; mov target,NULL<br />&nbsp;  .endif<br />endm<br /><br />Method CAllocateHierarchy.DestroyFrame,uses esi,pFrameToFree<br />&nbsp; &nbsp; mov eax,pFrameToFree<br />&nbsp; &nbsp; SafeFree .D3DXFRAME.pName<br />&nbsp; &nbsp; SafeFree pFrameToFree <br />&nbsp; &nbsp; return S_OK; <br />MethodEnd<br /></code></pre><br /><br />Well, that was pretty easy, huh?<br />There&#39;s not much involved in allocating and deallocating Frames :)<br /><br />Two interface methods down, and two to go..<br /><br /></div>
    <div class="meta">Posted on 2005-12-28 02:30:38 by Homer</div>
   </div>
   <div class="post" id="post-169206">
    <div class="subject"><a href="#post-169206">Re: OOPSkinMesh question</a></div>
    <div class="body">It&#39;s time to get our hands dirty.<br />Here&#39;s the original version of the CreateMeshContainer method.<br />It will look scary at first, but there&#39;s nothing to be afraid of..<br /><br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// Name: CAllocateHierarchy::CreateMeshContainer()<br />// Desc: <br />//--------------------------------------------------------------------------------------<br />HRESULT CAllocateHierarchy::CreateMeshContainer(<br />    LPCSTR Name, <br />    CONST D3DXMESHDATA *pMeshData,<br />    CONST D3DXMATERIAL *pMaterials, <br />    CONST D3DXEFFECTINSTANCE *pEffectInstances, <br />    DWORD NumMaterials, <br />    CONST DWORD *pAdjacency, <br />    LPD3DXSKININFO pSkinInfo, <br />    LPD3DXMESHCONTAINER *ppNewMeshContainer) <br />{<br />    HRESULT hr;<br />    D3DXMESHCONTAINER_DERIVED *pMeshContainer = NULL;<br />    UINT NumFaces;<br />    UINT iMaterial;<br />    UINT iBone, cBones;<br />    LPDIRECT3DDEVICE9 pd3dDevice = NULL;<br /><br />    LPD3DXMESH pMesh = NULL;<br /><br />    *ppNewMeshContainer = NULL;<br /><br />    // this sample does not handle patch meshes, so fail when one is found<br />    if (pMeshData-&gt;Type != D3DXMESHTYPE_MESH)<br />    {<br />        hr = E_FAIL;<br />        goto e_Exit;<br />    }<br /><br />    // get the pMesh interface pointer out of the mesh data structure<br />    pMesh = pMeshData-&gt;pMesh;<br /><br />    // this sample does not FVF compatible meshes, so fail when one is found<br />    if (pMesh-&gt;GetFVF() == 0)<br />    {<br />        hr = E_FAIL;<br />        goto e_Exit;<br />    }<br /><br />    // allocate the overloaded structure to return as a D3DXMESHCONTAINER<br />    pMeshContainer = new D3DXMESHCONTAINER_DERIVED;<br />    if (pMeshContainer == NULL)<br />    {<br />        hr = E_OUTOFMEMORY;<br />        goto e_Exit;<br />    }<br />    memset(pMeshContainer, 0, sizeof(D3DXMESHCONTAINER_DERIVED));<br /><br />    // make sure and copy the name.  All memory as input belongs to caller, interfaces can be addref&#39;d though<br />    hr = AllocateName(Name, &amp;pMeshContainer-&gt;Name);<br />    if (FAILED(hr))<br />        goto e_Exit;        <br /><br />    pMesh-&gt;GetDevice(&amp;pd3dDevice);<br />    NumFaces = pMesh-&gt;GetNumFaces();<br /><br />    // if no normals are in the mesh, add them<br />    if (!(pMesh-&gt;GetFVF() &amp; D3DFVF_NORMAL))<br />    {<br />        pMeshContainer-&gt;MeshData.Type = D3DXMESHTYPE_MESH;<br /><br />        // clone the mesh to make room for the normals<br />        hr = pMesh-&gt;CloneMeshFVF( pMesh-&gt;GetOptions(), <br />                                    pMesh-&gt;GetFVF() | D3DFVF_NORMAL, <br />                                    pd3dDevice, &amp;pMeshContainer-&gt;MeshData.pMesh );<br />        if (FAILED(hr))<br />            goto e_Exit;<br /><br />        // get the new pMesh pointer back out of the mesh container to use<br />        // NOTE: we do not release pMesh because we do not have a reference to it yet<br />        pMesh = pMeshContainer-&gt;MeshData.pMesh;<br /><br />        // now generate the normals for the pmesh<br />        D3DXComputeNormals( pMesh, NULL );<br />    }<br />    else  // if no normals, just add a reference to the mesh for the mesh container<br />    {<br />        pMeshContainer-&gt;MeshData.pMesh = pMesh;<br />        pMeshContainer-&gt;MeshData.Type = D3DXMESHTYPE_MESH;<br /><br />        pMesh-&gt;AddRef();<br />    }<br />        <br />    // allocate memory to contain the material information.  This sample uses<br />    //   the D3D9 materials and texture names instead of the EffectInstance style materials<br />    pMeshContainer-&gt;NumMaterials = max(1, NumMaterials);<br />    pMeshContainer-&gt;pMaterials = new D3DXMATERIAL;<br />    pMeshContainer-&gt;ppTextures = new LPDIRECT3DTEXTURE9;<br />    pMeshContainer-&gt;pAdjacency = new DWORD;<br />    if ((pMeshContainer-&gt;pAdjacency == NULL) || (pMeshContainer-&gt;pMaterials == NULL))<br />    {<br />        hr = E_OUTOFMEMORY;<br />        goto e_Exit;<br />    }<br /><br />    memcpy(pMeshContainer-&gt;pAdjacency, pAdjacency, sizeof(DWORD) * NumFaces*3);<br />    memset(pMeshContainer-&gt;ppTextures, 0, sizeof(LPDIRECT3DTEXTURE9) * pMeshContainer-&gt;NumMaterials);<br /><br />    // if materials provided, copy them<br />    if (NumMaterials &gt; 0)            <br />    {<br />        memcpy(pMeshContainer-&gt;pMaterials, pMaterials, sizeof(D3DXMATERIAL) * NumMaterials);<br /><br />        for (iMaterial = 0; iMaterial &lt; NumMaterials; iMaterial++)<br />        {<br />            if (pMeshContainer-&gt;pMaterials.pTextureFilename != NULL)<br />            {<br />                WCHAR strTexturePath;<br />                WCHAR wszBuf;<br />                MultiByteToWideChar( CP_ACP, 0, pMeshContainer-&gt;pMaterials.pTextureFilename, -1, wszBuf, MAX_PATH );<br />                wszBuf = L&#39;\0&#39;;<br />                DXUTFindDXSDKMediaFileCch( strTexturePath, MAX_PATH, wszBuf );<br />                if( FAILED( D3DXCreateTextureFromFile( pd3dDevice, strTexturePath,<br />                                                        &amp;pMeshContainer-&gt;ppTextures ) ) )<br />                    pMeshContainer-&gt;ppTextures = NULL;<br /><br />                // don&#39;t remember a pointer into the dynamic memory, just forget the name after loading<br />                pMeshContainer-&gt;pMaterials.pTextureFilename = NULL;<br />            }<br />        }<br />    }<br />    else // if no materials provided, use a default one<br />    {<br />        pMeshContainer-&gt;pMaterials[0].pTextureFilename = NULL;<br />        memset(&amp;pMeshContainer-&gt;pMaterials[0].MatD3D, 0, sizeof(D3DMATERIAL9));<br />        pMeshContainer-&gt;pMaterials[0].MatD3D.Diffuse.r = 0.5f;<br />        pMeshContainer-&gt;pMaterials[0].MatD3D.Diffuse.g = 0.5f;<br />        pMeshContainer-&gt;pMaterials[0].MatD3D.Diffuse.b = 0.5f;<br />        pMeshContainer-&gt;pMaterials[0].MatD3D.Specular = pMeshContainer-&gt;pMaterials[0].MatD3D.Diffuse;<br />    }<br /><br />    // if there is skinning information, save off the required data and then setup for HW skinning<br />    if (pSkinInfo != NULL)<br />    {<br />        // first save off the SkinInfo and original mesh data<br />        pMeshContainer-&gt;pSkinInfo = pSkinInfo;<br />        pSkinInfo-&gt;AddRef();<br /><br />        pMeshContainer-&gt;pOrigMesh = pMesh;<br />        pMesh-&gt;AddRef();<br /><br />        // Will need an array of offset matrices to move the vertices from the figure space to the bone&#39;s space<br />        cBones = pSkinInfo-&gt;GetNumBones();<br />        pMeshContainer-&gt;pBoneOffsetMatrices = new D3DXMATRIX;<br />        if (pMeshContainer-&gt;pBoneOffsetMatrices == NULL)<br />        {<br />            hr = E_OUTOFMEMORY;<br />            goto e_Exit;<br />        }<br /><br />        // get each of the bone offset matrices so that we don&#39;t need to get them later<br />        for (iBone = 0; iBone &lt; cBones; iBone++)<br />        {<br />            pMeshContainer-&gt;pBoneOffsetMatrices = *(pMeshContainer-&gt;pSkinInfo-&gt;GetBoneOffsetMatrix(iBone));<br />        }<br /><br />        // GenerateSkinnedMesh will take the general skinning information and transform it to a HW friendly version<br />        hr = GenerateSkinnedMesh( pd3dDevice, pMeshContainer );<br />        if (FAILED(hr))<br />            goto e_Exit;<br />    }<br /><br />    *ppNewMeshContainer = pMeshContainer;<br />    pMeshContainer = NULL;<br /><br />e_Exit:<br />    SAFE_RELEASE(pd3dDevice);<br /><br />    // call Destroy function to properly clean up the memory allocated <br />    if (pMeshContainer != NULL)<br />    {<br />        DestroyMeshContainer(pMeshContainer);<br />    }<br /><br />    return hr;<br />}<br /></code></pre><br /><br /><br />We will implement another helper macro, whose job is to call the IUnknown::Release method apon a given COM interface instance as follows:<br /><br /><pre><code><br />SafeRelease macro target<br />   .if target!=NULL<br />      ICall target::IUnknown.Release<br />      mov target,NULL<br />   .endif<br />endm<br /></code></pre><br /><br /><br />Now, here&#39;s our version of CreateMeshContainer method:<br /><br /><pre><code><br />Method CAllocateHierarchy.CreateMeshContainer,uses esi,pName,pMeshData,pMaterials,pEffectInstances,NUmMaterials,pAdjacency,pSkinInfo,ppNewMeshContainer<br />local hr<br />local pMeshContainer <br />local pd3dDevice<br />local NumFaces<br />local iMaterial<br />local iBone<br />local cBones<br />local pMesh<br />local fvf<br />local options<br /><br /><br />    ;Zero some locals<br />    mov pd3dDevice,NULL<br />    mov pMesh,NULL<br />    mov pMeshContainer,NULL<br />    ;Zero the output variable<br />    mov eax,ppNewMeshContainer<br />    mov dword ptr,NULL<br /><br />    ; this sample does not handle patch meshes, so fail when one is found<br />    mov eax,pMeshData<br />    .if .D3DXMESHDATA.dType!=D3DXMESHTYPE_MESH)<br />	mov hr,E_FAIL<br />        jmp e_Exit<br />    .endif<br /><br />    ; get the pMesh interface pointer out of the mesh data structure<br />    m2m pMesh,.D3DXMESHDATA.pMesh<br /><br />    ; this sample does not handle FVF compatible meshes, so fail when one is found<br />    ; NOTE : Use ICall when calling COM Interface Methods<br />    ICall pMesh::ID3DXMesh.GetFVF<br />    mov fvf,eax<br />    .if eax==0<br />        mov hr , E_FAIL<br />        jmp e_Exit<br />    .endif<br /><br />    ; allocate the overloaded structure to return as a D3DXMESHCONTAINER<br />    mov pMeshContainer ,$MemAlloc(sizeof D3DXMESHCONTAINER_DERIVED,MEM_INIT_ZERO)<br />    .if eax==NULL    <br />        mov hr, E_OUTOFMEMORY<br />        jmp e_Exit<br />    .endif<br /><br />    ; make sure to copy the name.  All memory as input belongs to caller, interfaces can be addref&#39;d though<br />    mov hr , $invoke (AllocateName,pName, addr .D3DXMESHCONTAINER.pName)<br />    .if (FAILED(eax)<br />        jmp e_Exit<br />    .endif        <br /><br />    ICall pMesh::ID3DXMesh.GetDevice,addr pd3dDevice<br />    ICall pMesh::ID3DXMesh.GetNumFaces<br />    mov NumFaces,eax<br /><br />    ; if no normals are in the mesh, add them<br />    mov eax,fvf<br />    and eax,D3DFVF_NORMAL<br />    .if eax==NULL<br />        mov eax,pMeshContainer<br />        mov .D3DXMESHCONTAINER.MeshData.dType,D3DXMESHTYPE_MESH<br /><br />        ; clone the mesh to make room for the normals<br />        ICall pMesh::ID3DXMesh.GetOptions<br />	mov options,eax<br />        mov ebx,fvf<br />        or ebx,D3DFVF_NORMAL<br />        mov eax,pMeshContainer<br />	ICall pMesh::ID3DXMesh.CloneMeshFVF,options,ebx,pd3dDevice,addr .D3DXMESHCONTAINER.MeshData.pMesh<br />        mov hr,eax<br />        .if FAILED(eax)<br />            jmp e_Exit<br />        .endif<br /><br />        ; get the new pMesh pointer back out of the mesh container to use<br />        ; NOTE: we do not release pMesh because we do not have a reference to it yet<br />        mov eax,pMeshContainer     <br />        m2m pMesh , .D3DXMESHCONTAINER.MeshData.pMesh<br /><br />        ; now generate the normals for the pmesh<br />        invoke D3DXComputeNormals, pMesh, NULL <br />    <br />    .else  ; if no normals, just add a reference to the mesh for the mesh container    <br />        mov eax,pMeshContainer     <br />        m2m .D3DXMESHCONTAINER.MeshData.pMesh,pMesh<br />        mov .D3DXMESHCONTAINER.MeshData.dType , D3DXMESHTYPE_MESH<br />        ICall pMesh::ID3DXMesh.AddRef<br />    .endif<br />        <br />    ; allocate memory to contain the material information.  This sample uses<br />    ;   the D3D9 materials and texture names instead of the EffectInstance style materials<br />    mov eax,pMeshContainer<br />    .if NumMaterials==NULL<br />       mov .D3DXMESHCONTAINER.NumMaterials,1<br />    .else<br />       m2m .D3DXMESHCONTAINER.NumMaterials,NumMaterials<br />    .endif<br /><br />    mov esi,pMeshContainer<br />    mov eax,sizeof D3DXMATERIAL<br />    mul .D3DXMESHCONTAINER.NumMaterials<br />    mov .D3DXMESHCONTAINER.pMaterials,$MemAlloc(eax)<br />    mov eax,.D3DXMESHCONTAINER.NumMaterials<br />    shl eax,2<br />    mov .D3DXMESHCONTAINER.ppTextures,$MemAlloc(eax)<br />    mov eax,3<br />    mul NumFaces<br />    shl eax,2<br />    mov .D3DXMESHCONTAINER.pAdjacency,$MemAlloc(eax)<br />    .if eax==NUll || esi].D3DXMESHCONTAINER.pMaterials==NULL || .D3DXMESHCONTAINER.ppTextures==NULL<br />        mov hr , E_OUTOFMEMORY<br />        jmp e_Exit<br />    .endif<br /><br />    mov eax,3<br />    mul NumFaces<br />    shl eax,2<br />    invoke RtlMoveMemory,.D3DXMESHCONTAINER.pAdjacency, pAdjacency, eax<br />    mov eax,.D3DXMESHCONTAINER.NumMaterials<br />    shl eax,2<br />    invoke RtlZeroMemory,.D3DXMESHCONTAINER.ppTextures, eax<br /><br />    ; if materials provided, copy them<br />    .if NumMaterials &gt; 0    <br />        mov eax,sizeof D3DXMATERIAL<br />        mul .D3DXMESHCONTAINER.NumMaterials<br />        invoke RtlMoveMemory,.D3DXMESHCONTAINER.pMaterials, pMaterials, eax<br /><br />        xor eax,eax<br />        mov iMaterial,eax<br />        .while eax&lt;NumMaterials<br />            mov esi,pMeshContainer<br />	    mov ebx,sizeof D3DXMATERIAL<br />            mul ebx<br />            add eax,.D3DXMESHCONTAINER.pMaterials<br />            mov pmaterial.eax<br />            .if .D3DXMATERIAL.pTextureFilename!=NULL<br />                ;WCHAR strTexturePath;<br />                ;WCHAR wszBuf;<br />                ;MultiByteToWideChar( CP_ACP, 0, pMeshContainer-&gt;pMaterials.pTextureFilename, -1, wszBuf, MAX_PATH );<br />                ;wszBuf = L&#39;\0&#39;;<br />                ;DXUTFindDXSDKMediaFileCch( strTexturePath, MAX_PATH, wszBuf );<br />		pop ebx<br />		push ebx<br />                shl ebx,2<br />                add ebx,.D3DXMESHCONTAINER.ppTextures<br />                invoke D3DXCreateTextureFromFile, pd3dDevice,.D3DXMATERIAL.pTextureFilename,ebx<br />		.if FAILED(eax)<br />		    pop ebx<br />		    push ebx<br />                    shl ebx,2<br />                    add ebx,.D3DXMESHCONTAINER.ppTextures<br />                    mov dword ptr,NULL<br />		.endif<br />                ; don&#39;t remember a pointer into the dynamic memory, just forget the name after loading<br />                mov eax,pmaterial<br />                mov .D3DXMATERIAL.pTextureFilename,NULL<br />            .endif<br />            inc iMaterial<br />            mov eax,iMaterial<br />        .endw<br />    <br />    .else ; if no materials provided, use a default one<br />        mov esi,pMeshContainer<br />        mov ebx,.D3DXMESHCONTAINER.pMaterials<br />        mov .D3DXMATERIAL.pTextureFilename,NULL<br />	push ebx<br />	invoke RtlZeroMemory,addr .D3DXMATERIAL.MatD3D,sizeof D3DMATERIAL9<br />	pop ebx<br />	fld fHalf<br />	fst .D3DXMATERIAL.MatD3D.Diffuse.r<br />	fst .D3DXMATERIAL.MatD3D.Diffuse.g<br />	fst .D3DXMATERIAL.MatD3D.Diffuse.b<br />	fst .D3DXMATERIAL.MatD3D.Specular.r<br />	fst .D3DXMATERIAL.MatD3D.Specular.g<br />	fstp .D3DXMATERIAL.MatD3D.Specular.b<br />    .endif<br /><br />    ; if there is skinning information, save off the required data and then setup for HW skinning<br />    .if pSkinInfo != NULL    <br />        ; first save off the SkinInfo and original mesh data<br />        mov ebx,pMeshContainer<br />        m2m .D3DXMESHCONTAINER.pSkinInfo , pSkinInfo<br />        ICall pSkinInfo::ID3DXSkinInfo.AddRef<br /><br />        mov ebx,pMeshContainer<br />        m2m .D3DXMESHCONTAINER.pOrigMesh , pMesh<br />	ICall pMesh::ID3DXMesh.AddRef<br /><br />        ; Will need an array of offset matrices to move the vertices from the figure space to the bone&#39;s space<br />	ICall pSkinInfo::ID3DXSkinInfo.GetNumBones<br />        mov cBones,eax<br />	mov eax,sizeof D3DXMATRIX<br />        mul cBones<br />        mov esi,pMeshContainer<br />        mov .D3DXMESHCONTAINER.pBoneOffsetMatrices,$MemAlloc(eax)<br />        .if eax==NULL        <br />            mov hr , E_OUTOFMEMORY<br />            jmp e_Exit<br />        .endif<br /><br />        ; get each of the bone offset matrices so that we don&#39;t need to get them later<br />	mov ebx,.D3DXMESHCONTAINER.pBoneOffsetMatrices<br />	xor eax,eax<br />        mov iBone,eax<br />        .while eax&lt;cBones<br />            push ebx<br />	    ICall .D3DXMESHCONTAINER.pSkinInfo::ID3DXSkinInfo.GetBoneOffsetMatrix,iBone<br />            pop ebx<br />            mov dword ptr,eax<br />            add ebx,4<br />	    inc iBone<br />            mov eax,iBone<br />        .endw<br /><br />        ; GenerateSkinnedMesh will take the general skinning information and transform it to a HW friendly version<br />        mov hr , $invoke (GenerateSkinnedMesh, pd3dDevice, pMeshContainer)<br />        .if FAILED(eax)<br />            jmp e_Exit<br />        .endif<br />    .endif<br /><br />    mov eax,ppNewMeshContainer<br />    m2m dword ptr,pMeshContainer<br />    return hr<br /><br />e_Exit:<br />    SafeRelease pd3dDevice<br /><br />    ; call Destroy function to properly clean up the memory allocated <br />    .if pMeshContainer != NULL   <br />        ICall DestroyMeshContainer,pMeshContainer<br />    .endif<br /><br />    return hr<br />MethodEnd<br /></code></pre><br /><br />Wow, that was pretty hefty, but not too difficult .. take a little time to stare at this one for a while.<br /><br /><br /></div>
    <div class="meta">Posted on 2005-12-28 03:31:52 by Homer</div>
   </div>
   <div class="post" id="post-169207">
    <div class="subject"><a href="#post-169207">Re: OOPSkinMesh question</a></div>
    <div class="body">We only have one of the four required interface methods left !!!<br /><br /><pre><code><br />//--------------------------------------------------------------------------------------<br />// Name: CAllocateHierarchy::DestroyMeshContainer()<br />// Desc: <br />//--------------------------------------------------------------------------------------<br />HRESULT CAllocateHierarchy::DestroyMeshContainer(LPD3DXMESHCONTAINER pMeshContainerBase)<br />{<br />&nbsp; &nbsp; UINT iMaterial;<br />&nbsp; &nbsp; D3DXMESHCONTAINER_DERIVED *pMeshContainer = (D3DXMESHCONTAINER_DERIVED*)pMeshContainerBase;<br /><br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pMeshContainer-&gt;Name );<br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pMeshContainer-&gt;pAdjacency );<br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pMeshContainer-&gt;pMaterials );<br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pMeshContainer-&gt;pBoneOffsetMatrices );<br /><br />&nbsp; &nbsp; // release all the allocated textures<br />&nbsp; &nbsp; if (pMeshContainer-&gt;ppTextures != NULL)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (iMaterial = 0; iMaterial &lt; pMeshContainer-&gt;NumMaterials; iMaterial++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SAFE_RELEASE( pMeshContainer-&gt;ppTextures );<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pMeshContainer-&gt;ppTextures );<br />&nbsp; &nbsp; SAFE_DELETE_ARRAY( pMeshContainer-&gt;ppBoneMatrixPtrs );<br />&nbsp; &nbsp; SAFE_RELEASE( pMeshContainer-&gt;pBoneCombinationBuf );<br />&nbsp; &nbsp; SAFE_RELEASE( pMeshContainer-&gt;MeshData.pMesh );<br />&nbsp; &nbsp; SAFE_RELEASE( pMeshContainer-&gt;pSkinInfo );<br />&nbsp; &nbsp; SAFE_RELEASE( pMeshContainer-&gt;pOrigMesh );<br />&nbsp; &nbsp; SAFE_DELETE( pMeshContainer );<br />&nbsp; &nbsp; return S_OK;<br />}<br /></code></pre><br /><br />And our version,<br /><br /><pre><code><br />Method CAllocateHierarchy.DestroyMeshContainer,uses esi,pMeshContainer<br /><br />&nbsp; &nbsp; mov esi,pMeshContainer<br />&nbsp; &nbsp; SafeFree .D3DXMESHCONTAINER.pName<br />&nbsp; &nbsp; SafeFree .D3DXMESHCONTAINER.pAdjacency<br />&nbsp; &nbsp; SafeFree .D3DXMESHCONTAINER.pMaterials<br />&nbsp; &nbsp; SafeFree .D3DXMESHCONTAINER.pBoneOffsetMatrices<br /><br />&nbsp; &nbsp; ; release all the allocated textures<br />&nbsp; &nbsp; .if .D3DXMESHCONTAINER.ppTextures != NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; xor ecx,ecx<br />	mov ebx,.D3DXMESHCONTAINER.ppTextures<br />&nbsp; &nbsp; &nbsp; &nbsp; .while ecx&lt;.D3DXMESHCONTAINER.NumMaterials<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shl ecx,2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SafeRelease dword ptr<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; .endw<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; SafeFree .D3DXMESHCONTAINER.ppTextures<br />&nbsp; &nbsp; SafeFree .D3DXMESHCONTAINER.ppBoneMatrixPtrs<br />&nbsp; &nbsp; SafeRelease .D3DXMESHCONTAINER.pBoneCombinationBuf <br />&nbsp; &nbsp; SafeRelease .D3DXMESHCONTAINER.MeshData.pMesh <br />&nbsp; &nbsp; SafeRelease .D3DXMESHCONTAINER.pSkinInfo <br />&nbsp; &nbsp; SafeRelease .D3DXMESHCONTAINER.pOrigMesh <br />&nbsp; &nbsp; SafeFree pMeshContainer<br />&nbsp; &nbsp; return S_OK<br />MethodEnd<br /></code></pre><br /><br />Say, we&#39;re beginning to make some progress huh?<br />So far the only thing that is preventing this useless garbage from compiling is a missing procedure called GenerateSkinnedMesh :)<br /><br />Any Questions?</div>
    <div class="meta">Posted on 2005-12-28 03:32:30 by Homer</div>
   </div>
   <div class="post" id="post-169208">
    <div class="subject"><a href="#post-169208">Re: OOPSkinMesh question</a></div>
    <div class="body">We have arrived at WinMain in the SDK sample.<br /><br />From here on, things will be weird, because we will attempt to avoid implementing mountains of unnecessary generic app support code.<br /><br />Things are also weird because the application-specific code and the skinmesh code are presented together, whereas we would ultimately like to separate SkinMesh class code from the application junk, so that we have a reusable SkinMesh class object we can instance in future apps.. We&#39;ll cross each bridge as we come to it, but really its time to start looking at the minimal framework requirements...<br /></div>
    <div class="meta">Posted on 2005-12-28 03:41:44 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=22096&amp;page=1" style="">&laquo;</a><a href="../?id=22096&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="22096" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=22096&amp;page=3">&gt;</a><a href="../?id=22096&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>