; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\src\test\imgflip\imgflip.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?fni@@3PBDB					; fni
PUBLIC	?fno@@3PBDB					; fno
_DATA	SEGMENT
?fni@@3PBDB DD	FLAT:$SG34984				; fni
?fno@@3PBDB DD	FLAT:$SG34986				; fno
_DATA	ENDS
CONST	SEGMENT
$SG34984 DB	'input_24bpp_bgr.raw', 00H
$SG34986 DB	'output32.raw', 00H
	ORG $+3
$SG35001 DB	'rb', 00H
	ORG $+1
$SG35006 DB	'%d iterations of f1: %d ticks', 0aH, 00H
	ORG $+1
$SG35011 DB	'%d iterations of f1: %d ticks', 0aH, 00H
	ORG $+1
$SG35016 DB	'%d iterations of nc1: %d ticks', 0aH, 00H
$SG35018 DB	'wb', 00H
; Function compile flags: /Ogtpy
; File d:\src\test\imgflip\imgflip.cpp
CONST	ENDS
_TEXT	SEGMENT
tv140 = -8						; size = 4
_iRowBytes$ = -4					; size = 4
_ib$34918 = 8						; size = 1
_tSrcImagePtr$ = 8					; size = 4
_iWidth$ = 12						; size = 4
?FlipVertical24_nc1@@YAXPAE0II@Z PROC			; FlipVertical24_nc1
; _tDstImagePtr$ = eax
; _iHeight$ = ecx

; 12   : {

	sub	esp, 8
	push	ebp
	push	esi
	push	edi

; 13   : 	const uint		iRowBytes    = iWidth*3;

	mov	edi, DWORD PTR _iWidth$[esp+16]

; 14   : 	const uint		iImageBytes  = iWidth*iHeight*3;
; 15   : 
; 16   : 	uint			*src;
; 17   : 	uint			*dst = (uint*) tDstImagePtr;

	mov	esi, eax

; 18   : 	uchar			*srcRow = tSrcImagePtr;
; 19   : 
; 20   : 	srcRow = srcRow + iImageBytes - iRowBytes;

	mov	eax, edi
	imul	eax, ecx
	lea	edx, DWORD PTR [edi+edi*2]
	lea	ebp, DWORD PTR [eax+eax*2]
	sub	ebp, edx
	add	ebp, DWORD PTR _tSrcImagePtr$[esp+16]

; 21   : 
; 22   : 	// Loop through each line
; 23   : 	for (uint y=0; y<iHeight; y++)

	test	ecx, ecx
	mov	DWORD PTR _iRowBytes$[esp+20], edx
	jbe	SHORT $LN4@FlipVertic
	mov	DWORD PTR tv140[esp+20], ecx
	push	ebx
	npad	6
$LL13@FlipVertic:

; 24   : 	{	
; 25   : 		src = (uint*) srcRow;
; 26   : 
; 27   : 		for (uint x=0; x<iWidth; x++)

	test	edi, edi
	mov	eax, ebp
	jbe	SHORT $LN1@FlipVertic
$LL3@FlipVertic:

; 28   : 		{
; 29   : 			uchar ir, ig, ib;
; 30   : 
; 31   : 			ir = *src++;

	mov	cl, BYTE PTR [eax]

; 32   : 			ig = *src++;

	mov	dl, BYTE PTR [eax+4]
	add	eax, 4

; 33   : 			ib = *src++;

	mov	bl, BYTE PTR [eax+4]
	add	eax, 4
	mov	BYTE PTR _ib$34918[esp+20], bl

; 34   : 
; 35   : 			*dst++ = (ir << 16) | (ig << 8) | ib;

	xor	ebx, ebx
	mov	bh, cl
	movzx	ecx, BYTE PTR _ib$34918[esp+20]
	add	eax, 4
	add	esi, 4
	mov	bl, dl
	shl	ebx, 8
	or	ebx, ecx
	sub	edi, 1
	mov	DWORD PTR [esi-4], ebx
	jne	SHORT $LL3@FlipVertic
	mov	edx, DWORD PTR _iRowBytes$[esp+24]
	mov	edi, DWORD PTR _iWidth$[esp+20]
$LN1@FlipVertic:

; 36   : 		}
; 37   : 
; 38   : 		// Decrement src pointer by a line
; 39   : 		srcRow = srcRow - iRowBytes;

	sub	ebp, edx
	sub	DWORD PTR tv140[esp+24], 1
	jne	SHORT $LL13@FlipVertic
	pop	ebx
$LN4@FlipVertic:
	pop	edi
	pop	esi
	pop	ebp

; 40   : 	}
; 41   : }

	add	esp, 8
	ret	0
?FlipVertical24_nc1@@YAXPAE0II@Z ENDP			; FlipVertical24_nc1
; Function compile flags: /Ogtpy
_iRowBytes$ = -8					; size = 4
$T35181 = -4						; size = 4
tv139 = 8						; size = 4
_tSrcImagePtr$ = 8					; size = 4
_srcRow$ = 12						; size = 4
_iHeight$ = 12						; size = 4
?FlipVertical24_f1@@YAXPAE0II@Z PROC			; FlipVertical24_f1
; _tDstImagePtr$ = eax
; _iWidth$ = edx

; 45   : {

	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR _iHeight$[esp+8]

; 46   : 	const uint		iRowBytes    = iWidth*3;
; 47   : 	const uint		iImageBytes  = iWidth*iHeight*3;
; 48   : 
; 49   : 	uint			*src;
; 50   : 	uint			*dst = (uint*) tDstImagePtr;

	mov	ecx, edx
	imul	ecx, esi
	push	edi
	lea	edi, DWORD PTR [edx+edx*2]

; 51   : 	uchar			*srcRow = tSrcImagePtr;
; 52   : 
; 53   : 	srcRow = srcRow + iImageBytes - iRowBytes;

	lea	ecx, DWORD PTR [ecx+ecx*2]
	sub	ecx, edi
	add	ecx, DWORD PTR _tSrcImagePtr$[esp+12]

; 54   : 
; 55   : 	// Loop through each line
; 56   : 	for (uint y=0; y<iHeight; y++)

	test	esi, esi
	mov	DWORD PTR _iRowBytes$[esp+16], edi
	mov	DWORD PTR _srcRow$[esp+12], ecx
	jbe	$LN4@FlipVertic@2
	shr	edx, 2
	push	ebx
	mov	DWORD PTR $T35181[esp+20], edx
	mov	DWORD PTR tv139[esp+16], esi
	push	ebp
$LL13@FlipVertic@2:

; 59   : 
; 60   : 		for (uint x=0; x<iWidth/4; x++)

	test	edx, edx
	jbe	SHORT $LN1@FlipVertic@2

; 57   : 	{	
; 58   : 		src = (uint*) srcRow;

	mov	ebx, edx
	npad	3
$LL3@FlipVertic@2:

; 61   : 		{
; 62   : 			uint i1, i2, i3;
; 63   : 			uint o1, o2, o3, o4;
; 64   : 
; 65   : 							// 00  08  16  24
; 66   : 			i1 = *src++;	// R1, G1, B1, R2

	mov	edx, DWORD PTR [ecx]

; 67   : 			i2 = *src++;	// G2, B2, R3, G3

	mov	esi, DWORD PTR [ecx+4]

; 68   : 			i3 = *src++;	// B3, R4, G4, B4
; 69   : 
; 70   : 			// directly extract 24bpp RGB -> 32bpp 0RGB
; 71   : 			o1 = i1 & 0x00FFFFFF;

	mov	ebp, edx
	and	ebp, 16777215				; 00ffffffH
	add	ecx, 4
	mov	edi, DWORD PTR [ecx+4]

; 72   : 			o2 = (i1 >> 24) | (i2 << 8);
; 73   : 			o3 = (i2 >> 16) | (i3 << 16);
; 74   : 			o4 = i3 >> 8;
; 75   : 
; 76   : 			// swap 0RGB -> 0BGR, store output
; 77   : 			*dst++ = _byteswap_ulong(o1) >> 8;

	bswap	ebp
	add	ecx, 4
	shr	ebp, 8
	mov	DWORD PTR [eax], ebp
	shr	edx, 24					; 00000018H
	mov	ebp, esi
	shl	ebp, 8
	or	edx, ebp

; 78   : 			*dst++ = _byteswap_ulong(o2) >> 8;

	bswap	edx
	shr	edx, 8
	mov	DWORD PTR [eax+4], edx
	add	eax, 4
	mov	edx, edi
	shl	edx, 16					; 00000010H
	shr	esi, 16					; 00000010H
	or	edx, esi
	add	eax, 4
	shr	edi, 8

; 79   : 			*dst++ = _byteswap_ulong(o3) >> 8;

	bswap	edx
	shr	edx, 8
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 80   : 			*dst++ = _byteswap_ulong(o4) >> 8;

	bswap	edi
	shr	edi, 8
	mov	DWORD PTR [eax], edi
	add	ecx, 4
	add	eax, 4
	sub	ebx, 1
	jne	SHORT $LL3@FlipVertic@2
	mov	edi, DWORD PTR _iRowBytes$[esp+24]
	mov	ecx, DWORD PTR _srcRow$[esp+20]
	mov	edx, DWORD PTR $T35181[esp+24]
$LN1@FlipVertic@2:

; 81   : 		}
; 82   : 
; 83   : 		// Decrement src pointer by a line
; 84   : 		srcRow = srcRow - iRowBytes;

	sub	ecx, edi
	sub	DWORD PTR tv139[esp+20], 1
	mov	DWORD PTR _srcRow$[esp+20], ecx
	jne	SHORT $LL13@FlipVertic@2
	pop	ebp
	pop	ebx
$LN4@FlipVertic@2:
	pop	edi
	pop	esi

; 85   : 	}
; 86   : }

	add	esp, 8
	ret	0
?FlipVertical24_f1@@YAXPAE0II@Z ENDP			; FlipVertical24_f1
; Function compile flags: /Ogtpy
_gg$ = 8						; size = 1
_rr$ = 12						; size = 1
?make32@@YAIEEE@Z PROC					; make32
; _bb$ = ecx

; 91   : 	return (rr << 16) | (gg << 8) | bb;

	xor	eax, eax
	mov	ah, BYTE PTR _rr$[esp-4]
	movzx	ecx, cl
	mov	al, BYTE PTR _gg$[esp-4]
	shl	eax, 8
	or	eax, ecx

; 92   : }

	ret	0
?make32@@YAIEEE@Z ENDP					; make32
; Function compile flags: /Ogtpy
_i3$34975 = -12					; size = 4
_iRowBytes$ = -8					; size = 4
$T35201 = -4						; size = 4
_i2$34974 = 8						; size = 4
_tSrcImagePtr$ = 8					; size = 4
tv208 = 12						; size = 4
_iHeight$ = 12						; size = 4
?FlipVertical24_f2@@YAXPAE0II@Z PROC			; FlipVertical24_f2
; _tDstImagePtr$ = eax
; _iWidth$ = edx

; 95   : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _iHeight$[esp+20]

; 96   : 	const uint		iRowBytes    = iWidth*3;
; 97   : 	const uint		iImageBytes  = iWidth*iHeight*3;
; 98   : 
; 99   : 	uint			*src;
; 100  : 	uint			*dst = (uint*) tDstImagePtr;

	mov	ecx, edx
	imul	ecx, esi
	lea	ebx, DWORD PTR [edx+edx*2]

; 101  : 	uchar			*srcRow = tSrcImagePtr;
; 102  : 
; 103  : 	srcRow = srcRow + iImageBytes - iRowBytes;

	lea	ebp, DWORD PTR [ecx+ecx*2]
	sub	ebp, ebx
	add	ebp, DWORD PTR _tSrcImagePtr$[esp+20]

; 104  : 
; 105  : 	// Loop through each line
; 106  : 	for (uint y=0; y<iHeight; y++)

	test	esi, esi
	mov	DWORD PTR _iRowBytes$[esp+24], ebx
	jbe	$LN4@FlipVertic@3
	shr	edx, 2
	mov	DWORD PTR $T35201[esp+24], edx
	mov	DWORD PTR tv208[esp+20], esi
	push	edi
$LL21@FlipVertic@3:

; 109  : 
; 110  : 		for (uint x=0; x<iWidth/4; x++)

	test	edx, edx
	mov	esi, ebp
	jbe	$LN1@FlipVertic@3

; 107  : 	{	
; 108  : 		src = (uint*) srcRow;

	mov	edi, edx
	npad	1
$LL3@FlipVertic@3:

; 111  : 		{
; 112  : 			uint i1, i2, i3;
; 113  : 			uint o1, o2, o3, o4;
; 114  : 
; 115  : 							// 00  08  16  24
; 116  : 			i1 = *src++;	// R1, G1, B1, R2

	mov	ecx, DWORD PTR [esi]

; 117  : 			i2 = *src++;	// G2, B2, R3, G3

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _i2$34974[esp+24], edx
	add	esi, 4

; 118  : 			i3 = *src++;	// B3, R4, G4, B4

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _i3$34975[esp+28], edx
	add	esi, 4

; 119  : 
; 120  : 			// 24bpp RGB -> 32bpp 0BGR
; 121  : 			o1 = make32( (i1>>16)&0xFF, (i1>>8)&0xFF, i1&0xFF);
; 122  : 			o2 = make32( (i2>>8)&0xFF,  i2&0xFF, (i1>>24));
; 123  : 			o3 = make32( (i3)&0xFF, (i2>>24), (i2>>16)&0xFF);
; 124  : 			o4 = make32( (i3>>24), (i3>>16)&0xFF, (i3>>8)&0xFF);
; 125  : 
; 126  : 			// swap 0RGB -> 0BGR, store output
; 127  : 			*dst++ = o1;

	movzx	edx, ch
	mov	dh, cl
	mov	ebx, ecx
	shr	ebx, 16					; 00000010H
	movzx	ebx, bl
	shr	ecx, 24					; 00000018H
	shl	edx, 8
	or	edx, ebx
	mov	DWORD PTR [eax], edx

; 128  : 			*dst++ = o2;

	xor	edx, edx
	mov	dh, cl
	mov	ecx, DWORD PTR _i2$34974[esp+24]
	mov	ebx, ecx
	shr	ebx, 8
	movzx	ebx, bl
	mov	dl, cl
	add	eax, 4
	add	eax, 4

; 129  : 			*dst++ = o3;

	add	eax, 4
	add	esi, 4

; 130  : 			*dst++ = o4;

	add	eax, 4
	shl	edx, 8
	or	edx, ebx
	mov	DWORD PTR [eax-12], edx
	xor	ebx, ebx
	mov	edx, ecx
	shr	edx, 16					; 00000010H
	mov	bh, dl
	shr	ecx, 24					; 00000018H
	mov	bl, cl
	mov	ecx, DWORD PTR _i3$34975[esp+28]
	movzx	edx, cl
	shl	ebx, 8
	or	ebx, edx
	mov	DWORD PTR [eax-8], ebx
	xor	ebx, ebx
	mov	edx, ecx
	shr	edx, 8
	mov	bh, dl
	mov	edx, ecx
	shr	edx, 16					; 00000010H
	shr	ecx, 24					; 00000018H
	mov	bl, dl
	shl	ebx, 8
	or	ebx, ecx
	sub	edi, 1
	mov	DWORD PTR [eax-4], ebx
	jne	$LL3@FlipVertic@3
	mov	ebx, DWORD PTR _iRowBytes$[esp+28]
	mov	edx, DWORD PTR $T35201[esp+28]
$LN1@FlipVertic@3:

; 131  : 		}
; 132  : 
; 133  : 		// Decrement src pointer by a line
; 134  : 		srcRow = srcRow - iRowBytes;

	sub	ebp, ebx
	sub	DWORD PTR tv208[esp+24], 1
	jne	$LL21@FlipVertic@3
	pop	edi
$LN4@FlipVertic@3:
	pop	esi
	pop	ebp
	pop	ebx

; 135  : 	}
; 136  : }

	add	esp, 12					; 0000000cH
	ret	0
?FlipVertical24_f2@@YAXPAE0II@Z ENDP			; FlipVertical24_f2
_TEXT	ENDS
PUBLIC	?boost_priority@@YAXXZ				; boost_priority
EXTRN	__imp__SetThreadAffinityMask@8:PROC
EXTRN	__imp__SetThreadPriority@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__SetPriorityClass@8:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?boost_priority@@YAXXZ PROC				; boost_priority

; 146  : {

	push	esi

; 147  : 	SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);

	push	256					; 00000100H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8

; 148  : 	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

	mov	esi, DWORD PTR __imp__GetCurrentThread@0
	push	15					; 0000000fH
	call	esi
	push	eax
	call	DWORD PTR __imp__SetThreadPriority@8

; 149  : 	SetThreadAffinityMask(GetCurrentThread(), 1);

	push	1
	call	esi
	push	eax
	call	DWORD PTR __imp__SetThreadAffinityMask@8
	pop	esi

; 150  : }

	ret	0
?boost_priority@@YAXXZ ENDP				; boost_priority
_TEXT	ENDS
PUBLIC	_main
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_fwrite:PROC
EXTRN	_printf:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_fclose:PROC
EXTRN	_fread:PROC
EXTRN	_fopen:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_tick$ = -4						; size = 4
_main	PROC

; 153  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 154  : 	DWORD tick;
; 155  : 	uchar *m1 = new uchar[WIDTH*HEIGHT*3];

	push	480000					; 00075300H
	call	??2@YAPAXI@Z				; operator new

; 156  : 	uchar *m2 = new uchar[WIDTH*HEIGHT*4];

	push	640000					; 0009c400H
	mov	esi, eax
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax

; 157  : 
; 158  : 	
; 159  : 	FILE *fin = fopen(fni, "rb");

	mov	eax, DWORD PTR ?fni@@3PBDB		; fni
	push	OFFSET $SG35001
	push	eax
	call	_fopen
	mov	ebx, eax

; 160  : 	fread(m1, 1, WIDTH*HEIGHT*3, fin);

	push	ebx
	push	480000					; 00075300H
	push	1
	push	esi
	call	_fread

; 161  : 	fclose(fin);

	push	ebx
	call	_fclose
	add	esp, 36					; 00000024H

; 162  : 
; 163  : 	boost_priority();

	push	256					; 00000100H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8
	mov	ebx, DWORD PTR __imp__GetCurrentThread@0
	push	15					; 0000000fH
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetThreadPriority@8
	push	1
	call	ebx
	push	eax
	call	DWORD PTR __imp__SetThreadAffinityMask@8

; 164  : 
; 165  : 	tick = GetTickCount();

	mov	ebx, DWORD PTR __imp__GetTickCount@0
	call	ebx
	mov	DWORD PTR _tick$[esp+20], eax
	mov	ebp, 5000				; 00001388H
$LL9@main:

; 166  : 	for(unsigned i=0; i<TESTITER; i++)
; 167  : 		FlipVertical24_f1(m1, m2, WIDTH, HEIGHT);

	push	400					; 00000190H
	push	esi
	mov	edx, 400				; 00000190H
	mov	eax, edi
	call	?FlipVertical24_f1@@YAXPAE0II@Z		; FlipVertical24_f1
	add	esp, 8
	sub	ebp, 1
	jne	SHORT $LL9@main

; 168  : 	tick = GetTickCount() - tick;

	call	ebx
	sub	eax, DWORD PTR _tick$[esp+20]

; 169  : 	printf("%d iterations of f1: %d ticks\n", TESTITER, tick);

	push	eax
	push	5000					; 00001388H
	push	OFFSET $SG35006
	call	_printf
	add	esp, 12					; 0000000cH

; 170  : 
; 171  : 	tick = GetTickCount();

	call	ebx
	mov	DWORD PTR _tick$[esp+20], eax
	mov	ebp, 5000				; 00001388H
$LL6@main:

; 172  : 	for(unsigned i=0; i<TESTITER; i++)
; 173  : 		FlipVertical24_f2(m1, m2, WIDTH, HEIGHT);

	push	400					; 00000190H
	push	esi
	mov	edx, 400				; 00000190H
	mov	eax, edi
	call	?FlipVertical24_f2@@YAXPAE0II@Z		; FlipVertical24_f2
	add	esp, 8
	sub	ebp, 1
	jne	SHORT $LL6@main

; 174  : 	tick = GetTickCount() - tick;

	call	ebx
	sub	eax, DWORD PTR _tick$[esp+20]

; 175  : 	printf("%d iterations of f1: %d ticks\n", TESTITER, tick);

	push	eax
	push	5000					; 00001388H
	push	OFFSET $SG35011
	call	_printf
	add	esp, 12					; 0000000cH

; 176  : 
; 177  : 	tick = GetTickCount();

	call	ebx
	mov	DWORD PTR _tick$[esp+20], eax
	mov	ebp, 5000				; 00001388H
$LL3@main:

; 178  : 	for(unsigned i=0; i<TESTITER; i++)
; 179  : 		FlipVertical24_nc1(m1, m2, WIDTH, HEIGHT);

	push	400					; 00000190H
	push	esi
	mov	ecx, 400				; 00000190H
	mov	eax, edi
	call	?FlipVertical24_nc1@@YAXPAE0II@Z	; FlipVertical24_nc1
	add	esp, 8
	sub	ebp, 1
	jne	SHORT $LL3@main

; 180  : 	tick = GetTickCount() - tick;

	call	ebx
	sub	eax, DWORD PTR _tick$[esp+20]

; 181  : 	printf("%d iterations of nc1: %d ticks\n", TESTITER, tick);

	push	eax
	push	5000					; 00001388H
	push	OFFSET $SG35016
	call	_printf

; 182  : 
; 183  : 	FILE *fout= fopen(fno, "wb");

	mov	ecx, DWORD PTR ?fno@@3PBDB		; fno
	push	OFFSET $SG35018
	push	ecx
	call	_fopen
	mov	ebx, eax

; 184  : 	fwrite(m2, 1, WIDTH*HEIGHT*4, fout);

	push	ebx
	push	640000					; 0009c400H
	push	1
	push	edi
	call	_fwrite

; 185  : 	fclose(fout);

	push	ebx
	call	_fclose

; 186  : 
; 187  : 	delete[] m1;

	push	esi
	call	??3@YAXPAX@Z				; operator delete

; 188  : 	delete[] m2;

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 48					; 00000030H
	pop	edi
	pop	esi
	pop	ebp

; 189  : }

	xor	eax, eax
	pop	ebx
	pop	ecx
	ret	0
_main	ENDP
_TEXT	ENDS
END
